// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=unknown, use-js-string=true, version=6.0.1+6.0.1
//# 6 ".floatview_js.eobjs/jsoo/floatview_js.bc.runtime.js"
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   function caml_highres_clock(n){
    console.log("Highres clock not implemented.");
    return 0;
   }
  }
  (globalThis));
(function(globalThis){
   "use strict";
   function caml_sub_uint8_array_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.subarray(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_uint8_array(a){
    return caml_sub_uint8_array_to_jsbytes(a, 0, a.length);
   }
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return caml_string_of_uint8_array
              (this.s.data.subarray(offset, offset + len));
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   function caml_str_repeat(n, s){
    if(n === 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n === 0) return r;
     s += s;
     l++;
     if(l === 9) s.slice(0, 1);
    }
   }
   function caml_convert_string_to_bytes(s){
    if(s.t === 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_sub_uint8_array_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.slice(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j === l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3ff));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.slice(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
       case 8:
        return this.c;
       case 4:
       case 2:
        caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)) this.t = 9; else this.t = 8; return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t === 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t === 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function MlChanid(id){this.id = id;}
   var jsoo_static_env = {};
   function jsoo_sys_getenv(n){
    if(jsoo_static_env[n]) return jsoo_static_env[n];
    var process = globalThis.process;
    if(process && process.env && process.env[n] !== undefined)
     return process.env[n];
    if(globalThis.jsoo_env && typeof globalThis.jsoo_env[n] === "string")
     return globalThis.jsoo_env[n];
   }
   var caml_record_backtrace_env_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] === "b"){
         caml_record_backtrace_env_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_env_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var
    caml_record_backtrace_runtime_flag = caml_record_backtrace_env_flag,
    caml_global_data = [0];
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] === 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_env_flag
            && caml_record_backtrace_runtime_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.slice(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j === l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 === l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.slice(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_arg
     (caml_global_data.Sys_error, caml_string_of_jsstring(msg));
   }
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, - errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function caml_raise_system_error(raise_unix, code, cmd, msg, path){
    var unix_error = caml_named_value("Unix.Unix_error");
    if(raise_unix && unix_error)
     caml_raise_with_args(unix_error, make_unix_err_args(code, cmd, path));
    else{
     var msg = code + ": " + msg + ", " + cmd;
     if(path !== undefined) msg += " '" + path + "'";
     caml_raise_sys_error(msg);
    }
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_jsbytes_of_string(x){return x;}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_no_such_file(name, raise_unix){
    caml_raise_system_error
     (raise_unix, "ENOENT", "no such file or directory", name);
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t !== 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_bytes_of_uint8_array(a){return new MlBytes(4, a, a.length);}
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len === 0) return 0;
    if(i2 === 0 && (len >= s2.l || s2.t === 2 && len >= s2.c.length)){
     s2.c =
      s1.t === 4
       ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else if(s2.t === 2 && i2 === s2.c.length){
     s2.c +=
      s1.t === 4
       ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else{
     if(s2.t !== 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t === 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes
      (caml_bytes_of_uint8_array(buf), pos, this.data, offset, len);
     return len;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
    this.offset = 0;
    this.seeked = false;
   }
   MlFakeFd.prototype.err_closed =
    function(cmd, raise_unix){
     caml_raise_system_error(raise_unix, "EBADF", cmd, "bad file descriptor");
    };
   MlFakeFd.prototype.length =
    function(){
     if(this.file) return this.file.length();
     this.err_closed("length");
    };
   MlFakeFd.prototype.truncate =
    function(len, raise_unix){
     if(this.file){
      if(! (this.flags.wronly || this.flags.rdwr))
       caml_raise_system_error
        (raise_unix, "EINVAL", "truncate", "invalid argument");
      return this.file.truncate(len);
     }
     this.err_closed("truncate", raise_unix);
    };
   MlFakeFd.prototype.write =
    function(buf, pos, len, raise_unix){
     if(this.file && (this.flags.wronly || this.flags.rdwr)){
      var offset = this.offset;
      this.offset += len;
      return this.file.write(offset, buf, pos, len);
     }
     this.err_closed("write", raise_unix);
    };
   MlFakeFd.prototype.read =
    function(buf, pos, len, raise_unix){
     if(this.file && ! this.flags.wronly){
      var offset = this.offset;
      this.offset += len;
      return this.file.read(offset, buf, pos, len);
     }
     this.err_closed("read", raise_unix);
    };
   MlFakeFd.prototype.seek =
    function(offset, whence, raise_unix){
     switch(whence){
       case 0: break;
       case 1:
        offset += this.offset; break;
       case 2:
        offset += this.length(); break;
     }
     if(offset < 0)
      caml_raise_system_error
       (raise_unix, "EINVAL", "lseek", "invalid argument");
     this.offset = offset;
     this.seeked = true;
    };
   MlFakeFd.prototype.close =
    function(){
     if(! this.file) this.err_closed("close");
     this.file = undefined;
    };
   MlFakeFd.prototype.check_stream_semantics =
    function(cmd){if(! this.file) return this.err_closed(cmd, 1);};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsstring(this.root), caml_string_of_jsstring(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name, do_not_lookup){
     if(name === "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     if(! do_not_lookup) this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     if(this.exists(name))
      caml_raise_system_error
       (raise_unix, "EEXIST", "mkdir", "file already exists", this.nm(name));
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      caml_raise_system_error
       (raise_unix,
        "ENOENT",
        "mkdir",
        "no such file or directory",
        this.nm(name));
     if(! this.is_dir(parent))
      caml_raise_system_error
       (raise_unix, "ENOTDIR", "mkdir", "not a directory", this.nm(name));
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      name_slash = name === "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      caml_raise_system_error
       (raise_unix,
        "ENOENT",
        "rmdir",
        "no such file or directory",
        this.nm(name));
     if(! this.is_dir(name))
      caml_raise_system_error
       (raise_unix, "ENOTDIR", "rmdir", "not a directory", this.nm(name));
     for(var n in this.content)
      if(n.match(r))
       caml_raise_system_error
        (raise_unix,
         "ENOTEMPTY",
         "rmdir",
         "directory not empty",
         this.nm(name));
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name === "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var a = this.readdir(name), c = false, i = 0;
     return {readSync:
             function(){
              if(c)
               caml_raise_system_error
                (raise_unix, "EBADF", "readdir", "bad file descriptor");
              if(i === a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               caml_raise_system_error
                (raise_unix, "EBADF", "readdir", "bad file descriptor");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name === "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name, raise_unix){
     if(! this.exists(name, true))
      caml_raise_system_error
       (raise_unix, "ENOENT", "unlink", "no such file or directory", name);
     delete this.content[name];
     return 0;
    };
   MlFakeDevice.prototype.open =
    function(name, f, _perms, raise_unix){
     var file;
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_system_error
        (raise_unix,
         "EISDIR",
         "open",
         "illegal operation on a directory",
         this.nm(name));
      if(f.create && f.excl)
       caml_raise_system_error
        (raise_unix, "EEXIST", "open", "file already exists", this.nm(name));
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name), raise_unix);
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.truncate =
    function(name, len, raise_unix){
     var file;
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_system_error
        (raise_unix,
         "EISDIR",
         "open",
         "illegal operation on a directory",
         this.nm(name));
      file = this.content[name];
      file.truncate(len);
     }
     else
      caml_raise_no_such_file(this.nm(name), raise_unix);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(Array.isArray(content))
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd === 1 && typeof console.log === "function")
     this.log = console.log;
    else if(fd === 2 && typeof console.error === "function")
     this.log = console.error;
    else if(typeof console.log === "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.truncate =
    function(len, raise_unix){
     caml_raise_system_error
      (raise_unix, "EINVAL", "ftruncate", "invalid argument");
    };
   MlFakeFd_out.prototype.write =
    function(buf, pos, len, raise_unix){
     var written = len;
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] === 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_uint8_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return written;
     }
     caml_raise_system_error
      (raise_unix, "EBADF", "write", "bad file descriptor");
    };
   MlFakeFd_out.prototype.read =
    function(buf, pos, len, raise_unix){
     caml_raise_system_error
      (raise_unix, "EBADF", "read", "bad file descriptor");
    };
   MlFakeFd_out.prototype.seek =
    function(len, whence, raise_unix){
     caml_raise_system_error(raise_unix, "ESPIPE", "lseek", "illegal seek");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   MlFakeFd_out.prototype.check_stream_semantics = function(cmd){};
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) === 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function MlMutex(){this.locked = false;}
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function caml_raise_nodejs_error(err, raise_unix, cmd){
    var unix_error = caml_named_value("Unix.Unix_error");
    if(raise_unix && unix_error){
     var
      args =
        make_unix_err_args(err.code, cmd || err.syscall, err.path, err.errno);
     caml_raise_with_args(unix_error, args);
    }
    else
     caml_raise_sys_error(err.toString());
   }
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   function fs_node_stats_from_js(js_stats, large){
    var file_kind;
    if(js_stats.isFile())
     file_kind = 0;
    else if(js_stats.isDirectory())
     file_kind = 1;
    else if(js_stats.isCharacterDevice())
     file_kind = 2;
    else if(js_stats.isBlockDevice())
     file_kind = 3;
    else if(js_stats.isSymbolicLink())
     file_kind = 4;
    else if(js_stats.isFIFO())
     file_kind = 5;
    else if(js_stats.isSocket()) file_kind = 6;
    return [0,
            js_stats.dev,
            js_stats.ino | 0,
            file_kind,
            js_stats.mode,
            js_stats.nlink,
            js_stats.uid,
            js_stats.gid,
            js_stats.rdev,
            large ? caml_int64_of_float(js_stats.size) : js_stats.size | 0,
            js_stats.atimeMs / 1000,
            js_stats.mtimeMs / 1000,
            js_stats.ctimeMs / 1000];
   }
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t !== 4){
     if(i === s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 === s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("node:fs");
    this.fd = fd;
    this.flags = flags;
    var stats = this.fs.fstatSync(fd);
    flags.noSeek =
     stats.isCharacterDevice() || stats.isFIFO() || stats.isSocket();
    this.offset = this.flags.append ? stats.size : 0;
    this.seeked = false;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len, raise_unix){
     try{
      this.fs.ftruncateSync(this.fd, len | 0);
      if(this.offset > len) this.offset = len;
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(buf, buf_offset, len, raise_unix){
     try{
      if(this.flags.noSeek || ! this.seeked)
       var written = this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       var
        written =
          this.fs.writeSync(this.fd, buf, buf_offset, len, this.offset);
      this.offset += written;
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
     return written;
    };
   MlNodeFd.prototype.read =
    function(a, buf_offset, len, raise_unix){
     try{
      if(this.flags.noSeek || ! this.seeked)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, this.offset);
      this.offset += read;
      return read;
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeFd.prototype.seek =
    function(offset, whence, raise_unix){
     if(this.flags.noSeek)
      caml_raise_system_error(raise_unix, "ESPIPE", "lseek", "illegal seek");
     switch(whence){
       case 0: break;
       case 1:
        offset += this.offset; break;
       case 2:
        offset += this.length(); break;
     }
     if(offset < 0)
      caml_raise_system_error
       (raise_unix, "EINVAL", "lseek", "invalid argument");
     this.offset = offset;
     this.seeked = true;
     return this.offset;
    };
   MlNodeFd.prototype.stat =
    function(large){
     try{
      var js_stats = this.fs.fstatSync(this.fd);
      return fs_node_stats_from_js(js_stats, large);
     }
     catch(err){caml_raise_nodejs_error(err, 1);}
    };
   MlNodeFd.prototype.close =
    function(raise_unix){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeFd.prototype.check_stream_semantics =
    function(cmd){
     try{var js_stats = this.fs.fstatSync(this.fd);}
     catch(err){caml_raise_nodejs_error(err, 1, cmd);}
     if
      (!
       (js_stats.isFile() || js_stats.isCharacterDevice() || js_stats.isFIFO()
       || js_stats.isSocket()))
      caml_raise_system_error(1, "EINVAL", cmd, "invalid argument");
    };
   function MlNodeDevice(root){
    this.fs = require("node:fs");
    this.root = root;
   }
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{this.fs.unlinkSync(this.nm(name)); return 0;}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.utimes =
    function(name, atime, mtime, raise_unix){
     try{
      if(atime === 0 && mtime === 0){
       atime = new Date().getTime() / 1000;
       mtime = atime;
      }
      this.fs.utimesSync(this.nm(name), atime, mtime);
      return 0;
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.truncate =
    function(name, len, raise_unix){
     try{this.fs.truncateSync(this.nm(name), len | 0); return 0;}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, perms, raise_unix){
     var consts = require("node:constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "rdwr":
         res |= consts.O_RDWR; break;
        case "append":
         res |= consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
        case "noctty":
         res |= consts.O_NOCTTY; break;
        case "dsync":
         res |= consts.O_DSYNC; break;
        case "sync":
         res |= consts.O_SYNC; break;
      }
     try{
      var fd = this.fs.openSync(this.nm(name), res, perms);
      return new MlNodeFd(fd, f);
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   if(globalThis.process?.platform === "win32")
    MlNodeDevice.prototype.rename =
     function(o, n, raise_unix){
      try{
       var
        target = this.nm(n),
        source = this.nm(o),
        target_stats,
        source_stats;
       if
        ((target_stats = this.fs.statSync(target, {throwIfNoEntry: false}))
         && (source_stats = this.fs.statSync(source, {throwIfNoEntry: false}))
         && source_stats.isDirectory())
        if(target_stats.isDirectory()){
         if(! target.startsWith(source))
          try{this.fs.rmdirSync(target);}catch{}
        }
        else{
         var
          err =
            new
             Error
             (`ENOTDIR: not a directory, rename '${source}' -> '${target}'`);
         throw Object.assign
                (err,
                 {errno: - 20,
                  code: "ENOTDIR",
                  syscall: "rename",
                  path: target});
        }
       this.fs.renameSync(this.nm(o), this.nm(n));
      }
      catch(err){caml_raise_nodejs_error(err, raise_unix);}
     };
   else
    MlNodeDevice.prototype.rename =
     function(o, n, raise_unix){
      try{this.fs.renameSync(this.nm(o), this.nm(n));}
      catch(err){caml_raise_nodejs_error(err, raise_unix);}
     };
   MlNodeDevice.prototype.stat =
    function(name, large, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return fs_node_stats_from_js(js_stats, large);
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, large, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return fs_node_stats_from_js(js_stats, large);
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (target,
        this.nm(path),
        to_dir === 0 ? null : to_dir[1] ? "dir" : "file");
      return 0;
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){caml_raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.slice(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   var
    caml_packFloat16 =
      function(){
        const INVERSE_OF_EPSILON = 1 / Number.EPSILON;
        function roundTiesToEven(num){
         return num + INVERSE_OF_EPSILON - INVERSE_OF_EPSILON;
        }
        const
         FLOAT16_MIN_VALUE = 6.103515625e-5,
         FLOAT16_MAX_VALUE = 65504,
         FLOAT16_EPSILON = 0.0009765625,
         FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE,
         FLOAT16_EPSILON_DEVIDED_BY_EPSILON =
           FLOAT16_EPSILON * INVERSE_OF_EPSILON;
        function roundToFloat16(num){
         const number = + num;
         if(! Number.isFinite(number) || number === 0) return number;
         const sign = number > 0 ? 1 : - 1, absolute = Math.abs(number);
         if(absolute < FLOAT16_MIN_VALUE)
          return sign
                 *
                  roundTiesToEven
                   (absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE)
                 * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;
         const
          temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute,
          result = temp - (temp - absolute);
         if(result > FLOAT16_MAX_VALUE || Number.isNaN(result))
          return sign * Number.POSITIVE_INFINITY;
         return sign * result;
        }
        const
         baseTable = new Uint16Array(512),
         shiftTable = new Uint8Array(512);
        for(let i = 0; i < 256; ++i){
         const e = i - 127;
         if(e < - 24){
          baseTable[i] = 0x0000;
          baseTable[i | 0x100] = 0x8000;
          shiftTable[i] = 24;
          shiftTable[i | 0x100] = 24;
         }
         else if(e < - 14){
          baseTable[i] = 0x0400 >> - e - 14;
          baseTable[i | 0x100] = 0x0400 >> - e - 14 | 0x8000;
          shiftTable[i] = - e - 1;
          shiftTable[i | 0x100] = - e - 1;
         }
         else if(e <= 15){
          baseTable[i] = e + 15 << 10;
          baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
          shiftTable[i] = 13;
          shiftTable[i | 0x100] = 13;
         }
         else if(e < 128){
          baseTable[i] = 0x7c00;
          baseTable[i | 0x100] = 0xfc00;
          shiftTable[i] = 24;
          shiftTable[i | 0x100] = 24;
         }
         else{
          baseTable[i] = 0x7c00;
          baseTable[i | 0x100] = 0xfc00;
          shiftTable[i] = 13;
          shiftTable[i | 0x100] = 13;
         }
        }
        const
         buffer = new ArrayBuffer(4),
         floatView = new Float32Array(buffer),
         uint32View = new Uint32Array(buffer);
        return function(num){
         floatView[0] = roundToFloat16(num);
         const f = uint32View[0], e = f >> 23 & 0x1ff;
         return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);};
       }
       (),
    caml_unpackFloat16 =
      function(){
        var
         pow = Math.pow,
         EXP_MASK16 = 31,
         SIGNIFICAND_MASK16 = 1023,
         MIN_SUBNORMAL16 = pow(2, - 24),
         SIGNIFICAND_DENOM16 = 0.0009765625;
        return function(bytes){
         var
          sign = bytes >>> 15,
          exponent = bytes >>> 10 & EXP_MASK16,
          significand = bytes & SIGNIFICAND_MASK16;
         if(exponent === EXP_MASK16)
          return significand === 0
                  ? sign
                    === 0
                    ? Number.POSITIVE_INFINITY
                    : Number.NEGATIVE_INFINITY
                  : Number.NaN;
         if(exponent === 0)
          return significand
                 * (sign === 0 ? MIN_SUBNORMAL16 : - MIN_SUBNORMAL16);
         var
          r =
            pow(2, exponent - 15)
            *
             (sign === 0
               ? 1 + significand * SIGNIFICAND_DENOM16
               : - 1 - significand * SIGNIFICAND_DENOM16);
         return r;};
       }
       ();
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! Array.isArray(arg))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length !== arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout === 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       case 13:
        return caml_unpackFloat16(this.data[ofs]);
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       case 13:
        this.data[ofs] = caml_packFloat16(v); break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a === b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 === 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im === re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 === 0 ? im : re;
        break;
       case 13:
        this.data.fill(caml_packFloat16(v)); break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout !== b.layout || this.kind !== b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length !== b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] !== b.dims[i])
       return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x !== y){
          if(! total) return Number.NaN;
          if(! Number.isNaN(x)) return 1;
          if(! Number.isNaN(y)) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 13:
        for(var i = 0; i < this.data.length; i++){
         var
          aa = caml_unpackFloat16(this.data[i]),
          bb = caml_unpackFloat16(b.data[i]);
         if(aa < bb) return - 1;
         if(aa > bb) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(Array.isArray(arg) && arg.length === 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_uint8_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x === x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x === x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element !== data.length)
     caml_invalid_argument("length doesn't match dims");
    if
     (layout === 0 && dims.length === 1 && size_per_element === 1
      && kind !== 13)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function bigstring_to_typed_array(bs){return bs.data;}
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xd76aa478);
         d = ff(d, a, b, c, buffer[1], 12, 0xe8c7b756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070db);
         b = ff(b, c, d, a, buffer[3], 22, 0xc1bdceee);
         a = ff(a, b, c, d, buffer[4], 7, 0xf57c0faf);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787c62a);
         c = ff(c, d, a, b, buffer[6], 17, 0xa8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xfd469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098d8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8b44f7af);
         c = ff(c, d, a, b, buffer[10], 17, 0xffff5bb1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895cd7be);
         a = ff(a, b, c, d, buffer[12], 7, 0x6b901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xfd987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xa679438e);
         b = ff(b, c, d, a, buffer[15], 22, 0x49b40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xf61e2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xc040b340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265e5a51);
         b = gg(b, c, d, a, buffer[0], 20, 0xe9b6c7aa);
         a = gg(a, b, c, d, buffer[5], 5, 0xd62f105d);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xd8a1e681);
         b = gg(b, c, d, a, buffer[4], 20, 0xe7d3fbc8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21e1cde6);
         d = gg(d, a, b, c, buffer[14], 9, 0xc33707d6);
         c = gg(c, d, a, b, buffer[3], 14, 0xf4d50d87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455a14ed);
         a = gg(a, b, c, d, buffer[13], 5, 0xa9e3e905);
         d = gg(d, a, b, c, buffer[2], 9, 0xfcefa3f8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676f02d9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8d2a4c8a);
         a = hh(a, b, c, d, buffer[5], 4, 0xfffa3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771f681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6d9d6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xfde5380c);
         a = hh(a, b, c, d, buffer[1], 4, 0xa4beea44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4bdecfa9);
         c = hh(c, d, a, b, buffer[7], 16, 0xf6bb4b60);
         b = hh(b, c, d, a, buffer[10], 23, 0xbebfbc70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289b7ec6);
         d = hh(d, a, b, c, buffer[0], 11, 0xeaa127fa);
         c = hh(c, d, a, b, buffer[3], 16, 0xd4ef3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881d05);
         a = hh(a, b, c, d, buffer[9], 4, 0xd9d4d039);
         d = hh(d, a, b, c, buffer[12], 11, 0xe6db99e5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1fa27cf8);
         b = hh(b, c, d, a, buffer[2], 23, 0xc4ac5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xf4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432aff97);
         c = ii(c, d, a, b, buffer[14], 15, 0xab9423a7);
         b = ii(b, c, d, a, buffer[5], 21, 0xfc93a039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655b59c3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8f0ccc92);
         c = ii(c, d, a, b, buffer[10], 15, 0xffeff47d);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845dd1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6fa87e4f);
         d = ii(d, a, b, c, buffer[15], 10, 0xfe2ce6e0);
         c = ii(c, d, a, b, buffer[6], 15, 0xa3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4e0811a1);
         a = ii(a, b, c, d, buffer[4], 6, 0xf7537e82);
         d = ii(d, a, b, c, buffer[11], 10, 0xbd3af235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2ad7d2bb);
         b = ii(b, c, d, a, buffer[9], 21, 0xeb86d391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1fffffff;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xff;
    return t;
   }
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d === 0)
     return f(...args);
    else if(d < 0){
     var g = f(...args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f(...nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f(...nargs);
            };
         break;
        }
       default:
        var
         g =
           function(...extra_args){
            if(extra_args.length === 0) extra_args = [undefined];
            return caml_call_gen(f, args.concat(extra_args));
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       ();
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_array_make(len, init){
    if(len >>> 0 >= (0x7fffffff / 4 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_ba_blit(src, dst){
    if(dst.dims.length !== src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] !== src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout === layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
      case 13:
       view = Uint16Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) === 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp === 2047)
     return (lo | mi | hi & 0xf) === 0
             ? hi
               & 0x8000
               ? Number.NEGATIVE_INFINITY
               : Number.POSITIVE_INFINITY
             : Number.NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name === "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim === 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi !== 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 13:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   function caml_hash_mix_float16(hash, d){
    if((d & 0x7c00) === 0x7c00 && (d & 0x03ff) !== 0)
     d = 0x7c01;
    else if(d === 0x8000) d = 0;
    return caml_hash_mix_int(hash, d);
   }
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474e307) === 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x === 0) return Number.NEGATIVE_INFINITY;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! Number.isFinite(x)){
     if(Number.isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var
     sign =
       x === 0 && 1 / x === Number.NEGATIVE_INFINITY
        ? 0x8000
        : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp === 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) !== 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 13:
       if(num_elts > 128) num_elts = 128;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float16(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_ba_init(){return 0;}
   function caml_ba_kind(ba){return ba.kind;}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts !== size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom === "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 13:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout === 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout === 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_runtime_flag ? 1 : 0;
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 !== ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 !== ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_uint8_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).subarray(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).subarray(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bswap16(x){return (x & 0x00ff) << 8 | (x & 0xff00) >> 8;}
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function caml_build_symbols(symb){
    var r = {}, max = - 1;
    if(symb)
     for(var i = 1; i < symb.length; i++){
      var idx = symb[i][2];
      max = Math.max(max, idx);
      r[caml_jsstring_of_string(symb[i][1])] = idx;
     }
    r.next_idx = max + 1;
    return r;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c === s2.c ? 1 : 0;
   }
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      case 0:
       return s.c.charCodeAt(i);
      case 2:
       if(i >= s.c.length) return 0; return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xff & i16 >> 8, b1 = 0xff & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xff & i32 >> 24,
     b3 = 0xff & i32 >> 16,
     b2 = 0xff & i32 >> 8,
     b1 = 0xff & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   var caml_callback = caml_call_gen;
   function caml_cbrt_float(x){return Math.cbrt(x);}
   function caml_ml_channels_state(){
    this.map = new globalThis.WeakMap();
    this.opened = new globalThis.Set();
   }
   caml_ml_channels_state.prototype.close =
    function(chanid){this.opened.delete(chanid);};
   caml_ml_channels_state.prototype.get =
    function(chanid){return this.map.get(chanid);};
   caml_ml_channels_state.prototype.set =
    function(chanid, val){
     if(val.opened) this.opened.add(chanid);
     return this.map.set(chanid, val);
    };
   caml_ml_channels_state.prototype.all =
    function(){return this.opened.values();};
   var caml_ml_channels = new caml_ml_channels_state();
   function caml_ml_channel_get(id){return caml_ml_channels.get(id);}
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.fd;
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_classify_float(x){
    if(Number.isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x !== 0) return 1;
     return 2;
    }
    return Number.isNaN(x) ? 4 : 3;
   }
   function caml_is_continuation_tag(t){return t === 245 ? 1 : 0;}
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large"); break;
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {_j:
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       _i: {deserialize: caml_int32_unmarshal, fixed_length: 4},
       _n: {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       _bigarray:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       _bigarr02:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && Number.isNaN(x)) return swap;
     if(Number.isNaN(+ x)) return + x;
     if((x | 0) !== 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(Array.isArray(a) && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag === 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a === "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a === "function")
     return 1247;
    else if(typeof a === "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a === b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a === 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b === 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a === 1000){
        if(tag_b === 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b === 1000){
        if(tag_a === 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]) | 0;
         if(x !== 0) return x;
         break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b) | 0;
          if(x !== 0) return x;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp !== caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b){
          if(! total) return Number.NaN;
          if(! Number.isNaN(a)) return 1;
          if(! Number.isNaN(b)) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b) return total ? 1 : Number.NaN;
         break;
        case 1251:
         if(a !== b) return total ? 1 : Number.NaN; break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length !== b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length === 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    if(stack === 0) return stack;
    var last = cont[2];
    if(last === 0){last = stack; while(last.e !== 0) last = last.e;}
    last.h[1] = hval;
    last.h[2] = hexn;
    last.h[3] = heff;
    return stack;
   }
   function caml_convert_raw_backtrace(){return [0];}
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_copysign_float(x, y){
    if(y === 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.slice(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = device.length > 0 && device.charAt(1) !== ":";
     if(result[2] || isUnc){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.slice(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split(/[/\\]/),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) === 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function caml_create_string(len){caml_invalid_argument("String.create");}
   var caml_custom_event_index = 0;
   function caml_custom_identifier(o){
    return caml_string_of_jsstring(o.caml_custom);
   }
   var caml_decompress_input = null;
   function caml_div(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   var
    caml_ephe_none = {caml_ephe_none: 0},
    caml_ephe_data_offset = 2,
    caml_ephe_key_offset = 3;
   function caml_ephe_get_data(x){
    var data = x[caml_ephe_data_offset];
    if(data === caml_ephe_none) return 0;
    for(var i = caml_ephe_key_offset; i < x.length; i++){
     var k = x[i];
     if(globalThis.WeakRef && k instanceof globalThis.WeakRef){
      var d = k.deref();
      if(d === undefined){
       x[i] = caml_ephe_none;
       x[caml_ephe_data_offset] = caml_ephe_none;
       return 0;
      }
      if(globalThis.WeakMap){
       data = data.get(k);
       if(data === undefined){
        x[caml_ephe_data_offset] = caml_ephe_none;
        return 0;
       }
      }
     }
    }
    return [0, data];
   }
   function caml_ephe_unset_data(x){
    x[caml_ephe_data_offset] = caml_ephe_none;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    for(var i = x.length - 1; i >= caml_ephe_key_offset; i--){
     var k = x[i];
     if(globalThis.WeakRef && k instanceof globalThis.WeakRef){
      var d = k.deref();
      if(d === undefined){x[i] = caml_ephe_none; continue;}
      if(globalThis.WeakMap) data = new globalThis.WeakMap().set(k, data);
     }
    }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_set_data_opt(x, data_opt){
    if(data_opt === 0)
     caml_ephe_unset_data(x);
    else
     caml_ephe_set_data(x, data_opt[1]);
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var old = caml_ephe_get_data(src);
    caml_ephe_set_data_opt(dst, old);
    return 0;
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    var old = caml_ephe_get_data(a1);
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    caml_ephe_set_data_opt(a2, old);
    return 0;
   }
   function caml_ephe_check_data(x){
    var data = caml_ephe_get_data(x);
    return data === 0 ? 0 : 1;
   }
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(weak === caml_ephe_none) return 0;
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef){
     weak = weak.deref();
     if(weak === undefined){
      x[caml_ephe_key_offset + i] = caml_ephe_none;
      x[caml_ephe_data_offset] = caml_ephe_none;
      return 0;
     }
    }
    return 1;
   }
   function caml_weak_create(n){
    var alen = caml_ephe_key_offset + n, x = new Array(alen);
    x[0] = 251;
    x[1] = "caml_ephe_list_head";
    for(var i = 2; i < alen; i++) x[i] = caml_ephe_none;
    return x;
   }
   function caml_ephe_create(n){return caml_weak_create(n);}
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    var r = caml_ephe_get_data(x);
    if(r === 0) return 0;
    var z = r[1];
    if(Array.isArray(z)) return [0, caml_obj_dup(z)];
    return r;
   }
   function caml_ephe_get_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(weak === caml_ephe_none) return 0;
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef){
     weak = weak.deref();
     if(weak === undefined){
      x[caml_ephe_key_offset + i] = caml_ephe_none;
      x[caml_ephe_data_offset] = caml_ephe_none;
      return 0;
     }
    }
    return [0, weak];
   }
   function caml_ephe_get_key_copy(x, i){
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(Array.isArray(z)) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_ephe_set_key(x, i, v){
    var old = caml_ephe_get_data(x);
    if(globalThis.WeakRef && v instanceof Object)
     v = new globalThis.WeakRef(v);
    x[caml_ephe_key_offset + i] = v;
    caml_ephe_set_data_opt(x, old);
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    var old = caml_ephe_get_data(x);
    x[caml_ephe_key_offset + i] = caml_ephe_none;
    caml_ephe_set_data_opt(x, old);
    return 0;
   }
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) === 0);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   var caml_executable_name = caml_argv[1];
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] === 0){
     r += exn[1][1];
     if
      (exn.length === 3 && exn[2][0] === 0
       && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v === "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v === "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] === 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(Array.isArray(err) && (err[0] === 0 || err[0] === 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i === 0 && (l >= s.l || s.t === 2 && l >= s.c.length))
      if(c === 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l === s.l ? 0 : 2;
      }
     else{
      if(s.t !== 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_final_register(){return 0;}
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_final_release(){return 0;}
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle !== "-")) len++;
    if(f.alternate){if(f.base === 8) len += 1; if(f.base === 16) len += 2;}
    var buffer = "";
    if(f.justify === "+" && f.filler === " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle !== "-") buffer += f.signstyle;
    if(f.alternate && f.base === 8) buffer += "0";
    if(f.alternate && f.base === 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify === "+" && f.filler === "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify === "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(! Number.isNaN(x)) return 1;
    if(! Number.isNaN(y)) return - 1;
    return 0;
   }
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_float_of_string(s){
    var res, r_float = /^ *[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?$/;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(! Number.isNaN(res) && r_float.test(s)) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(! Number.isNaN(res) && r_float.test(s) || /^[+-]?nan$/i.test(s))
     return res;
    var
     m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?$/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = Number.parseInt(m[1] + m[2] + m3, 16),
      exponent = (+ m[5] || 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Number.POSITIVE_INFINITY;
    if(/^-inf(inity)?$/i.test(s)) return Number.NEGATIVE_INFINITY;
    caml_failwith("float_of_string");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){return caml_array_blit(a1, i1, a2, i2, len);
   }
   function caml_floatarray_create(len){
    if(len >>> 0 >= (0x7fffffff / 8 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if(x === 0 || y === 0 || ! Number.isFinite(x) || ! Number.isFinite(y))
     return x * y + z;
    if(z === 0) return x * y;
    if(! Number.isFinite(z)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
        break;
       case "d":
       case "i":
        f.signedconv = true; f.base = 10; break;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = Number.parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x === 0 && 1 / x === Number.NEGATIVE_INFINITY){f.sign = - 1; x = - x;}
    if(Number.isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! Number.isFinite(x)){s = "inf"; f.filler = " ";}
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) === "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) === "0") i--;
         if(s.charAt(i) === ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) === "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) === "0") i--;
          if(s.charAt(i) === ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) === "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_frexp_float(x){
    if(x === 0 || ! Number.isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsstring(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.jsoo_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.jsoo_fs_tmp = [];
    return 0;
   }
   function caml_gc_compaction(){return 0;}
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc === "function") globalThis.gc();
    return 0;
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_gc_major(unit){
    if(typeof globalThis.gc === "function") globalThis.gc();
    return 0;
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_gc_minor(unit){
    if(typeof globalThis.gc === "function") globalThis.gc(true);
    return 0;
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_gc_set(_control){return 0;}
   function caml_gc_stat(){return caml_gc_quick_stat();}
   function caml_get_continuation_callstack(){return [0];}
   function caml_get_current_callstack(){return [0];}
   function caml_get_exception_backtrace(){return 0;}
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_get_global_data(){return caml_global_data;}
   function caml_get_minor_free(unit){return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag === meths[li + 1] ? meths[li] : 0;
   }
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j === 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev !== xPos || yPos_prev !== yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c === - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info === "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? Number.parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? Number.parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xff;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_gr_sigio_signal(){return 0;}
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      case 2:
       caml_convert_string_to_bytes(s); return s.c;
      default: return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(Array.isArray(v) && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3fffffff;
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--)
     if(nat.data[ofs + i] !== 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! Number.isFinite(x)){
     if(Number.isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var
     sign = x === 0 && 1 / x === Number.NEGATIVE_INFINITY ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x === 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.slice(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   var caml_marshal_header_size = 16;
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length === 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     if(chan.fd === - 1) caml_raise_sys_error("Bad file descriptor");
     var
      nread =
        chan.file.read
         (chan.buffer, chan.buffer_max, chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7f;
     while((c & 0x80) !== 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n !== n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7f;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495a6be:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495a6bd:
       var
        header_len = r.read8u() & 0x3f,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495a6bf:
       caml_failwith
        ("Marshal.data_size: object too large to be read back on a 32-bit platform");
       break;
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7f;
     while((c & 0x80) !== 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n !== n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7f;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495a6be:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495a6bd:
       var
        header_len = reader.read8u() & 0x3f,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495a6bf:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     objects = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xf, size = code >> 4 & 0x7, v = [tag];
       if(size === 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       if(tag === 248) objects.push(v);
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3f;
     else if(code >= 0x20){
      var len = code & 0x1f, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xff,
          size = header >> 10,
          v = [tag];
         if(size === 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         if(tag === 248) objects.push(v);
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0a:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0c:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0b:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0e:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0d:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0f:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) !== 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size !== undefined)
          if(expected_size !== size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    while(objects.length > 0){
     var x = objects.pop();
     if(x[2] >= 0) caml_set_oo_id(x);
    }
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs === "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channel_get(chanid),
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r === 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_uint8_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var res = caml_input_value_from_bytes(caml_bytes_of_uint8_array(buf), 0);
    return res;
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_install_signal_handler(){return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000ff) << 24 | (x & 0x0000ff00) << 8
           | (x & 0x00ff0000) >>> 8
           | (x & 0xff000000) >>> 24;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_and(x, y){return x.and(y);}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_int64_div(x, y){return x.div(y);}
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var
     i = 0,
     len = caml_ml_string_length(s),
     base = 10,
     sign = 1,
     signedness = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) === 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        signedness = 0; base = 16; i += 2; break;
       case 111:
       case 79:
        signedness = 0; base = 8; i += 2; break;
       case 98:
       case 66:
        signedness = 0; base = 2; i += 2; break;
       case 117:
       case 85:
        signedness = 0; i += 2; break;
     }
    return [i, sign, base, signedness];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i !== caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(signedness && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i !== len) caml_failwith("int_of_string");
    res = sign * res;
    if(signedness && (res | 0) !== res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_is_js(){return 1;}
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_js_from_bool(x){return ! ! x;}
   function caml_js_from_float(x){return x;}
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_get(o, f){return o[f];}
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     return null;
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /"/g, all: /[&<"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c();
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F();
   }
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_js_to_bool(x){return + x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_js_to_float(x){return x;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function caml_js_typeof(o){return typeof o;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_js_wrap_callback(f){
    return function(...args){
     if(args.length === 0) args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_callback_arguments(f){
    return function(...args){return caml_callback(f, [args]);};
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(...args){
     args.length = arity;
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(...args){
     var len = caml_js_function_arity(f);
     args.length = len;
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback(f){
    return function(...args){
     args.unshift(this);
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback_arguments(f){
    return function(...args){return caml_callback(f, [this, args]);};
   }
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(...args){
     args.length = arity;
     args.unshift(this);
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(...args){
     var len = caml_js_function_arity(f);
     args.unshift(this);
     args.length = len;
     return caml_callback(f, args);};
   }
   function caml_jsoo_flags_effects(unit){return "disabled";}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   function caml_lazy_make_forward(v){return [250, v];}
   function caml_obj_tag(x){
    if(Array.isArray(x) && x[0] === x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x === "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) === 250 ? o[1] : o;
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] === o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return Array.isArray(o) && o[0] === o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var c, state = start_state, buffer = lexbuf[lex_buffer];
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] === 0) return - state - 1; else c = 256;
     else{
      c = caml_bytes_unsafe_get(buffer, lexbuf[lex_curr_pos]);
      lexbuf[lex_curr_pos]++;
     }
     if(tbl.lex_check[base + c] === state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] === - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c === 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsstring(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   function caml_log10_float(x){return Math.log10(x);}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_log2_float(x){return Math.log2(x);}
   var
    caml_lxm_M =
      caml_int64_of_string(caml_string_of_jsstring("0xd1342543de82ef95")),
    caml_lxm_daba =
      caml_int64_of_string(caml_string_of_jsstring("0xdaba0b6eb09322e3"));
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_lxm_M,
     daba = caml_lxm_daba,
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_make_float_vect(len){
    if(len >>> 0 >= (0x7fffffff / 8 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_make_vect(len, init){return caml_array_make(len, init);}
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0a,
       CODE_DOUBLE_BIG: 0x0b,
       CODE_DOUBLE_LITTLE: 0x0c,
       CODE_DOUBLE_ARRAY8_BIG: 0x0d,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0e,
       CODE_DOUBLE_ARRAY32_BIG: 0x0f,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_maybe_print_stats(unit){return 0;}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_uint8_array(caml_MD5Final(ctx));
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read === 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read === 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_uint8_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_ml_channel_redirect(captured, into){
    var
     to_restore = caml_ml_channel_get(captured),
     new_ = caml_ml_channel_get(into);
    caml_ml_channels.set(captured, new_);
    return to_restore;
   }
   function caml_ml_channel_restore(captured, to_restore){caml_ml_channels.set(captured, to_restore); return 0;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length() | 0;
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channel_get(chanid);
    return caml_int64_of_float(chan.file.length());
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var x = caml_sys_fds[fd];
    if(x){x.file.close(); delete caml_sys_fds[fd];}
    return 0;
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr === 0) return 0;
    if(chan.output)
     chan.output
      (caml_sub_uint8_array_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     for(var pos = 0; pos < chan.buffer_curr;)
      pos += chan.file.write(chan.buffer, pos, chan.buffer_curr - pos);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.opened){
     chan.opened = false;
     caml_ml_channels.close(chanid);
     caml_sys_close(chan.fd);
     chan.fd = - 1;
     chan.buffer = new Uint8Array(0);
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_condition_broadcast(t){return 0;}
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_ml_condition_signal(t){return 0;}
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_ml_domain_id(unit){return caml_domain_id;}
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channel_get(chanid), res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max === chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] !== 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channel_get(chanid).buffered ? 1 : 0;
   }
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function caml_ml_mutex_new(unit){return new MlMutex();}
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.altname)
     try{
      var fs = require("node:fs"), fd2 = fs.openSync(flags.altname, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function caml_sys_open_internal(file, idx){
    var chanid;
    if(idx === undefined){
     idx = caml_sys_fds.length;
     chanid = new MlChanid(idx);
    }
    else if(caml_sys_fds[idx])
     chanid = caml_sys_fds[idx].chanid;
    else
     chanid = new MlChanid(idx);
    caml_sys_fds[idx] = {file: file, chanid: chanid};
    return idx | 0;
   }
   function caml_sys_open(name, flags, perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; f.writeonly = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    var
     root = resolve_fs_device(name),
     file = root.device.open(root.rest, f, perms);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      var is_node = fs_node_supported();
      function file(fd, flags){
       return is_node
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file
         (1, {buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true}),
        1);
      caml_sys_open_internal
       (file
         (2, {buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true}),
        2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined)
     caml_raise_sys_error("fd " + fd + " doesn't exist");
    var
     file = fd_desc.file,
     chanid = fd_desc.chanid,
     refill = null,
     channel =
       {file: file,
        offset: file.offset,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels.set(chanid, channel);
    return chanid;
   }
   function caml_ml_open_descriptor_in_with_flags(fd, flags){return caml_ml_open_descriptor_in(fd);
   }
   function caml_ml_open_descriptor_out(fd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined)
     caml_raise_sys_error("fd " + fd + " doesn't exist");
    var
     file = fd_desc.file,
     chanid = fd_desc.chanid,
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.offset,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels.set(chanid, channel);
    return chanid;
   }
   function caml_ml_open_descriptor_out_with_flags(fd, flags){return caml_ml_open_descriptor_out(fd);
   }
   function caml_ml_out_channels_list(){
    var l = 0, keys = caml_ml_channels.all();
    for(var k of keys){
     var chan = caml_ml_channel_get(k);
     if(chan.opened && chan.out) l = [0, k, l];
    }
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_ml_output_int(chanid, i){
    var arr = [i >> 24 & 0xff, i >> 16 & 0xff, i >> 8 & 0xff, i & 0xff];
    caml_ml_output_ta(chanid, new Uint8Array(arr), 0, 4);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr);
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid) | 0;}
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_pos_out(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset + chan.buffer_curr;
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid) | 0;}
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channel_get(chanid);
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{
     chan.file.seek(pos, 0);
     chan.offset = pos;
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channel_get(chanid);
    chan.file.seek(pos, 0);
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channel_get(chanid);
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channel_get(chanid).buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channel_get(chanid);
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channel_get(chanid).refill = f;
    return 0;
   }
   function caml_mod(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x % y;
   }
   function caml_modf_float(x){
    if(Number.isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(Number.isNaN(x)) return [0, Number.NaN, Number.NaN];
    return [0, 1 / x, x];
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst === 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src === 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst === 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src === 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var c, state = start_state, buffer = lexbuf[lex_buffer];
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] === 0) return - state - 1; else c = 256;
     else{
      c = caml_bytes_unsafe_get(buffer, lexbuf[lex_curr_pos]);
      lexbuf[lex_curr_pos]++;
     }
     var pstate = state;
     if(tbl.lex_check[base + c] === state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] === - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] === pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c === 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_nextafter_float(x, y){
    if(Number.isNaN(x) || Number.isNaN(y)) return Number.NaN;
    if(x === y) return y;
    if(x === 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y === x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) !== 0);
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] === old){x[i + 1] = n; return 1;}
    return 0;
   }
   function caml_obj_is_shared(x){return 1;}
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_obj_reachable_words(o){return 0;}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ojs_iterate_properties(o, f){
    var name;
    for(name in o) if(o.hasOwnProperty(name)) f(name);
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c();
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F();
   }
   function caml_ojs_wrap_fun_arguments(f){
    return function(){return caml_js_wrap_callback(f)(arguments);};
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xff;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xff;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xff;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495a6be);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length === undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length !== writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(Array.isArray(v) && v[0] === (v[0] | 0)){
           if(v[0] === 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0a, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0a, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v !== (v | 0)){
           var type_of_v = typeof v;
           if(type_of_v !== "number")
            caml_failwith("output_value: abstract value (" + type_of_v + ")");
           if(memo(v)) return;
           var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));
           writer.write(8, 0x0c);
           for(var i = 0; i < 8; i++) writer.write(8, t[7 - i]);
           writer.size_32 += 3;
           writer.size_64 += 2;
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0x40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return new Uint8Array(writer.chunk);};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_uint8_array(caml_output_val(v, flags));
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(caml_bytes_of_uint8_array(t), 0, s, ofs, t.length);
    return 0;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_uint8_array(caml_output_val(v, flags));
   }
   var caml_parser_trace = 0;
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(caml_sys_fds[2].chanid, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] === "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(Array.isArray(tok)){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] === "number")
       kind = "" + tok[1];
      else if(typeof tok[1] === "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    the_loop:
    for(;;)
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n !== 0){cmd = reduce; continue the_loop;}
        if(env[env_curr_char] >= 0){cmd = testshift; continue the_loop;}
        res = READ_TOKEN;
        break the_loop;
       case 1:
        if(Array.isArray(arg)){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === env[env_curr_char]){cmd = shift; continue the_loop;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         continue the_loop;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break the_loop;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] === ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           continue the_loop;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] === 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         continue the_loop;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break the_loop;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        continue the_loop;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break the_loop;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break the_loop;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        continue the_loop;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_raw_backtrace_next_slot(){return 0;}
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_read_file_content(name){
    var
     name = typeof name === "string" ? caml_string_of_jsstring(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(buf, 0, len);
     return caml_string_of_uint8_array(buf);
    }
    caml_raise_no_such_file(caml_jsstring_of_string(name));
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_record_backtrace(b){
    caml_record_backtrace_runtime_flag = b;
    return 0;
   }
   var jsoo_toplevel_reloc = undefined;
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(jsoo_toplevel_reloc)
      n = caml_callback(jsoo_toplevel_reloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else{
       var n = caml_global_data.symidx.next_idx++;
       caml_global_data.symidx[name] = n;
      }
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_runtime_events_pause(){return 0;}
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_runtime_events_resume(){return 0;}
   function caml_runtime_events_start(){return 0;}
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_set_static_env(k, v){jsoo_static_env[k] = v; return 0;}
   function caml_signbit_float(x){
    if(x === 0) x = 1 / x;
    return x < 0 ? 1 : 0;
   }
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_concat(a, b){return a + b;}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3fffffff;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_sys_argv(a){return caml_argv;}
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.is_dir(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else if(root.device.exists(root.rest))
     caml_raise_sys_error
      ("ENOTDIR: not a directory, chdir '" + caml_jsstring_of_string(dir)
       + "'");
    else
     caml_raise_no_such_file(caml_jsstring_of_string(dir));
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_sys_const_int_size(){return 32;}
   function caml_sys_const_max_wosize(){return 0x7fffffff / 4 | 0;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform === "win32"
       ? "Win32"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type === "Cygwin" ? 1 : 0;
   }
   function caml_sys_const_ostype_unix(){return os_type === "Unix" ? 1 : 0;}
   function caml_sys_const_ostype_win32(){return os_type === "Win32" ? 1 : 0;}
   function caml_sys_const_word_size(){return 32;}
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsstring(caml_current_dir);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_sys_isatty(_chan){return 0;}
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++)
     l[i + 1] = caml_string_of_jsstring(a[i]);
    return l;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name);
    return root.device.unlink(root.rest);
   }
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device !== n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require !== "undefined"){
     var child_process = require("node:child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_trampoline_return(f, args, direct){
    return {joo_tramp: f, joo_args: args, joo_direct: direct};
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_unix_cleanup(){}
   function caml_unix_lookup_file(fd, cmd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined) caml_raise_system_error(1, "EBADF", cmd);
    return fd_desc.file;
   }
   function caml_unix_close(fd){
    var file = caml_unix_lookup_file(fd, "close");
    file.close(1);
    return 0;
   }
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){caml_raise_system_error(1, "EBADF", "closedir");}
   }
   function caml_unix_filedescr_of_fd(x){return x;}
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){caml_raise_system_error(1, "EBADF", "readdir");}
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_unix_fstat(fd){
    var file = caml_unix_lookup_file(fd, "fstat");
    if(! file.stat) caml_failwith("caml_unix_fstat: not implemented");
    return file.stat(false);
   }
   function caml_unix_fstat_64(fd){
    var file = caml_unix_lookup_file(fd, "fstat");
    if(! file.stat) caml_failwith("caml_unix_fstat64: not implemented");
    return file.stat(true);
   }
   function caml_unix_ftruncate(fd, len){
    var file = caml_unix_lookup_file(fd, "ftruncate");
    if(! file.truncate) caml_failwith("caml_unix_ftruncate: not implemented");
    file.truncate(len, 1);
    return 0;
   }
   function caml_unix_ftruncate_64(fd, len){
    var file = caml_unix_lookup_file(fd, "ftruncate");
    if(! file.truncate)
     caml_failwith("caml_unix_ftruncate_64: not implemented");
    file.truncate(caml_int64_to_float(len), 1);
    return 0;
   }
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    return 1;
   }
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_unix_inchannel_of_filedescr(fd){
    var file = caml_unix_lookup_file(fd, "out_channel_of_descr");
    file.check_stream_semantics("in_channel_of_descr");
    return caml_ml_open_descriptor_in(fd);
   }
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_unix_isatty(fd){
    if(fs_node_supported()){
     var tty = require("node:tty");
     return tty.isatty(caml_unix_lookup_file(fd).fd) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_lseek(fd, len, whence){
    var file = caml_unix_lookup_file(fd, "lseek");
    return file.seek(len, whence, 1);
   }
   function caml_unix_lseek_64(fd, len, whence){
    var file = caml_unix_lookup_file(fd, "lseek");
    return file.seek(caml_int64_to_float(len), whence, 1);
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, false, true);
   }
   function caml_unix_lstat_64(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat)
     caml_failwith("caml_unix_lstat_64: not implemented");
    return root.device.lstat(root.rest, true, true);
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_unix_open(name, flags, perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.rdwr = 1; break;
       case 3:
        f.nonblock = 1; break;
       case 4:
        f.append = 1; break;
       case 5:
        f.create = 1; break;
       case 6:
        f.truncate = 1; break;
       case 7:
        f.excl = 1; break;
       case 8:
        f.noctty = 1; break;
       case 9:
        f.dsync = 1; break;
       case 10:
        f.sync = 1; break;
     }
     flags = flags[2];
    }
    var
     root = resolve_fs_device(name),
     file = root.device.open(root.rest, f, perms, true),
     idx = caml_sys_fds.length,
     chanid = new MlChanid(idx);
    caml_sys_fds[idx] = {file: file, chanid: chanid};
    return idx | 0;
   }
   function caml_unix_outchannel_of_filedescr(fd){
    var file = caml_unix_lookup_file(fd, "out_channel_of_descr");
    file.check_stream_semantics("out_channel_of_descr");
    return caml_ml_open_descriptor_out(fd);
   }
   function caml_unix_read(fd, buf, pos, len){
    var file = caml_unix_lookup_file(fd, "read");
    return file.read(caml_uint8_array_of_bytes(buf), pos, len, 1);
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_unix_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device !== n_root.device)
     caml_raise_system_error(1, "EXDEV", "rename");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest, true);
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_unix_startup(){}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, false, true);
   }
   function caml_unix_stat_64(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat)
     caml_failwith("caml_unix_stat_64: not implemented");
    return root.device.stat(root.rest, true, true);
   }
   function caml_unix_symlink(to_dir, src, dst){
    var dst_root = resolve_fs_device(dst);
    if(! dst_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return dst_root.device.symlink
            (to_dir, caml_jsstring_of_string(src), dst_root.rest, true);
   }
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_unix_truncate(name, len){
    var root = resolve_fs_device(name);
    if(! root.device.truncate)
     caml_failwith("caml_unix_truncate: not implemented");
    root.device.truncate(root.rest, len, true);
    return 0;
   }
   function caml_unix_truncate_64(name, len){
    var root = resolve_fs_device(name);
    if(! root.device.truncate)
     caml_failwith("caml_unix_truncate_64: not implemented");
    root.device.truncate(root.rest, caml_int64_to_float(len), true);
    return 0;
   }
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    root.device.unlink(root.rest, true);
    return 0;
   }
   function caml_unix_utimes(name, atime, mtime){
    var root = resolve_fs_device(name);
    if(! root.device.utimes)
     caml_failwith("caml_unix_utimes: not implemented");
    root.device.utimes(root.rest, atime, mtime, true);
    return 0;
   }
   function caml_unix_write(fd, buf, pos, len){
    var
     file = caml_unix_lookup_file(fd, "write"),
     a = caml_uint8_array_of_bytes(buf),
     written = 0;
    while(len > 0){
     var n = file.write(a, pos, len, 1);
     written += n;
     pos += n;
     len -= n;
    }
    return written;
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path === name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v === 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_wrap_exception(e){
    {
     if(Array.isArray(e)) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest();}catch(e){}
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function caml_zarith_marshal(writer, v, sz){
    let vn = BigInt(v), neg = vn < 0;
    if(neg) vn = - vn;
    let bits = [];
    while(vn >= 2 ** 32){bits.push(Number(vn & 0xffffffffn)); vn >>= 32n;}
    bits.push(Number(vn) | 0);
    writer.write(8, neg ? 1 : 0);
    let block = bits.length, len = block * 4;
    writer.write(32, len);
    for(let i = 0; i < block; i++){
     writer.write(8, bits[i] >>> 0 & 0xff);
     writer.write(8, bits[i] >>> 8 & 0xff);
     writer.write(8, bits[i] >>> 16 & 0xff);
     writer.write(8, bits[i] >>> 24 & 0xff);
    }
    sz[0] = 4 * (1 + ((len + 3) / 4 | 0));
    sz[1] = 8 * (1 + ((len + 7) / 8 | 0));
   }
   function ml_z_normalize(x){
    if(typeof x === "number"){if(x === (x | 0)) return x; return BigInt(x);}
    if(- 2147483648 <= x && x <= 2147483647) return Number(x) | 0;
    return x;
   }
   function caml_zarith_unmarshal(reader, sz){
    let negate;
    switch(reader.read8u()){
      case 1:
       negate = true; break;
      case 0:
       negate = false; break;
      default: caml_failwith("input_value: z (malformed input)");
    }
    let len = reader.read32u(), x = 0n;
    for(let i = 0; i < len / 4; i++){
     let y = reader.read8u();
     y |= reader.read8u() << 8;
     y |= reader.read8u() << 16;
     y |= reader.read8u() << 24;
     x |= BigInt.asUintN(32, BigInt(y)) << BigInt(i) * 32n;
    }
    if(negate) x = - x;
    sz[0] = len + 4;
    return ml_z_normalize(x);
   }
   var
    zstd_decompress =
      function(){
        var
         ab = ArrayBuffer,
         u8 = Uint8Array,
         u16 = Uint16Array,
         i16 = Int16Array,
         u32 = Uint32Array,
         i32 = Int32Array;
        function slc(v, s, e){
         if(u8.prototype.slice) return u8.prototype.slice.call(v, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         var n = new u8(e - s);
         n.set(v.subarray(s, e));
         return n;
        }
        function fill(v, n, s, e){
         if(u8.prototype.fill) return u8.prototype.fill.call(v, n, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         for(; s < e; ++s) v[s] = n;
         return v;
        }
        function cpw(v, t, s, e){
         if(u8.prototype.copyWithin)
          return u8.prototype.copyWithin.call(v, t, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         while(s < e) v[t++] = v[s++];
        }
        var
         ec =
           ["invalid zstd data",
            "window size too large (>2046MB)",
            "invalid block type",
            "FSE accuracy too high",
            "match distance too far back",
            "unexpected EOF"];
        function err(ind, msg, nt){
         var e = new Error(msg || ec[ind]);
         e.code = ind;
         if(! nt) throw e;
         return e;
        }
        function rb(d, b, n){
         var i = 0, o = 0;
         for(; i < n; ++i) o |= d[b++] << (i << 3);
         return o;
        }
        function b4(d, b){
         return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        }
        function rzfh(dat, w){
         var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
         if(n3 === 0x2fb528 && dat[3] === 253){
          var
           flg = dat[4],
           ss = flg >> 5 & 1,
           cc = flg >> 2 & 1,
           df = flg & 3,
           fcf = flg >> 6;
          if(flg & 8) err(0);
          var bt = 6 - ss, db = df === 3 ? 4 : df, di = rb(dat, bt, db);
          bt += db;
          var
           fsb = fcf ? 1 << fcf : ss,
           fss = rb(dat, bt, fsb) + (fcf === 1 && 256),
           ws = fss;
          if(! ss){
           var wb = 1 << 10 + (dat[5] >> 3);
           ws = wb + (wb >> 3) * (dat[5] & 7);
          }
          if(ws > 2145386496) err(1);
          var buf = new u8((w === 1 ? fss || ws : w ? 0 : ws) + 12);
          buf[0] = 1, buf[4] = 4, buf[8] = 8;
          return {b: bt + fsb,
                  y: 0,
                  l: 0,
                  d: di,
                  w: w && w !== 1 ? w : buf.subarray(12),
                  e: ws,
                  o: new i32(buf.buffer, 0, 3),
                  u: fss,
                  c: cc,
                  m: Math.min(131072, ws)};
         }
         else if((n3 >> 4 | dat[3] << 20) === 0x184d2a5)
          return b4(dat, 4) + 8;
         err(0);
        }
        function msb(val){
         var bits = 0;
         for(; 1 << bits <= val; ++bits) ;
         return bits - 1;
        }
        function rfse(dat, bt, mal){
         var tpos = (bt << 3) + 4, al = (dat[bt] & 15) + 5;
         if(al > mal) err(3);
         var
          sz = 1 << al,
          probs = sz,
          sym = - 1,
          re = - 1,
          i = - 1,
          ht = sz,
          buf = new ab(512 + (sz << 2)),
          freq = new i16(buf, 0, 256),
          dstate = new u16(buf, 0, 256),
          nstate = new u16(buf, 512, sz),
          bb1 = 512 + (sz << 1),
          syms = new u8(buf, bb1, sz),
          nbits = new u8(buf, bb1 + sz);
         while(sym < 255 && probs > 0){
          var
           bits = msb(probs + 1),
           cbt = tpos >> 3,
           msk = (1 << bits + 1) - 1,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7)
             & msk,
           msk1fb = (1 << bits) - 1,
           msv = msk - probs - 1,
           sval = val & msk1fb;
          if(sval < msv)
           tpos += bits, val = sval;
          else{tpos += bits + 1; if(val > msk1fb) val -= msv;}
          freq[++sym] = --val;
          if(val === - 1){probs += val; syms[--ht] = sym;} else probs -= val;
          if(! val)
           do{
            var rbt = tpos >> 3;
            re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
            tpos += 2;
            sym += re;
           }
           while
            (re === 3);
         }
         if(sym > 255 || probs) err(0);
         var sympos = 0, sstep = (sz >> 1) + (sz >> 3) + 3, smask = sz - 1;
         for(var s = 0; s <= sym; ++s){
          var sf = freq[s];
          if(sf < 1){dstate[s] = - sf; continue;}
          for(i = 0; i < sf; ++i){
           syms[sympos] = s;
           do sympos = sympos + sstep & smask;while(sympos >= ht);
          }
         }
         if(sympos) err(0);
         for(i = 0; i < sz; ++i){
          var ns = dstate[syms[i]]++, nb = nbits[i] = al - msb(ns);
          nstate[i] = (ns << nb) - sz;
         }
         return [tpos + 7 >> 3, {b: al, s: syms, n: nbits, t: nstate}];
        }
        function rhu(dat, bt){
         var
          i = 0,
          wc = - 1,
          buf = new u8(292),
          hb = dat[bt],
          hw = buf.subarray(0, 256),
          rc = buf.subarray(256, 268),
          ri = new u16(buf.buffer, 268);
         if(hb < 128){
          var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];
          bt += hb;
          var epos = ebt << 3, lb = dat[bt];
          if(! lb) err(0);
          var
           st1 = 0,
           st2 = 0,
           btr1 = fdt.b,
           btr2 = btr1,
           fpos = (++bt << 3) - 8 + msb(lb);
          for(;;){
           fpos -= btr1;
           if(fpos < epos) break;
           var cbt = fpos >> 3;
           st1 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
           hw[++wc] = fdt.s[st1];
           fpos -= btr2;
           if(fpos < epos) break;
           cbt = fpos >> 3;
           st2 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
           hw[++wc] = fdt.s[st2];
           btr1 = fdt.n[st1];
           st1 = fdt.t[st1];
           btr2 = fdt.n[st2];
           st2 = fdt.t[st2];
          }
          if(++wc > 255) err(0);
         }
         else{
          wc = hb - 127;
          for(; i < wc; i += 2){
           var byte = dat[++bt];
           hw[i] = byte >> 4;
           hw[i + 1] = byte & 15;
          }
          ++bt;
         }
         var wes = 0;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          if(wt > 11) err(0);
          wes += wt && 1 << wt - 1;
         }
         var mb = msb(wes) + 1, ts = 1 << mb, rem = ts - wes;
         if(rem & rem - 1) err(0);
         hw[wc++] = msb(rem) + 1;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          ++rc[hw[i] = wt && mb + 1 - wt];
         }
         var
          hbuf = new u8(ts << 1),
          syms = hbuf.subarray(0, ts),
          nb = hbuf.subarray(ts);
         ri[mb] = 0;
         for(i = mb; i > 0; --i){
          var pv = ri[i];
          fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
         }
         if(ri[0] !== ts) err(0);
         for(i = 0; i < wc; ++i){
          var bits = hw[i];
          if(bits){
           var code = ri[bits];
           fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
          }
         }
         return [bt, {n: nb, b: mb, s: syms}];
        }
        var
         dllt =
           rfse
             (new
               u8
               ([81,
                 16,
                 99,
                 140,
                 49,
                 198,
                 24,
                 99,
                 12,
                 33,
                 196,
                 24,
                 99,
                 102,
                 102,
                 134,
                 70,
                 146,
                 4]),
              0,
              6)
            [1],
         dmlt =
           rfse
             (new
               u8
               ([33,
                 20,
                 196,
                 24,
                 99,
                 140,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 36,
                 9]),
              0,
              6)
            [1],
         doct =
           rfse
             (new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]),
              0,
              5)
            [1];
        function b2bl(b, s){
         var len = b.length, bl = new i32(len);
         for(var i = 0; i < len; ++i){bl[i] = s; s += 1 << b[i];}
         return bl;
        }
        var
         llb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                16843009,
                50528770,
                134678020,
                202050057,
                269422093]).buffer,
             0,
             36),
         llbl = b2bl(llb, 0),
         mlb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                16843009,
                50528770,
                117769220,
                185207048,
                252579084,
                16]).buffer,
             0,
             53),
         mlbl = b2bl(mlb, 3);
        function dhu(dat, out, hu){
         var
          len = dat.length,
          ss = out.length,
          lb = dat[len - 1],
          msk = (1 << hu.b) - 1,
          eb = - hu.b;
         if(! lb) err(0);
         var
          st = 0,
          btr = hu.b,
          pos = (len << 3) - 8 + msb(lb) - btr,
          i = - 1;
         while(pos > eb && i < ss){
          var
           cbt = pos >> 3,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
          st = (st << btr | val) & msk;
          out[++i] = hu.s[st];
          pos -= btr = hu.n[st];
         }
         if(pos !== eb || i + 1 !== ss) err(0);
        }
        function dhu4(dat, out, hu){
         var
          bt = 6,
          ss = out.length,
          sz1 = ss + 3 >> 2,
          sz2 = sz1 << 1,
          sz3 = sz1 + sz2;
         dhu
          (dat.subarray(bt, bt += dat[0] | dat[1] << 8),
           out.subarray(0, sz1),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[2] | dat[3] << 8),
           out.subarray(sz1, sz2),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[4] | dat[5] << 8),
           out.subarray(sz2, sz3),
           hu);
         dhu(dat.subarray(bt), out.subarray(sz3), hu);
        }
        function rzb(dat, st, out){
         var _a, bt = st.b, b0 = dat[bt], btype = b0 >> 1 & 3;
         st.l = b0 & 1;
         var
          sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13,
          ebt = (bt += 3) + sz;
         if(btype === 1){
          if(bt >= dat.length) return;
          st.b = bt + 1;
          if(out){fill(out, dat[bt], st.y, st.y += sz); return out;}
          return fill(new u8(sz), dat[bt]);
         }
         if(ebt > dat.length) return;
         if(btype === 0){
          st.b = ebt;
          if(out){
           out.set(dat.subarray(bt, ebt), st.y);
           st.y += sz;
           return out;
          }
          return slc(dat, bt, ebt);
         }
         if(btype === 2){
          var
           b3 = dat[bt],
           lbt = b3 & 3,
           sf = b3 >> 2 & 3,
           lss = b3 >> 4,
           lcs = 0,
           s4 = 0;
          if(lbt < 2)
           if(sf & 1)
            lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);
           else
            lss = b3 >> 3;
          else{
           s4 = sf;
           if(sf < 2)
            lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;
           else if(sf === 2)
            lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12,
            lcs = dat[bt] >> 2 | dat[++bt] << 6;
           else
            lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12,
            lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
          }
          ++bt;
          var
           buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m),
           spl = buf.length - lss;
          if(lbt === 0)
           buf.set(dat.subarray(bt, bt += lss), spl);
          else if(lbt === 1)
           fill(buf, dat[bt++], spl);
          else{
           var hu = st.h;
           if(lbt === 2){
            var hud = rhu(dat, bt);
            lcs += bt - (bt = hud[0]);
            st.h = hu = hud[1];
           }
           else if(! hu) err(0);
           (s4 ? dhu4 : dhu)
            (dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
          }
          var ns = dat[bt++];
          if(ns){
           if(ns === 255)
            ns = (dat[bt++] | dat[bt++] << 8) + 0x7f00;
           else if(ns > 127) ns = ns - 128 << 8 | dat[bt++];
           var scm = dat[bt++];
           if(scm & 3) err(0);
           var dts = [dmlt, doct, dllt];
           for(var i = 2; i > - 1; --i){
            var md = scm >> (i << 1) + 2 & 3;
            if(md === 1){
             var rbuf = new u8([0, 0, dat[bt++]]);
             dts[i] =
              {s: rbuf.subarray(2, 3),
               n: rbuf.subarray(0, 1),
               t: new u16(rbuf.buffer, 0, 1),
               b: 0};
            }
            else if(md === 2)
             _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
            else if(md === 3){if(! st.t) err(0); dts[i] = st.t[i];}
           }
           var
            _b = st.t = dts,
            mlt = _b[0],
            oct = _b[1],
            llt = _b[2],
            lb = dat[ebt - 1];
           if(! lb) err(0);
           var
            spos = (ebt << 3) - 8 + msb(lb) - llt.b,
            cbt = spos >> 3,
            oubt = 0,
            lst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
           cbt = (spos -= oct.b) >> 3;
           var
            ost =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
           cbt = (spos -= mlt.b) >> 3;
           var
            mst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
           for(++ns; --ns;){
            var
             llc = llt.s[lst],
             lbtr = llt.n[lst],
             mlc = mlt.s[mst],
             mbtr = mlt.n[mst],
             ofc = oct.s[ost],
             obtr = oct.n[ost];
            cbt = (spos -= ofc) >> 3;
            var
             ofp = 1 << ofc,
             off =
               ofp
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16
                | dat[cbt + 3] << 24)
                >>> (spos & 7)
                & ofp - 1);
            cbt = (spos -= mlb[mlc]) >> 3;
            var
             ml =
               mlbl[mlc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << mlb[mlc]) - 1);
            cbt = (spos -= llb[llc]) >> 3;
            var
             ll =
               llbl[llc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << llb[llc]) - 1);
            cbt = (spos -= lbtr) >> 3;
            lst =
             llt.t[lst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
            cbt = (spos -= mbtr) >> 3;
            mst =
             mlt.t[mst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
            cbt = (spos -= obtr) >> 3;
            ost =
             oct.t[ost]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
            if(off > 3){
             st.o[2] = st.o[1];
             st.o[1] = st.o[0];
             st.o[0] = off -= 3;
            }
            else{
             var idx = off - (ll !== 0);
             if(idx){
              off = idx === 3 ? st.o[0] - 1 : st.o[idx];
              if(idx > 1) st.o[2] = st.o[1];
              st.o[1] = st.o[0];
              st.o[0] = off;
             }
             else
              off = st.o[0];
            }
            for(var i = 0; i < ll; ++i) buf[oubt + i] = buf[spl + i];
            oubt += ll, spl += ll;
            var stin = oubt - off;
            if(stin < 0){
             var len = - stin, bs = st.e + stin;
             if(len > ml) len = ml;
             for(var i = 0; i < len; ++i) buf[oubt + i] = st.w[bs + i];
             oubt += len, ml -= len, stin = 0;
            }
            for(var i = 0; i < ml; ++i) buf[oubt + i] = buf[stin + i];
            oubt += ml;
           }
           if(oubt !== spl)
            while(spl < buf.length) buf[oubt++] = buf[spl++];
           else
            oubt = buf.length;
           if(out) st.y += oubt; else buf = slc(buf, 0, oubt);
          }
          else if(out){
           st.y += lss;
           if(spl) for(var i = 0; i < lss; ++i) buf[i] = buf[spl + i];
          }
          else if(spl) buf = slc(buf, spl);
          st.b = ebt;
          return buf;
         }
         err(2);
        }
        function cct(bufs, ol){
         if(bufs.length === 1) return bufs[0];
         var buf = new u8(ol);
         for(var i = 0, b = 0; i < bufs.length; ++i){
          var chk = bufs[i];
          buf.set(chk, b);
          b += chk.length;
         }
         return buf;
        }
        return function(dat, buf){
         var bt = 0, bufs = [], nb = + ! buf, ol = 0;
         while(dat.length){
          var st = rzfh(dat, nb || buf);
          if(typeof st === "object"){
           if(nb){
            buf = null;
            if(st.w.length === st.u){bufs.push(buf = st.w); ol += st.u;}
           }
           else{bufs.push(buf); st.e = 0;}
           while(! st.l){
            var blk = rzb(dat, st, buf);
            if(! blk) err(5);
            if(buf)
             st.e = st.y;
            else{
             bufs.push(blk);
             ol += blk.length;
             cpw(st.w, 0, blk.length);
             st.w.set(blk, st.w.length - blk.length);
            }
           }
           bt = st.b + st.c * 4;
          }
          else
           bt = st;
          dat = dat.subarray(bt);
         }
         return cct(bufs, ol);};
       }
       ();
   function caml_zstd_initialize(unit){
    caml_decompress_input = zstd_decompress;
    return 1;
   }
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in === 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow === 1 ? 0 : 1;
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000ffff);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xffff0000){b += 16; a >>>= 16;}
    if(a & 0xff00){b += 8; a >>>= 8;}
    if(a & 0xf0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits === 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits === 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000ffff)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in === 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow === 1 ? 0 : 1);
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 === 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d === 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] !== 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function initialize_nat(){
    caml_custom_ops._nat =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function is_digit_normalized(nat, ofs){return 1;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] === 0) return 1;
    return 0;
   }
   function jsoo_bigint_mod_pow(self, exp, mod){
    if(mod === 0n) throw new Error("Cannot take modPow with modulo 0");
    if(exp < 0) throw new Error("Cannot take modPow with negative exponent");
    let r = 1n, base = self % mod;
    while(exp > 0){
     if(base === 0n) return 0n;
     if((exp & 1n) === 1n) r = r * base % mod;
     exp >>= 1n;
     base = base * base % mod;
    }
    return r;
   }
   function jsoo_bigint_rand_between(low, high){
    let
     range = high - low + 1n,
     base = 1e7,
     bigbase = BigInt(base),
     result = 0n,
     restricted = true,
     digits = [];
    while(range >= bigbase){
     digits.push(Number(range % bigbase));
     range /= bigbase;
    }
    digits.push(Number(range));
    digits.reverse();
    for(let i = 0; i < digits.length; i++){
     let top = restricted ? digits[i] | 0 : base;
     range /= bigbase;
     let digit = Math.floor(Math.random() * top);
     result *= bigbase;
     result += BigInt(digit);
     if(digit < top) restricted = false;
    }
    return low + result;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.jsoo_fs_tmp) globalThis.jsoo_fs_tmp = [];
     globalThis.jsoo_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   function jsoo_z_of_js_string_base(base, s){
    if(base == 0){
     base = 10;
     let p = 0, sign = 1;
     if(s[p] == "-"){sign = - 1; p++;} else if(s[p] == "+") p++;
     if(s[p] == "0"){
      p++;
      if(s.length == p)
       return 0;
      else{
       let bc = s[p];
       if(bc == "o" || bc == "O")
        base = 8;
       else if(bc == "x" || bc == "X")
        base = 16;
       else if(bc == "b" || bc == "B") base = 2;
       if(base != 10){s = s.substring(p + 1); if(sign == - 1) s = "-" + s;}
      }
     }
    }
    function digit(code){
     if(code >= 48 && code <= 57) return code - 48;
     if(code >= 97 && code <= 102) return code - 97 + 10;
     if(code >= 65 && code <= 70) return code - 65 + 10;
    }
    let i = 0;
    if(s[i] == "+") s = s.substring(1); else if(s[i] == "-") i++;
    if(s[i] == "_")
     caml_invalid_argument("Z.of_substring_base: invalid digit");
    s = s.replace(/_/g, "");
    if(s == "-" || s == "") s = "0";
    for(; i < s.length; i++){
     let c = digit(s.charCodeAt(i));
     if(c == undefined || c >= base)
      caml_invalid_argument("Z.of_substring_base: invalid digit");
    }
    if(base === 10) return ml_z_normalize(BigInt(s));
    let neg = false;
    i = 0;
    if(s[i] == "-"){neg = true; i++;}
    let n = 0n;
    for(; i < s.length; i++){
     n *= BigInt(base);
     n += BigInt(digit(s.charCodeAt(i)));
    }
    if(neg) n = - n;
    return ml_z_normalize(n);
   }
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function length_nat(x){return x.data.length;}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function ml_z_abs(z1){if(z1 < 0) return ml_z_normalize(- z1); return z1;}
   function ml_z_add(z1, z2){return ml_z_normalize(BigInt(z1) + BigInt(z2));}
   function ml_z_bin(n, k){
    if(k < 0) caml_invalid_argument("Z.bin: non-positive argument");
    n = BigInt(n);
    k = BigInt(k);
    let coeff = 1n;
    for(let x = n - k + 1n; x <= n; x++) coeff *= x;
    for(let x = 1n; x <= k; x++) coeff /= x;
    return ml_z_normalize(coeff);
   }
   function ml_z_div(z1, z2){
    if(z2 == 0) caml_raise_zero_divide();
    return ml_z_normalize(BigInt(z1) / BigInt(z2));
   }
   function ml_z_sign(z1){return z1 == 0 ? 0 : z1 > 0 ? 1 : - 1;}
   function ml_z_cdiv(z1, z2){
    let z1_pos = ml_z_sign(z1), z2_pos = ml_z_sign(z2);
    if(z1_pos * z2_pos > 0)
     if(BigInt(z1) % BigInt(z2) !== 0n)
      return ml_z_normalize(BigInt(z1) / BigInt(z2) + 1n);
    return ml_z_div(z1, z2);
   }
   function ml_z_compare(z1, z2){return z1 == z2 ? 0 : z1 > z2 ? 1 : - 1;}
   function ml_z_divisible(a, b){
    if(a == 0 && b == 0) return 1;
    if(b == 0) return 0;
    if(b == 1) return 1;
    if(b == 2 || b == - 2) return + ((BigInt(a) & 1n) === 0n);
    return + (BigInt(a) % BigInt(b) === 0n);
   }
   function ml_z_congruent(a, b, c){
    return ml_z_divisible(BigInt(a) - BigInt(b), c);
   }
   function ml_z_rem(z1, z2){
    if(z2 == 0) caml_raise_zero_divide();
    return ml_z_normalize(BigInt(z1) % BigInt(z2));
   }
   function ml_z_div_rem(z1, z2){
    return [0, ml_z_div(z1, z2), ml_z_rem(z1, z2)];
   }
   function ml_z_divexact(z1, z2){return ml_z_div(z1, z2);}
   function ml_z_equal(z1, z2){return z1 == z2 ? 1 : 0;}
   function ml_z_extract(z1, pos, len){
    return ml_z_normalize
            (BigInt(z1) >> BigInt(pos) & (1n << BigInt(len)) - 1n);
   }
   function ml_z_extract_small(z1, pos, len){
    return Number(BigInt.asIntN(32, z1 >> BigInt(pos))) & (1 << len) - 1;
   }
   function ml_z_facM(i, m){
    if(i < 0 || m < 0) caml_invalid_argument("Z.facM: non-positive argument");
    if(m == 0) return i;
    let mn = BigInt(m), current = BigInt(i), res = 1n;
    while(current > 0){res *= current; current -= mn;}
    return ml_z_normalize(res);
   }
   function ml_z_fac(i){
    if(i < 0) caml_invalid_argument("Z.fac: non-positive argument");
    return ml_z_facM(i, 1);
   }
   function ml_z_fac2(i){
    if(i < 0) caml_invalid_argument("Z.fac2: non-positive argument");
    return ml_z_facM(i, 2);
   }
   function ml_z_fdiv(z1, z2){
    let z1_pos = ml_z_sign(z1), z2_pos = ml_z_sign(z2);
    if(z1_pos * z2_pos < 0)
     if(BigInt(z1) % BigInt(z2) !== 0n)
      return ml_z_normalize(BigInt(z1) / BigInt(z2) - 1n);
    return ml_z_div(z1, z2);
   }
   function ml_z_fib(i){
    if(i < 0) caml_invalid_argument("Z.fib: negative arguments");
    if(i == 0 || i == 1) return i;
    let a = 0n, b = 1n;
    for(let k = 1; k < i; k++){let b2 = b; b += a; a = b2;}
    return ml_z_normalize(b);
   }
   function ml_z_fits_int(z1){
    return typeof z1 === "number" ? + (z1 === (z1 | 0)) : 0;
   }
   function ml_z_fits_int32(z1){return ml_z_fits_int(z1);}
   function ml_z_fits_int32_unsigned(z1){return 0 <= z1 && z1 <= 4294967295;}
   function ml_z_fits_int64(z1){
    return z1 <= 9223372036854775807n && z1 >= - 9223372036854775808n ? 1 : 0;
   }
   function ml_z_fits_int64_unsigned(z1){
    return 0 <= z1 && z1 <= 18446744073709551615n;
   }
   function ml_z_fits_nativeint(z1){return ml_z_fits_int(z1);}
   function ml_z_fits_nativeint_unsigned(z1){return ml_z_fits_int32_unsigned(z1);
   }
   function ml_z_format(fmt, z1){
    let z1n = BigInt(z1);
    fmt = caml_jsbytes_of_string(fmt);
    let
     base = 10,
     cas = 0,
     width = 0,
     alt = 0,
     dir = 0,
     sign = "",
     pad = " ",
     idx = 0,
     prefix = "";
    while(fmt[idx] == "%") idx++;
    for(;; idx++)
     if(fmt[idx] == "#")
      alt = 1;
     else if(fmt[idx] == "0")
      pad = "0";
     else if(fmt[idx] == "-")
      dir = 1;
     else if(fmt[idx] == " " || fmt[idx] == "+") sign = fmt[idx]; else break;
    if(z1n < 0){sign = "-"; z1n = - z1n;}
    for(; fmt[idx] >= "0" && fmt[idx] <= "9"; idx++)
     width = 10 * width + + fmt[idx];
    switch(fmt[idx]){
      case "i":
      case "d":
      case "u": break;
      case "b":
       base = 2; if(alt) prefix = "0b"; break;
      case "o":
       base = 8; if(alt) prefix = "0o"; break;
      case "x":
       base = 16; if(alt) prefix = "0x"; break;
      case "X":
       base = 16; if(alt) prefix = "0X"; cas = 1; break;
      default: caml_failwith("Unsupported format '" + fmt + "'");
    }
    if(dir) pad = " ";
    let res = z1n.toString(base);
    if(cas === 1) res = res.toUpperCase();
    let size = res.length;
    if(pad == " ")
     if(dir){
      res = sign + prefix + res;
      for(; res.length < width;) res = res + pad;
     }
     else{
      res = sign + prefix + res;
      for(; res.length < width;) res = pad + res;
     }
    else{
     let pre = sign + prefix;
     for(; res.length + pre.length < width;) res = pad + res;
     res = pre + res;
    }
    return caml_string_of_jsbytes(res);
   }
   function ml_z_gcd(z1, z2){
    let a = BigInt(z1);
    if(a < 0) a = - a;
    let b = BigInt(z2);
    if(b < 0) b = - b;
    if(a === b) return ml_z_normalize(a);
    if(a === 0n) return ml_z_normalize(b);
    if(b === 0n) return ml_z_normalize(a);
    let c = 1n, d, t;
    function min(a, b){return a < b ? a : b;}
    while((a & 1n) === 0n && (b & 1n) === 0n){
     d = min(a & - a, b & - b);
     a /= d;
     b /= d;
     c *= d;
    }
    while((a & 1n) === 0n) a /= a & - a;
    do{
     while((b & 1n) === 0n) b /= b & - b;
     if(a > b){t = b; b = a; a = t;}
     b -= a;
    }
    while
     (b !== 0n);
    return ml_z_normalize(c === 1n ? a : a * c);
   }
   function ml_z_gcdext_intern(z1, z2){
    if(z1 == 0) caml_raise_zero_divide();
    let
     a = BigInt(z1),
     b = BigInt(z2),
     x = 0n,
     lastx = 1n,
     y = 1n,
     lasty = 1n,
     q,
     t,
     r;
    while(b !== 0n){
     q = a / b;
     r = a - q * b;
     t = x;
     x = lastx - q * x;
     lastx = t;
     t = y;
     y = lasty - q * y;
     lasty = t;
     a = b;
     b = r;
    }
    return a < 0
            ? [0, ml_z_normalize(- a), ml_z_normalize(- lastx), 1]
            : [0, ml_z_normalize(a), ml_z_normalize(lastx), 1];
   }
   function ml_z_popcount(z){
    if(z < 0) caml_raise_constant(caml_named_value("ml_z_overflow"));
    z = BigInt(z);
    let i;
    for(i = 0; z !== 0n; i++) z &= z - 1n;
    if(i !== (i | 0)) caml_raise_constant(caml_named_value("ml_z_overflow"));
    return i | 0;
   }
   function ml_z_hamdist(z1, z2){
    if(z1 < 0 !== z2 < 0)
     caml_raise_constant(caml_named_value("ml_z_overflow"));
    if((typeof z1 == "bignum" || typeof z2 == "bignum") && (z1 < 0 || z2 < 0))
     caml_invalid_argument("Z.hamdist: negative arguments");
    return ml_z_popcount(BigInt(z1) ^ BigInt(z2));
   }
   function ml_z_hash(z1){
    let z1n = BigInt(z1), neg = z1n < 0;
    if(neg) z1n = - z1n;
    let acc = 0, len = 1, left = z1n;
    while(left >= 2 ** 32){
     acc = caml_hash_mix_int(acc, Number(left & 0xffffffffn));
     left >>= 32n;
     len += 1;
    }
    acc = caml_hash_mix_int(acc, Number(left) | 0);
    if(len % 2 !== 0) acc = caml_hash_mix_int(acc, 0);
    if(neg) acc = acc + 1;
    return acc | 0;
   }
   function ml_z_init(unit){
    caml_custom_ops["_z"] =
     {serialize: caml_zarith_marshal,
      deserialize: caml_zarith_unmarshal,
      hash: ml_z_hash,
      compare: ml_z_compare};
    Object.defineProperty(BigInt.prototype, "caml_custom", {value: "_z"});
    return 0;
   }
   function ml_z_invert(a, n){
    if(n == 1 || n == - 1) return 0;
    if(n == 0 && (a == 1 || a == - 1)) return a;
    if(n == 0 || a == 0) caml_raise_zero_divide();
    let x = ml_z_gcdext_intern(a, n), r = BigInt(x[2]);
    a = BigInt(a);
    n = BigInt(n);
    if(n < 0) n = - n;
    let tmp = a * r % n;
    if(tmp < 0) tmp += n;
    if(r < 0) r += n;
    if(tmp == 1) return ml_z_normalize(r);
    caml_raise_zero_divide();
   }
   function ml_z_jacobi(n, k){
    let nn = BigInt(n), kn = BigInt(k);
    if(kn <= 0 || kn % 2n !== 1n)
     caml_invalid_argument("Z.jacobi: second argument is negative or even");
    nn = nn % kn;
    if(nn < 0) nn += kn;
    let t = 1;
    while(nn !== 0n){
     while(nn % 2n === 0n){
      nn /= 2n;
      let r = kn % 8n;
      if(r === 3n || r === 5n) t = - t;
     }
     let n1 = nn, k1 = kn;
     nn = k1;
     kn = n1;
     if(nn % 4n === 3n && kn % 4n === 3n) t = - t;
     nn = nn % kn;
    }
    return kn === 1n ? t : 0;
   }
   function ml_z_kronecker(n, k){
    caml_failwith("ml_z_kronecker is not implemented");
   }
   function ml_z_legendre(a, b){return ml_z_jacobi(a, b);}
   function ml_z_logand(z1, z2){
    return ml_z_normalize(BigInt(z1) & BigInt(z2));
   }
   function ml_z_lognot(z1){return ml_z_normalize(~ z1);}
   function ml_z_logor(z1, z2){
    return ml_z_normalize(BigInt(z1) | BigInt(z2));
   }
   function ml_z_logxor(z1, z2){
    return ml_z_normalize(BigInt(z1) ^ BigInt(z2));
   }
   function ml_z_lucnum(i){
    if(i < 0) caml_invalid_argument("Z.lucnum: negative arguments");
    if(i == 0) return 2;
    if(i == 1) return 1;
    let a = 2n, b = 1n;
    for(let k = 1; k < i; k++){let b2 = b; b += a; a = b2;}
    return ml_z_normalize(b);
   }
   function ml_z_mul(z1, z2){return ml_z_normalize(BigInt(z1) * BigInt(z2));}
   function ml_z_mul_overflows(x, y){let z = x * y; return + (z !== (z | 0));}
   function ml_z_neg(z1){return ml_z_normalize(- z1);}
   function ml_z_probab_prime(z, i){
    if(z < 0) z = - z;
    if(z == 1) return 0;
    if(z == 2 || z == 3 || z == 5) return 1;
    let n = BigInt(z);
    if(n % 2n === 0n || n % 3n === 0n || n % 5n === 0n) return 0;
    if(z < 49) return 1;
    let nPrev = n - 1n, b = nPrev, r = 0, a, d, j, x;
    while(b % 2n === 0n) b /= 2n, r++;
    next:
    for(j = 0; j < i; j++){
     a = jsoo_bigint_rand_between(2n, n - 2n);
     x = jsoo_bigint_mod_pow(a, b, n);
     if(x === 1n || x === nPrev) continue;
     for(d = r - 1; d != 0; d--){
      x = x * x % n;
      if(x === 1n) return 0;
      if(x === nPrev) continue next;
     }
     return 0;
    }
    return 1;
   }
   function ml_z_nextprime(z1){
    if(z1 < 1 || z1 == 1) return 2;
    let z1n = BigInt(z1);
    if((z1n & 1n) === 1n) z1n += 2n; else z1n += 1n;
    for(;;)
     if(ml_z_probab_prime(z1n, 25))
      return ml_z_normalize(z1n);
     else
      z1n += 2n;
   }
   function ml_z_numbits(z1){
    if(z1 < 0) z1 = - z1;
    let n = 0, upperBound = 1n;
    while(upperBound <= z1){n += 1; upperBound = upperBound << 1n;}
    return n;
   }
   function ml_z_of_bits(z1){
    let r = 0n, base = 1n;
    for(let i = 0; i < caml_ml_string_length(z1); i++){
     let d = caml_string_unsafe_get(z1, i);
     r += base * BigInt(d);
     base *= 256n;
    }
    return ml_z_normalize(r);
   }
   function ml_z_of_float(f1){
    if(f1 == Infinity || f1 == - Infinity || f1 != f1)
     caml_raise_constant(caml_named_value("ml_z_overflow"));
    return ml_z_normalize(f1 < 0 ? Math.ceil(f1) : Math.floor(f1));
   }
   function ml_z_of_int32(i){return i | 0;}
   function ml_z_of_int64(i64){
    let neg = false;
    if(caml_int64_compare(i64, caml_int64_create_lo_hi(0, 0)) < 0){neg = true; i64 = caml_int64_neg(i64);}
    let
     lo = caml_int64_lo32(i64) >>> 0,
     hi = caml_int64_hi32(i64) >>> 0,
     x = BigInt(lo) + (BigInt(hi) << 32n);
    if(neg) x = - x;
    return ml_z_normalize(x);
   }
   function ml_z_of_nativeint(i){return i | 0;}
   function ml_z_of_substring_base(base, s, pos, len){
    s = caml_jsbytes_of_string(s);
    if(pos != 0 || len != s.length){
     if(s.length - pos < len)
      caml_invalid_argument("Z.of_substring_base: invalid offset or length");
     s = s.slice(pos, pos + len);
    }
    return jsoo_z_of_js_string_base(base, s);
   }
   function ml_z_pow(z1, i1){
    if(i1 < 0) caml_invalid_argument("Z.pow: exponent must be nonnegative");
    return ml_z_normalize(BigInt(z1) ** BigInt(i1));
   }
   function ml_z_root(z, i){
    if(i % 2 === 0 && z < 0)
     caml_invalid_argument("Z.root: even root of a negative number");
    if(z == 0 || z == 1) return Number(z) | 0;
    let start = 0n, end = BigInt(z), ans = 0n, bigi = BigInt(i);
    while(start <= end){
     let mid = (start + end) / 2n, po = mid ** bigi;
     if(po == z)
      return ml_z_normalize(mid);
     else if(po < z){start = mid + 1n; ans = mid;} else end = mid - 1n;
    }
    return ml_z_normalize(ans);
   }
   function ml_z_perfect_power(z){
    if(z == 0 || z == 1 || z == - 1) return 1;
    let zp = z < 0 ? - z : z, log2z = ml_z_numbits(zp);
    for(let b = 2; b <= log2z; b++){
     if(z < 0 && b % 2 == 0) continue;
     let p = ml_z_root(zp, b);
     if(z < 0) p = - p;
     let r = ml_z_pow(p, b);
     if(z == r) return 1;
    }
    return 0;
   }
   function ml_z_perfect_square(z){
    if(z < 0) return 0;
    let root = BigInt(ml_z_root(z, 2));
    return root * root == z ? 1 : 0;
   }
   function ml_z_powm(z1, z2, z3){
    if(z3 == 0) caml_raise_zero_divide();
    if(z3 == 1 || z3 == - 1) return 0;
    if(z2 == 0) return 1;
    let z3n = BigInt(z3);
    if(z2 < 0){
     let
      inv = BigInt(ml_z_invert(z1, z3)),
      r = jsoo_bigint_mod_pow(inv, BigInt(- z2), z3n);
     if(r < 0) r = r + (z3n < 0 ? - z3n : z3n);
     return ml_z_normalize(r);
    }
    else{
     let r = jsoo_bigint_mod_pow(BigInt(z1), BigInt(z2), z3n);
     if(r < 0) r = r + (z3n < 0 ? - z3n : z3n);
     return ml_z_normalize(r);
    }
   }
   function ml_z_powm_sec(z1, z2, z3){
    if(z1 < 0) z3 = - z3;
    if(z2 < 1) caml_invalid_argument("Z.powm_sec: exponent must be positive");
    if((BigInt(z3) & 1n) !== 1n)
     caml_invalid_argument("Z.powm_sec: modulus must be odd");
    return ml_z_powm(z1, z2, z3);
   }
   function ml_z_pred(z1){return ml_z_normalize(BigInt(z1) - 1n);}
   function ml_z_primorial(a){
    if(a < 0) caml_invalid_argument("Z.primorial: non-positive argument");
    let z1 = 1n, res = 1n;
    while(z1 <= a){
     if(ml_z_probab_prime(z1, 25)) res *= z1;
     if(z1 === 1n || z1 === 2n) z1 += 1n; else z1 += 2n;
    }
    return ml_z_normalize(res);
   }
   function ml_z_remove(a, b){
    if(b == 0) caml_raise_zero_divide();
    if(a == 0 || b == 1 || b == - 1) return [0, a, 0];
    let i = 0;
    a = BigInt(a);
    b = BigInt(b);
    while(a % b === 0n){a /= b; i++;}
    return [0, ml_z_normalize(a), i];
   }
   function ml_z_rootrem(z, i){
    if(i % 2 === 0 && z < 0)
     caml_invalid_argument("Z.rootrem: even root of a negative number");
    if(z == 0 || z === 1) return [0, Number(z) | 0, 0];
    let start = 0n, end = BigInt(z), ans = 0n, bigi = BigInt(i);
    while(start <= end){
     let mid = (start + end) / 2n, po = mid ** bigi;
     if(po == z)
      return [0, ml_z_normalize(mid), 0];
     else if(po < z){start = mid + 1n; ans = mid;} else end = mid - 1n;
    }
    return [0, ml_z_normalize(ans), ml_z_normalize(BigInt(z) - ans ** bigi)];
   }
   function ml_z_shift_left(z1, amt){
    return ml_z_normalize(BigInt(z1) << BigInt(amt));
   }
   function ml_z_shift_right(z1, amt){
    return ml_z_normalize(BigInt(z1) >> BigInt(amt));
   }
   function ml_z_shift_right_trunc(z1, z2){
    return ml_z_normalize(BigInt(z1) / (1n << BigInt(z2)));
   }
   function ml_z_size(z1){
    if(z1 < 0) z1 = - z1;
    let z1n = BigInt(z1), len = 1;
    while(z1n >= 2 ** 32){len += 1; z1n >>= 32n;}
    return len | 0;
   }
   function ml_z_sqrt(z1){
    if(z1 < 0)
     caml_invalid_argument("Z.sqrt: square root of a negative number");
    return ml_z_root(z1, 2);
   }
   function ml_z_sqrt_rem(z){
    if(z < 0)
     caml_invalid_argument("Z.sqrt_rem: square root of a negative number");
    let
     root = ml_z_root(z, 2),
     rootn = BigInt(root),
     diff = BigInt(z) - rootn * rootn;
    return [0, root, ml_z_normalize(diff)];
   }
   function ml_z_sub(z1, z2){return ml_z_normalize(BigInt(z1) - BigInt(z2));}
   function ml_z_succ(z1){return ml_z_normalize(BigInt(z1) + 1n);}
   function ml_z_testbit(z, pos){
    return Number(BigInt(z) >> BigInt(pos) & 1n);
   }
   function ml_z_to_bits(z1){
    let z1n = BigInt(z1);
    if(z1n < 0) z1n = - z1n;
    let res = "";
    while(z1n !== 0n){
     res += String.fromCharCode(Number(z1n % 256n) | 0);
     z1n /= 256n;
    }
    while(res.length % 4 != 0) res += String.fromCharCode(0);
    return caml_string_of_jsbytes(res);
   }
   function ml_z_to_int(z1){
    if(typeof z1 === "number" && z1 === (z1 | 0)) return z1;
    caml_raise_constant(caml_named_value("ml_z_overflow"));
   }
   function ml_z_to_int32(z1){return ml_z_to_int(z1);}
   function ml_z_to_int32_unsigned(z1){
    if(ml_z_fits_int32_unsigned(z1))
     return Number(BigInt.asIntN(32, BigInt(z1))) | 0;
    caml_raise_constant(caml_named_value("ml_z_overflow"));
   }
   function ml_z_to_int64(z1){
    if(! ml_z_fits_int64(z1))
     caml_raise_constant(caml_named_value("ml_z_overflow"));
    let
     z1n = BigInt(z1),
     mask = 0xffffffffn,
     lo = Number(z1n & mask),
     hi = Number(z1n >> 32n & mask),
     x = caml_int64_create_lo_hi(lo, hi);
    return x;
   }
   function ml_z_to_int64_unsigned(z1){
    if(! ml_z_fits_int64_unsigned(z1))
     caml_raise_constant(caml_named_value("ml_z_overflow"));
    let
     z1n = BigInt.asIntN(64, BigInt(z1)),
     mask = 0xffffffffn,
     lo = Number(z1n & mask),
     hi = Number(z1n >> 32n & mask),
     x = caml_int64_create_lo_hi(lo, hi);
    return x;
   }
   function ml_z_to_nativeint(z1){return ml_z_to_int(z1);}
   function ml_z_to_nativeint_unsigned(z1){return ml_z_to_int32_unsigned(z1);}
   function ml_z_trailing_zeros(z){
    if(z == 0) return 0x7fffffff;
    if(z < 0) z = - z;
    let zn = BigInt(z), i = 0;
    zn = (zn ^ zn - 1n) >> 1n;
    for(i = 0; zn !== 0n; i++) zn >>= 1n;
    return i;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xff,
            0x03,
            0xfe,
            0xff,
            0xff,
            0x87,
            0xfe,
            0xff,
            0xff,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xff,
            0xff,
            0x7f,
            0xff,
            0xff,
            0xff,
            0x7f,
            0xff],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] !== 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] !== 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos === 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) !== is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] !== s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur !== "\\")
      res += cur;
     else{
      if(n === len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start === - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {caml_ojs_iterate_properties: caml_ojs_iterate_properties,
     caml_ojs_wrap_fun_arguments: caml_ojs_wrap_fun_arguments,
     ml_z_bin: ml_z_bin,
     ml_z_primorial: ml_z_primorial,
     ml_z_kronecker: ml_z_kronecker,
     ml_z_legendre: ml_z_legendre,
     ml_z_jacobi: ml_z_jacobi,
     ml_z_lucnum: ml_z_lucnum,
     ml_z_fib: ml_z_fib,
     ml_z_facM: ml_z_facM,
     ml_z_fac2: ml_z_fac2,
     ml_z_fac: ml_z_fac,
     ml_z_remove: ml_z_remove,
     ml_z_congruent: ml_z_congruent,
     ml_z_divisible: ml_z_divisible,
     caml_zarith_unmarshal: caml_zarith_unmarshal,
     caml_zarith_marshal: caml_zarith_marshal,
     ml_z_divexact: ml_z_divexact,
     ml_z_size: ml_z_size,
     ml_z_hamdist: ml_z_hamdist,
     ml_z_popcount: ml_z_popcount,
     ml_z_trailing_zeros: ml_z_trailing_zeros,
     ml_z_sqrt_rem: ml_z_sqrt_rem,
     ml_z_sqrt: ml_z_sqrt,
     ml_z_gcdext_intern: ml_z_gcdext_intern,
     ml_z_extract_small: ml_z_extract_small,
     ml_z_extract: ml_z_extract,
     ml_z_nextprime: ml_z_nextprime,
     ml_z_probab_prime: ml_z_probab_prime,
     jsoo_bigint_mod_pow: jsoo_bigint_mod_pow,
     jsoo_bigint_rand_between: jsoo_bigint_rand_between,
     ml_z_perfect_square: ml_z_perfect_square,
     ml_z_perfect_power: ml_z_perfect_power,
     ml_z_invert: ml_z_invert,
     ml_z_rootrem: ml_z_rootrem,
     ml_z_root: ml_z_root,
     ml_z_powm_sec: ml_z_powm_sec,
     ml_z_of_bits: ml_z_of_bits,
     ml_z_to_bits: ml_z_to_bits,
     ml_z_hash: ml_z_hash,
     ml_z_pow: ml_z_pow,
     ml_z_powm: ml_z_powm,
     ml_z_fits_nativeint: ml_z_fits_nativeint,
     ml_z_fits_int64: ml_z_fits_int64,
     ml_z_fits_nativeint_unsigned: ml_z_fits_nativeint_unsigned,
     ml_z_fits_int64_unsigned: ml_z_fits_int64_unsigned,
     ml_z_fits_int32_unsigned: ml_z_fits_int32_unsigned,
     ml_z_fits_int32: ml_z_fits_int32,
     ml_z_fits_int: ml_z_fits_int,
     ml_z_numbits: ml_z_numbits,
     ml_z_gcd: ml_z_gcd,
     ml_z_sign: ml_z_sign,
     ml_z_equal: ml_z_equal,
     ml_z_compare: ml_z_compare,
     ml_z_of_substring_base: ml_z_of_substring_base,
     jsoo_z_of_js_string_base: jsoo_z_of_js_string_base,
     ml_z_format: ml_z_format,
     ml_z_to_nativeint: ml_z_to_nativeint,
     ml_z_testbit: ml_z_testbit,
     ml_z_to_int64_unsigned: ml_z_to_int64_unsigned,
     ml_z_to_int64: ml_z_to_int64,
     ml_z_to_nativeint_unsigned: ml_z_to_nativeint_unsigned,
     ml_z_to_int32_unsigned: ml_z_to_int32_unsigned,
     ml_z_to_int32: ml_z_to_int32,
     ml_z_to_int: ml_z_to_int,
     ml_z_of_float: ml_z_of_float,
     ml_z_of_int64: ml_z_of_int64,
     ml_z_of_nativeint: ml_z_of_nativeint,
     ml_z_of_int32: ml_z_of_int32,
     ml_z_shift_right_trunc: ml_z_shift_right_trunc,
     ml_z_shift_right: ml_z_shift_right,
     ml_z_shift_left: ml_z_shift_left,
     ml_z_lognot: ml_z_lognot,
     ml_z_logxor: ml_z_logxor,
     ml_z_logor: ml_z_logor,
     ml_z_logand: ml_z_logand,
     ml_z_abs: ml_z_abs,
     ml_z_pred: ml_z_pred,
     ml_z_succ: ml_z_succ,
     ml_z_div_rem: ml_z_div_rem,
     ml_z_rem: ml_z_rem,
     ml_z_fdiv: ml_z_fdiv,
     ml_z_cdiv: ml_z_cdiv,
     ml_z_div: ml_z_div,
     ml_z_mul: ml_z_mul,
     ml_z_sub: ml_z_sub,
     ml_z_add: ml_z_add,
     ml_z_neg: ml_z_neg,
     ml_z_init: ml_z_init,
     ml_z_mul_overflows: ml_z_mul_overflows,
     ml_z_normalize: ml_z_normalize,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_runtime_events_resume: caml_runtime_events_resume,
     caml_runtime_events_pause: caml_runtime_events_pause,
     caml_runtime_events_start: caml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_zstd_initialize: caml_zstd_initialize,
     caml_decompress_input: caml_decompress_input,
     zstd_decompress: zstd_decompress,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_lxm_daba: caml_lxm_daba,
     caml_lxm_M: caml_lxm_M,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data_opt: caml_ephe_set_data_opt,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_none: caml_ephe_none,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_raise_system_error: caml_raise_system_error,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_outchannel_of_filedescr: caml_unix_outchannel_of_filedescr,
     caml_unix_inchannel_of_filedescr: caml_unix_inchannel_of_filedescr,
     caml_unix_close: caml_unix_close,
     caml_unix_ftruncate_64: caml_unix_ftruncate_64,
     caml_unix_ftruncate: caml_unix_ftruncate,
     caml_unix_lseek_64: caml_unix_lseek_64,
     caml_unix_lseek: caml_unix_lseek,
     caml_unix_read: caml_unix_read,
     caml_unix_write: caml_unix_write,
     caml_unix_fstat_64: caml_unix_fstat_64,
     caml_unix_fstat: caml_unix_fstat,
     caml_unix_lookup_file: caml_unix_lookup_file,
     caml_unix_open: caml_unix_open,
     caml_unix_truncate_64: caml_unix_truncate_64,
     caml_unix_truncate: caml_unix_truncate,
     caml_unix_utimes: caml_unix_utimes,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_rename: caml_unix_rename,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     unix_error: unix_error,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     jsoo_static_env: jsoo_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     jsoo_toplevel_reloc: jsoo_toplevel_reloc,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_custom_identifier: caml_custom_identifier,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_tag: caml_obj_tag,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_normalized: is_digit_normalized,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_new_string: caml_new_string,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_string_concat: caml_string_concat,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_uint8_array: caml_bytes_of_uint8_array,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_uint8_array: caml_string_of_uint8_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_bytes_set64: caml_bytes_set64,
     caml_bytes_set32: caml_bytes_set32,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_sub_uint8_array_to_jsbytes: caml_sub_uint8_array_to_jsbytes,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_out_with_flags:
     caml_ml_open_descriptor_out_with_flags,
     caml_ml_open_descriptor_in_with_flags:
     caml_ml_open_descriptor_in_with_flags,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channel_restore: caml_ml_channel_restore,
     caml_ml_channel_redirect: caml_ml_channel_redirect,
     caml_ml_channel_get: caml_ml_channel_get,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     MlChanid: MlChanid,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_raise_nodejs_error: caml_raise_nodejs_error,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     fs_node_stats_from_js: fs_node_stats_from_js,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_hash_mix_float16: caml_hash_mix_float16,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_packFloat16: caml_packFloat16,
     caml_unpackFloat16: caml_unpackFloat16,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_runtime_flag: caml_record_backtrace_runtime_flag,
     caml_record_backtrace_env_flag: caml_record_backtrace_env_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_array_make: caml_array_make,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));

(function(a){"use strict";var
w="Sys_error",aC="Stdlib__Obj",aR="Stdlib__Type",aE="Stdlib__Unit",aN="Dune__exe__Floatview_js",n="Bitv",aQ="Stdlib__Nativeint",m="Stdlib__Gc",aP="Stdlib__Stack",v="CamlinternalFormat",aM="Stdlib__Random",G="Stack_overflow",al="Stdlib__ArrayLabels",ao="Stdlib__Either",aw="Stdlib__Printexc",B="Stdlib__Map",F="Stdlib__Arg",_="Undefined_recursive_module",av="Ojs_exn",aB="Stdlib__Domain",aL="Stdlib__Array",M="Assert_failure",Z="CamlinternalFormatBasics",g="Color",l="Stdlib__Lazy",Y="Stdlib__Queue",aK="Jsoo_runtime__",A="Stdlib__Format",X="Dune__exe__Utils",ad="Stdlib__In_channel",aA="Q",f="Stdlib__Bool",u="Jsoo_runtime",L="Stdlib__BytesLabels",a2="Stdlib__Bytes",au="Division_by_zero",z="End_of_file",W="CamlinternalMod",a1="Stdlib__Condition",K="Stdlib__Marshal",V="Big_int_Z",a0="Out_of_memory",ak="Zarith_version",U="Stdlib__Parsing",at="Stdlib__Weak",aj="Dune__exe",an="Not_found",aD="Ojs",T="Stdlib__Effect",as=101,aZ="Failure",e="Stdlib__Int",t="Stdlib__StdLabels",aJ="Jsoo_runtime__Runtime_version",d="Stdlib__Oo",R="Stdlib__Bigarray",S="Stdlib__List",ai="Stdlib__Ephemeron",aI="Stdlib__String",aY="Stdlib__Printf",ac="Stdlib",ar="Dune__exe__Log",s="Binary",Q="Utils",aq=100,az="Stdlib__Callback",ab="Stdlib__Filename",ay="Stdlib__Hashtbl",aa="Floats",k="Invalid_argument",E="Log",ah="Stdlib__Fun",aX="Stdlib__Mutex",y="Stdlib__Option",D="Stdlib__Lexing",aW="Stdlib__ListLabels",r=102,aO="Stdlib__Atomic",ax="Stdlib__MoreLabels",aH="Zarith_stubs_js",x="Js_core",ag="Stdlib__Result",j="Std_exit",P="Stdlib__Set",af="Stdlib__Buffer",ap="Dune__exe__Helper",aU="Match_failure",aV="Stdlib__Semaphore",i="Stdlib__StringLabels",aG="Stdlib__Complex",$="Stdlib__Int64",ae="Stdlib__Out_channel",q="Stdlib__Seq",aF="Stdlib__Sys",p="Z",am="CamlinternalLazy",O="Sys_blocked_io",C="Stdlib__Float",N="Stdlib__Uchar",h="Stdlib__Scanf",o="CamlinternalOO",J="Convert",aT="Decimal",aS="Stdlib__Digest",I="Stdlib__Char",H="Stdlib__Int32",c=a.jsoo_runtime,b=c.caml_get_global_data();b.prim_count=936;b.symbols=[0,[0,ak,79],[0,aH,83],[0,p,80],[0,Q,84],[0,_,11],[0,w,10],[0,O,9],[0,at,59],[0,aE,31],[0,N,26],[0,aR,17],[0,aF,15],[0,i,72],[0,aI,30],[0,t,74],[0,aP,42],[0,P,40],[0,q,21],[0,aV,47],[0,h,61],[0,ag,23],[0,aM,57],[0,Y,43],[0,aY,50],[0,aw,52],[0,U,39],[0,ae,76],[0,y,22],[0,d,64],[0,aC,16],[0,aQ,37],[0,aX,45],[0,ax,73],[0,K,32],[0,B,41],[0,aW,70],[0,S,27],[0,D,38],[0,l,20],[0,$,36],[0,H,35],[0,e,28],[0,ad,75],[0,ay,58],[0,m,54],[0,ah,53],[0,A,60],[0,C,34],[0,ab,67],[0,ai,66],[0,ao,14],[0,T,77],[0,aB,48],[0,aS,55],[0,a1,46],[0,aG,68],[0,I,25],[0,az,62],[0,L,71],[0,a2,29],[0,af,44],[0,f,24],[0,R,56],[0,aO,18],[0,al,69],[0,aL,33],[0,F,51],[0,ac,13],[0,j,r],[0,G,8],[0,aA,81],[0,a0,7],[0,av,95],[0,aD,94],[0,an,6],[0,aU,5],[0,E,86],[0,aJ,92],[0,aK,91],[0,u,93],[0,x,96],[0,k,4],[0,aa,87],[0,aZ,3],[0,z,2],[0,X,aq],[0,ar,98],[0,ap,99],[0,aN,as],[0,aj,97],[0,au,1],[0,aT,88],[0,J,90],[0,g,85],[0,o,63],[0,W,65],[0,am,19],[0,Z,12],[0,v,49],[0,n,78],[0,s,89],[0,V,82],[0,M,0]];var
a3=[2,aN];b.sections=[0,[0,103,[0,[0,[0,[0,[0,[0,[0,0,[2,M],0,0,1],[2,V],82,[0,[0,0,[2,s],89,0,1],[2,n],78,0,2],3],[2,v],49,[0,0,[2,Z],12,0,1],4],[2,am],19,[0,[0,[0,[0,0,[2,W],65,0,1],[2,o],63,0,2],[2,g],85,[0,[0,0,[2,J],90,0,1],[2,aT],88,0,2],3],[2,au],1,[0,[0,0,[2,aj],97,[0,[0,0,a3,as,0,1],[2,ap],99,0,2],3],[2,ar],98,[0,[0,0,[2,X],aq,0,1],[2,z],2,0,2],4],5],6],[2,aZ],3,[0,[0,[0,0,[2,aa],87,0,1],[2,k],4,[0,[0,[0,0,[2,x],96,0,1],[2,u],93,0,2],[2,aK],91,[0,0,[2,aJ],92,0,1],3],4],[2,E],86,[0,[0,[0,0,[2,aU],5,0,1],[2,an],6,[0,0,[2,aD],94,[0,0,[2,av],95,0,1],2],3],[2,a0],7,[0,[0,0,[2,aA],81,0,1],[2,G],8,[0,0,[2,j],r,0,1],2],4],5],7],[2,ac],13,[0,[0,[0,[0,0,[2,F],51,0,1],[2,aL],33,[0,0,[2,al],69,0,1],2],[2,aO],18,[0,0,[2,R],56,0,1],3],[2,f],24,[0,[0,[0,0,[2,af],44,0,1],[2,a2],29,[0,[0,0,[2,L],71,0,1],[2,az],62,0,2],3],[2,I],25,[0,[0,0,[2,aG],68,0,1],[2,a1],46,[0,[0,0,[2,aS],55,0,1],[2,aB],48,[0,0,[2,T],77,0,1],2],3],4],5],8],[2,ao],14,[0,[0,[0,[0,[0,[0,0,[2,ai],66,[0,0,[2,ab],67,0,1],2],[2,C],34,[0,0,[2,A],60,0,1],3],[2,ah],53,[0,0,[2,m],54,[0,0,[2,ay],58,[0,0,[2,ad],75,0,1],2],3],4],[2,e],28,[0,0,[2,H],35,[0,0,[2,$],36,0,1],2],5],[2,l],20,[0,[0,[0,0,[2,D],38,0,1],[2,S],27,[0,[0,0,[2,aW],70,0,1],[2,B],41,0,2],3],[2,K],32,[0,[0,[0,0,[2,ax],73,0,1],[2,aX],45,0,2],[2,aQ],37,0,3],4],6],[2,aC],16,[0,[0,[0,[0,[0,[0,0,[2,d],64,0,1],[2,y],22,[0,0,[2,ae],76,0,1],2],[2,U],39,[0,[0,0,[2,aw],52,0,1],[2,aY],50,0,2],3],[2,Y],43,[0,[0,0,[2,aM],57,0,1],[2,ag],23,[0,[0,0,[2,h],61,0,1],[2,aV],47,0,2],3],4],[2,q],21,[0,[0,0,[2,P],40,[0,0,[2,aP],42,[0,0,[2,t],74,0,1],2],3],[2,aI],30,[0,0,[2,i],72,0,1],4],5],[2,aF],15,[0,[0,[0,0,[2,aR],17,0,1],[2,N],26,[0,0,[2,aE],31,[0,0,[2,at],59,0,1],2],3],[2,O],9,[0,[0,0,[2,w],10,0,1],[2,_],11,[0,[0,[0,0,[2,Q],84,0,1],[2,p],80,[0,0,[2,aH],83,0,1],2],[2,ak],79,0,3],4],5],6],7],9]],0,c.caml_list_of_js_array(["%caml_format_int_special","%direct_int_div","%direct_int_mod","%direct_int_mul","%direct_obj_tag","%identity","%int_add","%int_and","%int_asr","%int_div","%int_lsl","%int_lsr","%int_mod","%int_mul","%int_neg","%int_or","%int_sub","%int_xor","BigStringReader","MlBytes","MlChanid","MlFakeDevice","MlFakeFd","MlFakeFd_out","MlFakeFile","MlFile","MlInt64","MlMutex","MlNat","MlNodeDevice","MlNodeFd","MlObjectTable","MlStringReader","Ml_Bigarray","Ml_Bigarray_c_1_1","UInt8ArrayReader","add_nat","bigstring_of_array_buffer","bigstring_of_typed_array","bigstring_to_array_buffer","bigstring_to_typed_array","blit_nat","caml_MD5Final","caml_MD5Init","caml_MD5Transform","caml_MD5Update","caml_abs_float","caml_acos_float","caml_acosh_float","caml_add_float","caml_alloc_dummy","caml_alloc_dummy_float","caml_alloc_dummy_infix","caml_alloc_stack","caml_argv","caml_array_append","caml_array_blit","caml_array_bound_error","caml_array_concat","caml_array_fill","caml_array_get","caml_array_get_addr","caml_array_get_float","caml_array_make","caml_array_of_bytes","caml_array_of_string","caml_array_of_uniform_array","caml_array_set","caml_array_set_addr","caml_array_set_float","caml_array_sub","caml_array_unsafe_get","caml_array_unsafe_get_float","caml_array_unsafe_set","caml_array_unsafe_set_addr","caml_array_unsafe_set_float","caml_asin_float","caml_asinh_float","caml_atan2_float","caml_atan_float","caml_atanh_float","caml_atomic_cas","caml_atomic_exchange","caml_atomic_fetch_add","caml_atomic_load","caml_ba_blit","caml_ba_change_layout","caml_ba_compare","caml_ba_create","caml_ba_create_buffer","caml_ba_create_from","caml_ba_create_unsafe","caml_ba_custom_name","caml_ba_deserialize","caml_ba_dim","caml_ba_dim_1","caml_ba_dim_2","caml_ba_dim_3","caml_ba_fill","caml_ba_from_typed_array","caml_ba_get_1","caml_ba_get_2","caml_ba_get_3","caml_ba_get_generic","caml_ba_get_size","caml_ba_get_size_per_element","caml_ba_hash","caml_ba_init","caml_ba_kind","caml_ba_kind_of_typed_array","caml_ba_layout","caml_ba_map_file","caml_ba_map_file_bytecode","caml_ba_num_dims","caml_ba_reshape","caml_ba_serialize","caml_ba_set_1","caml_ba_set_2","caml_ba_set_3","caml_ba_set_generic","caml_ba_slice","caml_ba_sub","caml_ba_to_typed_array","caml_ba_uint8_get16","caml_ba_uint8_get32","caml_ba_uint8_get64","caml_ba_uint8_set16","caml_ba_uint8_set32","caml_ba_uint8_set64","caml_backtrace_status","caml_bigstring_blit_ba_to_ba","caml_bigstring_blit_ba_to_bytes","caml_bigstring_blit_bytes_to_ba","caml_bigstring_blit_string_to_ba","caml_bigstring_memcmp","caml_blit_bytes","caml_blit_string","caml_bswap16","caml_build_symbols","caml_bytes_bound_error","caml_bytes_compare","caml_bytes_equal","caml_bytes_get","caml_bytes_get16","caml_bytes_get32","caml_bytes_get64","caml_bytes_greaterequal","caml_bytes_greaterthan","caml_bytes_lessequal","caml_bytes_lessthan","caml_bytes_notequal","caml_bytes_of_array","caml_bytes_of_jsbytes","caml_bytes_of_string","caml_bytes_of_uint8_array","caml_bytes_of_utf16_jsstring","caml_bytes_set","caml_bytes_set16","caml_bytes_set32","caml_bytes_set64","caml_bytes_unsafe_get","caml_bytes_unsafe_set","caml_call_gen","caml_callback","caml_cbrt_float","caml_ceil_float","caml_channel_descriptor","caml_check_bound","caml_check_bound_float","caml_check_bound_gen","caml_classify_float","caml_compare","caml_compare_val","caml_compare_val_get_custom","caml_compare_val_number_custom","caml_compare_val_tag","caml_continuation_use_and_update_handler_noexc","caml_continuation_use_noexc","caml_convert_bytes_to_array","caml_convert_raw_backtrace","caml_convert_raw_backtrace_slot","caml_convert_string_to_bytes","caml_copysign_float","caml_cos_float","caml_cosh_float","caml_create_bytes","caml_create_file","caml_create_string","caml_current_dir","caml_custom_event_index","caml_custom_identifier","caml_custom_ops","caml_decompress_input","caml_div","caml_div_float","caml_domain_dls","caml_domain_dls_get","caml_domain_dls_set","caml_domain_id","caml_domain_spawn","caml_ensure_stack_capacity","caml_ephe_blit_data","caml_ephe_blit_key","caml_ephe_check_data","caml_ephe_check_key","caml_ephe_create","caml_ephe_data_offset","caml_ephe_get_data","caml_ephe_get_data_copy","caml_ephe_get_key","caml_ephe_get_key_copy","caml_ephe_key_offset","caml_ephe_none","caml_ephe_set_data","caml_ephe_set_data_opt","caml_ephe_set_key","caml_ephe_unset_data","caml_ephe_unset_key","caml_eq_float","caml_equal","caml_erf_float","caml_erfc_float","caml_executable_name","caml_exn_with_js_backtrace","caml_exp2_float","caml_exp_float","caml_expm1_float","caml_failwith","caml_fatal_uncaught_exception","caml_fill_bytes","caml_final_register","caml_final_register_called_without_value","caml_final_release","caml_finish_formatting","caml_float_compare","caml_float_of_bytes","caml_float_of_int","caml_float_of_string","caml_floatarray_blit","caml_floatarray_create","caml_floatarray_get","caml_floatarray_set","caml_floatarray_unsafe_get","caml_floatarray_unsafe_set","caml_floor_float","caml_fma_float","caml_fmod_float","caml_format_exception","caml_format_float","caml_format_int","caml_fresh_oo_id","caml_frexp_float","caml_fs_init","caml_gc_compaction","caml_gc_counters","caml_gc_full_major","caml_gc_get","caml_gc_major","caml_gc_major_slice","caml_gc_minor","caml_gc_minor_words","caml_gc_quick_stat","caml_gc_set","caml_gc_stat","caml_ge_float","caml_get_continuation_callstack","caml_get_current_callstack","caml_get_exception_backtrace","caml_get_exception_raw_backtrace","caml_get_global_data","caml_get_minor_free","caml_get_public_method","caml_get_root","caml_global_data","caml_gr_arc_aux","caml_gr_blit_image","caml_gr_clear_graph","caml_gr_close_graph","caml_gr_close_subwindow","caml_gr_create_image","caml_gr_current_x","caml_gr_current_y","caml_gr_display_mode","caml_gr_doc_of_state","caml_gr_draw_arc","caml_gr_draw_char","caml_gr_draw_image","caml_gr_draw_rect","caml_gr_draw_str","caml_gr_draw_string","caml_gr_dump_image","caml_gr_fill_arc","caml_gr_fill_poly","caml_gr_fill_rect","caml_gr_lineto","caml_gr_make_image","caml_gr_moveto","caml_gr_open_graph","caml_gr_open_subwindow","caml_gr_plot","caml_gr_point_color","caml_gr_remember_mode","caml_gr_resize_window","caml_gr_set_color","caml_gr_set_font","caml_gr_set_line_width","caml_gr_set_text_size","caml_gr_set_window_title","caml_gr_sigio_handler","caml_gr_sigio_signal","caml_gr_size_x","caml_gr_size_y","caml_gr_state","caml_gr_state_create","caml_gr_state_get","caml_gr_state_init","caml_gr_state_set","caml_gr_synchronize","caml_gr_text_size","caml_gr_wait_event","caml_gr_window_id","caml_greaterequal","caml_greaterthan","caml_gt_float","caml_hash","caml_hash_mix_bigstring","caml_hash_mix_bytes","caml_hash_mix_bytes_arr","caml_hash_mix_final","caml_hash_mix_float","caml_hash_mix_float16","caml_hash_mix_int","caml_hash_mix_int64","caml_hash_mix_jsbytes","caml_hash_mix_string","caml_hash_nat","caml_hexstring_of_float","caml_hypot_float","caml_input_value","caml_input_value_from_bytes","caml_input_value_from_reader","caml_input_value_to_outside_heap","caml_install_signal_handler","caml_int32_add","caml_int32_and","caml_int32_bits_of_float","caml_int32_bswap","caml_int32_compare","caml_int32_div","caml_int32_float_of_bits","caml_int32_format","caml_int32_mod","caml_int32_mul","caml_int32_neg","caml_int32_of_float","caml_int32_of_int","caml_int32_of_string","caml_int32_or","caml_int32_shift_left","caml_int32_shift_right","caml_int32_shift_right_unsigned","caml_int32_sub","caml_int32_to_float","caml_int32_to_int","caml_int32_unmarshal","caml_int32_xor","caml_int64_add","caml_int64_and","caml_int64_bits_of_float","caml_int64_bswap","caml_int64_compare","caml_int64_create_lo_hi","caml_int64_create_lo_mi_hi","caml_int64_div","caml_int64_float_of_bits","caml_int64_format","caml_int64_hash","caml_int64_hi32","caml_int64_is_negative","caml_int64_is_zero","caml_int64_lo32","caml_int64_marshal","caml_int64_mod","caml_int64_mul","caml_int64_neg","caml_int64_of_bytes","caml_int64_of_float","caml_int64_of_int","caml_int64_of_int32","caml_int64_of_nativeint","caml_int64_of_string","caml_int64_offset","caml_int64_or","caml_int64_shift_left","caml_int64_shift_right","caml_int64_shift_right_unsigned","caml_int64_sub","caml_int64_to_bytes","caml_int64_to_float","caml_int64_to_int","caml_int64_to_int32","caml_int64_to_nativeint","caml_int64_ult","caml_int64_unmarshal","caml_int64_xor","caml_int_compare","caml_int_of_float","caml_int_of_string","caml_invalid_argument","caml_is_continuation_tag","caml_is_js","caml_is_ml_bytes","caml_is_ml_string","caml_is_printable","caml_is_special_exception","caml_js_call","caml_js_delete","caml_js_equals","caml_js_error_of_exception","caml_js_error_option_of_exception","caml_js_eval_string","caml_js_expr","caml_js_from_array","caml_js_from_bool","caml_js_from_float","caml_js_from_int32","caml_js_from_nativeint","caml_js_from_string","caml_js_fun_call","caml_js_function_arity","caml_js_get","caml_js_get_console","caml_js_html_entities","caml_js_html_escape","caml_js_instanceof","caml_js_meth_call","caml_js_new","caml_js_object","caml_js_pure_expr","caml_js_set","caml_js_strict_equals","caml_js_to_array","caml_js_to_bool","caml_js_to_byte_string","caml_js_to_float","caml_js_to_int32","caml_js_to_nativeint","caml_js_to_string","caml_js_typeof","caml_js_var","caml_js_wrap_callback","caml_js_wrap_callback_arguments","caml_js_wrap_callback_strict","caml_js_wrap_callback_unsafe","caml_js_wrap_meth_callback","caml_js_wrap_meth_callback_arguments","caml_js_wrap_meth_callback_strict","caml_js_wrap_meth_callback_unsafe","caml_jsbytes_of_string","caml_jsoo_flags_effects","caml_jsoo_flags_use_js_string","caml_jsstring_of_string","caml_lazy_make_forward","caml_lazy_read_result","caml_lazy_reset_to_lazy","caml_lazy_update_to_forcing","caml_lazy_update_to_forward","caml_ldexp_float","caml_le_float","caml_lessequal","caml_lessthan","caml_lex_array","caml_lex_engine","caml_list_mount_point","caml_list_of_js_array","caml_list_to_js_array","caml_log10_float","caml_log1p_float","caml_log2_float","caml_log_float","caml_lt_float","caml_lxm_M","caml_lxm_daba","caml_lxm_next","caml_make_array","caml_make_float_vect","caml_make_path","caml_make_vect","caml_marshal_constants","caml_marshal_data_size","caml_marshal_header_size","caml_maybe_attach_backtrace","caml_maybe_print_stats","caml_md5_bytes","caml_md5_chan","caml_md5_string","caml_memprof_start","caml_memprof_stop","caml_ml_bytes_content","caml_ml_bytes_length","caml_ml_channel_get","caml_ml_channel_redirect","caml_ml_channel_restore","caml_ml_channel_size","caml_ml_channel_size_64","caml_ml_channels","caml_ml_close_channel","caml_ml_condition_broadcast","caml_ml_condition_new","caml_ml_condition_signal","caml_ml_condition_wait","caml_ml_debug_info_status","caml_ml_domain_cpu_relax","caml_ml_domain_id","caml_ml_domain_unique_token","caml_ml_enable_runtime_warnings","caml_ml_flush","caml_ml_input","caml_ml_input_block","caml_ml_input_char","caml_ml_input_int","caml_ml_input_scan_line","caml_ml_is_buffered","caml_ml_mutex_lock","caml_ml_mutex_new","caml_ml_mutex_try_lock","caml_ml_mutex_unlock","caml_ml_open_descriptor_in","caml_ml_open_descriptor_in_with_flags","caml_ml_open_descriptor_out","caml_ml_open_descriptor_out_with_flags","caml_ml_out_channels_list","caml_ml_output","caml_ml_output_bytes","caml_ml_output_char","caml_ml_output_int","caml_ml_output_ta","caml_ml_pos_in","caml_ml_pos_in_64","caml_ml_pos_out","caml_ml_pos_out_64","caml_ml_runtime_warnings_enabled","caml_ml_seek_in","caml_ml_seek_in_64","caml_ml_seek_out","caml_ml_seek_out_64","caml_ml_set_binary_mode","caml_ml_set_buffered","caml_ml_set_channel_name","caml_ml_set_channel_output","caml_ml_set_channel_refill","caml_ml_string_length","caml_mod","caml_modf_float","caml_mount_autoload","caml_mul","caml_mul_float","caml_named_value","caml_named_values","caml_nativeint_add","caml_nativeint_and","caml_nativeint_bswap","caml_nativeint_compare","caml_nativeint_div","caml_nativeint_format","caml_nativeint_mod","caml_nativeint_mul","caml_nativeint_neg","caml_nativeint_of_float","caml_nativeint_of_int","caml_nativeint_of_int32","caml_nativeint_of_string","caml_nativeint_or","caml_nativeint_shift_left","caml_nativeint_shift_right","caml_nativeint_shift_right_unsigned","caml_nativeint_sub","caml_nativeint_to_float","caml_nativeint_to_int","caml_nativeint_to_int32","caml_nativeint_unmarshal","caml_nativeint_xor","caml_neg_float","caml_neq_float","caml_new_lex_engine","caml_new_string","caml_nextafter_float","caml_notequal","caml_obj_add_offset","caml_obj_block","caml_obj_compare_and_swap","caml_obj_dup","caml_obj_is_shared","caml_obj_raw_field","caml_obj_reachable_words","caml_obj_set_raw_field","caml_obj_tag","caml_obj_update_tag","caml_obj_with_tag","caml_ojs_iterate_properties","caml_ojs_new_arr","caml_ojs_wrap_fun_arguments","caml_oo_last_id","caml_output_val","caml_output_value","caml_output_value_to_buffer","caml_output_value_to_bytes","caml_output_value_to_string","caml_packFloat16","caml_parse_digit","caml_parse_engine","caml_parse_format","caml_parse_sign_and_base","caml_parser_trace","caml_pos_in","caml_pos_out","caml_power_float","caml_pure_js_expr","caml_raise_constant","caml_raise_end_of_file","caml_raise_no_such_file","caml_raise_nodejs_error","caml_raise_not_found","caml_raise_sys_error","caml_raise_system_error","caml_raise_with_arg","caml_raise_with_args","caml_raise_with_string","caml_raise_zero_divide","caml_raw_backtrace_length","caml_raw_backtrace_next_slot","caml_raw_backtrace_slot","caml_read_file_content","caml_recommended_domain_count","caml_record_backtrace","caml_record_backtrace_env_flag","caml_record_backtrace_runtime_flag","caml_refill","caml_register_global","caml_register_named_value","caml_restore_raw_backtrace","caml_root","caml_round_float","caml_runtime_events_create_cursor","caml_runtime_events_free_cursor","caml_runtime_events_pause","caml_runtime_events_read_poll","caml_runtime_events_resume","caml_runtime_events_start","caml_runtime_events_user_register","caml_runtime_events_user_resolve","caml_runtime_events_user_write","caml_runtime_parameters","caml_runtime_variant","caml_runtime_warnings","caml_seek_in","caml_seek_out","caml_set_oo_id","caml_set_parser_trace","caml_set_static_env","caml_signbit_float","caml_sin_float","caml_sinh_float","caml_sqrt_float","caml_str_repeat","caml_string_bound_error","caml_string_compare","caml_string_concat","caml_string_equal","caml_string_get","caml_string_get16","caml_string_get32","caml_string_get64","caml_string_greaterequal","caml_string_greaterthan","caml_string_hash","caml_string_lessequal","caml_string_lessthan","caml_string_notequal","caml_string_of_array","caml_string_of_bytes","caml_string_of_jsbytes","caml_string_of_jsstring","caml_string_of_uint8_array","caml_string_set","caml_string_unsafe_get","caml_sub_float","caml_sub_uint8_array_to_jsbytes","caml_subarray_to_jsbytes","caml_sys_argv","caml_sys_chdir","caml_sys_close","caml_sys_const_backend_type","caml_sys_const_big_endian","caml_sys_const_int_size","caml_sys_const_max_wosize","caml_sys_const_naked_pointers_checked","caml_sys_const_ostype_cygwin","caml_sys_const_ostype_unix","caml_sys_const_ostype_win32","caml_sys_const_word_size","caml_sys_executable_name","caml_sys_exit","caml_sys_fds","caml_sys_file_exists","caml_sys_get_argv","caml_sys_get_config","caml_sys_getcwd","caml_sys_getenv","caml_sys_is_directory","caml_sys_is_regular_file","caml_sys_isatty","caml_sys_mkdir","caml_sys_modify_argv","caml_sys_open","caml_sys_open_for_node","caml_sys_random_seed","caml_sys_read_directory","caml_sys_remove","caml_sys_rename","caml_sys_rmdir","caml_sys_system_command","caml_sys_time","caml_sys_time_include_children","caml_sys_unsafe_getenv","caml_tan_float","caml_tanh_float","caml_to_js_string","caml_trailing_slash","caml_trampoline","caml_trampoline_return","caml_trunc_float","caml_uint8_array_of_bytes","caml_uint8_array_of_string","caml_unix_cleanup","caml_unix_close","caml_unix_closedir","caml_unix_filedescr_of_fd","caml_unix_findclose","caml_unix_findfirst","caml_unix_findnext","caml_unix_fstat","caml_unix_fstat_64","caml_unix_ftruncate","caml_unix_ftruncate_64","caml_unix_getpwuid","caml_unix_gettimeofday","caml_unix_getuid","caml_unix_gmtime","caml_unix_has_symlink","caml_unix_inchannel_of_filedescr","caml_unix_inet_addr_of_string","caml_unix_isatty","caml_unix_localtime","caml_unix_lookup_file","caml_unix_lseek","caml_unix_lseek_64","caml_unix_lstat","caml_unix_lstat_64","caml_unix_mkdir","caml_unix_mktime","caml_unix_open","caml_unix_opendir","caml_unix_outchannel_of_filedescr","caml_unix_read","caml_unix_readdir","caml_unix_readlink","caml_unix_rename","caml_unix_rewinddir","caml_unix_rmdir","caml_unix_startup","caml_unix_stat","caml_unix_stat_64","caml_unix_symlink","caml_unix_time","caml_unix_truncate","caml_unix_truncate_64","caml_unix_unlink","caml_unix_utimes","caml_unix_write","caml_unmount","caml_unpackFloat16","caml_update_dummy","caml_utf16_of_utf8","caml_utf8_of_utf16","caml_weak_create","caml_weak_set","caml_wrap_exception","caml_xmlhttprequest_create","caml_zarith_marshal","caml_zarith_unmarshal","caml_zstd_initialize","compare_digits_nat","compare_nat","complement_nat","create_nat","decr_nat","deserialize_nat","div_digit_nat","div_helper","div_nat","fs_node_stats_from_js","fs_node_supported","incr_nat","initialize_nat","is_digit_int","is_digit_normalized","is_digit_odd","is_digit_zero","jsoo_bigint_mod_pow","jsoo_bigint_rand_between","jsoo_create_file","jsoo_create_file_extern","jsoo_effect_not_supported","jsoo_floor_log2","jsoo_is_ascii","jsoo_mount_point","jsoo_static_env","jsoo_sys_getenv","jsoo_toplevel_reloc","jsoo_z_of_js_string_base","land_digit_nat","length_nat","lor_digit_nat","lxor_digit_nat","make_unix_err_args","ml_z_abs","ml_z_add","ml_z_bin","ml_z_cdiv","ml_z_compare","ml_z_congruent","ml_z_div","ml_z_div_rem","ml_z_divexact","ml_z_divisible","ml_z_equal","ml_z_extract","ml_z_extract_small","ml_z_fac","ml_z_fac2","ml_z_facM","ml_z_fdiv","ml_z_fib","ml_z_fits_int","ml_z_fits_int32","ml_z_fits_int32_unsigned","ml_z_fits_int64","ml_z_fits_int64_unsigned","ml_z_fits_nativeint","ml_z_fits_nativeint_unsigned","ml_z_format","ml_z_gcd","ml_z_gcdext_intern","ml_z_hamdist","ml_z_hash","ml_z_init","ml_z_invert","ml_z_jacobi","ml_z_kronecker","ml_z_legendre","ml_z_logand","ml_z_lognot","ml_z_logor","ml_z_logxor","ml_z_lucnum","ml_z_mul","ml_z_mul_overflows","ml_z_neg","ml_z_nextprime","ml_z_normalize","ml_z_numbits","ml_z_of_bits","ml_z_of_float","ml_z_of_int32","ml_z_of_int64","ml_z_of_nativeint","ml_z_of_substring_base","ml_z_perfect_power","ml_z_perfect_square","ml_z_popcount","ml_z_pow","ml_z_powm","ml_z_powm_sec","ml_z_pred","ml_z_primorial","ml_z_probab_prime","ml_z_rem","ml_z_remove","ml_z_root","ml_z_rootrem","ml_z_shift_left","ml_z_shift_right","ml_z_shift_right_trunc","ml_z_sign","ml_z_size","ml_z_sqrt","ml_z_sqrt_rem","ml_z_sub","ml_z_succ","ml_z_testbit","ml_z_to_bits","ml_z_to_int","ml_z_to_int32","ml_z_to_int32_unsigned","ml_z_to_int64","ml_z_to_int64_unsigned","ml_z_to_nativeint","ml_z_to_nativeint_unsigned","ml_z_trailing_zeros","mult_digit_nat","mult_nat","nat_of_array","nth_digit_nat","nth_digit_nat_native","num_digits_nat","num_leading_zero_bits_in_digit","os_type","path_is_absolute","re_match","re_partial_match","re_replacement_text","re_search_backward","re_search_forward","re_string_match","resolve_fs_device","serialize_nat","set_digit_nat","set_digit_nat_native","set_to_zero_nat","shift_left_nat","shift_right_nat","square_nat","sub_nat","unix_error","zstd_decompress"]),0];return}(globalThis));

//# 4 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# 179 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_atomic_cas = runtime.caml_atomic_cas,
    caml_atomic_load = runtime.caml_atomic_load,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)),
    neg_infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)),
    nan =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32760)),
    max_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)),
    min_float =
      caml_int64_float_of_bits(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)),
    epsilon_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)),
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    _a_ = [0, 1],
    _b_ = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : _a_ : _b_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _w_ = [0, caml_int_of_string(s)]; return _w_;}
    catch(_x_){
     var _v_ = caml_wrap_exception(_x_);
     if(_v_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _t_ = [0, caml_float_of_string(s)]; return _t_;}
    catch(_u_){
     var _s_ = caml_wrap_exception(_u_);
     if(_s_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_s_, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var _q_ = l1[2], h1 = l1[1];
    if(! _q_) return [0, h1, l2];
    var match = _q_[2], h2 = _q_[1];
    if(! match) return [0, h1, [0, h2, l2]];
    var
     tl = match[2],
     h3 = match[1],
     block = [0, h3, 24029],
     dst = block,
     offset = 1,
     l1$0 = tl;
    for(;;){
     if(l1$0){
      var _r_ = l1$0[2], h1$0 = l1$0[1];
      if(_r_){
       var match$0 = _r_[2], h2$0 = _r_[1];
       if(match$0){
        var tl$0 = match$0[2], h3$0 = match$0[1], dst$0 = [0, h3$0, 24029];
        dst[1 + offset] = [0, h1$0, [0, h2$0, dst$0]];
        dst = dst$0;
        offset = 1;
        l1$0 = tl$0;
        continue;
       }
       dst[1 + offset] = [0, h1$0, [0, h2$0, l2]];
      }
      else
       dst[1 + offset] = [0, h1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, h1, [0, h2, block]];
    }
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    _e_ = [0, 0, [0, 7, 0]],
    _f_ = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_c_, 438, name);}
   function open_out_bin(name){return open_out_gen(_d_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_p_){
      var _o_ = caml_wrap_exception(_p_);
      if(_o_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_o_, 0);
     }
     param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_n_){}
    try{var _l_ = caml_ml_close_channel(oc); return _l_;}catch(_m_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_e_, 0, name);}
   function open_in_bin(name){return open_in_gen(_f_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
     ofs$0 = ofs$1;
     len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0;
      pos$0 = pos$1;
      param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _k_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _k_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _k_ = res;
     }
     return caml_string_of_bytes(_k_);
    }
   }
   function close_in_noerr(ic){
    try{var _i_ = caml_ml_close_channel(ic); return _i_;}catch(_j_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(param, _h_){
    var
     str2 = _h_[2],
     fmt2 = _h_[1],
     str1 = param[2],
     fmt1 = param[1],
     s2 = "%," + str2;
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), str1 + s2];
   }
   var exit_function = [0, flush_all];
   function at_exit(f){
    for(;;){
     var f_yet_to_run = [0, 1], old_exit = caml_atomic_load(exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(caml_atomic_cas(f_yet_to_run$0, 1, 0)) caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success = caml_atomic_cas(exit_function, old_exit, new_exit),
      _g_ = 1 - success;
     if(! _g_) return _g_;
    }
   }
   var do_domain_local_at_exit = [0, function(param){return 0;}];
   function do_at_exit(param){
    caml_call1(do_domain_local_at_exit[1], 0);
    return caml_call1(caml_atomic_load(exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit];
   runtime.caml_register_global(45, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# 774 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "5.1.1",
    ocaml_release = [0, 5, 1, 1, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# 869 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   function double_field(x, i){return caml_check_bound(x, i)[1 + i];}
   function set_double_field(x, i, v){
    caml_check_bound(x, i)[1 + i] = v;
    return 0;
   }
   var
    _a_ = [0, "obj.ml", 94, 4],
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       243,
       244,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       255,
       1000,
       1001,
       1002,
       [0, info],
       Extension_constructor,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# 1059 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_atomic_exchange = runtime.caml_atomic_exchange,
    caml_atomic_fetch_add = runtime.caml_atomic_fetch_add;
   function set(r, x){caml_atomic_exchange(r, x); return 0;}
   function incr(r){caml_atomic_fetch_add(r, 1); return 0;}
   function decr(r){caml_atomic_fetch_add(r, -1); return 0;}
   var
    Stdlib_Atomic =
      [0,
       function(_a_){return [0, _a_];},
       runtime.caml_atomic_load,
       set,
       caml_atomic_exchange,
       runtime.caml_atomic_cas,
       caml_atomic_fetch_add,
       incr,
       decr];
   runtime.caml_register_global(0, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# 1086 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lazy_update_to_forward = runtime.caml_lazy_update_to_forward,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function force_gen_lazy_block(only_val, blk){
    if(0 !== runtime.caml_lazy_update_to_forcing(blk))
     throw caml_maybe_attach_backtrace(Undefined, 1);
    if(only_val){
     var closure$0 = blk[1];
     blk[1] = 0;
     var result$0 = caml_call1(closure$0, 0);
     blk[1] = result$0;
     caml_lazy_update_to_forward(blk);
     return result$0;
    }
    var closure = blk[1];
    blk[1] = 0;
    try{
     var result = caml_call1(closure, 0);
     blk[1] = result;
     caml_lazy_update_to_forward(blk);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     runtime.caml_lazy_reset_to_lazy(blk);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_lazy_block(blk){return force_gen_lazy_block(0, blk);}
   function force_gen(only_val, lzv){
    var t = runtime.caml_obj_tag(lzv);
    if(t === Stdlib_Obj[12]) return lzv[1];
    if(t === Stdlib_Obj[6]) throw caml_maybe_attach_backtrace(Undefined, 1);
    return t !== Stdlib_Obj[8] ? lzv : force_gen_lazy_block(only_val, lzv);
   }
   var CamlinternalLazy = [0, Undefined, force_lazy_block, force_gen];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# 1145 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1];
   function force_val(l){return caml_call2(CamlinternalLazy[3], 1, l);}
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[8], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if
     (t !== Stdlib_Obj[12]
      && t !== Stdlib_Obj[8] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[16])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[8];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var _g_ = caml_obj_tag(x);
             a:
             if(250 === _g_)
              var _h_ = x[1];
             else{
              if(246 !== _g_ && 244 !== _g_){var _h_ = x; break a;}
              var _h_ = caml_call1(CamlinternalLazy[2], x);
             }
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var _d_ = caml_obj_tag(x);
              a:
              if(250 === _d_)
               var _e_ = x[1];
              else{
               if(246 !== _d_ && 244 !== _d_){var _e_ = x; break a;}
               var _e_ = caml_call1(CamlinternalLazy[2], x);
              }
              return caml_call1(f, _e_);
             }];
    var _a_ = caml_obj_tag(x);
    a:
    if(250 === _a_)
     var _b_ = x[1];
    else{
     if(246 !== _a_ && 244 !== _a_){var _b_ = x; break a;}
     var _b_ = caml_call1(CamlinternalLazy[2], x);
    }
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0, Undefined, map, is_val, from_val, map_val, from_fun, force_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# 1230 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_av_){return append(next, seq2, _av_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_au_){return map(f, next, _au_);}];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_at_){return filter_map(f, next, _at_);}];
     }
     seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_as_){return filter(f, next, _as_);}];
     seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(_ar_){return concat(next, _ar_);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x),
             function(_aq_){return flat_map(f, next, _aq_);},
             0);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var next = match[2], x = match[1], acc$1 = caml_call2(f, acc$0, x);
     acc$0 = acc$1;
     seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_ap_){return unfold(f, u$0, _ap_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _ao_ = caml_call1(p, x);
     if(! _ao_) return _ao_;
     xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _an_ = caml_call1(p, x);
     if(_an_) return _an_;
     xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs$0 = xs$1;
    }
   }
   function find_index(p, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
     xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs$0 = xs$1;
    }
   }
   function find_mapi(f, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = i + 1 | 0;
     i = i$0;
     xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y);
     accu$0 = accu$1;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _am_ = caml_call2(f, x, y);
     if(! _am_) return _am_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _al_ = caml_call2(f, x, y);
     if(_al_) return _al_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ak_ = caml_call2(eq, x, y);
       if(! _ak_) return _ak_;
       xs$0 = xs$1;
       ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _ai_ = i + 1 | 0;
    return [0,
            caml_call1(f, i),
            function(_aj_){return init_aux(f, _ai_, j, _aj_);}];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _ag_ = 0;
    return function(_ah_){return init_aux(f, _ag_, n, _ah_);};
   }
   function repeat(x, param){
    return [0, x, function(_af_){return repeat(x, _af_);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(_ae_){return forever(f, _ae_);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(_ad_){return cycle_nonempty(xs, _ad_);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _aa_(_ac_){return cycle_nonempty(xs, _ac_);}
    return [0, x, function(_ab_){return append(xs$0, _aa_, _ab_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_$_){return iterate1(f, y, _$_);}];
   }
   function iterate(f, x){
    function next(___){return iterate1(f, x, ___);}
    return function(_Z_){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _X_ = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(_Y_){return mapi_aux(f, _X_, xs$0, _Y_);}];
   }
   function mapi(f, xs){
    var _V_ = 0;
    return function(_W_){return mapi_aux(f, _V_, xs, _W_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_U_){return tail_scan(f, s$0, xs$0, _U_);}];
   }
   function scan(f, s, xs){
    function next(_T_){return tail_scan(f, s, xs, _T_);}
    return function(_S_){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_R_){return take_while(p, xs$0, _R_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _K_ = caml_call1(eq, x);
    function _L_(_Q_){return drop_while(_K_, xs$0, _Q_);}
    var _M_ = caml_call1(eq, x);
    function next(_P_){return take_while(_M_, xs$0, _P_);}
    return [0,
            function(_O_){return [0, x, next];},
            function(_N_){return group(eq, _L_, _N_);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    _a_ = [0, "seq.ml", 616, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_J_){
     var _I_ = runtime.caml_obj_tag(s);
     if(250 === _I_) return s[1];
     if(246 !== _I_ && 244 !== _I_) return s;
     return caml_call1(CamlinternalLazy[2], s);};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(Stdlib_Atomic[1], f);
    return function(param){
     var f = caml_call2(Stdlib_Atomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_H_){return zip(xs$0, ys$0, _H_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(_G_){return map2(f, xs$0, ys$0, _G_);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_F_){return interleave(ys, xs$0, _F_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_D_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_E_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_C_){return map_fst(xys$0, _C_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_B_){return map_snd(xys$0, _B_);}];
   }
   function unzip(xys){
    return [0,
            function(_A_){return map_fst(xys, _A_);},
            function(_z_){return map_snd(xys, _z_);}];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_y_){return filter_map_find_left_map(f, xs$1, _y_);}];
     }
     xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_x_){return filter_map_find_right_map(f, xs$1, _x_);}];
     }
     xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    return [0,
            function(_w_){return filter_map_find_left_map(f, xs, _w_);},
            function(_v_){return filter_map_find_right_map(f, xs, _v_);}];
   }
   function partition(p, xs){
    function _s_(x){return 1 - caml_call1(p, x);}
    return [0,
            function(_u_){return filter(p, xs, _u_);},
            function(_t_){return filter(_s_, xs, _t_);}];
   }
   function peel(xss){
    return unzip(function(_r_){return filter_map(uncons, xss, _r_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_q_){return transpose(tails, _q_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_p_){return [0, xs$0, tails];};
     return [0,
             function(_o_){return [0, x, heads];},
             function(_n_){return _b_(_l_, xss$0, _n_);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_m_){return _b_(tails$0, xss$0, _m_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_index,
       find_map,
       find_mapi,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# 2216 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_hash = runtime.caml_hash,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal,
       seeded_hash,
       hash];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# 2300 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
    if(_o_)
     var _p_ = _o_;
    else
     var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
    return _p_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _m_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _m_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _k_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _l_ = caml_call2(Stdlib[28], cst_U, _k_);
    return caml_call1(Stdlib[1], _l_);
   }
   function unsafe_to_char(_j_){return _j_;}
   function equal(_i_, _h_){return _i_ === _h_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_uchar_ml, 85, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _d_ = [0, cst_uchar_ml, 88, 18];
   function hash(_g_){return _g_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       function(_e_){return _e_;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# 2432 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_map2$1 = "List.map2",
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var
    append = Stdlib[37],
    cst_List_init = "List.init",
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _a_ = [0, 0, 0],
    cst_List_combine = "List.combine";
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    var last = len - 1 | 0, i$1 = 0;
    if(last < 0) return 0;
    if(0 === last) return [0, caml_call1(f, i$1), 0];
    var
     r1 = caml_call1(f, i$1),
     r2 = caml_call1(f, 1),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2;
    for(;;){
     if(last < i)
      dst[1 + offset] = 0;
     else{
      if(i !== last){
       var
        r1$0 = caml_call1(f, i),
        r2$0 = caml_call1(f, i + 1 | 0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$0, dst$0];
       var i$0 = i + 2 | 0;
       dst = dst$0;
       offset = 1;
       i = i$0;
       continue;
      }
      dst[1 + offset] = [0, caml_call1(f, i), 0];
     }
     return [0, r1, block];
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _I_ = flatten(r);
    return caml_call2(Stdlib[37], l, _I_);
   }
   function map(f, param){
    if(! param) return 0;
    var match = param[2], a1 = param[1];
    if(! match){var r1$0 = caml_call1(f, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call1(f, a1),
     r2 = caml_call1(f, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     param$0 = l;
    for(;;){
     if(param$0){
      var match$0 = param$0[2], a1$0 = param$0[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call1(f, a1$0),
        r2$0 = caml_call1(f, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       dst = dst$0;
       offset = 1;
       param$0 = l$0;
       continue;
      }
      var r1$2 = caml_call1(f, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function mapi(f, l$1){
    var i$1 = 0;
    if(! l$1) return 0;
    var match = l$1[2], a1 = l$1[1];
    if(! match){var r1$0 = caml_call2(f, i$1, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call2(f, i$1, a1),
     r2 = caml_call2(f, 1, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2,
     param = l;
    for(;;){
     if(param){
      var match$0 = param[2], a1$0 = param[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call2(f, i, a1$0),
        r2$0 = caml_call2(f, i + 1 | 0, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       var i$0 = i + 2 | 0;
       dst = dst$0;
       offset = 1;
       i = i$0;
       param = l$0;
       continue;
      }
      var r1$2 = caml_call2(f, i, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     var _G_ = l1[2], a1 = l1[1];
     if(_G_){
      if(l2){
       var match = l2[2];
       if(match){
        var
         l2$0 = match[2],
         b2 = match[1],
         b1 = l2[1],
         l1$0 = _G_[2],
         a2 = _G_[1],
         r1 = caml_call2(f, a1, b1),
         r2 = caml_call2(f, a2, b2),
         block = [0, r2, 24029],
         dst = block,
         offset = 1,
         l1$1 = l1$0,
         l2$1 = l2$0;
        for(;;){
         a:
         {
          if(l1$1){
           var _H_ = l1$1[2], a1$0 = l1$1[1];
           if(_H_){
            if(l2$1){
             var match$0 = l2$1[2];
             if(match$0){
              var
               l2$2 = match$0[2],
               b2$0 = match$0[1],
               b1$1 = l2$1[1],
               l1$2 = _H_[2],
               a2$0 = _H_[1],
               r1$1 = caml_call2(f, a1$0, b1$1),
               r2$0 = caml_call2(f, a2$0, b2$0),
               dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$1, dst$0];
              dst = dst$0;
              offset = 1;
              l1$1 = l1$2;
              l2$1 = l2$2;
              continue;
             }
            }
           }
           else if(l2$1 && ! l2$1[2]){
            var b1$2 = l2$1[1], r1$2 = caml_call2(f, a1$0, b1$2);
            dst[1 + offset] = [0, r1$2, 0];
            break a;
           }
          }
          else if(! l2$1){dst[1 + offset] = 0; break a;}
          dst[1 + offset] = caml_call1(Stdlib[1], cst_List_map2$0);
         }
         return [0, r1, block];
        }
       }
      }
     }
     else if(l2 && ! l2[2]){
      var b1$0 = l2[1], r1$0 = caml_call2(f, a1, b1$0);
      return [0, r1$0, 0];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2);
       accu$0 = accu$1;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(! _F_) return _F_;
     param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _E_ = caml_call1(p, a);
     if(_E_) return _E_;
     param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(! _D_) return _D_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _C_ = caml_call2(p, a1, a2);
       if(_C_) return _C_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _B_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_B_) return _B_;
     param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _A_ = a === x ? 1 : 0;
     if(_A_) return _A_;
     param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _z_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_z_) return _z_;
     param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _y_ = a === x ? 1 : 0;
     if(_y_) return _y_;
     param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     param$0 = l;
    }
   }
   function find_index(p){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], a = param[1];
      if(caml_call1(p, a)) return [0, i$0];
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      param = l;
     }};
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     param$0 = l;
    }
   }
   function find_mapi(f){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], x = param[1], result = caml_call2(f, i$0, x);
      if(result) return result;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      param = l;
     }};
   }
   function find_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)){
      var block = [0, x, 24029], dst = block, offset = 1, param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1];
       if(caml_call1(p, x$0)){
        var dst$0 = [0, x$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        param$1 = l$0;
       }
       else
        param$1 = l$0;
      }
     }
     else
      param$0 = l;
    }
   }
   function filteri(p, l$1){
    var i = 0, param = l$1;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], i$0 = i + 1 | 0;
     if(caml_call2(p, i, x)) break;
     i = i$0;
     param = l;
    }
    var
     block = [0, x, 24029],
     dst = block,
     offset = 1,
     i$1 = i$0,
     param$0 = l;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var l$0 = param$0[2], x$0 = param$0[1], i$2 = i$1 + 1 | 0;
     if(caml_call2(p, i$1, x$0)){
      var dst$0 = [0, x$0, 24029];
      dst[1 + offset] = dst$0;
      dst = dst$0;
      offset = 1;
      i$1 = i$2;
      param$0 = l$0;
     }
     else{i$1 = i$2; param$0 = l$0;}
    }
   }
   function filter_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], match = caml_call1(f, x);
     if(match){
      var
       v = match[1],
       block = [0, v, 24029],
       dst = block,
       offset = 1,
       param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1], match$0 = caml_call1(f, x$0);
       if(match$0){
        var v$0 = match$0[1], dst$0 = [0, v$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        param$1 = l$0;
       }
       else
        param$1 = l$0;
      }
     }
     else
      param$0 = l;
    }
   }
   function concat_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var xs = param$0[2], x = param$0[1], ys = caml_call1(f, x);
     if(ys){
      var
       ys$1 = ys[2],
       y = ys[1],
       block = [0, y, 24029],
       dst = block,
       offset = 1,
       ys$2 = ys$1,
       xs$1 = xs;
      for(;;)
       if(ys$2){
        var ys$3 = ys$2[2], y$0 = ys$2[1], dst$0 = [0, y$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        ys$2 = ys$3;
       }
       else{
        if(! xs$1){dst[1 + offset] = 0; return block;}
        var xs$0 = xs$1[2], x$0 = xs$1[1], ys$0 = caml_call1(f, x$0);
        ys$2 = ys$0;
        xs$1 = xs$0;
       }
     }
     else
      param$0 = xs;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(no); return [0, rev(yes), _x_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _w_ = rev(right); return [0, rev(left), _w_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return _a_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _v_ = l[2];
      if(_v_){
       var match$2 = _v_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _v_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var _u_ = rev_append(l1, accu);
      }
      else
       var _u_ = rev_append(l2, accu);
      return [0, _u_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _t_ = l[2];
      if(_t_){
       var match$2 = _t_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _t_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var _s_ = rev_append(l1, accu);
      }
      else
       var _s_ = rev_append(l2, accu);
      return [0, _s_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _m_ = l[2];
      if(_m_){
       var match$2 = _m_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _m_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _n_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _n_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _o_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _p_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _o_ = _p_;
         else
          var _o_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _o_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _q_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _r_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _q_ = _r_;
         else
          var _q_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _q_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var _l_ = rev_append(l1, accu);
      }
      else
       var _l_ = rev_append(l2, accu);
      return [0, _l_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _f_ = l[2];
      if(_f_){
       var match$2 = _f_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _f_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _g_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _g_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _h_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _h_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _i_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _h_ = _i_;
         var s$0 = _h_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _j_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _j_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _k_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _j_ = _k_;
         var s$0 = _j_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var _e_ = rev_append(l1, accu);
      }
      else
       var _e_ = rev_append(l2, accu);
      return [0, _e_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function is_empty(param){return param ? 0 : 1;}
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _d_ = caml_call2(eq, a1, a2);
       if(! _d_) return _d_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_c_){return aux(tail, _c_);}];
    }
    return function(_b_){return aux(l, _b_);};
   }
   function of_seq(seq){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var seq$0 = match[2], x1 = match[1], match$0 = caml_call1(seq$0, 0);
    if(! match$0) return [0, x1, 0];
    var
     seq$1 = match$0[2],
     x2 = match$0[1],
     block = [0, x2, 24029],
     dst = block,
     offset = 1,
     seq$2 = seq$1;
    for(;;){
     var match$1 = caml_call1(seq$2, 0);
     if(match$1){
      var
       seq$3 = match$1[2],
       x1$0 = match$1[1],
       match$2 = caml_call1(seq$3, 0);
      if(match$2){
       var seq$4 = match$2[2], x2$0 = match$2[1], dst$0 = [0, x2$0, 24029];
       dst[1 + offset] = [0, x1$0, dst$0];
       dst = dst$0;
       offset = 1;
       seq$2 = seq$4;
       continue;
      }
      dst[1 + offset] = [0, x1$0, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, x1, block];
    }
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       is_empty,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(17, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# 3812 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_hash = runtime.caml_hash;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string,
       seeded_hash,
       hash];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# 3848 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _ap_ = n - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_an_ && ! match) break a;} else if(! _an_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _al_ = caml_ml_bytes_length(a) - 1 | 0, _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _am_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _ai_ = caml_ml_bytes_length(a) - 1 | 0, _ah_ = 0;
    if(_ai_ >= 0){
     var i = _ah_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      i = _aj_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat);
       acc = acc$0;
       param = tl;
      }
      var _ag_ = acc;
      break a;
     }
     var _ag_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ag_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _af_ = param - 9 | 0;
    a:
    {
     if(4 < _af_ >>> 0){if(23 !== _af_) break a;} else if(2 === _af_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function unsafe_escape(s){
    var n = [0, 0], ___ = caml_ml_bytes_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i$0 = _Z_;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ac_ = match - 34 | 0;
          if(58 < _ac_ >>> 0){
           if(93 <= _ac_) break c;
          }
          else if(56 < _ac_ - 1 >>> 0) break b;
          var _ad_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ad_ = 4;
        break a;
       }
       var _ad_ = 2;
      }
      n[1] = n[1] + _ad_ | 0;
      var _ae_ = i$0 + 1 | 0;
      if(___ === i$0) break;
      i$0 = _ae_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _aa_ = caml_ml_bytes_length(s) - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return s$0;
   }
   function escaped(b){var b$0 = copy(b); return unsafe_escape(b$0);}
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _X_ = l - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _U_ = l - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _R_ = caml_ml_bytes_length(a) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[4], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[3], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[3], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _N_ = len_pre <= len_s ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _M_ = 0 <= diff ? 1 : 0;
    if(! _M_) return _M_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _C_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_C_ >= 0){
     var i = _C_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _E_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
       j[1] = i;
      }
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    var _D_ = r[1];
    return [0, sub(s, 0, j[1]), _D_];
   }
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _A_ = i + 1 | 0;
     return [0, x, function(_B_){return aux(_A_, _B_);}];
    }
    var _y_ = 0;
    return function(_z_){return aux(_y_, _z_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _w_ = i + 1 | 0;
     return [0, [0, i, x], function(_x_){return aux(_w_, _x_);}];
    }
    var _u_ = 0;
    return function(_v_){return aux(_u_, _v_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    caml_call2
     (Stdlib_Seq[4],
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           caml_call2
            (Stdlib_Int[10],
             2 * caml_ml_bytes_length(buf[1]) | 0,
             Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    _a_ = [0, cst_bytes_ml, 679, 9],
    _b_ = [0, cst_bytes_ml, 654, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _c_ = [0, cst_bytes_ml, 777, 9],
    _d_ = [0, cst_bytes_ml, 766, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _e_ = [0, cst_bytes_ml, 831, 9],
    _f_ = [0, cst_bytes_ml, 820, 20];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_);}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# 5068 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_hash = runtime.caml_string_hash,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[44],
    bos = Stdlib_Bytes[45];
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _X_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _X_, ofs, len));
   }
   var blit = Stdlib_Bytes[12], cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat);
       acc = acc$0;
       param = tl;
      }
      var _W_ = acc;
      break a;
     }
     var _W_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_W_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var _U_ = caml_ml_string_length(s) - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _R_ = caml_ml_string_length(s) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _P_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _P_));
   }
   function mapi(f, s){
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _O_));
   }
   function fold_right(f, x, a){
    var _N_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _N_, a);
   }
   function fold_left(f, a, x){
    var _M_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _M_);
   }
   function exists(f, s){
    var _L_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _L_);
   }
   function for_all(f, s){
    var _K_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _K_);
   }
   function is_space(param){
    var _J_ = param - 9 | 0;
    a:
    {
     if(4 < _J_ >>> 0){if(23 !== _J_) break a;} else if(2 === _J_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s === cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _I_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _I_));
   }
   function escaped(s){
    var b = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[87], b));
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _G_ = 1; return _G_;}
     catch(_H_){
      var _F_ = caml_wrap_exception(_H_);
      if(_F_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_F_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _D_ = 1; return _D_;}
     catch(_E_){
      var _C_ = caml_wrap_exception(_E_);
      if(_C_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_C_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _B_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _B_));
   }
   function lowercase_ascii(s){
    var _A_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _A_));
   }
   function capitalize_ascii(s){
    var _z_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _z_));
   }
   function uncapitalize_ascii(s){
    var _y_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _y_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _x_ = len_pre <= len_s ? 1 : 0;
    if(! _x_) return _x_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _w_ = 0 <= diff ? 1 : 0;
    if(! _w_) return _w_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function hash(x){return caml_string_hash(0, x);}
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _s_ = caml_ml_string_length(s) - 1 | 0;
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _u_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _u_];
       j[1] = i;
      }
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      i = _v_;
     }
    }
    var _t_ = r[1];
    return [0, sub(s, 0, j[1]), _t_];
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[47], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[48], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[49], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[50], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[53], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[55], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[56], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[58], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[63], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[62], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[65], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[71], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       hash,
       caml_string_hash,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# 5631 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _aw_ = l - 1 | 0, _av_ = 1;
    if(_aw_ >= 1){
     var i = _av_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _ax_ = i + 1 | 0;
      if(_aw_ === i) break;
      i = _ax_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _at_ = sx - 1 | 0, _as_ = 0;
    if(_at_ >= 0){
     var x = _as_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _au_ = x + 1 | 0;
      if(_at_ === x) break;
      x = _au_;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _aq_ = a.length - 2 | 0, _ap_ = 0;
    if(_aq_ >= 0){
     var i = _ap_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _ar_ = i + 1 | 0;
      if(_aq_ === i) break;
      i = _ar_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _an_ = a.length - 2 | 0, _am_ = 0;
    if(_an_ >= 0){
     var i = _am_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ao_ = i + 1 | 0;
      if(_an_ === i) break;
      i = _ao_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _ak_ = l - 1 | 0,
     _aj_ = 1;
    if(_ak_ >= 1){
     var i = _aj_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _al_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _al_;
     }
    }
    return r;
   }
   function map_inplace(f, a){
    var _ah_ = a.length - 2 | 0, _ag_ = 0;
    if(_ah_ >= 0){
     var i = _ag_;
     for(;;){
      a[1 + i] = caml_call1(f, a[1 + i]);
      var _ai_ = i + 1 | 0;
      if(_ah_ === i) break;
      i = _ai_;
     }
    }
    return 0;
   }
   function mapi_inplace(f, a){
    var _ae_ = a.length - 2 | 0, _ad_ = 0;
    if(_ae_ >= 0){
     var i = _ad_;
     for(;;){
      a[1 + i] = caml_call2(f, i, a[1 + i]);
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      i = _af_;
     }
    }
    return 0;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ab_ = la - 1 | 0,
     _aa_ = 1;
    if(_ab_ >= 1){
     var i = _aa_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ac_ = i + 1 | 0;
      if(_ab_ === i) break;
      i = _ac_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var ___ = a.length - 2 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _X_ = l - 1 | 0,
     _W_ = 1;
    if(_X_ >= 1){
     var i = _W_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var t = param$0[2], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _U_ = a.length - 2 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _R_ = len - 1 | 0,
     _Q_ = 1;
    if(_R_ >= 1){
     var i = _Q_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = a.length - 2 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_index(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_mapi(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call2(f, i, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _M_ = n - 1 | 0,
     _L_ = 1;
    if(_M_ >= 1){
     var i = _L_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _J_ = na - 1 | 0, _I_ = 1;
    if(_J_ >= 1){
     var i = _I_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _K_ = i + 1 | 0;
      if(_J_ === i) break;
      i = _K_;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "array.ml", 348, 4];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _B_ = i31 + 1 | 0, _C_ = caml_check_bound(a, _B_)[1 + _B_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _C_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _D_ = i31 + 2 | 0,
       _E_ = caml_check_bound(a, _D_)[1 + _D_],
       _F_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _F_)[1 + _F_], _E_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _G_ = i31 + 1 | 0, _H_ = caml_check_bound(a, _G_)[1 + _G_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _H_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _v_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_v_ >= 0){
     var i$6 = _v_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _s_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _s_;
        i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _A_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _A_;
     }
    }
    var _w_ = l - 1 | 0;
    if(_w_ >= 2){
     var i$4 = _w_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _t_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _t_;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _u_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _u_;
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _z_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _z_;
      }
     }
    }
    var _x_ = 1 < l ? 1 : 0;
    if(_x_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _y_ = 0;
    }
    else
     var _y_ = _x_;
    return _y_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[1 + i1$0];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _k_ = len - 1 | 0, _j_ = 0;
     if(_k_ >= 0){
      var i = _j_;
      for(;;){
       var
        _l_ = srcofs + i | 0,
        e = caml_check_bound(a, _l_)[1 + _l_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _m_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _m_)[1 + _m_], e))
         break;
        var
         _n_ = j[1],
         _o_ = caml_check_bound(dst, _n_)[1 + _n_],
         _p_ = j[1] + 1 | 0;
        caml_check_bound(dst, _p_)[1 + _p_] = _o_;
        j[1]--;
       }
       var _q_ = j[1] + 1 | 0;
       caml_check_bound(dst, _q_)[1 + _q_] = e;
       var _r_ = i + 1 | 0;
       if(_k_ === i) break;
       i = _r_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _h_ = i + 1 | 0;
     return [0, x, function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _d_ = i + 1 | 0;
     return [0, [0, i, x], function(_e_){return aux(_d_, _e_);}];
    }
    var _b_ = 0;
    return function(_c_){return aux(_b_, _c_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       init,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# 7217 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    _a_ = Stdlib_Sys[9],
    _b_ = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# 7317 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? caml_int64_add(q, _a_) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# 7420 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# 8803 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 408, 10],
    _c_ = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _K_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
          if(_F_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _G_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
         }
         if((hl + 2 | 0) >= hr){
          var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _J_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
         if(_H_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _I_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _I_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _E_ = 0 === c ? 1 : 0;
          if(_E_) return _E_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function add_to_list(x, data, m){
         function add(param){
          if(! param) return [0, [0, data, 0]];
          var l = param[1];
          return [0, [0, data, l]];
         }
         return update(x, add, m);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0));
          m$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call2(p, v, d);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call2(p, v, d);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _u_ = merge(f, r1, r2),
            _v_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _w_ = merge(f, r1$0, r2$0),
          _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _s_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _s_];
         }
         var _t_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _t_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0];
          m$0 = l;
          e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_p_){
           var _q_ = caml_call2(cmp, d1, d2);
           if(_q_){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var _r_ = _q_;
          }
          else
           var _r_ = _p_;
          return _r_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _o_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _o_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function of_list(bs){
         return caml_call3
                 (Stdlib_List[26],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  empty,
                  bs);
        }
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         a:
         {
          b:
          {
           var m$0 = m, c = 0;
           for(;;){
            if(! m$0) break;
            var
             r = m$0[4],
             d = m$0[3],
             v = m$0[2],
             l = m$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, d, r, c];
             m$0 = l;
             c = c$0;
            }
            else
             m$0 = r;
           }
           var _e_ = c;
           break a;
          }
          var _e_ = [0, v, d, r, c];
         }
         return function(_f_){return seq_of_enum(_e_, _f_);};
        }
        return [0,
                empty,
                add,
                add_to_list,
                update,
                singleton,
                remove,
                merge,
                union,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                iter,
                fold,
                map,
                mapi,
                filter,
                filter_map,
                partition,
                split,
                is_empty,
                mem,
                equal,
                compare,
                for_all,
                exists,
                bindings,
                of_list,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# 9691 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0; return 0;}
   function copy(s){return [0, s[1], s[2]];}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd;
   }
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function drop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return 0;
   }
   function top(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var hd = match[1];
    return hd;
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   function is_empty(s){return 0 === s[1] ? 1 : 0;}
   function length(s){return s[2];}
   function iter(f, s){return caml_call2(Stdlib_List[18], f, s[1]);}
   function fold(f, acc, s){return caml_call3(Stdlib_List[26], f, acc, s[1]);}
   function to_seq(s){return caml_call1(Stdlib_List[64], s[1]);}
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return push(x, q);}, i);
   }
   function of_seq(g){var s = create(0); add_seq(s, g); return s;}
   var
    Stdlib_Stack =
      [0,
       Empty,
       create,
       push,
       pop,
       pop_opt,
       drop,
       top,
       top_opt,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
   return;
  }
  (globalThis));

//# 9793 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var _f_ = q[2];
    if(! _f_) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = _f_[1];
    if(_f_[2]){
     var next = _f_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var _e_ = q[2];
    if(! _e_) return 0;
    var content = _e_[1];
    if(_e_[2]){
     var next = _e_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev) prev[2] = prev$0; else q_res[2] = prev$0;
     prev = prev$0;
     cell = next;
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content);
     accu = accu$0;
     cell = next;
    }
   }
   function transfer(q1, q2){
    var _d_ = 0 < q1[1] ? 1 : 0;
    if(! _d_) return _d_;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(_c_){return aux(next, _c_);}];
    }
    var _a_ = q[2];
    return function(_b_){return aux(_a_, _b_);};
   }
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return add(x, q);}, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# 9948 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer",
    dummy = 0;
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, [0, s, n$1], 0, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1][1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1][1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1][1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return caml_call5(Stdlib_Bytes[11], src[1][1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    var position = b[2], match = b[1], length = match[2], buffer = match[1];
    if(0 <= ofs && position > ofs && length >= position)
     return runtime.caml_bytes_unsafe_get(buffer, ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    var inner = [0, b[3], caml_ml_bytes_length(b[3])];
    b[1] = inner;
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1][1], 0, new_buffer, 0, b[2]);
    b[1] = [0, new_buffer, new_len[1]];
   }
   function add_char(b, c){
    var pos = b[2], match = b[1], length = match[2], buffer = match[1];
    if(length <= pos){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], c);
    }
    else
     caml_bytes_unsafe_set(buffer, pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    cst_Buffer_add_channel = "Buffer.add_channel",
    _a_ = [0, "buffer.ml", 220, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[51], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[54], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[57], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _q_ = offset < 0 ? 1 : 0;
    if(_q_)
     var _r_ = _q_;
    else
     var
      _s_ = len < 0 ? 1 : 0,
      _r_ = _s_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_r_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, offset, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, offset, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[44], s), offset, len);
   }
   function add_string(b, s){
    var
     len = caml_ml_string_length(s),
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, 0, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, 0, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[44], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1][1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _o_ = to_read$1 < 0 ? 1 : 0,
     _p_ = _o_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_p_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[1][2] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1][1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1][1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _n_ = 92 === previous ? 1 : 0;
      return _n_ ? add_char(b, previous) : _n_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length(s);
         b:
         {
          c:
          {
           d:
           {
            var i$2 = start;
            for(;;){
             if(lim$0 <= i$2) break c;
             var match = caml_string_get(s, i$2);
             if(91 <= match){
              if(97 <= match){
               if(123 <= match) break d;
              }
              else if(95 !== match) break d;
             }
             else
              if(58 <= match){
               if(65 > match) break;
              }
              else if(48 > match) break d;
             var i$3 = i$2 + 1 | 0;
             i$2 = i$3;
            }
           }
           var stop$0 = i$2;
           break b;
          }
          var stop$0 = lim$0;
         }
         var
          match$0 =
            [0,
             caml_call3(Stdlib_String[16], s, start$0, stop$0 - start$0 | 0),
             stop$0];
         break a;
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening){
          var i = stop + 1 | 0, k$0 = k + 1 | 0;
          k = k$0;
          stop = i;
         }
         else if(caml_string_get(s, stop) === closing){
          if(0 === k) break;
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
          k = k$1;
          stop = i$0;
         }
         else{var i$1 = stop + 1 | 0; stop = i$1;}
        }
        var
         match$0 =
           [0,
            caml_call3
             (Stdlib_String[16], s, new_start, (stop - start$0 | 0) - 1 | 0),
            stop + 1 | 0];
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = 32;
      i$4 = i$6;
     }
     else if(92 === previous$0){
      var i$7 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$7;
     }
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _l_ = i + 1 | 0;
     return [0, x, function(_m_){return aux(_l_, _m_);}];
    }
    var _j_ = 0;
    return function(_k_){return aux(_j_, _k_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _h_ = i + 1 | 0;
     return [0, [0, i, x], function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function add_seq(b, seq){
    return caml_call2
            (Stdlib_Seq[4], function(_e_){return add_char(b, _e_);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 1 | 0;
    if(length < new_position){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], x);
    }
    else
     caml_bytes_unsafe_set(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 2 | 0;
    if(length < new_position){
     resize(b, 2);
     caml_bytes_set16(b[1][1], b[2], x);
    }
    else
     caml_bytes_set16(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 4 | 0;
    if(length < new_position){
     resize(b, 4);
     caml_bytes_set32(b[1][1], b[2], x);
    }
    else
     caml_bytes_set32(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 8 | 0;
    if(length < new_position){
     resize(b, 8);
     caml_bytes_set64(b[1][1], b[2], x);
    }
    else
     caml_bytes_set64(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _d_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _d_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _c_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _c_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _b_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _b_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(14, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# 10468 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_mutex_lock = runtime.caml_ml_mutex_lock,
    caml_ml_mutex_unlock = runtime.caml_ml_mutex_unlock,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function protect(m, f){
    caml_ml_mutex_lock(m);
    try{var x = caml_call1(f, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_ml_mutex_unlock(m);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_ml_mutex_unlock(m);
    return x;
   }
   var
    Stdlib_Mutex =
      [0,
       runtime.caml_ml_mutex_new,
       caml_ml_mutex_lock,
       runtime.caml_ml_mutex_try_lock,
       caml_ml_mutex_unlock,
       protect];
   runtime.caml_register_global(0, Stdlib_Mutex, "Stdlib__Mutex");
   return;
  }
  (globalThis));

//# 10506 "../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Stdlib_Condition =
      [0,
       runtime.caml_ml_condition_new,
       runtime.caml_ml_condition_wait,
       runtime.caml_ml_condition_signal,
       runtime.caml_ml_condition_broadcast];
   runtime.caml_register_global(0, Stdlib_Condition, "Stdlib__Condition");
   return;
  }
  (globalThis));

//# 10614 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_domain_dls_set = runtime.caml_domain_dls_set,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_domain_id = runtime.caml_ml_domain_id,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array;
   function cpu_relax(param){return runtime.caml_ml_domain_cpu_relax(0);}
   var unique_value = [0, 0];
   function create_dls(param){
    var st = caml_make_vect(8, unique_value);
    caml_domain_dls_set(st);
   }
   create_dls(0);
   var
    key_counter = caml_call1(Stdlib_Atomic[1], 0),
    parent_keys = caml_call1(Stdlib_Atomic[1], 0);
   function new_key(split_from_parent, init_orphan){
    var
     idx = caml_call2(Stdlib_Atomic[6], key_counter, 1),
     k = [0, idx, init_orphan];
    if(split_from_parent){
     var split = split_from_parent[1], ki = [0, k, split];
     for(;;){
      var l = caml_call1(Stdlib_Atomic[2], parent_keys);
      if(! (1 - caml_call3(Stdlib_Atomic[5], parent_keys, l, [0, ki, l])))
       break;
     }
    }
    return k;
   }
   function maybe_grow(idx){
    var st = runtime.caml_domain_dls_get(0), sz = st.length - 1;
    if(idx < sz) return st;
    var new_sz = sz;
    for(;;){
     if(idx < new_sz){
      var new_st = caml_make_vect(new_sz, unique_value);
      caml_call5(Stdlib_Array[8], st, 0, new_st, 0, sz);
      caml_domain_dls_set(new_st);
      return new_st;
     }
     var s = 2 * new_sz | 0;
     new_sz = s;
    }
   }
   function set(param, x){
    var idx = param[1], st = maybe_grow(idx);
    caml_check_bound(st, idx)[1 + idx] = x;
    return 0;
   }
   function get(param){
    var
     init = param[2],
     idx = param[1],
     st = maybe_grow(idx),
     v = caml_check_bound(st, idx)[1 + idx];
    if(v !== unique_value) return v;
    var v$0 = caml_call1(init, 0);
    caml_check_bound(st, idx)[1 + idx] = v$0;
    return v$0;
   }
   function get_id(param){var domain = param[1]; return domain;}
   function self(param){return caml_ml_domain_id(0);}
   function is_main_domain(param){return 0 === caml_ml_domain_id(0) ? 1 : 0;}
   var
    first_domain_spawned = caml_call1(Stdlib_Atomic[1], 0),
    first_spawn_function = [0, function(param){}],
    cst_first_domain_already_spawn = "first domain already spawned";
   function before_first_spawn(f){
    if(caml_call1(Stdlib_Atomic[2], first_domain_spawned))
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_first_domain_already_spawn], 1);
    var old_f = first_spawn_function[1];
    function new_f(param){caml_call1(old_f, 0); return caml_call1(f, 0);}
    first_spawn_function[1] = new_f;
    return 0;
   }
   var at_exit_key = new_key(0, function(param, _c_){return 0;});
   function at_exit(f){
    var old_exit = get(at_exit_key);
    function new_exit(param){
     caml_call1(f, 0);
     return caml_call1(old_exit, 0);
    }
    return set(at_exit_key, new_exit);
   }
   function do_at_exit(param){
    var f = get(at_exit_key);
    return caml_call1(f, 0);
   }
   Stdlib[104][1] = do_at_exit;
   var
    cst_internal_error_Am_I_alread = "internal error: Am I already finished?";
   function spawn(f){
    if(1 - caml_call1(Stdlib_Atomic[2], first_domain_spawned)){
     caml_call2(Stdlib_Atomic[3], first_domain_spawned, 1);
     caml_call1(first_spawn_function[1], 0);
     first_spawn_function[1] = function(param){return 0;};
    }
    var
     _a_ = caml_call1(Stdlib_Atomic[2], parent_keys),
     pk =
       caml_call2
        (Stdlib_List[20],
         function(param){
          var split = param[2], k = param[1], idx = k[1];
          return [0, idx, caml_call1(split, get(k))];
         },
         _a_),
     term_mutex = caml_call1(Stdlib_Mutex[1], 0),
     term_condition = caml_call1(Stdlib_Condition[1], 0),
     term_state = [0, 0];
    function body(param){
     a:
     {
      try{
       create_dls(0);
       caml_call2
        (Stdlib_List[18],
         function(param){
          var v = param[2], idx = param[1], st = maybe_grow(idx);
          caml_check_bound(st, idx)[1 + idx] = v;
          return 0;
         },
         pk);
       var res = caml_call1(f, 0);
      }
      catch(ex$0){
       var ex = caml_wrap_exception(ex$0), result = [1, ex];
       break a;
      }
      var result = [0, res];
     }
     try{do_at_exit(0); var result$0 = result;}
     catch(ex){
      var
       ex$0 = caml_wrap_exception(ex),
       _b_ = 0 === result[0] ? [1, ex$0] : result,
       result$0 = _b_;
     }
     caml_call1(Stdlib_Mutex[2], term_mutex);
     return term_state[1]
             ? caml_call1(Stdlib[2], cst_internal_error_Am_I_alread)
             : (term_state
                [1]
               = [0, result$0],
               caml_call1(Stdlib_Condition[4], term_condition));
    }
    return [0,
            runtime.caml_domain_spawn(body, term_mutex),
            term_mutex,
            term_condition,
            term_state];
   }
   function join(param){
    var
     term_state = param[4],
     term_condition = param[3],
     term_mutex = param[2];
    caml_call1(Stdlib_Mutex[2], term_mutex);
    for(;;){
     var match = term_state[1];
     if(match){
      var res = match[1];
      caml_call1(Stdlib_Mutex[4], term_mutex);
      if(0 === res[0]){var x = res[1]; return x;}
      var ex = res[1];
      throw caml_maybe_attach_backtrace(ex, 1);
     }
     caml_call2(Stdlib_Condition[2], term_condition, term_mutex);
    }
   }
   var
    recommended_domain_count = runtime.caml_recommended_domain_count,
    Stdlib_Domain =
      [0,
       spawn,
       join,
       get_id,
       self,
       before_first_spawn,
       at_exit,
       cpu_relax,
       is_main_domain,
       recommended_domain_count,
       [0, new_key, get, set]];
   runtime.caml_register_global(8, Stdlib_Domain, "Stdlib__Domain");
   return;
  }
  (globalThis));

//# 10841 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    _a_ = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _cU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _cU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _cS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _cS_));
     var _cT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[44], char_set$0);
     i = _cT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _cR_ = [0, ndec];
       else
        var _cR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _cR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[6], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _cQ_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _cQ_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _cO_ = caml_ml_string_length(str) - 1 | 0, _cN_ = 0;
    if(_cO_ >= 0){
     var i = _cN_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _cP_ = i + 1 | 0;
      if(_cO_ === i) break;
      i = _cP_;
     }
    }
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         fmt$0 = rest;
         ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         fmt$0 = rest$0;
         ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt$0 = rest$1;
         ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt$0 = rest$2;
         ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt$0 = rest$3;
         ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         fmt$0 = rest$4;
         ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         fmt$0 = rest$5;
         ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         fmt$0 = rest$6;
         ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt$0 = rest$7;
         ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt$0 = rest$8;
         ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt$0 = rest$12;
         ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt$0 = rest$13;
         ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         fmt$0 = rest$14;
         ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         fmt$0 = rest$15;
         ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         fmt$0 = rest$18;
         ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set;
         let set$0 = set;
         var
          is_alone =
            function(c){
             var
              after = caml_call1(Stdlib_Char[1], c + 1 | 0),
              before = caml_call1(Stdlib_Char[1], c - 1 | 0),
              _cJ_ = is_in_char_set(set$0, c);
             if(_cJ_)
              var
               _cK_ = is_in_char_set(set$0, before),
               _cL_ = _cK_ ? is_in_char_set(set$0, after) : _cK_,
               _cM_ = 1 - _cL_;
             else
              var _cM_ = _cJ_;
             return _cM_;
            };
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0;
               i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0;
                i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0;
                 j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0;
                i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0;
                i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0;
               i = i$6;
              }
             }
             else{var i$0 = i + 1 | 0; i = i$0;}
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         fmt$0 = rest$19;
         ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _cF_ = 108; break;
           case 1:
            var _cF_ = 110; break;
           default: var _cF_ = 78;
         }
         buffer_add_char(buf, _cF_);
         fmt$0 = rest$20;
         ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         fmt$0 = rest$21;
         ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt$0 = fmt$1;
         ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _cH_ = int_of_custom_arity(arity),
          _cG_ = 1;
         if(_cH_ >= 1){
          var i$8 = _cG_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _cI_ = i$8 + 1 | 0;
           if(_cH_ === i$8) break;
           i$8 = _cI_;
          }
         }
         fmt$0 = rest$23;
         ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0, , function(param){}, , function(param){}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        af = match[2];
       return [0, , function(param){af(0);}, , de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        af$0 = match$0[2];
       return [0, , function(param){af$0(0);}, , de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        af$1 = match$1[2];
       return [0, , function(param){af$1(0);}, , de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        af$2 = match$2[2];
       return [0, , function(param){af$2(0);}, , de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        af$3 = match$3[2];
       return [0, , function(param){af$3(0);}, , de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        af$4 = match$4[2];
       return [0, , function(param){af$4(0);}, , de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        af$5 = match$5[2];
       return [0, , function(param){af$5(0);}, , de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        af$6 = match$6[2];
       return [0, , function(param){af$6(0);}, , de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        af$7 = match$7[2];
       return [0, , function(param){af$7(0);}, , de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        af$8 = match$8[2],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        ga = match$9[2];
       return [0,
               ,
               function(param){ga(0); af$8(0);},
               ,
               function(param){jd(0); de$8(0);}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        af$9 = match$10[2];
       return [0, , function(param){af$9(0);}, , de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        af$10 = match$11[2];
       return [0, , function(param){af$10(0);}, , de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        af$11 = match$12[2];
       return [0, , function(param){af$11(0);}, , de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        af$12 = match$13[2];
       return [0, , function(param){af$12(0);}, , function(param){de$12(0);}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        af$13 = match$14[2];
       return [0, , function(param){af$13(0);}, , function(param){de$13(0);}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _cE_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _cE_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2]; fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2]; fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2]; fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _cB_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _cC_, _cB_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            fmtty$0 = fmtty$5; break;
           case 3:
            fmtty$0 = fmtty$5; break;
           case 4:
            fmtty$0 = fmtty$5; break;
           case 5:
            fmtty$0 = fmtty$5; break;
           case 6:
            fmtty$0 = fmtty$5; break;
           case 7:
            fmtty$0 = fmtty$5; break;
           case 8:
            fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _cD_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _cD_);
           case 10:
            fmtty$0 = fmtty$5; break;
           default: fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d = "%d",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$0 = cst_i$3,
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_u = cst_u$0,
    cst_Ld = "%Ld",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$0 = cst_Li$3,
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Lu = "%Lu",
    cst_ld = "%ld",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$0 = cst_li$3,
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_lu = "%lu",
    cst_nd = "%nd",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$0 = cst_ni$3,
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nu = "%nu",
    _r_ = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    _x_ = [0, 0, 4],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    cst_0 = cst_0$3,
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _cA_ = type_format_gen(fmt, fmtty);
    if(typeof _cA_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _cA_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _cy_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _cy_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _cz_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _cz_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _cz_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _cw_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _cw_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _cx_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _cx_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _cv_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _cv_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _cu_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _cu_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[6], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[6],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[6],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[6],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[44], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[6],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[44], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[6], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[44], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[25], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _cp_ = caml_ml_string_length(s) - 1 | 0, _co_ = 0;
    if(_cp_ >= 0){
     var i$0 = _co_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ct_ = i$0 + 1 | 0;
      if(_cp_ === i$0) break;
      i$0 = _ct_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _cr_ = caml_ml_string_length(s) - 1 | 0,
     _cq_ = 0;
    if(_cr_ >= 0){
     var i = _cq_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _cs_ = i + 1 | 0;
      if(_cr_ === i) break;
      i = _cs_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cn_ = cst_d$0; break;
      case 2:
       var _cn_ = cst_d$1; break;
      case 4:
       var _cn_ = cst_i$1; break;
      case 5:
       var _cn_ = cst_i$2; break;
      case 6:
       var _cn_ = cst_x; break;
      case 7:
       var _cn_ = cst_x$0; break;
      case 8:
       var _cn_ = cst_X; break;
      case 9:
       var _cn_ = cst_X$0; break;
      case 10:
       var _cn_ = cst_o; break;
      case 11:
       var _cn_ = cst_o$0; break;
      case 0:
      case 13:
       var _cn_ = cst_d; break;
      case 3:
      case 14:
       var _cn_ = cst_i$0; break;
      default: var _cn_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cn_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cm_ = cst_ld$0; break;
      case 2:
       var _cm_ = cst_ld$1; break;
      case 4:
       var _cm_ = cst_li$1; break;
      case 5:
       var _cm_ = cst_li$2; break;
      case 6:
       var _cm_ = cst_lx; break;
      case 7:
       var _cm_ = cst_lx$0; break;
      case 8:
       var _cm_ = cst_lX; break;
      case 9:
       var _cm_ = cst_lX$0; break;
      case 10:
       var _cm_ = cst_lo; break;
      case 11:
       var _cm_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cm_ = cst_ld; break;
      case 3:
      case 14:
       var _cm_ = cst_li$0; break;
      default: var _cm_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cm_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cl_ = cst_nd$0; break;
      case 2:
       var _cl_ = cst_nd$1; break;
      case 4:
       var _cl_ = cst_ni$1; break;
      case 5:
       var _cl_ = cst_ni$2; break;
      case 6:
       var _cl_ = cst_nx; break;
      case 7:
       var _cl_ = cst_nx$0; break;
      case 8:
       var _cl_ = cst_nX; break;
      case 9:
       var _cl_ = cst_nX$0; break;
      case 10:
       var _cl_ = cst_no; break;
      case 11:
       var _cl_ = cst_no$0; break;
      case 0:
      case 13:
       var _cl_ = cst_nd; break;
      case 3:
      case 14:
       var _cl_ = cst_ni$0; break;
      default: var _cl_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cl_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _ck_ = cst_Ld$0; break;
      case 2:
       var _ck_ = cst_Ld$1; break;
      case 4:
       var _ck_ = cst_Li$1; break;
      case 5:
       var _ck_ = cst_Li$2; break;
      case 6:
       var _ck_ = cst_Lx; break;
      case 7:
       var _ck_ = cst_Lx$0; break;
      case 8:
       var _ck_ = cst_LX; break;
      case 9:
       var _ck_ = cst_LX$0; break;
      case 10:
       var _ck_ = cst_Lo; break;
      case 11:
       var _ck_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _ck_ = cst_Ld; break;
      case 3:
      case 14:
       var _ck_ = cst_Li$0; break;
      default: var _ck_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_ck_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _ch_ = 0;
        else{
         var _cg_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cg_ >>> 0){
           if(55 === _cg_) break a;
          }
          else if(21 < _cg_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _ch_ = 1;
        }
        var _ci_ = _ch_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_ci_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cj_ = hex(0); return caml_call1(Stdlib_String[26], _cj_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[44], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cf_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cf_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _cd_ = fmt$0[1];
        if(0 === _cd_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _ce_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _ce_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _ce_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cc_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cb_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cb_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cb_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _ca_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _ca_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _ca_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], x = make_iprintf(k$0, o, rest);
        return function(_b$_){return x;};
       case 1:
        var rest$0 = fmt$0[1], x$0 = make_iprintf(k$0, o, rest$0);
        return function(_b__){return x$0;};
       case 2:
        var _bM_ = fmt$0[1];
        if(typeof _bM_ === "number"){
         var rest$1 = fmt$0[2], x$1 = make_iprintf(k$0, o, rest$1);
         return function(_b9_){return x$1;};
        }
        if(0 === _bM_[0]){
         var rest$2 = fmt$0[2], x$2 = make_iprintf(k$0, o, rest$2);
         return function(_b8_){return x$2;};
        }
        var
         rest$3 = fmt$0[2],
         x$3 = make_iprintf(k$0, o, rest$3),
         x$4 = function(_b7_){return x$3;};
        return function(_b6_){return x$4;};
       case 3:
        var _bN_ = fmt$0[1];
        if(typeof _bN_ === "number"){
         var rest$4 = fmt$0[2], x$5 = make_iprintf(k$0, o, rest$4);
         return function(_b5_){return x$5;};
        }
        if(0 === _bN_[0]){
         var rest$5 = fmt$0[2], x$6 = make_iprintf(k$0, o, rest$5);
         return function(_b4_){return x$6;};
        }
        var
         rest$6 = fmt$0[2],
         x$7 = make_iprintf(k$0, o, rest$6),
         x$8 = function(_b3_){return x$7;};
        return function(_b2_){return x$8;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bO_ = fmt$0[1];
        if(typeof _bO_ === "number"){
         var rest$12 = fmt$0[2], x$9 = make_iprintf(k$0, o, rest$12);
         return function(_b1_){return x$9;};
        }
        if(0 === _bO_[0]){
         var rest$13 = fmt$0[2], x$10 = make_iprintf(k$0, o, rest$13);
         return function(_b0_){return x$10;};
        }
        var
         rest$14 = fmt$0[2],
         x$11 = make_iprintf(k$0, o, rest$14),
         x$12 = function(_bZ_){return x$11;};
        return function(_bY_){return x$12;};
       case 10:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2]; fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], x$13 = make_iprintf(k$0, o, rest$18);
        return function(_bX_){return x$13;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _bW_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _bW_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         x$14 = make_iprintf(k$0, o, rest$20),
         x$15 = function(_bV_){return x$14;};
        return function(_bU_){return x$15;};
       case 16:
        var rest$21 = fmt$0[1], x$16 = make_iprintf(k$0, o, rest$21);
        return function(_bT_){return x$16;};
       case 17:
        var rest$22 = fmt$0[2]; fmt$0 = rest$22; break;
       case 18:
        var _bP_ = fmt$0[1];
        if(0 === _bP_[0]){
         var rest$23 = fmt$0[2], fmt$1 = _bP_[1][1];
         let k = k$0, rest = rest$23;
         var k$1 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$1;
         fmt$0 = fmt$1;
        }
        else{
         var rest$24 = fmt$0[2], fmt$2 = _bP_[1][1];
         let k = k$0, rest = rest$24;
         var k$2 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$2;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], x$17 = make_iprintf(k$0, o, rest$25);
        return function(_bS_){return x$17;};
       case 21:
        var rest$26 = fmt$0[2], x$18 = make_iprintf(k$0, o, rest$26);
        return function(_bR_){return x$18;};
       case 22:
        var rest$27 = fmt$0[1], x$19 = make_iprintf(k$0, o, rest$27);
        return function(_bQ_){return x$19;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1];
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);}, 0, ign, rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var x$2 = make_iprintf(k, o, fmt);
      return function(_bL_){return x$2;};
     }
     if(prec){
      var x = make_iprintf(k, o, fmt), x$0 = function(_bK_){return x;};
      return function(_bJ_){return x$0;};
     }
     var x$1 = make_iprintf(k, o, fmt);
     return function(_bI_){return x$1;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var x$6 = make_iprintf(k, o, fmt);
      return function(_bH_){return x$6;};
     }
     if(prec){
      var x$3 = make_iprintf(k, o, fmt), x$4 = function(_bG_){return x$3;};
      return function(_bF_){return x$4;};
     }
     var x$5 = make_iprintf(k, o, fmt);
     return function(_bE_){return x$5;};
    }
    if(typeof prec !== "number"){
     var x$12 = make_iprintf(k, o, fmt), x$13 = function(_bD_){return x$12;};
     return function(_bC_){return x$13;};
    }
    if(prec){
     var
      x$7 = make_iprintf(k, o, fmt),
      x$8 = function(_bB_){return x$7;},
      x$9 = function(_bA_){return x$8;};
     return function(_bz_){return x$9;};
    }
    var x$10 = make_iprintf(k, o, fmt);
    function x$11(_by_){return x$10;}
    return function(_bx_){return x$11;};
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bw_){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str === cst$43) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0;
      wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[16], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0;
      nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[16], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0;
       str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[16],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           char_set = create_char_set(0),
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                i = _a$_;
               }
              }
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_in_char_set(char_set, 45);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_in_char_set(char_set, c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind)
                  invalid_format_message
                   (end_ind, cst_unexpected_end_of_format);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   invalid_format_message
                    (end_ind, cst_unexpected_end_of_format);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$1 = counter + 1 | 0;
                  return parse_char_set_content(counter$1, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_in_char_set(char_set, c$0);
                  add_in_char_set(char_set, 45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_in_char_set(char_set, c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$2 = counter + 1 | 0;
                 return parse_char_set_content(counter$2, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_in_char_set(char_set, c$0);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
               c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[32], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[16], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
      acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[16], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0;
             str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0;
          str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0;
          str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0;
         str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0;
         str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0;
       str_ind$0 = str_ind$1;
      }
      else{var str_ind$7 = str_ind$0 + 1 | 0; str_ind$0 = str_ind$7;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[16], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# 16044 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[9], o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[10], b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# 16852 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) === 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, [3, 0, 0], "%S"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _ag_ = Stdlib_Obj[15];
    if(caml_obj_tag(f) === _ag_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _ah_ = Stdlib_Obj[16];
    return caml_obj_tag(f) === _ah_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _ae_ = other_fields(x, i + 1 | 0), _af_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _af_, _ae_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ad_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     param = tl;
    }
   }
   function string_of_extension_constructo(t){
    if(0 === caml_obj_tag(t)){
     var constructor = t[1][1], match = t.length - 1;
     if(2 < match >>> 0)
      var
       _$_ = other_fields(t, 2),
       _aa_ = field(t, 1),
       _ac_ = caml_call3(Stdlib_Printf[4], _d_, _aa_, _$_);
     else
      switch(match){
        case 0:
         var _ac_ = cst$1; break;
        case 1:
         var _ac_ = cst$2; break;
        default:
         var
          _ab_ = field(t, 1),
          _ac_ = caml_call2(Stdlib_Printf[4], _e_, _ab_);
      }
     var match$0 = [0, constructor, [0, _ac_]];
    }
    else
     var match$0 = [0, t[1], 0];
    var fields_opt = match$0[2], constructor$0 = match$0[1];
    if(! fields_opt) return constructor$0;
    var f = fields_opt[1];
    return caml_call2(Stdlib[28], constructor$0, f);
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var match = x[2], char$0 = match[3], line = match[2], file = match[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$0 = x[2],
      char$1 = match$0[3],
      line$0 = match$0[2],
      file$0 = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] !== Stdlib[15]) return string_of_extension_constructo(x);
    var
     match$1 = x[2],
     char$2 = match$1[3],
     line$1 = match$1[2],
     file$1 = match$1[1];
    return caml_call6
            (Stdlib_Printf[4],
             locfmt,
             file$1,
             line$1,
             char$2,
             char$2 + 6 | 0,
             cst_Undefined_recursive_module);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var ___ = caml_call1(fct, arg); return ___;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _Z_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _Z_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _Y_ = caml_call1(fct, arg); return _Y_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _X_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _X_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _P_ = slot[5],
      _Q_ = slot[4],
      _R_ = slot[3],
      _S_ = slot[6] ? cst_inlined : cst$3,
      _T_ = slot[2],
      _U_ = slot[7],
      _V_ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, _V_, _U_, _T_, _S_, _R_, _Q_, _P_)];
    }
    if(slot[1]) return 0;
    var _W_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _W_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _N_ = a.length - 2 | 0, _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _K_ = a.length - 2 | 0,
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[7] !== cst$4) return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _I_ = 0;
     else{
      var _H_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _H_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _I_ = _H_;
     }
     return _I_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _G_ = 1 - success;
     if(! _G_) return _G_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      [0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    _m_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _D_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _m_, _D_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _E_ = caml_call1(Stdlib[18], status),
      _F_ = caml_check_bound(errors, _E_)[1 + _E_];
     caml_call1(Stdlib[53], _F_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _o_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_C_){}
      try{
       var
        _y_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _x_ = _y_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _v_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _n_, _v_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _w_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _o_, _w_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _x_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _z_ = _x_;
     }
     catch(_B_){
      var _u_ = caml_wrap_exception(_B_);
      if(_u_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_u_, 0);
      var _z_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _z_;
    }
    catch(_A_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_t_){return caml_get_exception_raw_backtra(_t_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       function(_s_, _r_){return runtime.caml_raw_backtrace_slot(_s_, _r_);},
       function(_q_){return runtime.caml_convert_raw_backtrace_slot(_q_);},
       function(_p_){return runtime.caml_raw_backtrace_next_slot(_p_);},
       exn_slot_id,
       exn_slot_name,
       string_of_extension_constructo];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# 17587 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[10],
    equal = Stdlib_String[9],
    cst_Digest_substring = "Digest.substring",
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1;
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[44], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[44], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# 17708 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      default: return 1;
    }
   }
   var
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray";
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ === j) break;
      j = _an_;
     }
    }
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ === j) break;
      j = _ak_;
     }
    }
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), dlen = dims.length - 1;
    return layout
            ? (floop
               (arr, caml_make_vect(dlen, 1), f, dlen - 1 | 0, dims),
              arr)
            : (cloop(arr, caml_make_vect(dlen, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ === i) break;
      i = _ah_;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[17], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim === i$0) break;
       i$0 = ___;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 2 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         i$0 = _Q_;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       j$0 = _P_;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ === j) break;
        j = _M_;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _L_;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ === j) break;
        j = _G_;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           i$0 = _x_;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         j$0 = _w_;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       k$0 = _u_;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ === k) break;
          k = _r_;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ === j) break;
        j = _q_;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _n_;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ === k) break;
          k = _i_;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ === j) break;
        j = _h_;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _e_;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       0,
       1,
       10,
       11,
       2,
       3,
       4,
       5,
       8,
       6,
       7,
       9,
       12,
       kind_size_in_bytes,
       0,
       1,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));

//# 18237 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_blit = runtime.caml_ba_blit,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_lxm_next = runtime.caml_lxm_next,
    caml_mod = runtime.caml_mod,
    caml_notequal = runtime.caml_notequal,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    serialization_prefix = "lxm1:",
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function create(param){return caml_call3(Stdlib_Bigarray[19][1], 7, 0, 4);}
   function set(s, i1, i2, i3, i4){
    caml_ba_set_1(s, 0, runtime.caml_int64_or(i1, _a_));
    caml_ba_set_1(s, 1, i2);
    var i3$0 = caml_notequal(i3, _b_) ? i3 : _e_;
    caml_ba_set_1(s, 2, i3$0);
    var i4$0 = caml_notequal(i4, _c_) ? i4 : _d_;
    return caml_ba_set_1(s, 3, i4$0);
   }
   function mk(i1, i2, i3, i4){
    var s = create(0);
    set(s, i1, i2, i3, i4);
    return s;
   }
   var
    serialization_prefix_len = 5,
    cst_Random_State_of_binary_str =
      "Random.State.of_binary_string: expected a format compatible with OCaml ",
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int32 = "Random.int32";
   function to_binary_string(s){
    var buf = caml_create_bytes(37);
    caml_call5
     (Stdlib_Bytes[12],
      serialization_prefix,
      0,
      buf,
      0,
      serialization_prefix_len);
    var i = 0;
    for(;;){
     var _y_ = runtime.caml_ba_get_1(s, i);
     caml_call3(Stdlib_Bytes[86], buf, 5 + (i * 8 | 0) | 0, _y_);
     var _z_ = i + 1 | 0;
     if(3 === i) return caml_call1(Stdlib_Bytes[44], buf);
     i = _z_;
    }
   }
   function of_binary_string(buf){
    var
     _v_ = runtime.caml_ml_string_length(buf) !== 37 ? 1 : 0,
     _w_ = _v_ || 1 - caml_call2(Stdlib_String[11], serialization_prefix, buf);
    if(_w_){
     var
      _x_ =
        caml_call2(Stdlib[28], cst_Random_State_of_binary_str, Stdlib_Sys[46]);
     caml_call1(Stdlib[2], _x_);
    }
    var
     i1 = caml_call2(Stdlib_String[64], buf, 5),
     i2 = caml_call2(Stdlib_String[64], buf, 13),
     i3 = caml_call2(Stdlib_String[64], buf, 21),
     i4 = caml_call2(Stdlib_String[64], buf, 29);
    return mk(i1, i2, i3, i4);
   }
   function copy(src){
    var dst = create(0);
    caml_ba_blit(src, dst);
    return dst;
   }
   function reinit(s, seed){
    var
     n = seed.length - 1,
     b = caml_create_bytes((n * 8 | 0) + 1 | 0),
     _p_ = n - 1 | 0,
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var _t_ = caml_int64_of_int32(runtime.caml_check_bound(seed, i)[1 + i]);
      caml_call3(Stdlib_Bytes[86], b, i * 8 | 0, _t_);
      var _u_ = i + 1 | 0;
      if(_p_ === i) break;
      i = _u_;
     }
    }
    caml_bytes_set(b, n * 8 | 0, 1);
    var d1 = caml_call1(Stdlib_Digest[4], b);
    caml_bytes_set(b, n * 8 | 0, 2);
    var
     d2 = caml_call1(Stdlib_Digest[4], b),
     _q_ = caml_call2(Stdlib_String[64], d2, 8),
     _r_ = caml_call2(Stdlib_String[64], d2, 0),
     _s_ = caml_call2(Stdlib_String[64], d1, 8);
    return set(s, caml_call2(Stdlib_String[64], d1, 0), _s_, _r_, _q_);
   }
   function make(seed){var s = create(0); reinit(s, seed); return s;}
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function bits(s){
    return caml_int64_to_int32(caml_lxm_next(s)) & 1073741823;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var
      _n_ = Stdlib[19],
      r = caml_int64_to_int32(caml_lxm_next(s)) & _n_,
      v = caml_mod(r, bound);
     if(((Stdlib[19] - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function bits32(s){return caml_int64_to_int32(caml_lxm_next(s));}
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var r = bits32(s) >>> 1 | 0, v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   var
    bits64 = caml_lxm_next,
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64";
   function int64(s, bound){
    if(caml_lessequal(bound, _g_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      r = caml_int64_shift_right_unsigne(caml_lxm_next(s), 1),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _f_)))
      return v;
    }
   }
   var
    _j_ = runtime.caml_int64_create_lo_mi_hi(14371852, 15349651, 22696),
    _k_ = runtime.caml_int64_create_lo_mi_hi(12230193, 11438743, 35013),
    _l_ = runtime.caml_int64_create_lo_mi_hi(1424933, 15549263, 2083),
    _m_ = runtime.caml_int64_create_lo_mi_hi(9492471, 4696708, 43520),
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(caml_lxm_next(s));},
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    for(;;){
     var b = caml_lxm_next(s), n = caml_int64_shift_right_unsigne(b, 11);
     if(caml_notequal(n, _h_))
      return runtime.caml_int64_to_float(n) * 1.1102230246251565e-16 * bound;
    }
   }
   function bool(s){return runtime.caml_lessthan(caml_lxm_next(s), _i_);}
   function split(s){
    var
     i1 = caml_lxm_next(s),
     i2 = caml_lxm_next(s),
     i3 = caml_lxm_next(s),
     i4 = caml_lxm_next(s);
    return mk(i1, i2, i3, i4);
   }
   function mk_default(param){return mk(_m_, _l_, _k_, _j_);}
   var random_key = caml_call2(Stdlib_Domain[10][1], [0, split], mk_default);
   function bits$0(param){
    return bits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function int$1(bound){
    return int$0(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function full_int$0(bound){
    return full_int(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int32$0(bound){
    return int32(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function nativeint$0(bound){
    return nativeint(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int64$0(bound){
    return int64(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function float$1(scale){
    return float$0(caml_call1(Stdlib_Domain[10][2], random_key), scale);
   }
   function bool$0(param){
    return bool(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits32$0(param){
    return bits32(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits64$0(param){
    var s = caml_call1(Stdlib_Domain[10][2], random_key);
    return caml_lxm_next(s);
   }
   function nativebits$0(param){
    return nativebits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function full_init(seed){
    return reinit(caml_call1(Stdlib_Domain[10][2], random_key), seed);
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(param){return full_init(caml_sys_random_seed(0));}
   function split$0(param){
    return split(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function get_state(param){
    return copy(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function set_state(src){
    var dst = caml_call1(Stdlib_Domain[10][2], random_key);
    return caml_ba_blit(src, dst);
   }
   var
    Stdlib_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits,
        split,
        to_binary_string,
        of_binary_string],
       get_state,
       set_state,
       split$0];
   runtime.caml_register_global(32, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# 18567 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _d_ = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var _an_ = h.length - 1 < 4 ? 1 : 0, _ao_ = _an_ || (h[4] < 0 ? 1 : 0);
    return _ao_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_al_){
    var _a_ = caml_wrap_exception(_al_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_am_){
     var _b_ = caml_wrap_exception(_am_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[15], params, 82),
    randomized = caml_call1(Stdlib_Atomic[1], randomized_default);
   function randomize(param){
    return caml_call2(Stdlib_Atomic[3], randomized, 1);
   }
   function is_randomized(param){
    return caml_call1(Stdlib_Atomic[2], randomized);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[15][2]);
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0;
     x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    if(opt)
     var sth = opt[1], random = sth;
    else
     var random = caml_call1(Stdlib_Atomic[2], randomized);
    var s = power_2_above(16, initial_size);
    if(random)
     var
      _ak_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[15][4], _ak_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _aj_ = 0 < h[1] ? 1 : 0;
    return _aj_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[7], h[2], 0, h[2].length - 1, 0))
            : _aj_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     _ag_ = h[4],
     _ah_ = h[3],
     _ai_ = caml_call2(Stdlib_Array[13], copy_bucketlist, h[2]);
    return [0, h[1], _ai_, _ah_, _ag_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _aa_ = odata.length - 2 | 0,
     _$_ = 0;
    if(_aa_ >= 0){
     var i$0 = _$_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       cell = next;
      }
      var _af_ = i$0 + 1 | 0;
      if(_aa_ === i$0) break;
      i$0 = _af_;
     }
    }
    if(inplace){
     var _ac_ = nsize - 1 | 0, _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _ae_ = i + 1 | 0;
       if(_ac_ === i) break;
       i = _ae_;
      }
     }
     var _ad_ = 0;
    }
    else
     var _ad_ = inplace;
    return _ad_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     ___ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! ___) return ___;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _W_ = d.length - 2 | 0, _V_ = 0;
     if(_W_ >= 0){
      var i = _V_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
       var _Z_ = i + 1 | 0;
       if(_W_ === i) break;
       i = _Z_;
      }
     }
     var _X_ = 1 - old_trav, _Y_ = _X_ ? flip_ongoing_traversal(h) : _X_;
     return _Y_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _R_ = d.length - 2 | 0, _Q_ = 0;
     if(_R_ >= 0){
      var i = _Q_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _U_ = i + 1 | 0;
       if(_R_ === i) break;
       i = _U_;
      }
     }
     var _S_ = 1 - old_trav, _T_ = _S_ ? flip_ongoing_traversal(h) : _S_;
     return _T_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _N_ = d.length - 2 | 0, _M_ = 0;
     if(_N_ >= 0){
      var i = _M_;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
       accu$1[1] = accu;
       var _P_ = i + 1 | 0;
       if(_N_ === i) break;
       i = _P_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _O_ = accu$1[1];
     return _O_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var next = param$0[3], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = next;
    }
   }
   function stats(h){
    var
     mbl =
       caml_call3
        (Stdlib_Array[17],
         function(m, b){
          var _L_ = bucket_length(0, b);
          return caml_call2(Stdlib_Int[11], m, _L_);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    caml_call2
     (Stdlib_Array[11],
      function(b){
       var l = bucket_length(0, b);
       histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_K_){return aux(i$0, next, _K_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      buck$0 = buck$1;
     }
    }
    var _H_ = 0, _I_ = 0;
    return function(_J_){return aux(_I_, _H_, _J_);};
   }
   function to_seq_keys(m){
    var _F_ = to_seq(m);
    return caml_call2(Stdlib_Seq[29], function(_G_){return _G_[1];}, _F_);
   }
   function to_seq_values(m){
    var _D_ = to_seq(m);
    return caml_call2(Stdlib_Seq[29], function(_E_){return _E_[2];}, _D_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _C_ = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & _C_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _B_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _B_ ? resize(key_index, h) : _B_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var
      _A_ = key_index(h, key),
      match = caml_check_bound(h[2], _A_)[1 + _A_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var
      _z_ = key_index(h, key),
      match = caml_check_bound(h[2], _z_)[1 + _z_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     var
      _y_ = key_index(h, key),
      param = caml_check_bound(h[2], _y_)[1 + _y_];
     for(;;){
      if(! param) return 0;
      var k = param[1], d = param[2], next = param[3];
      if(caml_call2(H[1], k, key)) break;
      param = next;
     }
     var block = [0, d, 24029], dst = block, offset = 1, param$0 = next;
     for(;;){
      if(! param$0){dst[1 + offset] = 0; return block;}
      var k$0 = param$0[1], d$0 = param$0[2], next$0 = param$0[3];
      if(caml_call2(H[1], k$0, key)){
       var dst$0 = [0, d$0, 24029];
       dst[1 + offset] = dst$0;
       dst = dst$0;
       offset = 1;
       param$0 = next$0;
      }
      else
       param$0 = next$0;
     }
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _v_ = 0;
      }
      else
       var _v_ = 1;
      if(_v_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _w_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_w_) return resize(key_index, h);
       var _x_ = _w_;
      }
      else
       var _x_ = _v_;
      return _x_;
     }
    }
    function mem(h, key){
     var
      _u_ = key_index(h, key),
      param = caml_check_bound(h[2], _u_)[1 + _u_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _t_ = caml_call2(H[1], k, key);
      if(_t_) return _t_;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, seeded_hash]),
     _s_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(_s_, _d_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_s_, _d_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _r_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _r_ ? resize(key_index, h) : _r_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var _q_ = key_index(h, key), match = caml_check_bound(h[2], _q_)[1 + _q_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var _p_ = key_index(h, key), match = caml_check_bound(h[2], _p_)[1 + _p_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    var _o_ = key_index(h, key), param = caml_check_bound(h[2], _o_)[1 + _o_];
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(k, key)) break;
     param = next;
    }
    var block = [0, data, 24029], dst = block, offset = 1, param$0 = next;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var k$0 = param$0[1], data$0 = param$0[2], next$0 = param$0[3];
     if(0 === caml_compare(k$0, key)){
      var dst$0 = [0, data$0, 24029];
      dst[1 + offset] = dst$0;
      dst = dst$0;
      offset = 1;
      param$0 = next$0;
     }
     else
      param$0 = next$0;
    }
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _l_ = 0;
     }
     else
      var _l_ = 1;
     if(_l_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _m_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_m_) return resize(key_index, h);
      var _n_ = _m_;
     }
     else
      var _n_ = _l_;
     return _n_;
    }
   }
   function mem(h, key){
    var _k_ = key_index(h, key), param = caml_check_bound(h[2], _k_)[1 + _k_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _j_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_j_) return _j_;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt)
     var sth = opt[1], random = sth;
    else
     var random = caml_call1(Stdlib_Atomic[2], randomized);
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[15][4], _g_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _h_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _h_];
    insert_all_buckets
     (function(_i_){return key_index(h$0, _i_);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(16, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# 19872 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$16 = "",
    cst$15 = ">",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$14 = ".",
    cst$11 = cst$15,
    cst$12 = "<\/",
    cst$13 = cst$16,
    cst$8 = cst$15,
    cst$9 = "<",
    cst$10 = cst$16,
    cst$7 = "\n",
    cst$3 = cst$16,
    cst$4 = cst$16,
    cst$5 = cst$16,
    cst$6 = cst$16,
    cst = cst$16,
    cst$0 = cst$16,
    cst$1 = cst$16,
    cst$2 = cst$16,
    _a_ = [0, cst$16, 0, cst$16],
    Stdlib_Queue = global_data.Stdlib__Queue,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function id(x){return x;}
   var
    zero = 0,
    unknown = -1,
    String_tag =
      [248, "Stdlib.Format.String_tag", runtime.caml_fresh_oo_id(0)];
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return caml_call2(Stdlib_Queue[3], token, state[28]);
   }
   var
    pp_infinity = 1000000010,
    _b_ = [0, cst$16],
    _c_ = [1, "margin <= max_indent"],
    _d_ = [0, 0],
    _e_ = [1, "max_indent < 2"],
    cst_Format_pp_set_geometry = "Format.pp_set_geometry: ";
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
   }
   function format_string(state, s){
    var _a9_ = s !== cst$16 ? 1 : 0;
    return _a9_ ? format_pp_text(state, caml_ml_string_length(s), s) : _a9_;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = caml_call2(Stdlib_Int[10], state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = caml_call1(Stdlib_Stack[8], state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return runtime.caml_lessthan(n, x)
                    ? [0, n, ls]
                    : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        caml_call1(Stdlib_Stack[5], state[2]); return;
       case 2:
        caml_call1(Stdlib_Stack[5], state[3]); return;
       case 3:
        var match$4 = caml_call1(Stdlib_Stack[8], state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_new_line(state, _a_, width$0);
       case 4:
        var _a7_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! _a7_) return _a7_;
        var match$1 = caml_call1(Stdlib_Queue[6], state[28]);
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = caml_call1(Stdlib_Stack[5], state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = caml_call1(Stdlib_Stack[8], state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 0:
          return break_same_line(state, fits);
         case 1:
          return break_new_line(state, breaks, width$1);
         case 2:
          return break_new_line(state, breaks, width$1);
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         default: return break_same_line(state, fits);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = caml_call1(Stdlib_Stack[8], state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(param$0){
          var tail = param$0[2], head = param$0[1];
          if(insertion_point > head){param$0 = tail; continue;}
          var _a8_ = head;
         }
         else
          var _a8_ = first;
         var tab = _a8_;
         break;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, cst$0, offset + n | 0, cst])
               : break_new_line
                 (state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = caml_call1(Stdlib_Stack[8], state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_new_line(state, _a_, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return caml_call2(Stdlib_Stack[3], [0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1];
       return caml_call2(Stdlib_Stack[3], tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return caml_call2(Stdlib_Stack[3], tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var match = caml_call1(Stdlib_Queue[9], state[28]);
     if(! match) return 0;
     var
      match$0 = match[1],
      size = match$0[1],
      length = match$0[3],
      token = match$0[2],
      pending_count = state[13] - state[12] | 0,
      _a5_ = 0 <= size ? 1 : 0,
      _a6_ = _a5_ || (state[9] <= pending_count ? 1 : 0);
     if(! _a6_) return _a6_;
     caml_call1(Stdlib_Queue[5], state[28]);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function enqueue_advance(state, tok){
    pp_enqueue(state, tok);
    return advance_left(state);
   }
   function enqueue_string_as(state, size, s){
    return enqueue_advance(state, [0, size, [0, s], size]);
   }
   function initialize_scan_stack(stack){
    caml_call1(Stdlib_Stack[9], stack);
    var queue_elem = [0, unknown, _b_, 0];
    return caml_call2(Stdlib_Stack[3], [0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = caml_call1(Stdlib_Stack[8], state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var _a4_ = queue_elem[2];
    if(typeof _a4_ !== "number")
     switch(_a4_[0]){
       case 3:
        if(1 - ty){
         var x$0 = state[13] + size | 0;
         queue_elem[1] = x$0;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         var x = state[13] + size | 0;
         queue_elem[1] = x;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
     }
   }
   function scan_push(state, b, token){
    pp_enqueue(state, token);
    if(b) set_size(state, 1);
    var elem = [0, state[13], token];
    return caml_call2(Stdlib_Stack[3], elem, state[1]);
   }
   function pp_open_box_gen(state, indent, br_ty){
    state[14] = state[14] + 1 | 0;
    if(state[14] < state[15]){
     var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
     return scan_push(state, 0, elem);
    }
    var _a3_ = state[14] === state[15] ? 1 : 0;
    if(! _a3_) return _a3_;
    var s = state[16], x = caml_ml_string_length(s);
    return enqueue_string_as(state, x, s);
   }
   function pp_close_box(state, param){
    var _a1_ = 1 < state[14] ? 1 : 0;
    if(_a1_){
     if(state[14] < state[15]){
      pp_enqueue(state, [0, zero, 1, 0]);
      set_size(state, 1);
      set_size(state, 0);
     }
     state[14] = state[14] - 1 | 0;
     var _a2_ = 0;
    }
    else
     var _a2_ = _a1_;
    return _a2_;
   }
   function pp_open_stag(state, tag_name){
    if(state[22]){
     caml_call2(Stdlib_Stack[3], tag_name, state[4]);
     caml_call1(state[26], tag_name);
    }
    var _a0_ = state[23];
    if(! _a0_) return _a0_;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, zero, token, 0]);
   }
   function pp_close_stag(state, param){
    if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
    var _aY_ = state[22];
    if(_aY_){
     var match = caml_call1(Stdlib_Stack[5], state[4]);
     if(match){
      var tag_name = match[1];
      return caml_call1(state[27], tag_name);
     }
     var _aZ_ = 0;
    }
    else
     var _aZ_ = _aY_;
    return _aZ_;
   }
   function pp_set_print_tags(state, b){state[22] = b; return 0;}
   function pp_set_mark_tags(state, b){state[23] = b; return 0;}
   function pp_get_print_tags(state, param){return state[22];}
   function pp_get_mark_tags(state, param){return state[23];}
   function pp_set_tags(state, b){
    pp_set_print_tags(state, b);
    return pp_set_mark_tags(state, b);
   }
   function pp_get_formatter_stag_function(state, param){
    return [0, state[24], state[25], state[26], state[27]];
   }
   function pp_set_formatter_stag_function(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0;
   }
   function pp_rinit(state){
    state[12] = 1;
    state[13] = 1;
    caml_call1(Stdlib_Queue[11], state[28]);
    initialize_scan_stack(state[1]);
    caml_call1(Stdlib_Stack[9], state[2]);
    caml_call1(Stdlib_Stack[9], state[3]);
    caml_call1(Stdlib_Stack[9], state[4]);
    caml_call1(Stdlib_Stack[9], state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3);
   }
   function pp_flush_queue(state, end_with_newline){
    caml_call2
     (Stdlib_Stack[13],
      function(param){return pp_close_stag(state, 0);},
      state[4]);
    for(;;){
     if(1 >= state[14]){
      state[13] = pp_infinity;
      advance_left(state);
      if(end_with_newline) pp_output_newline(state);
      return pp_rinit(state);
     }
     pp_close_box(state, 0);
    }
   }
   function pp_print_as_size(state, size, s){
    var _aX_ = state[14] < state[15] ? 1 : 0;
    return _aX_ ? enqueue_string_as(state, size, s) : _aX_;
   }
   function pp_print_as(state, isize, s){
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_string(state, s){
    var isize = caml_ml_string_length(s);
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_bytes(state, s){
    var
     s$0 = caml_call1(Stdlib_Bytes[6], s),
     isize = runtime.caml_ml_bytes_length(s);
    return pp_print_as_size(state, isize, s$0);
   }
   function pp_print_int(state, i){
    return pp_print_string(state, caml_call1(Stdlib_Int[12], i));
   }
   function pp_print_float(state, f){
    return pp_print_string(state, caml_call1(Stdlib[35], f));
   }
   function pp_print_bool(state, b){
    return pp_print_string(state, caml_call1(Stdlib[30], b));
   }
   function pp_print_char(state, c){
    var s = caml_call2(Stdlib_String[1], 1, c);
    return pp_print_as_size(state, 1, s);
   }
   function pp_open_hbox(state, param){return pp_open_box_gen(state, 0, 0);}
   function pp_open_vbox(state, indent){
    return pp_open_box_gen(state, indent, 1);
   }
   function pp_open_hvbox(state, indent){
    return pp_open_box_gen(state, indent, 2);
   }
   function pp_open_hovbox(state, indent){
    return pp_open_box_gen(state, indent, 3);
   }
   function pp_open_box(state, indent){
    return pp_open_box_gen(state, indent, 4);
   }
   function pp_print_newline(state, param){
    pp_flush_queue(state, 1);
    return caml_call1(state[18], 0);
   }
   function pp_print_flush(state, param){
    pp_flush_queue(state, 0);
    return caml_call1(state[18], 0);
   }
   function pp_force_newline(state, param){
    var _aW_ = state[14] < state[15] ? 1 : 0;
    return _aW_ ? enqueue_advance(state, [0, zero, 3, 0]) : _aW_;
   }
   function pp_print_if_newline(state, param){
    var _aV_ = state[14] < state[15] ? 1 : 0;
    return _aV_ ? enqueue_advance(state, [0, zero, 4, 0]) : _aV_;
   }
   function pp_print_custom_break(state, fits, breaks){
    var
     after = fits[3],
     width = fits[2],
     before = fits[1],
     _aU_ = state[14] < state[15] ? 1 : 0;
    if(! _aU_) return _aU_;
    var
     size = - state[13] | 0,
     token = [1, fits, breaks],
     length =
       (caml_ml_string_length(before) + width | 0)
       + caml_ml_string_length(after)
       | 0,
     elem = [0, size, token, length];
    return scan_push(state, 1, elem);
   }
   function pp_print_break(state, width, offset){
    return pp_print_custom_break
            (state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
   }
   function pp_print_space(state, param){return pp_print_break(state, 1, 0);}
   function pp_print_cut(state, param){return pp_print_break(state, 0, 0);}
   function pp_open_tbox(state, param){
    state[14] = state[14] + 1 | 0;
    var _aT_ = state[14] < state[15] ? 1 : 0;
    if(! _aT_) return _aT_;
    var elem = [0, zero, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem);
   }
   function pp_close_tbox(state, param){
    var _aQ_ = 1 < state[14] ? 1 : 0;
    if(_aQ_){
     var _aR_ = state[14] < state[15] ? 1 : 0;
     if(_aR_){
      var elem = [0, zero, 2, 0];
      enqueue_advance(state, elem);
      state[14] = state[14] - 1 | 0;
      var _aS_ = 0;
     }
     else
      var _aS_ = _aR_;
    }
    else
     var _aS_ = _aQ_;
    return _aS_;
   }
   function pp_print_tbreak(state, width, offset){
    var _aP_ = state[14] < state[15] ? 1 : 0;
    if(! _aP_) return _aP_;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem);
   }
   function pp_print_tab(state, param){return pp_print_tbreak(state, 0, 0);}
   function pp_set_tab(state, param){
    var _aO_ = state[14] < state[15] ? 1 : 0;
    if(! _aO_) return _aO_;
    var elem = [0, zero, 0, 0];
    return enqueue_advance(state, elem);
   }
   function pp_set_max_boxes(state, n){
    var _aM_ = 1 < n ? 1 : 0, _aN_ = _aM_ ? (state[15] = n, 0) : _aM_;
    return _aN_;
   }
   function pp_get_max_boxes(state, param){return state[15];}
   function pp_over_max_boxes(state, param){return state[14] === state[15] ? 1 : 0;
   }
   function pp_set_ellipsis_text(state, s){state[16] = s; return 0;}
   function pp_get_ellipsis_text(state, param){return state[16];}
   function pp_limit(n){return n < 1000000010 ? n : 1000000009;}
   function pp_set_max_indent(state, n$0){
    var _aL_ = 1 < n$0 ? 1 : 0;
    if(! _aL_) return _aL_;
    var n$1 = state[6] - n$0 | 0, _aK_ = 1 <= n$1 ? 1 : 0;
    if(! _aK_) return _aK_;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state);
   }
   function pp_get_max_indent(state, param){return state[8];}
   function pp_set_margin(state, n){
    var _aI_ = 1 <= n ? 1 : 0;
    if(! _aI_) return _aI_;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    if(state[8] <= state[6])
     var new_max_indent = state[8];
    else
     var
      _aJ_ =
        caml_call2(Stdlib_Int[11], state[6] - state[7] | 0, state[6] / 2 | 0),
      new_max_indent = caml_call2(Stdlib_Int[11], _aJ_, 1);
    return pp_set_max_indent(state, new_max_indent);
   }
   function validate_geometry(param){
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent ? margin <= max_indent ? _c_ : _d_ : _e_;
   }
   function check_geometry(geometry){
    return 0 === validate_geometry(geometry)[0] ? 1 : 0;
   }
   function pp_get_margin(state, param){return state[6];}
   function pp_set_full_geometry(state, param){
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0;
   }
   function pp_set_geometry(state, max_indent, margin){
    var
     geometry = [0, max_indent, margin],
     match = validate_geometry(geometry);
    if(0 === match[0]) return pp_set_full_geometry(state, geometry);
    var
     msg = match[1],
     _aH_ = caml_call2(Stdlib[28], cst_Format_pp_set_geometry, msg);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], _aH_], 1);
   }
   function pp_safe_set_geometry(state, max_indent, margin){
    var geometry = [0, max_indent, margin];
    return 0 === validate_geometry(geometry)[0]
            ? pp_set_full_geometry(state, geometry)
            : 0;
   }
   function pp_get_geometry(state, param){return [0, state[8], state[6]];}
   function pp_update_geometry(state, update){
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry));
   }
   function pp_set_formatter_out_functions(state, param){
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0;
   }
   function pp_get_formatter_out_functions(state, param){
    return [0, state[17], state[18], state[19], state[20], state[21]];
   }
   function pp_set_formatter_output_functi(state, f, g){state[17] = f; state[18] = g; return 0;
   }
   function pp_get_formatter_output_functi(state, param){return [0, state[17], state[18]];
   }
   function display_newline(state, param){
    return caml_call3(state[17], cst$7, 0, 1);
   }
   var blank_line = caml_call2(Stdlib_String[1], 80, 32), _f_ = [3, 0, 3];
   function display_blanks(state, n){
    var n$0 = n;
    for(;;){
     var _aG_ = 0 < n$0 ? 1 : 0;
     if(! _aG_) return _aG_;
     if(80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
     caml_call3(state[17], blank_line, 0, 80);
     var n$1 = n$0 - 80 | 0;
     n$0 = n$1;
    }
   }
   function pp_set_formatter_out_channel(state, oc){
    state[17] = caml_call1(Stdlib[69], oc);
    state[18] = function(param){return caml_call1(Stdlib[63], oc);};
    state[19] = function(_aF_){return display_newline(state, _aF_);};
    state[20] = function(_aE_){return display_blanks(state, _aE_);};
    state[21] = function(_aD_){return display_blanks(state, _aD_);};
    return 0;
   }
   function default_pp_mark_open_tag(param){
    if(param[1] !== String_tag) return cst$10;
    var s = param[2], _aC_ = caml_call2(Stdlib[28], s, cst$8);
    return caml_call2(Stdlib[28], cst$9, _aC_);
   }
   function default_pp_mark_close_tag(param){
    if(param[1] !== String_tag) return cst$13;
    var s = param[2], _aB_ = caml_call2(Stdlib[28], s, cst$11);
    return caml_call2(Stdlib[28], cst$12, _aB_);
   }
   function default_pp_print_open_tag(_aA_){return 0;}
   function default_pp_print_close_tag(_az_){return 0;}
   function pp_make_formatter(f, g, h, i, j){
    var
     pp_queue = caml_call1(Stdlib_Queue[2], 0),
     sys_tok = [0, unknown, _f_, 0];
    caml_call2(Stdlib_Queue[3], sys_tok, pp_queue);
    var scan_stack = caml_call1(Stdlib_Stack[2], 0);
    initialize_scan_stack(scan_stack);
    caml_call2(Stdlib_Stack[3], [0, 1, sys_tok], scan_stack);
    var
     pp_margin = 78,
     _av_ = Stdlib[19],
     _aw_ = caml_call1(Stdlib_Stack[2], 0),
     _ax_ = caml_call1(Stdlib_Stack[2], 0),
     _ay_ = caml_call1(Stdlib_Stack[2], 0);
    return [0,
            scan_stack,
            caml_call1(Stdlib_Stack[2], 0),
            _ay_,
            _ax_,
            _aw_,
            pp_margin,
            10,
            68,
            pp_margin,
            0,
            1,
            1,
            1,
            1,
            _av_,
            cst$14,
            f,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function formatter_of_out_functions(out_funs){
    return pp_make_formatter
            (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
   }
   function make_formatter(output, flush){
    var
     ppf =
       pp_make_formatter
        (output,
         flush,
         function(_au_){return 0;},
         function(_at_){return 0;},
         function(_as_){return 0;});
    ppf[19] = function(_ar_){return display_newline(ppf, _ar_);};
    ppf[20] = function(_aq_){return display_blanks(ppf, _aq_);};
    ppf[21] = function(_ap_){return display_blanks(ppf, _ap_);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    return make_formatter
            (caml_call1(Stdlib[69], oc),
             function(param){return caml_call1(Stdlib[63], oc);});
   }
   function formatter_of_buffer(b){
    return make_formatter
            (caml_call1(Stdlib_Buffer[18], b), function(_ao_){return 0;});
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){
    return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
   }
   var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(Stdlib[39]),
    err_formatter = formatter_of_out_channel(Stdlib[40]),
    str_formatter = formatter_of_buffer(stdbuf),
    stdbuf_key = caml_call2(Stdlib_Domain[10][1], 0, pp_make_buffer);
   caml_call2(Stdlib_Domain[10][3], stdbuf_key, stdbuf);
   var
    str_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         return formatter_of_buffer
                 (caml_call1(Stdlib_Domain[10][2], stdbuf_key));
        });
   caml_call2(Stdlib_Domain[10][3], str_formatter_key, str_formatter);
   function buffered_out_string(key, str, ofs, len){
    var _an_ = caml_call1(Stdlib_Domain[10][2], key);
    return caml_call4(Stdlib_Buffer[18], _an_, str, ofs, len);
   }
   function buffered_out_flush(oc, key, param){
    var
     buf = caml_call1(Stdlib_Domain[10][2], key),
     len = caml_call1(Stdlib_Buffer[7], buf),
     str = caml_call1(Stdlib_Buffer[2], buf);
    caml_call4(Stdlib[69], oc, str, 0, len);
    caml_call1(Stdlib[63], oc);
    return caml_call1(Stdlib_Buffer[8], buf);
   }
   var
    std_buf_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}),
    err_buf_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}),
    std_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         var
          _ab_ = Stdlib[39],
          ppf =
            pp_make_formatter
             (function(_ak_, _al_, _am_){
               return buffered_out_string(std_buf_key, _ak_, _al_, _am_);
              },
              function(_aj_){
               return buffered_out_flush(_ab_, std_buf_key, _aj_);
              },
              function(_ai_){return 0;},
              function(_ah_){return 0;},
              function(_ag_){return 0;});
         ppf[19] = function(_af_){return display_newline(ppf, _af_);};
         ppf[20] = function(_ae_){return display_blanks(ppf, _ae_);};
         ppf[21] = function(_ad_){return display_blanks(ppf, _ad_);};
         caml_call1
          (Stdlib_Domain[6],
           function(_ac_){return pp_print_flush(ppf, _ac_);});
         return ppf;
        });
   caml_call2(Stdlib_Domain[10][3], std_formatter_key, std_formatter);
   var
    err_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         var
          _R_ = Stdlib[40],
          ppf =
            pp_make_formatter
             (function(___, _$_, _aa_){
               return buffered_out_string(err_buf_key, ___, _$_, _aa_);
              },
              function(_Z_){return buffered_out_flush(_R_, err_buf_key, _Z_);},
              function(_Y_){return 0;},
              function(_X_){return 0;},
              function(_W_){return 0;});
         ppf[19] = function(_V_){return display_newline(ppf, _V_);};
         ppf[20] = function(_U_){return display_blanks(ppf, _U_);};
         ppf[21] = function(_T_){return display_blanks(ppf, _T_);};
         caml_call1
          (Stdlib_Domain[6], function(_S_){return pp_print_flush(ppf, _S_);});
         return ppf;
        });
   caml_call2(Stdlib_Domain[10][3], err_formatter_key, err_formatter);
   function get_std_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key);
   }
   function get_err_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], err_formatter_key);
   }
   function get_str_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], str_formatter_key);
   }
   function get_stdbuf(param){
    return caml_call1(Stdlib_Domain[10][2], stdbuf_key);
   }
   function flush_buffer_formatter(buf, ppf){
    pp_flush_queue(ppf, 0);
    var s = caml_call1(Stdlib_Buffer[2], buf);
    caml_call1(Stdlib_Buffer[9], buf);
    return s;
   }
   function flush_str_formatter(param){
    var
     stdbuf = caml_call1(Stdlib_Domain[10][2], stdbuf_key),
     str_formatter = caml_call1(Stdlib_Domain[10][2], str_formatter_key);
    return flush_buffer_formatter(stdbuf, str_formatter);
   }
   function make_synchronized_formatter(output, flush){
    return caml_call2
            (Stdlib_Domain[10][1],
             0,
             function(param){
              var
               buf = caml_call1(Stdlib_Buffer[1], pp_buffer_size),
               output$0 = caml_call1(Stdlib_Buffer[18], buf);
              function flush$0(param){
               var _Q_ = caml_call1(Stdlib_Buffer[7], buf);
               caml_call3(output, caml_call1(Stdlib_Buffer[2], buf), 0, _Q_);
               caml_call1(Stdlib_Buffer[8], buf);
               return caml_call1(flush, 0);
              }
              return make_formatter(output$0, flush$0);
             });
   }
   function synchronized_formatter_of_out_(oc){
    return make_synchronized_formatter
            (caml_call1(Stdlib[69], oc),
             function(param){return caml_call1(Stdlib[63], oc);});
   }
   function make_symbolic_output_buffer(param){return [0, 0];}
   function clear_symbolic_output_buffer(sob){sob[1] = 0; return 0;}
   function get_symbolic_output_buffer(sob){
    return caml_call1(Stdlib_List[10], sob[1]);
   }
   function flush_symbolic_output_buffer(sob){
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items;
   }
   function add_symbolic_output_item(sob, item){sob[1] = [0, item, sob[1]]; return 0;
   }
   function formatter_of_symbolic_output_b(sob){
    function f(s, i, n){
     return add_symbolic_output_item
             (sob, [0, caml_call3(Stdlib_String[16], s, i, n)]);
    }
    function g(_P_){return add_symbolic_output_item(sob, 0);}
    function h(_O_){return add_symbolic_output_item(sob, 1);}
    function i(n){return add_symbolic_output_item(sob, [1, n]);}
    function j(n){return add_symbolic_output_item(sob, [2, n]);}
    return pp_make_formatter(f, g, h, i, j);
   }
   function open_hbox(v){
    return pp_open_hbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_vbox(v){
    return pp_open_vbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hvbox(v){
    return pp_open_hvbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hovbox(v){
    return pp_open_hovbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_box(v){
    return pp_open_box(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_box(v){
    return pp_close_box
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_stag(v){
    return pp_open_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_stag(v){
    return pp_close_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_as(isize, w){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return pp_print_as_size(state, isize, w);
   }
   function print_string(v){
    return pp_print_string
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bytes(v){
    return pp_print_bytes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_int(v){
    return pp_print_int
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_float(v){
    return pp_print_float
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_char(v){
    return pp_print_char
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bool(v){
    return pp_print_bool
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_break(v, w){
    return pp_print_break
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function print_cut(v){
    return pp_print_cut
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_space(v){
    return pp_print_space
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function force_newline(v){
    return pp_force_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_flush(v){
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_newline(v){
    return pp_print_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_if_newline(v){
    return pp_print_if_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_tbox(v){
    return pp_open_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_tbox(v){
    return pp_close_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tbreak(v, w){
    return pp_print_tbreak
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function set_tab(v){
    return pp_set_tab(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tab(v){
    return pp_print_tab
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_margin(v){
    return pp_set_margin
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_margin(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[6];
   }
   function set_max_indent(v){
    return pp_set_max_indent
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_indent(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[8];
   }
   function set_geometry(max_indent, margin){
    return pp_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function safe_set_geometry(max_indent, margin){
    return pp_safe_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function get_geometry(v){
    return pp_get_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function update_geometry(v){
    return pp_update_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_max_boxes(v){
    return pp_set_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_boxes(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[15];
   }
   function over_max_boxes(v){
    return pp_over_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_ellipsis_text(v){
    return pp_set_ellipsis_text
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_ellipsis_text(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[16];
   }
   function set_formatter_out_channel(v){
    return pp_set_formatter_out_channel
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_out_functions(v){
    return pp_set_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_out_functions(v){
    return pp_get_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_output_functions(v, w){
    return pp_set_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function get_formatter_output_functions(v){
    return pp_get_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_stag_functions(v){
    return pp_set_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_stag_functions(v){
    return pp_get_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_print_tags(v){
    return pp_set_print_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_print_tags(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[22];
   }
   function set_mark_tags(v){
    return pp_set_mark_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_mark_tags(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[23];
   }
   function set_tags(v){
    return pp_set_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function pp_print_iter(opt, iter, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    var is_first = [0, 1];
    function pp_v$0(v){
     if(is_first[1]) is_first[1] = 0; else caml_call2(pp_sep, ppf, 0);
     return caml_call2(pp_v, ppf, v);
    }
    return caml_call2(iter, pp_v$0, v);
   }
   function pp_print_list(opt, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_List[18], pp_v, ppf, v);
   }
   function pp_print_array(opt, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Array[11], pp_v, ppf, v);
   }
   function pp_print_seq(opt, pp_v, ppf, seq){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Seq[4], pp_v, ppf, seq);
   }
   function pp_print_text(ppf, s){
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param){
     pp_print_string
      (ppf, caml_call3(Stdlib_String[16], s, left[1], right[1] - left[1] | 0));
     right[1]++;
     left[1] = right[1];
     return 0;
    }
    for(;;){
     if(right[1] === len){
      var _N_ = left[1] !== len ? 1 : 0;
      return _N_ ? flush(0) : _N_;
     }
     var match = runtime.caml_string_get(s, right[1]);
     if(10 === match){
      flush(0);
      pp_force_newline(ppf, 0);
     }
     else if(32 === match){flush(0); pp_print_space(ppf, 0);} else right[1]++;
    }
   }
   function pp_print_option(opt, pp_v, ppf, param){
    if(opt)
     var sth = opt[1], none = sth;
    else
     var none = function(param, _M_){return 0;};
    if(! param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v);
   }
   function pp_print_result(ok, error, ppf, param){
    if(0 === param[0]){var v = param[1]; return caml_call2(ok, ppf, v);}
    var e = param[1];
    return caml_call2(error, ppf, e);
   }
   function pp_print_either(left, right, ppf, param){
    if(0 === param[0]){var l = param[1]; return caml_call2(left, ppf, l);}
    var r = param[1];
    return caml_call2(right, ppf, r);
   }
   function compute_tag(output, tag_acc){
    var
     buf = caml_call1(Stdlib_Buffer[1], 16),
     ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = caml_call1(Stdlib_Buffer[7], buf);
    return 2 <= len
            ? caml_call3(Stdlib_Buffer[4], buf, 1, len - 2 | 0)
            : caml_call1(Stdlib_Buffer[2], buf);
   }
   function output_formatting_lit(ppf, fmting_lit){
    if(typeof fmting_lit === "number")
     switch(fmting_lit){
       case 0:
        return pp_close_box(ppf, 0);
       case 1:
        return pp_close_stag(ppf, 0);
       case 2:
        return pp_print_flush(ppf, 0);
       case 3:
        return pp_force_newline(ppf, 0);
       case 4:
        return pp_print_newline(ppf, 0);
       case 5:
        return pp_print_char(ppf, 64);
       default: return pp_print_char(ppf, 37);
     }
    switch(fmting_lit[0]){
      case 0:
       var offset = fmting_lit[3], width = fmting_lit[2];
       return pp_print_break(ppf, width, offset);
      case 1:
       return 0;
      default:
       var c = fmting_lit[1];
       pp_print_char(ppf, 64);
       return pp_print_char(ppf, c);
    }
   }
   function output_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          output_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           output_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
          }
          var acc$1 = match[1];
          output_acc(ppf, p$0);
          var
           _D_ = compute_tag(output_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _D_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _E_ = acc[1];
          if(typeof _E_ !== "number" && 0 === _E_[0]){
           var _F_ = _E_[2];
           if(typeof _F_ !== "number" && 1 === _F_[0]){
            var s$0 = acc[2], size = _F_[2], p$2 = _E_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _E_;
          break a;
         case 3:
          var _G_ = acc[1];
          if(typeof _G_ !== "number" && 0 === _G_[0]){
           var _H_ = _G_[2];
           if(typeof _H_ !== "number" && 1 === _H_[0]){
            var c$0 = acc[2], size$0 = _H_[2], p$4 = _G_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _G_;
          break c;
         case 4:
          var _I_ = acc[1];
          if(typeof _I_ !== "number" && 0 === _I_[0]){
           var _J_ = _I_[2];
           if(typeof _J_ !== "number" && 1 === _J_[0]){
            var s$0 = acc[2], size = _J_[2], p$2 = _I_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _I_;
          break a;
         case 5:
          var _K_ = acc[1];
          if(typeof _K_ !== "number" && 0 === _K_[0]){
           var _L_ = _K_[2];
           if(typeof _L_ !== "number" && 1 === _L_[0]){
            var c$0 = acc[2], size$0 = _L_[2], p$4 = _K_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _K_;
          break c;
         case 6:
          var f$0 = acc[2], p$5 = acc[1];
          output_acc(ppf, p$5);
          return caml_call1(f$0, ppf);
         case 7:
          var p$6 = acc[1];
          output_acc(ppf, p$6);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$7 = acc[1];
          output_acc(ppf, p$7);
          return caml_call1(Stdlib[1], msg);
       }
       output_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      output_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     output_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    output_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function strput_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          strput_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           strput_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
          }
          var acc$1 = match[1];
          strput_acc(ppf, p$0);
          var
           _u_ = compute_tag(strput_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _u_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _v_ = acc[1];
          if(typeof _v_ !== "number" && 0 === _v_[0]){
           var _w_ = _v_[2];
           if(typeof _w_ !== "number" && 1 === _w_[0]){
            var s$0 = acc[2], size = _w_[2], p$2 = _v_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _v_;
          break a;
         case 3:
          var _x_ = acc[1];
          if(typeof _x_ !== "number" && 0 === _x_[0]){
           var _y_ = _x_[2];
           if(typeof _y_ !== "number" && 1 === _y_[0]){
            var c$0 = acc[2], size$0 = _y_[2], p$4 = _x_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _x_;
          break c;
         case 4:
          var _z_ = acc[1];
          if(typeof _z_ !== "number" && 0 === _z_[0]){
           var _A_ = _z_[2];
           if(typeof _A_ !== "number" && 1 === _A_[0]){
            var s$0 = acc[2], size = _A_[2], p$2 = _z_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _z_;
          break a;
         case 5:
          var _B_ = acc[1];
          if(typeof _B_ !== "number" && 0 === _B_[0]){
           var _C_ = _B_[2];
           if(typeof _C_ !== "number" && 1 === _C_[0]){
            var c$0 = acc[2], size$0 = _C_[2], p$4 = _B_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _B_;
          break c;
         case 6:
          var p$5 = acc[1];
          if(typeof p$5 !== "number" && 0 === p$5[0]){
           var match$1 = p$5[2];
           if(typeof match$1 !== "number" && 1 === match$1[0]){
            var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
            strput_acc(ppf, p$6);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
           }
          }
          var f$0 = acc[2];
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, caml_call1(f$0, 0));
         case 7:
          var p$7 = acc[1];
          strput_acc(ppf, p$7);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$8 = acc[1];
          strput_acc(ppf, p$8);
          return caml_call1(Stdlib[1], msg);
       }
       strput_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      strput_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     strput_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    strput_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function kfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){output_acc(ppf, acc); return caml_call1(k, ppf);},
             0,
             fmt);
   }
   function ikfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, ppf, fmt);
   }
   function ifprintf(ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], function(_t_){return 0;}, 0, fmt);
   }
   function fprintf(ppf){
    function _q_(_s_){return 0;}
    return function(_r_){return kfprintf(_q_, ppf, _r_);};
   }
   function printf(param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return output_acc
                      (caml_call1(Stdlib_Domain[10][2], std_formatter_key), acc);
             },
             0,
             fmt);
   }
   function eprintf(param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return output_acc
                      (caml_call1(Stdlib_Domain[10][2], err_formatter_key), acc);
             },
             0,
             fmt);
   }
   function kdprintf(k, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return caml_call1
                      (k, function(ppf){return output_acc(ppf, acc);});
             },
             0,
             fmt);
   }
   function dprintf(fmt){return kdprintf(function(i){return i;}, fmt);}
   function ksprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     strput_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(id, fmt);}
   function kasprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     output_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function asprintf(fmt){return kasprintf(id, fmt);}
   function flush_standard_formatters(param){
    pp_print_flush(caml_call1(Stdlib_Domain[10][2], std_formatter_key), 0);
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], err_formatter_key), 0);
   }
   caml_call1(Stdlib[100], flush_standard_formatters);
   caml_call1
    (Stdlib_Domain[5],
     function(param){
      flush_standard_formatters(0);
      var
       fs = pp_get_formatter_out_functions(std_formatter, 0),
       _g_ = Stdlib[39];
      pp_set_formatter_out_functions
       (std_formatter,
        [0,
         function(_n_, _o_, _p_){
          return buffered_out_string(std_buf_key, _n_, _o_, _p_);
         },
         function(_m_){return buffered_out_flush(_g_, std_buf_key, _m_);},
         fs[3],
         fs[4],
         fs[5]]);
      var
       fs$0 = pp_get_formatter_out_functions(err_formatter, 0),
       _h_ = Stdlib[40];
      return pp_set_formatter_out_functions
              (err_formatter,
               [0,
                function(_j_, _k_, _l_){
                 return buffered_out_string(err_buf_key, _j_, _k_, _l_);
                },
                function(_i_){
                 return buffered_out_flush(_h_, err_buf_key, _i_);
                },
                fs$0[3],
                fs$0[4],
                fs$0[5]]);
     });
   var
    Stdlib_Format =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       synchronized_formatter_of_out_,
       std_formatter,
       get_std_formatter,
       err_formatter,
       get_err_formatter,
       formatter_of_buffer,
       stdbuf,
       get_stdbuf,
       str_formatter,
       get_str_formatter,
       flush_str_formatter,
       make_formatter,
       make_synchronized_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_iter,
       pp_print_list,
       pp_print_array,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf];
   runtime.caml_register_global(37, Stdlib_Format, "Stdlib__Format");
   return;
  }
  (globalThis));

//# 23320 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[10],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# 23343 "../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalOO_ml = "camlinternalOO.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_block = runtime.caml_obj_block,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_string_compare = runtime.caml_string_compare,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map;
   function copy(o){var o$0 = o.slice(); return caml_set_oo_id(o$0);}
   var params = [0, 1, 1, 1, 3, 16];
   function public_method_label(s){
    var
     accu = [0, 0],
     _al_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      var _am_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _am_ | 0;
      var _an_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _an_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag;
   }
   var
    compare = caml_string_compare,
    Vars = caml_call1(Stdlib_Map[1], [0, compare]),
    compare$0 = caml_string_compare,
    Meths = caml_call1(Stdlib_Map[1], [0, compare$0]),
    compare$1 = runtime.caml_int_compare,
    Labs = caml_call1(Stdlib_Map[1], [0, compare$1]),
    dummy_table = [0, 0, [0, 0], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0),
    initial_object_size = 2;
   function fit_size(n){
    return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
   }
   function new_table(pub_labels){
    table_count[1]++;
    var
     len = pub_labels.length - 1,
     methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var
     _ad_ = Stdlib_Sys[9],
     _ae_ = (runtime.caml_mul(fit_size(len), _ad_) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = _ae_;
    var _ag_ = len - 1 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      var
       _ai_ = (i * 2 | 0) + 3 | 0,
       _ah_ = caml_check_bound(pub_labels, i)[1 + i];
      caml_check_bound(methods, _ai_)[1 + _ai_] = _ah_;
      var _aj_ = i + 1 | 0;
      if(_ag_ === i) break;
      i = _aj_;
     }
    }
    return [0,
            initial_object_size,
            methods,
            Meths[1],
            Labs[1],
            0,
            0,
            Vars[1],
            0];
   }
   function resize(array, new_size){
    var old_size = array[2].length - 1, _ab_ = old_size < new_size ? 1 : 0;
    if(_ab_){
     var new_buck = caml_make_vect(new_size, dummy_met);
     caml_call5(Stdlib_Array[8], array[2], 0, new_buck, 0, old_size);
     array[2] = new_buck;
     var _ac_ = 0;
    }
    else
     var _ac_ = _ab_;
    return _ac_;
   }
   var
    method_count = [0, 0],
    inst_var_count = [0, 0],
    _a_ = [0, cst_camlinternalOO_ml, 279, 50],
    _b_ = [0, cst_camlinternalOO_ml, 407, 13],
    _c_ = [0, cst_camlinternalOO_ml, 410, 13],
    _d_ = [0, cst_camlinternalOO_ml, 413, 13],
    _e_ = [0, cst_camlinternalOO_ml, 416, 13],
    _f_ = [0, cst_camlinternalOO_ml, 419, 13],
    _g_ = [0, cst_camlinternalOO_ml, 437, 17];
   function new_method(table){
    var index = table[2].length - 1;
    resize(table, index + 1 | 0);
    return index;
   }
   function get_method_label(table, name){
    try{var _$_ = caml_call2(Meths[17], name, table[3]); return _$_;}
    catch(_aa_){
     var ___ = caml_wrap_exception(_aa_);
     if(___ !== Stdlib[8]) throw caml_maybe_attach_backtrace(___, 0);
     var label = new_method(table);
     table[3] = caml_call3(Meths[2], name, label, table[3]);
     table[4] = caml_call3(Labs[2], label, 1, table[4]);
     return label;
    }
   }
   function get_method_labels(table, names){
    return caml_call2
            (Stdlib_Array[13],
             function(_Z_){return get_method_label(table, _Z_);},
             names);
   }
   function set_method(table, label, element){
    method_count[1]++;
    return caml_call2(Labs[17], label, table[4])
            ? (resize
               (table, label + 1 | 0),
              caml_check_bound(table[2], label)[1 + label] = element,
              0)
            : (table[6] = [0, [0, label, element], table[6]], 0);
   }
   function get_method(table, label){
    try{var _X_ = caml_call2(Stdlib_List[49], label, table[6]); return _X_;}
    catch(_Y_){
     var _W_ = caml_wrap_exception(_Y_);
     if(_W_ === Stdlib[8])
      return caml_check_bound(table[2], label)[1 + label];
     throw caml_maybe_attach_backtrace(_W_, 0);
    }
   }
   function to_list(arr){
    return 0 === arr ? 0 : caml_call1(Stdlib_Array[9], arr);
   }
   function narrow(table, vars, virt_meths, concr_meths){
    var
     vars$0 = to_list(vars),
     virt_meths$0 = to_list(virt_meths),
     concr_meths$0 = to_list(concr_meths),
     virt_meth_labs =
       caml_call2
        (Stdlib_List[20],
         function(_V_){return get_method_label(table, _V_);},
         virt_meths$0),
     concr_meth_labs =
       caml_call2
        (Stdlib_List[20],
         function(_U_){return get_method_label(table, _U_);},
         concr_meths$0);
    table[5] =
     [0,
      [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
      table[5]];
    table[7] =
     caml_call3
      (Vars[24],
       function(lab, info, tvars){
        return caml_call2(Stdlib_List[37], lab, vars$0)
                ? caml_call3(Vars[2], lab, info, tvars)
                : tvars;
       },
       table[7],
       Vars[1]);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    caml_call3
     (Stdlib_List[28],
      function(met, label){
       by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
       var _P_ = by_label[1];
       try{var _S_ = caml_call2(Labs[17], label, table[4]), _R_ = _S_;}
       catch(_T_){
        var _Q_ = caml_wrap_exception(_T_);
        if(_Q_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Q_, 0);
        var _R_ = 1;
       }
       by_label[1] = caml_call3(Labs[2], label, _R_, _P_);
       return 0;
      },
      concr_meths$0,
      concr_meth_labs);
    caml_call3
     (Stdlib_List[28],
      function(met, label){
       by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
       by_label[1] = caml_call3(Labs[2], label, 0, by_label[1]);
       return 0;
      },
      virt_meths$0,
      virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    table[6] =
     caml_call3
      (Stdlib_List[27],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[37], lab, virt_meth_labs)
                ? hm
                : [0, met, hm];
       },
       table[6],
       0);
    return 0;
   }
   function widen(table){
    var
     match = caml_call1(Stdlib_List[6], table[5]),
     vars = match[6],
     virt_meths = match[5],
     saved_vars = match[4],
     saved_hidden_meths = match[3],
     by_label = match[2],
     by_name = match[1];
    table[5] = caml_call1(Stdlib_List[7], table[5]);
    table[7] =
     caml_call3
      (Stdlib_List[26],
       function(s, v){
        var _O_ = caml_call2(Vars[17], v, table[7]);
        return caml_call3(Vars[2], v, _O_, s);
       },
       saved_vars,
       vars);
    table[3] = by_name;
    table[4] = by_label;
    table[6] =
     caml_call3
      (Stdlib_List[27],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[37], lab, virt_meths)
                ? hm
                : [0, met, hm];
       },
       table[6],
       saved_hidden_meths);
    return 0;
   }
   function new_variable(table, name){
    try{var _M_ = caml_call2(Vars[17], name, table[7]); return _M_;}
    catch(_N_){
     var _L_ = caml_wrap_exception(_N_);
     if(_L_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_L_, 0);
     var index = table[1];
     table[1] = index + 1 | 0;
     if(name !== "") table[7] = caml_call3(Vars[2], name, index, table[7]);
     return index;
    }
   }
   function to_array(arr){return runtime.caml_equal(arr, 0) ? [0] : arr;}
   function new_methods_variables(table, meths, vals){
    var
     meths$0 = to_array(meths),
     nmeths = meths$0.length - 1,
     nvals = vals.length - 1,
     res = caml_make_vect(nmeths + nvals | 0, 0),
     _D_ = nmeths - 1 | 0,
     _C_ = 0;
    if(_D_ >= 0){
     var i$0 = _C_;
     for(;;){
      var
       _J_ = get_method_label(table, caml_check_bound(meths$0, i$0)[1 + i$0]);
      caml_check_bound(res, i$0)[1 + i$0] = _J_;
      var _K_ = i$0 + 1 | 0;
      if(_D_ === i$0) break;
      i$0 = _K_;
     }
    }
    var _F_ = nvals - 1 | 0, _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      var
       _H_ = i + nmeths | 0,
       _G_ = new_variable(table, caml_check_bound(vals, i)[1 + i]);
      caml_check_bound(res, _H_)[1 + _H_] = _G_;
      var _I_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _I_;
     }
    }
    return res;
   }
   function get_variable(table, name){
    try{var _A_ = caml_call2(Vars[17], name, table[7]); return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_ === Stdlib[8])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function get_variables(table, names){
    return caml_call2
            (Stdlib_Array[13],
             function(_y_){return get_variable(table, _y_);},
             names);
   }
   function add_initializer(table, f){table[8] = [0, f, table[8]]; return 0;}
   function create_table(public_methods){
    if(0 === public_methods) return new_table([0]);
    var
     tags = caml_call2(Stdlib_Array[13], public_method_label, public_methods),
     table = new_table(tags);
    caml_call2
     (Stdlib_Array[12],
      function(i, met){
       var lab = (i * 2 | 0) + 2 | 0;
       table[3] = caml_call3(Meths[2], met, lab, table[3]);
       table[4] = caml_call3(Labs[2], lab, 1, table[4]);
       return 0;
      },
      public_methods);
    return table;
   }
   function init_class(table){
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = caml_call1(Stdlib_List[10], table[8]);
    var _x_ = Stdlib_Sys[9];
    return resize
            (table,
             3 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _x_) | 0);
   }
   function inherits(cla, vals, virt_meths, concr_meths, param, top){
    var env = param[4], super$0 = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
    widen(cla);
    var
     _s_ = to_array(concr_meths),
     _t_ =
       [0,
        caml_call2
         (Stdlib_Array[13],
          function(nm){return get_method(cla, get_method_label(cla, nm));},
          _s_),
        0],
     _u_ = to_array(vals),
     _v_ =
       [0,
        [0, init],
        [0,
         caml_call2
          (Stdlib_Array[13],
           function(_w_){return get_variable(cla, _w_);},
           _u_),
         _t_]];
    return caml_call1(Stdlib_Array[4], _v_);
   }
   function make_class(pub_meths, class_init){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0];
   }
   function make_class_store(pub_meths, class_init, init_table){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0;
   }
   function dummy_class(loc){
    function undef(param){
     throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
    }
    return [0, undef, undef, undef, 0];
   }
   function create_object(table){
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function create_object_opt(obj_0, table){
    if(obj_0) return obj_0;
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function iter_f(obj, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], f = param$0[1];
     caml_call1(f, obj);
     param$0 = l;
    }
   }
   function run_initializers(obj, table){
    var inits = table[8], _r_ = 0 !== inits ? 1 : 0;
    return _r_ ? iter_f(obj, inits) : _r_;
   }
   function run_initializers_opt(obj_0, obj, table){
    if(obj_0) return obj;
    var inits = table[8];
    if(0 !== inits) iter_f(obj, inits);
    return obj;
   }
   function create_object_and_run_initiali(obj_0, table){
    if(obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
   }
   function get_data(param){
    if(param) return param[2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function build_path(n, keys, tables){
    var res = [0, 0, 0, 0], r = [0, res], _o_ = 0;
    if(n >= 0){
     var i = _o_;
     for(;;){
      var _p_ = r[1];
      r[1] = [0, caml_check_bound(keys, i)[1 + i], _p_, 0];
      var _q_ = i + 1 | 0;
      if(n === i) break;
      i = _q_;
     }
    }
    var v = r[1];
    if(! tables)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    tables[2] = v;
    return res;
   }
   function lookup_tables(root, keys){
    var root_data = get_data(root);
    if(! root_data) return build_path(keys.length - 2 | 0, keys, root);
    var i$1 = keys.length - 2 | 0, i = i$1, tables$0 = root_data;
    for(;;){
     if(0 > i) return tables$0;
     var key = caml_check_bound(keys, i)[1 + i], tables$1 = tables$0;
     for(;;){
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      if(tables$1[1] === key) break;
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      var tables = tables$1[3];
      if(! tables){
       var next = [0, key, 0, 0];
       if(! tables$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       tables$1[3] = next;
       return build_path(i - 1 | 0, keys, next);
      }
      tables$1 = tables;
     }
     var tables_data = get_data(tables$1);
     if(! tables_data)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     var i$0 = i - 1 | 0;
     i = i$0;
     tables$0 = tables_data;
    }
   }
   function new_cache(table){
    var n = new_method(table);
    a:
    {
     if(0 !== (n % 2 | 0)){
      var _n_ = Stdlib_Sys[9];
      if
       ((2 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _n_) | 0)
        >= n){
       var n$0 = new_method(table);
       break a;
      }
     }
     var n$0 = n;
    }
    caml_check_bound(table[2], n$0)[1 + n$0] = 0;
    return n$0;
   }
   function set_methods(table, methods){
    var len = methods.length - 1, i = [0, 0];
    for(;;){
     if(i[1] >= len) return 0;
     var
      _h_ = i[1],
      label = caml_check_bound(methods, _h_)[1 + _h_],
      next =
        function(param){
         i[1]++;
         var _m_ = i[1];
         return caml_check_bound(methods, _m_)[1 + _m_];
        },
      clo = next(0);
     if(typeof clo === "number")
      switch(clo){
        case 0:
         var x = next(0);
         let x$20 = x;
         var clo$0 = function(obj){return x$20;};
         break;
        case 1:
         var n = next(0);
         let n$38 = n;
         var clo$0 = function(obj){return obj[1 + n$38];};
         break;
        case 2:
         var e = next(0), n$0 = next(0);
         let e$10 = e, n$37 = n$0;
         var clo$0 = function(obj){return obj[1 + e$10][1 + n$37];};
         break;
        case 3:
         var n$1 = next(0);
         let n$36 = n$1;
         var clo$0 = function(obj){return caml_call1(obj[1][1 + n$36], obj);};
         break;
        case 4:
         var n$2 = next(0);
         let n$35 = n$2;
         var clo$0 = function(obj, x){obj[1 + n$35] = x; return 0;};
         break;
        case 5:
         var f = next(0), x$0 = next(0);
         let f$20 = f, x$19 = x$0;
         var clo$0 = function(obj){return caml_call1(f$20, x$19);};
         break;
        case 6:
         var f$0 = next(0), n$3 = next(0);
         let f$19 = f$0, n$34 = n$3;
         var clo$0 = function(obj){return caml_call1(f$19, obj[1 + n$34]);};
         break;
        case 7:
         var f$1 = next(0), e$0 = next(0), n$4 = next(0);
         let f$18 = f$1, e$9 = e$0, n$33 = n$4;
         var
          clo$0 =
            function(obj){return caml_call1(f$18, obj[1 + e$9][1 + n$33]);};
         break;
        case 8:
         var f$2 = next(0), n$5 = next(0);
         let f$17 = f$2, n$32 = n$5;
         var
          clo$0 =
            function(obj){
             return caml_call1(f$17, caml_call1(obj[1][1 + n$32], obj));
            };
         break;
        case 9:
         var f$3 = next(0), x$1 = next(0), y = next(0);
         let f$16 = f$3, x$18 = x$1, y$0 = y;
         var clo$0 = function(obj){return caml_call2(f$16, x$18, y$0);};
         break;
        case 10:
         var f$4 = next(0), x$2 = next(0), n$6 = next(0);
         let f$15 = f$4, x$17 = x$2, n$31 = n$6;
         var
          clo$0 = function(obj){return caml_call2(f$15, x$17, obj[1 + n$31]);};
         break;
        case 11:
         var f$5 = next(0), x$3 = next(0), e$1 = next(0), n$7 = next(0);
         let f$14 = f$5, x$16 = x$3, e$8 = e$1, n$30 = n$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$14, x$16, obj[1 + e$8][1 + n$30]);
            };
         break;
        case 12:
         var f$6 = next(0), x$4 = next(0), n$8 = next(0);
         let f$13 = f$6, x$15 = x$4, n$29 = n$8;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$13, x$15, caml_call1(obj[1][1 + n$29], obj));
            };
         break;
        case 13:
         var f$7 = next(0), n$9 = next(0), x$5 = next(0);
         let f$12 = f$7, n$28 = n$9, x$14 = x$5;
         var
          clo$0 = function(obj){return caml_call2(f$12, obj[1 + n$28], x$14);};
         break;
        case 14:
         var f$8 = next(0), e$2 = next(0), n$10 = next(0), x$6 = next(0);
         let f$11 = f$8, e$7 = e$2, n$27 = n$10, x$13 = x$6;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$11, obj[1 + e$7][1 + n$27], x$13);
            };
         break;
        case 15:
         var f$9 = next(0), n$11 = next(0), x$7 = next(0);
         let f$10 = f$9, n$26 = n$11, x$12 = x$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$10, caml_call1(obj[1][1 + n$26], obj), x$12);
            };
         break;
        case 16:
         var n$12 = next(0), x$8 = next(0);
         let n$25 = n$12, x$11 = x$8;
         var
          clo$0 =
            function(obj){return caml_call2(obj[1][1 + n$25], obj, x$11);};
         break;
        case 17:
         var n$13 = next(0), m = next(0);
         let n$24 = n$13, m$12 = m;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$24], obj, obj[1 + m$12]);
            };
         break;
        case 18:
         var n$14 = next(0), e$3 = next(0), m$0 = next(0);
         let n$23 = n$14, e$6 = e$3, m$11 = m$0;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$23], obj, obj[1 + e$6][1 + m$11]);
            };
         break;
        case 19:
         var n$15 = next(0), m$1 = next(0);
         let n$22 = n$15, m$10 = m$1;
         var
          clo$0 =
            function(obj){
             var _l_ = caml_call1(obj[1][1 + m$10], obj);
             return caml_call2(obj[1][1 + n$22], obj, _l_);
            };
         break;
        case 20:
         var m$2 = next(0), x$9 = next(0);
         new_cache(table);
         let m$9 = m$2, x$10 = x$9;
         var
          clo$0 =
            function(obj){
             return caml_call1(caml_get_public_method(x$10, m$9, 0), x$10);
            };
         break;
        case 21:
         var m$3 = next(0), n$16 = next(0);
         new_cache(table);
         let m$8 = m$3, n$21 = n$16;
         var
          clo$0 =
            function(obj){
             var _k_ = obj[1 + n$21];
             return caml_call1(caml_get_public_method(_k_, m$8, 0), _k_);
            };
         break;
        case 22:
         var m$4 = next(0), e$4 = next(0), n$17 = next(0);
         new_cache(table);
         let m$7 = m$4, e$5 = e$4, n$20 = n$17;
         var
          clo$0 =
            function(obj){
             var _j_ = obj[1 + e$5][1 + n$20];
             return caml_call1(caml_get_public_method(_j_, m$7, 0), _j_);
            };
         break;
        default:
         var m$5 = next(0), n$18 = next(0);
         new_cache(table);
         let m$6 = m$5, n$19 = n$18;
         var
          clo$0 =
            function(obj){
             var _i_ = caml_call1(obj[1][1 + n$19], obj);
             return caml_call1(caml_get_public_method(_i_, m$6, 0), _i_);
            };
      }
     else
      var clo$0 = clo;
     set_method(table, label, clo$0);
     i[1]++;
    }
   }
   function stats(param){
    return [0, table_count[1], method_count[1], inst_var_count[1]];
   }
   var
    CamlinternalOO =
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params,
       stats];
   runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
   return;
  }
  (globalThis));

//# 5 "../.js/default/bitv/bitv.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bitv_bw_or$1 = "Bitv.bw_or",
    cst_Bitv_of_list$1 = "Bitv.of_list",
    cst_Bitv_of_list_with_length$1 = "Bitv.of_list_with_length",
    cst_bitv_ml = "bitv.ml",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_mod = runtime.caml_mod,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array;
   function set_byte(s, i, x){caml_bytes_unsafe_set(s, i, x); return 0;}
   function length(v){return v[1];}
   var
    equal = runtime.caml_equal,
    n = Stdlib_Sys[12] * 8 | 0,
    _a_ = [0, cst_bitv_ml, 202, 2],
    _j_ = [0, cst_bitv_ml, 610, 9],
    _i_ = [0, cst_bitv_ml, 604, 9],
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(255, 0, 0),
    _c_ = [0, cst_bitv_ml, 503, 2],
    cst_Bitv_tanimoto = "Bitv.tanimoto",
    cst_Bitv_of_string = "Bitv.of_string",
    cst_Bitv_sub = "Bitv.sub",
    cst_Bitv_blit = "Bitv.blit",
    cst_Bitv_of_list_with_length$0 = cst_Bitv_of_list_with_length$1,
    cst_Bitv_of_list_with_length = cst_Bitv_of_list_with_length$1,
    cst_Bitv_of_list$0 = cst_Bitv_of_list$1,
    cst_Bitv_of_list = cst_Bitv_of_list$1,
    cst_Bitv_bw_or$0 = cst_Bitv_bw_or$1,
    cst_Bitv_bw_or = cst_Bitv_bw_or$1,
    cst_Bitv_bw_and = "Bitv.bw_and",
    cst_Bitv_fill = "Bitv.fill",
    cst_Bitv_set = "Bitv.set",
    cst_Bitv_get = "Bitv.get",
    cst_Bitv_create = "Bitv.create",
    max_length = 0 <= n ? n : Stdlib[19];
   function exceeds_max_length(n){
    var
     s = n / 8 | 0,
     _bF_ = Stdlib_Sys[12],
     s$0 = 0 === (n % 8 | 0) ? s : s + 1 | 0;
    return _bF_ < s$0 ? 1 : 0;
   }
   var
    low_mask =
      caml_call2(Stdlib_Array[1], 9, function(i){return (1 << i) - 1 | 0;});
   function create(n, b){
    var _bB_ = n < 0 ? 1 : 0, _bC_ = _bB_ || (max_length < n ? 1 : 0);
    if(_bC_) caml_call1(Stdlib[1], cst_Bitv_create);
    var initv = b ? 255 : 0, q = n >>> 3 | 0, r = n & 7;
    if(0 === r){
     var _bD_ = caml_call1(Stdlib_Char[1], initv);
     return [0, n, caml_call2(Stdlib_Bytes[1], q, _bD_)];
    }
    var
     _bE_ = caml_call1(Stdlib_Char[1], initv),
     s = caml_call2(Stdlib_Bytes[1], q + 1 | 0, _bE_);
    set_byte(s, q, initv & caml_check_bound(low_mask, r)[1 + r]);
    return [0, n, s];
   }
   function copy(v){
    var _bA_ = caml_call1(Stdlib_Bytes[4], v[2]);
    return [0, v[1], _bA_];
   }
   function unsafe_get(v, n){
    var i = n >>> 3 | 0, s = v[2];
    return 0 < (caml_bytes_unsafe_get(s, i) & 1 << (n & 7)) ? 1 : 0;
   }
   function get(v, n){
    var _by_ = n < 0 ? 1 : 0, _bz_ = _by_ || (v[1] <= n ? 1 : 0);
    if(_bz_) caml_call1(Stdlib[1], cst_Bitv_get);
    return unsafe_get(v, n);
   }
   function unsafe_set(v, n, b){
    var
     i = n >>> 3 | 0,
     s = v[2],
     c = caml_bytes_unsafe_get(s, i),
     mask = 1 << (n & 7),
     _bx_ = b ? c | mask : c & caml_call1(Stdlib[21], mask);
    return set_byte(v[2], i, _bx_);
   }
   function set(v, n, b){
    var _bv_ = n < 0 ? 1 : 0, _bw_ = _bv_ || (v[1] <= n ? 1 : 0);
    if(_bw_) caml_call1(Stdlib[1], cst_Bitv_set);
    return unsafe_set(v, n, b);
   }
   function init(n, f){
    var v = create(n, 0), _bt_ = n - 1 | 0, _bs_ = 0;
    if(_bt_ >= 0){
     var i = _bs_;
     for(;;){
      unsafe_set(v, i, caml_call1(f, i));
      var _bu_ = i + 1 | 0;
      if(_bt_ === i) break;
      i = _bu_;
     }
    }
    return v;
   }
   function fill(v, ofs, len, b){
    var _bd_ = ofs < 0 ? 1 : 0;
    if(_bd_)
     var _be_ = _bd_;
    else
     var
      _br_ = len < 0 ? 1 : 0,
      _be_ = _br_ || ((v[1] - len | 0) < ofs ? 1 : 0);
    if(_be_) caml_call1(Stdlib[1], cst_Bitv_fill);
    var _bf_ = 0 < len ? 1 : 0;
    if(_bf_){
     var
      r = ofs & 7,
      first = 0 === r ? 0 : caml_call2(Stdlib[16], len, 8 - r | 0),
      _bg_ = (ofs + first | 0) - 1 | 0;
     if(_bg_ >= ofs){
      var i$1 = ofs;
      for(;;){
       unsafe_set(v, i$1, b);
       var _bq_ = i$1 + 1 | 0;
       if(_bg_ === i$1) break;
       i$1 = _bq_;
      }
     }
     var
      start = (ofs + first | 0) >>> 3 | 0,
      n = (len - first | 0) >>> 3 | 0,
      _bh_ = b ? 255 : 0,
      x = caml_call1(Stdlib_Char[1], _bh_),
      _bi_ = (start + n | 0) - 1 | 0;
     if(_bi_ >= start){
      var i$0 = start;
      for(;;){
       caml_bytes_unsafe_set(v[2], i$0, x);
       var _bp_ = i$0 + 1 | 0;
       if(_bi_ === i$0) break;
       i$0 = _bp_;
      }
     }
     var s = (len - first | 0) & 7, _bj_ = 0 < s ? 1 : 0;
     if(_bj_){
      var stop = ofs + len | 0, _bk_ = stop - s | 0, _bl_ = stop - 1 | 0;
      if(_bl_ >= _bk_){
       var i = _bk_;
       for(;;){
        unsafe_set(v, i, b);
        var _bo_ = i + 1 | 0;
        if(_bl_ === i) break;
        i = _bo_;
       }
      }
      var _bm_ = 0;
     }
     else
      var _bm_ = _bj_;
     var _bn_ = _bm_;
    }
    else
     var _bn_ = _bf_;
    return _bn_;
   }
   function iter(f, v){
    var _bb_ = v[1] - 1 | 0, _ba_ = 0;
    if(_bb_ >= 0){
     var i = _ba_;
     for(;;){
      caml_call1(f, unsafe_get(v, i));
      var _bc_ = i + 1 | 0;
      if(_bb_ === i) break;
      i = _bc_;
     }
    }
    return 0;
   }
   function map(f, v){
    var l = v[1], r = create(l, 0), _a__ = l - 1 | 0, _a9_ = 0;
    if(_a__ >= 0){
     var i = _a9_;
     for(;;){
      unsafe_set(r, i, caml_call1(f, unsafe_get(v, i)));
      var _a$_ = i + 1 | 0;
      if(_a__ === i) break;
      i = _a$_;
     }
    }
    return r;
   }
   function iteri(f, v){
    var _a7_ = v[1] - 1 | 0, _a6_ = 0;
    if(_a7_ >= 0){
     var i = _a6_;
     for(;;){
      caml_call2(f, i, unsafe_get(v, i));
      var _a8_ = i + 1 | 0;
      if(_a7_ === i) break;
      i = _a8_;
     }
    }
    return 0;
   }
   function mapi(f, v){
    var l = v[1], r = create(l, 0), _a4_ = l - 1 | 0, _a3_ = 0;
    if(_a4_ >= 0){
     var i = _a3_;
     for(;;){
      unsafe_set(r, i, caml_call2(f, i, unsafe_get(v, i)));
      var _a5_ = i + 1 | 0;
      if(_a4_ === i) break;
      i = _a5_;
     }
    }
    return r;
   }
   function fold_left(f, x, v){
    var r = [0, x], _a0_ = v[1] - 1 | 0, _aZ_ = 0;
    if(_a0_ >= 0){
     var i = _aZ_;
     for(;;){
      var _a1_ = unsafe_get(v, i);
      r[1] = caml_call2(f, r[1], _a1_);
      var _a2_ = i + 1 | 0;
      if(_a0_ === i) break;
      i = _a2_;
     }
    }
    return r[1];
   }
   function fold_right(f, v, x){
    var r = [0, x], _aW_ = v[1] - 1 | 0;
    if(_aW_ >= 0){
     var i = _aW_;
     for(;;){
      var _aX_ = r[1];
      r[1] = caml_call2(f, unsafe_get(v, i), _aX_);
      var _aY_ = i - 1 | 0;
      if(0 === i) break;
      i = _aY_;
     }
    }
    return r[1];
   }
   function foldi_left(f, x, v){
    var r = [0, x], _aT_ = v[1] - 1 | 0, _aS_ = 0;
    if(_aT_ >= 0){
     var i = _aS_;
     for(;;){
      var _aU_ = unsafe_get(v, i);
      r[1] = caml_call3(f, r[1], i, _aU_);
      var _aV_ = i + 1 | 0;
      if(_aT_ === i) break;
      i = _aV_;
     }
    }
    return r[1];
   }
   function foldi_right(f, v, x){
    var r = [0, x], _aP_ = v[1] - 1 | 0;
    if(_aP_ >= 0){
     var i = _aP_;
     for(;;){
      var _aQ_ = r[1];
      r[1] = caml_call3(f, i, unsafe_get(v, i), _aQ_);
      var _aR_ = i - 1 | 0;
      if(0 === i) break;
      i = _aR_;
     }
    }
    return r[1];
   }
   var ntz = runtime.caml_make_vect(256, 0), i = 0;
   for(;;){
    var _k_ = 1 << i;
    caml_check_bound(ntz, _k_)[1 + _k_] = i;
    var _l_ = i + 1 | 0;
    if(7 === i) break;
    i = _l_;
   }
   function iteri_true(f, v){
    return caml_call2
            (Stdlib_Bytes[16],
             function(i, c){
              var i_bpi = i << 3, x = c;
              for(;;){
               var _aO_ = 0 !== x ? 1 : 0;
               if(! _aO_) return _aO_;
               var b = x & (- x | 0);
               caml_call1(f, i_bpi + ntz[1 + b] | 0);
               var x$0 = x - b | 0;
               x = x$0;
              }
             },
             v[2]);
   }
   function naive_pop(x){
    if(256 <= x)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 0 === x ? 0 : 1 + naive_pop(x - (x & (- x | 0)) | 0) | 0;
   }
   var _b_ = caml_call2(Stdlib_Array[1], 256, naive_pop);
   function pop(v){
    var n = caml_ml_bytes_length(v[2]), b = v[2], acc = 0, i = 0;
    for(;;){
     if(n <= i) return acc;
     var
      i$0 = i + 1 | 0,
      n$0 = caml_bytes_unsafe_get(b, i),
      acc$0 = acc + _b_[1 + n$0] | 0;
     acc = acc$0;
     i = i$0;
    }
   }
   function bw_and(v1, v2){
    var l = v1[1];
    if(l !== v2[1]) caml_call1(Stdlib[1], cst_Bitv_bw_and);
    var
     b1 = v1[2],
     b2 = v2[2],
     n = caml_ml_bytes_length(b1),
     _aK_ = caml_call1(Stdlib_Char[1], 0),
     a = caml_call2(Stdlib_Bytes[1], n, _aK_),
     _aM_ = n - 1 | 0,
     _aL_ = 0;
    if(_aM_ >= 0){
     var i = _aL_;
     for(;;){
      set_byte
       (a, i, caml_bytes_unsafe_get(b1, i) & caml_bytes_unsafe_get(b2, i));
      var _aN_ = i + 1 | 0;
      if(_aM_ === i) break;
      i = _aN_;
     }
    }
    return [0, l, a];
   }
   function bw_or(v1, v2){
    var l = v1[1];
    if(l !== v2[1]) caml_call1(Stdlib[1], cst_Bitv_bw_or);
    var
     b1 = v1[2],
     b2 = v2[2],
     n = caml_ml_bytes_length(b1),
     _aG_ = caml_call1(Stdlib_Char[1], 0),
     a = caml_call2(Stdlib_Bytes[1], n, _aG_),
     _aI_ = n - 1 | 0,
     _aH_ = 0;
    if(_aI_ >= 0){
     var i = _aH_;
     for(;;){
      set_byte
       (a, i, caml_bytes_unsafe_get(b1, i) | caml_bytes_unsafe_get(b2, i));
      var _aJ_ = i + 1 | 0;
      if(_aI_ === i) break;
      i = _aJ_;
     }
    }
    return [0, l, a];
   }
   function bw_xor(v1, v2){
    var l = v1[1];
    if(l !== v2[1]) caml_call1(Stdlib[1], cst_Bitv_bw_or$0);
    var
     b1 = v1[2],
     b2 = v2[2],
     n = caml_ml_bytes_length(b1),
     _aC_ = caml_call1(Stdlib_Char[1], 0),
     a = caml_call2(Stdlib_Bytes[1], n, _aC_),
     _aE_ = n - 1 | 0,
     _aD_ = 0;
    if(_aE_ >= 0){
     var i = _aD_;
     for(;;){
      set_byte
       (a, i, caml_bytes_unsafe_get(b1, i) ^ caml_bytes_unsafe_get(b2, i));
      var _aF_ = i + 1 | 0;
      if(_aE_ === i) break;
      i = _aF_;
     }
    }
    return [0, l, a];
   }
   function bw_not(v){
    var
     b$0 = v[2],
     n = caml_ml_bytes_length(b$0),
     _ay_ = caml_call1(Stdlib_Char[1], 0),
     a = caml_call2(Stdlib_Bytes[1], n, _ay_),
     _aA_ = n - 1 | 0,
     _az_ = 0;
    if(_aA_ >= 0){
     var i$0 = _az_;
     for(;;){
      set_byte
       (a, i$0, 255 & caml_call1(Stdlib[21], caml_bytes_unsafe_get(b$0, i$0)));
      var _aB_ = i$0 + 1 | 0;
      if(_aA_ === i$0) break;
      i$0 = _aB_;
     }
    }
    var r$0 = [0, v[1], a], r = r$0[1] & 7;
    if(0 < r){
     var
      b = r$0[2],
      s = caml_ml_bytes_length(b),
      i = s - 1 | 0,
      _ax_ = caml_check_bound(low_mask, r)[1 + r];
     set_byte(b, s - 1 | 0, caml_bytes_unsafe_get(b, i) & _ax_);
    }
    return r$0;
   }
   function of_list(l){
    var
     n = 1 + caml_call3(Stdlib_List[26], Stdlib[17], -1, l) | 0,
     _av_ = n < 0 ? 1 : 0,
     _aw_ = _av_ || (max_length < n ? 1 : 0);
    if(_aw_) caml_call1(Stdlib[1], cst_Bitv_of_list);
    var b = create(n, 0);
    function add_element(i){
     if(i < 0) caml_call1(Stdlib[1], cst_Bitv_of_list$0);
     return unsafe_set(b, i, 1);
    }
    caml_call2(Stdlib_List[18], add_element, l);
    return b;
   }
   function of_list_with_length(l, len){
    var _ar_ = len < 0 ? 1 : 0, _as_ = _ar_ || (max_length < len ? 1 : 0);
    if(_as_) caml_call1(Stdlib[1], cst_Bitv_of_list_with_length);
    var b = create(len, 0);
    function add_element(i){
     var _at_ = i < 0 ? 1 : 0, _au_ = _at_ || (len <= i ? 1 : 0);
     if(_au_) caml_call1(Stdlib[1], cst_Bitv_of_list_with_length$0);
     return unsafe_set(b, i, 1);
    }
    caml_call2(Stdlib_List[18], add_element, l);
    return b;
   }
   function to_list(b){
    var n = b[1], i$1 = n - 1 | 0, i = i$1, acc = 0;
    for(;;){
     if(0 > i) return acc;
     var acc$0 = unsafe_get(b, i) ? [0, i, acc] : acc, i$0 = i - 1 | 0;
     i = i$0;
     acc = acc$0;
    }
   }
   function unsafe_blit(b1, ofs1, b2, ofs2, len){
    var _am_ = 0 < len ? 1 : 0;
    if(_am_){
     if(0 === (ofs1 & 7) && 0 === (ofs2 & 7) && 0 === (len & 7))
      return caml_call5
              (Stdlib_Bytes[11],
               b1,
               ofs1 >>> 3 | 0,
               b2,
               ofs2 >>> 3 | 0,
               len >>> 3 | 0);
     var _ao_ = len - 1 | 0, _an_ = 0;
     if(_ao_ >= 0){
      var i$1 = _an_;
      for(;;){
       var
        n = ofs1 + i$1 | 0,
        i = n >>> 3 | 0,
        v = 0 < (caml_bytes_unsafe_get(b1, i) & 1 << (n & 7)) ? 1 : 0,
        n$0 = ofs2 + i$1 | 0,
        i$0 = n$0 >>> 3 | 0,
        c = caml_bytes_unsafe_get(b2, i$0),
        mask = 1 << (n$0 & 7),
        _al_ = v ? c | mask : c & caml_call1(Stdlib[21], mask);
       set_byte(b2, i$0, _al_);
       var _aq_ = i$1 + 1 | 0;
       if(_ao_ === i$1) break;
       i$1 = _aq_;
      }
     }
     var _ap_ = 0;
    }
    else
     var _ap_ = _am_;
    return _ap_;
   }
   function blit(v1, ofs1, v2, ofs2, len){
    var _ag_ = len < 0 ? 1 : 0;
    if(_ag_)
     var _ah_ = _ag_;
    else{
     var _ai_ = ofs1 < 0 ? 1 : 0;
     if(_ai_)
      var _ah_ = _ai_;
     else{
      var _aj_ = (v1[1] - len | 0) < ofs1 ? 1 : 0;
      if(_aj_)
       var _ah_ = _aj_;
      else
       var
        _ak_ = ofs2 < 0 ? 1 : 0,
        _ah_ = _ak_ || ((v2[1] - len | 0) < ofs2 ? 1 : 0);
     }
    }
    if(_ah_) caml_call1(Stdlib[1], cst_Bitv_blit);
    return unsafe_blit(v1[2], ofs1, v2[2], ofs2, len);
   }
   function sub(v, ofs, len){
    var _ad_ = ofs < 0 ? 1 : 0;
    if(_ad_)
     var _ae_ = _ad_;
    else
     var
      _af_ = len < 0 ? 1 : 0,
      _ae_ = _af_ || ((v[1] - len | 0) < ofs ? 1 : 0);
    if(_ae_) caml_call1(Stdlib[1], cst_Bitv_sub);
    var r = create(len, 0);
    unsafe_blit(v[2], ofs, r[2], 0, len);
    return r;
   }
   function append(v1, v2){
    var
     l1 = v1[1],
     l2 = v2[1],
     r = create(l1 + l2 | 0, 0),
     b1 = v1[2],
     b = r[2];
    caml_call5(Stdlib_Bytes[11], b1, 0, b, 0, caml_ml_bytes_length(b1));
    unsafe_blit(v2[2], 0, b, l1, l2);
    return r;
   }
   function concat(vl){
    var
     size =
       caml_call3
        (Stdlib_List[26], function(sz, v){return sz + v[1] | 0;}, 0, vl),
     res = create(size, 0),
     b = res[2],
     pos = [0, 0];
    caml_call2
     (Stdlib_List[18],
      function(v){
       var n = v[1];
       unsafe_blit(v[2], 0, b, pos[1], n);
       pos[1] = pos[1] + n | 0;
       return 0;
      },
      vl);
    return res;
   }
   function all_zeros(v){
    var b = v[2], n = caml_ml_bytes_length(b), i = 0;
    for(;;){
     var _aa_ = i === n ? 1 : 0;
     if(_aa_)
      var _ab_ = _aa_;
     else{
      var _ac_ = 0 === caml_bytes_unsafe_get(b, i) ? 1 : 0;
      if(_ac_){var i$0 = i + 1 | 0; i = i$0; continue;}
      var _ab_ = _ac_;
     }
     return _ab_;
    }
   }
   function all_ones(v){
    var b = v[2], n = caml_ml_bytes_length(b), _$_ = 0 === n ? 1 : 0;
    if(_$_) return _$_;
    var i = 0;
    for(;;){
     if(i === (n - 1 | 0)){
      var
       m = v[1] & 7,
       _Z_ = 0 === m ? 255 : caml_check_bound(low_mask, m)[1 + m];
      return caml_bytes_unsafe_get(b, i) === _Z_ ? 1 : 0;
     }
     var ___ = 255 === caml_bytes_unsafe_get(b, i) ? 1 : 0;
     if(! ___) return ___;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function shiftl$0(counter, v, d){
    if(0 === d) return copy(v);
    if(0 <= d){
     var n = v[1], r = create(n, 0);
     if(d < n) unsafe_blit(v[2], 0, r[2], d, n - d | 0);
     return r;
    }
    var _Y_ = - d | 0;
    if(counter >= 50) return caml_trampoline_return(shiftr$0, [0, v, _Y_]);
    var counter$0 = counter + 1 | 0;
    return shiftr$0(counter$0, v, _Y_);
   }
   function shiftl(v, d){return caml_trampoline(shiftl$0(0, v, d));}
   function shiftr$0(counter, v, d){
    if(0 === d) return copy(v);
    if(0 <= d){
     var n = v[1], r = create(n, 0);
     if(d < n) unsafe_blit(v[2], d, r[2], 0, n - d | 0);
     return r;
    }
    var _X_ = - d | 0;
    if(counter >= 50) return caml_trampoline_return(shiftl$0, [0, v, _X_]);
    var counter$0 = counter + 1 | 0;
    return shiftl$0(counter$0, v, _X_);
   }
   function shiftr(v, d){return caml_trampoline(shiftr$0(0, v, d));}
   function rotatel$0(counter, v, d){
    if(0 > d){
     var _W_ = - d | 0;
     if(counter >= 50) return caml_trampoline_return(rotater$0, [0, v, _W_]);
     var counter$0 = counter + 1 | 0;
     return rotater$0(counter$0, v, _W_);
    }
    var n = v[1];
    if(0 !== d && 0 !== n){
     var d$0 = caml_mod(d, n), r = create(n, 0);
     unsafe_blit(v[2], 0, r[2], d$0, n - d$0 | 0);
     unsafe_blit(v[2], n - d$0 | 0, r[2], 0, d$0);
     return r;
    }
    return copy(v);
   }
   function rotatel(v, d){return caml_trampoline(rotatel$0(0, v, d));}
   function rotater$0(counter, v, d){
    if(0 > d){
     var _V_ = - d | 0;
     if(counter >= 50) return caml_trampoline_return(rotatel$0, [0, v, _V_]);
     var counter$0 = counter + 1 | 0;
     return rotatel$0(counter$0, v, _V_);
    }
    var n = v[1];
    if(0 !== d && 0 !== n){
     var d$0 = caml_mod(d, n), r = create(n, 0);
     unsafe_blit(v[2], d$0, r[2], 0, n - d$0 | 0);
     unsafe_blit(v[2], 0, r[2], n - d$0 | 0, d$0);
     return r;
    }
    return copy(v);
   }
   function rotater(v, d){return caml_trampoline(rotater$0(0, v, d));}
   function gray_iter(f, n){
    var bv = create(n, 0), _U_ = 0 < n ? 1 : 0;
    if(! _U_) return _U_;
    for(;;){
     caml_call1(f, bv);
     unsafe_set(bv, 0, 1 - unsafe_get(bv, 0));
     caml_call1(f, bv);
     var i = 0;
     for(;;){
      if(i === n) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(unsafe_get(bv, i)) break;
      var i$0 = i + 1 | 0;
      i = i$0;
     }
     var pos = i + 1 | 0, _T_ = pos < n ? 1 : 0;
     if(! _T_) return _T_;
     unsafe_set(bv, pos, 1 - unsafe_get(bv, pos));
    }
   }
   function S(I){
    function to_string(v){
     var
      n = v[1],
      s = caml_call2(Stdlib_Bytes[1], n, 48),
      _R_ = n - 1 | 0,
      _Q_ = 0;
     if(_R_ >= 0){
      var i = _Q_;
      for(;;){
       if(unsafe_get(v, i)){
        var i$0 = I[1] ? i : (n - 1 | 0) - i | 0;
        runtime.caml_bytes_set(s, i$0, 49);
       }
       var _S_ = i + 1 | 0;
       if(_R_ === i) break;
       i = _S_;
      }
     }
     return caml_call1(Stdlib_Bytes[44], s);
    }
    function print(fmt, v){
     var _P_ = to_string(v);
     return caml_call2(Stdlib_Format[13], fmt, _P_);
    }
    function of_string(s){
     var
      n = runtime.caml_ml_string_length(s),
      v = create(n, 0),
      _M_ = n - 1 | 0,
      _L_ = 0;
     if(_M_ >= 0){
      var i = _L_;
      for(;;){
       var c = runtime.caml_string_unsafe_get(s, i);
       if(49 === c){
        var _N_ = 1, i$0 = I[1] ? i : (n - 1 | 0) - i | 0;
        unsafe_set(v, i$0, _N_);
       }
       else if(48 !== c) caml_call1(Stdlib[1], cst_Bitv_of_string);
       var _O_ = i + 1 | 0;
       if(_M_ === i) break;
       i = _O_;
      }
     }
     return v;
    }
    return [0, to_string, print, of_string];
   }
   var L = S([0, 1]), M = S([0, 0]);
   function tanimoto(v1, v2){
    var l = v1[1];
    if(l !== v2[1]) caml_call1(Stdlib[1], cst_Bitv_tanimoto);
    var a = pop(v1), b = pop(v2), c = pop(bw_and(v1, v2));
    return c / ((a + b | 0) - c | 0);
   }
   function to_bin(write, v){
    var
     x = v[1],
     _K_ =
       caml_call2
        (Stdlib_Bytes[2],
         8,
         function(i){
          return caml_call1(Stdlib_Char[1], (x >>> (8 * i | 0) | 0) & 255);
         });
    caml_call1(caml_call1(Stdlib_Bytes[15], write), _K_);
    return caml_call2(Stdlib_Bytes[15], write, v[2]);
   }
   function output_bin(out_ch, v){
    var write = caml_call1(Stdlib[65], out_ch);
    return to_bin(write, v);
   }
   function to_bytes(t){
    var buf = caml_call1(Stdlib_Buffer[1], 0);
    function write(x){return caml_call2(Stdlib_Buffer[12], buf, x);}
    to_bin(write, t);
    return caml_call1(Stdlib_Buffer[3], buf);
   }
   function of_bin(read){
    var
     b =
       caml_call2
        (Stdlib_Bytes[2], 8, function(param){return caml_call1(read, 0);});
    if(8 !== caml_ml_bytes_length(b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var len = 0, i = 7;
    for(;;){
     if(0 > i) break;
     var i$0 = i - 1 | 0, x = len << 8 | caml_bytes_get(b, i);
     len = x;
     i = i$0;
    }
    var
     v = create(len, 0),
     b$0 = v[2],
     _I_ = caml_ml_bytes_length(b$0) - 1 | 0,
     _H_ = 0;
    if(_I_ >= 0){
     var i$1 = _H_;
     for(;;){
      caml_bytes_unsafe_set(b$0, i$1, caml_call1(read, 0));
      var _J_ = i$1 + 1 | 0;
      if(_I_ === i$1) break;
      i$1 = _J_;
     }
    }
    return v;
   }
   function input_bin(in_ch){
    function read(param){return caml_call1(Stdlib[82], in_ch);}
    return of_bin(read);
   }
   function of_bytes(b){
    var p = [0, 0];
    function read(param){
     var ret = caml_bytes_get(b, p[1]);
     p[1]++;
     return ret;
    }
    return of_bin(read);
   }
   function of_int_gen(len, getbyte, getbit){
    var v = create(len, 0), _B_ = (len >>> 3 | 0) - 1 | 0, _A_ = 0;
    if(_B_ >= 0){
     var i$0 = _A_;
     for(;;){
      var _F_ = caml_call1(getbyte, i$0);
      set_byte(v[2], i$0, _F_);
      var _G_ = i$0 + 1 | 0;
      if(_B_ === i$0) break;
      i$0 = _G_;
     }
    }
    var _C_ = len & caml_call1(Stdlib[21], 7), _D_ = len - 1 | 0;
    if(_D_ >= _C_){
     var i = _C_;
     for(;;){
      unsafe_set(v, i, caml_call1(getbit, i));
      var _E_ = i + 1 | 0;
      if(_D_ === i) break;
      i = _E_;
     }
    }
    return v;
   }
   function getbyte(x, i){return (x >>> (8 * i | 0) | 0) & 255;}
   function getbit(x, i){return 0 < ((x >>> i | 0) & 1) ? 1 : 0;}
   function of_int_us(x){
    return of_int_gen
            (Stdlib_Sys[10] - 1 | 0,
             function(_z_){return getbyte(x, _z_);},
             function(_y_){return getbit(x, _y_);});
   }
   function of_int_s(x){
    return of_int_gen
            (Stdlib_Sys[10],
             function(_x_){return getbyte(x, _x_);},
             function(_w_){return getbit(x, _w_);});
   }
   function to_int_gen(zero, shiftor, v){
    var x = [0, zero];
    caml_call2
     (Stdlib_Bytes[16],
      function(i, c){
       x[1] = caml_call3(shiftor, x[1], c, 8 * i | 0);
       return 0;
      },
      v[2]);
    return x[1];
   }
   function shiftor(x, b, i){return x | b << i;}
   function to_int_us(v){return to_int_gen(0, shiftor, v);}
   function to_int_s(v){return to_int_gen(0, shiftor, v);}
   function getbyte32(x, i){return x >> (8 * i | 0) & 255;}
   function getbit32(x, i){return caml_greaterthan(x >> i & 1, 0);}
   function of_int32_us(x){
    return of_int_gen
            (31,
             function(_v_){return getbyte32(x, _v_);},
             function(_u_){return getbit32(x, _u_);});
   }
   function of_int32_s(x){
    return of_int_gen
            (32,
             function(_t_){return getbyte32(x, _t_);},
             function(_s_){return getbit32(x, _s_);});
   }
   function shiftor32(x, b, i){return x | b << i;}
   function to_int32_us(v){return to_int_gen(0, shiftor32, v);}
   function to_int32_s(v){return to_int_gen(0, shiftor32, v);}
   function getbyte64(x, i){
    return caml_int64_to_int32
            (caml_int64_and(caml_int64_shift_right(x, 8 * i | 0), _d_));
   }
   function getbit64(x, i){
    return caml_greaterthan
            (caml_int64_and(caml_int64_shift_right(x, i), _f_), _e_);
   }
   function of_int64_us(x){
    return of_int_gen
            (63,
             function(_r_){return getbyte64(x, _r_);},
             function(_q_){return getbit64(x, _q_);});
   }
   function of_int64_s(x){
    return of_int_gen
            (64,
             function(_p_){return getbyte64(x, _p_);},
             function(_o_){return getbit64(x, _o_);});
   }
   function shiftor64(x, b, i){
    return runtime.caml_int64_or
            (x, runtime.caml_int64_shift_left(caml_int64_of_int32(b), i));
   }
   function to_int64_us(v){return to_int_gen(_g_, shiftor64, v);}
   function to_int64_s(v){return to_int_gen(_h_, shiftor64, v);}
   function select_of(f32, f64){
    var _n_ = Stdlib_Sys[9];
    if(32 === _n_) return function(i){return caml_call1(f32, i);};
    if(64 === _n_)
     return function(i){return caml_call1(f64, caml_int64_of_int32(i));};
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   var
    of_nativeint_s = select_of(of_int32_s, of_int64_s),
    of_nativeint_us = select_of(of_int32_us, of_int64_us);
   function select_to(f32, f64){
    var _m_ = Stdlib_Sys[9];
    if(32 === _m_) return function(i){return caml_call1(f32, i);};
    if(64 === _m_)
     return function(i){return caml_int64_to_int32(caml_call1(f64, i));};
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   var
    to_nativeint_s = select_to(to_int32_s, to_int64_s),
    to_nativeint_us = select_to(to_int32_us, to_int64_us),
    Bitv =
      [0,
       create,
       init,
       set,
       get,
       length,
       equal,
       tanimoto,
       max_length,
       exceeds_max_length,
       copy,
       append,
       concat,
       sub,
       fill,
       blit,
       iter,
       map,
       iteri,
       mapi,
       fold_left,
       fold_right,
       foldi_left,
       foldi_right,
       pop,
       iteri_true,
       gray_iter,
       bw_and,
       bw_or,
       bw_xor,
       bw_not,
       shiftl,
       shiftr,
       rotatel,
       rotater,
       all_zeros,
       all_ones,
       [0, L[1], L[3], L[2]],
       [0, M[1], M[3], M[2]],
       output_bin,
       input_bin,
       to_bytes,
       of_bytes,
       to_list,
       of_list,
       of_list_with_length,
       of_int_s,
       to_int_s,
       of_int_us,
       to_int_us,
       of_int32_s,
       to_int32_s,
       of_int32_us,
       to_int32_us,
       of_int64_s,
       to_int64_s,
       of_int64_us,
       to_int64_us,
       of_nativeint_s,
       to_nativeint_s,
       of_nativeint_us,
       to_nativeint_us,
       unsafe_set,
       unsafe_get];
   runtime.caml_register_global(38, Bitv, "Bitv");
   return;
  }
  (globalThis));

//# 4 "../.js/default/zarith/zarith.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    version = "1.14",
    Zarith_version = [0, version];
   runtime.caml_register_global(1, Zarith_version, "Zarith_version");
   return;
  }
  (globalThis));

//# 18 "../.js/default/zarith/zarith.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_d = "%d",
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_int64_to_float = runtime.caml_int64_to_float,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Zarith_version = global_data.Zarith_version,
    Overflow = [248, "Z.Overflow", runtime.caml_fresh_oo_id(0)];
   runtime.ml_z_init(0);
   caml_call2(Stdlib_Callback[2], "ml_z_overflow", Overflow);
   function neg(x){
    if(typeof x === "number" && x !== Stdlib[20]) return - x | 0;
    return runtime.ml_z_neg(x);
   }
   function add(x, y){
    if(typeof x === "number" && typeof y === "number"){
     var z = x + y | 0;
     return 0 <= ((z ^ x) & (z ^ y)) ? z : runtime.ml_z_add(x, y);
    }
    return runtime.ml_z_add(x, y);
   }
   function sub(x, y){
    if(typeof x === "number" && typeof y === "number"){
     var z = x - y | 0;
     return 0 <= ((x ^ y) & (z ^ x)) ? z : runtime.ml_z_sub(x, y);
    }
    return runtime.ml_z_sub(x, y);
   }
   function mul(x, y){
    if
     (typeof x === "number"
      && typeof y === "number" && ! runtime.ml_z_mul_overflows(x, y))
     return runtime.caml_mul(x, y);
    return runtime.ml_z_mul(x, y);
   }
   function div(x, y){
    return typeof y === "number"
            ? -1
              === y
              ? neg(x)
              : typeof
                x
                === "number"
                ? caml_div(x, y)
                : runtime.ml_z_div(x, y)
            : runtime.ml_z_div(x, y);
   }
   function rem(x, y){
    return typeof y === "number"
            ? -1
              === y
              ? 0
              : typeof
                x
                === "number"
                ? caml_mod(x, y)
                : runtime.ml_z_rem(x, y)
            : runtime.ml_z_rem(x, y);
   }
   function divexact(x, y){
    return typeof y === "number"
            ? -1
              === y
              ? neg(x)
              : typeof
                x
                === "number"
                ? caml_div(x, y)
                : runtime.ml_z_divexact(x, y)
            : runtime.ml_z_divexact(x, y);
   }
   function succ(x){
    if(typeof x === "number" && x !== Stdlib[19]) return x + 1 | 0;
    return runtime.ml_z_succ(x);
   }
   function pred(x){
    if(typeof x === "number" && x !== Stdlib[20]) return x - 1 | 0;
    return runtime.ml_z_pred(x);
   }
   function abs(x){
    return typeof x === "number"
            ? 0 <= x ? x : x !== Stdlib[20] ? - x | 0 : runtime.ml_z_abs(x)
            : runtime.ml_z_abs(x);
   }
   function logand(x, y){
    if(typeof x === "number" && typeof y === "number") return x & y;
    return runtime.ml_z_logand(x, y);
   }
   function logor(x, y){
    if(typeof x === "number" && typeof y === "number") return x | y;
    return runtime.ml_z_logor(x, y);
   }
   function logxor(x, y){
    if(typeof x === "number" && typeof y === "number") return x ^ y;
    return runtime.ml_z_logxor(x, y);
   }
   function lognot(x){
    return typeof x === "number" ? x ^ -1 : runtime.ml_z_lognot(x);
   }
   function shift_left(x, y){
    if(typeof x === "number" && 0 <= y && y < Stdlib_Sys[9]){
     var z = x << y;
     return z >> y === x ? z : runtime.ml_z_shift_left(x, y);
    }
    return runtime.ml_z_shift_left(x, y);
   }
   function shift_right(x, y){
    if(typeof x === "number" && 0 <= y){
     var y$0 = y < Stdlib_Sys[9] ? y : Stdlib_Sys[9] - 1 | 0;
     return x >> y$0;
    }
    return runtime.ml_z_shift_right(x, y);
   }
   function shift_right_trunc(x, y){
    if(typeof x === "number" && 0 <= y)
     return Stdlib_Sys[9] <= y
             ? 0
             : 0 <= x ? x >>> y | 0 : - ((- x | 0) >>> y | 0) | 0;
    return runtime.ml_z_shift_right_trunc(x, y);
   }
   var uint32_mask = pred(shift_left(1, 32));
   function of_int32_unsigned(x){
    return logand(runtime.ml_z_of_int32(x), uint32_mask);
   }
   var uint64_mask = pred(shift_left(1, 64));
   function of_int64_unsigned(x){
    return logand(runtime.ml_z_of_int64(x), uint64_mask);
   }
   var uintnat_mask = pred(shift_left(1, Stdlib_Nativeint[9]));
   function of_nativeint_unsigned(x){
    return logand(runtime.ml_z_of_nativeint(x), uintnat_mask);
   }
   function to_int(x){
    return typeof x === "number" ? x : runtime.ml_z_to_int(x);
   }
   var hash = Stdlib_Hashtbl[28], seeded_hash = Stdlib_Hashtbl[29];
   function divisible(x, y){
    if(typeof x !== "number") return runtime.ml_z_divisible(x, y);
    if(typeof y === "number")
     return 0 === y ? 0 === x ? 1 : 0 : 0 === caml_mod(x, y) ? 1 : 0;
    var _s_ = 0 === x ? 1 : 0;
    if(_s_)
     var _t_ = _s_;
    else
     var
      _u_ = x === Stdlib[20] ? 1 : 0,
      _t_ = _u_ ? caml_equal(y, runtime.ml_z_neg(x)) : _u_;
    return _t_;
   }
   var
    zero = 0,
    one = 1,
    minus_one = -1,
    cst_Z_testbit = "Z.testbit",
    cst_Z_extract_negative_bit_off = "Z.extract: negative bit offset",
    cst_Z_extract_nonpositive_bit_ = "Z.extract: nonpositive bit length",
    cst_Z_signed_extract_negative_ = "Z.signed_extract: negative bit offset",
    cst_Z_signed_extract_nonpositi =
      "Z.signed_extract: nonpositive bit length",
    cst_Z_log2 = "Z.log2",
    cst_Z_log2up = "Z.log2up",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    cst_random_bits_number_of_bits =
      "random_bits: number of bits must be >= 0",
    cst_random_int_bound_must_be_0 = "random_int: bound must be > 0";
   function min(a, b){return 0 < runtime.ml_z_compare(a, b) ? b : a;}
   function max(a, b){return 0 <= runtime.ml_z_compare(a, b) ? a : b;}
   function leq(a, b){return runtime.ml_z_compare(a, b) <= 0 ? 1 : 0;}
   function geq(a, b){return 0 <= runtime.ml_z_compare(a, b) ? 1 : 0;}
   function lt(a, b){return runtime.ml_z_compare(a, b) < 0 ? 1 : 0;}
   function gt(a, b){return 0 < runtime.ml_z_compare(a, b) ? 1 : 0;}
   function to_string(_r_){return runtime.ml_z_format(cst_d, _r_);}
   function of_string(s){
    return runtime.ml_z_of_substring_base(0, s, 0, caml_ml_string_length(s));
   }
   function of_substring(_o_, _p_, _q_){
    return runtime.ml_z_of_substring_base(0, _o_, _p_, _q_);
   }
   function of_string_base(base, s){
    return runtime.ml_z_of_substring_base
            (base, s, 0, caml_ml_string_length(s));
   }
   function ediv_rem(a, b){
    var match = runtime.ml_z_div_rem(a, b), r = match[2], q = match[1];
    if(0 <= runtime.ml_z_sign(r)) return [0, q, r];
    if(0 <= runtime.ml_z_sign(b)){
     var _m_ = add(r, b);
     return [0, pred(q), _m_];
    }
    var _n_ = sub(r, b);
    return [0, succ(q), _n_];
   }
   function ediv(a, b){
    return 0 <= runtime.ml_z_sign(b)
            ? runtime.ml_z_fdiv(a, b)
            : runtime.ml_z_cdiv(a, b);
   }
   function erem(a, b){
    var r = rem(a, b);
    return 0 <= runtime.ml_z_sign(r) ? r : add(r, abs(b));
   }
   function gcdext(u, v){
    var
     match = runtime.ml_z_sign(u),
     match$0 = runtime.ml_z_sign(v),
     switcher = match + 1 | 0;
    if(2 >= switcher >>> 0)
     switch(switcher){
       case 0:
        if(0 === match$0) return [0, neg(u), minus_one, zero]; break;
       case 1:
        var switcher$0 = match$0 + 1 | 0;
        if(2 >= switcher$0 >>> 0)
         switch(switcher$0){
           case 0:
            return [0, neg(v), zero, minus_one];
           case 1:
            return [0, zero, zero, zero];
           default: return [0, v, zero, one];
         }
        break;
       default: if(0 === match$0) return [0, u, one, zero];
     }
    var
     match$1 = runtime.ml_z_gcdext_intern(u, v),
     z = match$1[3],
     s = match$1[2],
     g = match$1[1];
    return z
            ? [0, g, s, div(sub(g, mul(u, s)), v)]
            : [0, g, div(sub(g, mul(v, s)), u), s];
   }
   function lcm(u, v){
    if(! caml_equal(u, zero) && ! caml_equal(v, zero)){
     var g = runtime.ml_z_gcd(u, v);
     return abs(mul(divexact(u, g), v));
    }
    return zero;
   }
   function testbit(x, n){
    return 0 <= n
            ? runtime.ml_z_testbit(x, n)
            : caml_call1(Stdlib[1], cst_Z_testbit);
   }
   function is_odd(x){return runtime.ml_z_testbit(x, 0);}
   function is_even(x){return 1 - runtime.ml_z_testbit(x, 0);}
   function extract(x, o$0, l){
    if(o$0 < 0) caml_call1(Stdlib[1], cst_Z_extract_negative_bit_off);
    if(l < 1) caml_call1(Stdlib[1], cst_Z_extract_nonpositive_bit_);
    if(typeof x !== "number")
     return l < Stdlib_Sys[10]
             ? runtime.ml_z_extract_small(x, o$0, l)
             : runtime.ml_z_extract(x, o$0, l);
    var o = Stdlib_Sys[10] <= o$0 ? Stdlib_Sys[10] - 1 | 0 : o$0, z = x >> o;
    return l < Stdlib_Sys[10]
            ? z & ((1 << l) - 1 | 0)
            : 0 <= z ? z : runtime.ml_z_extract(x, o, l);
   }
   function signed_extract(x, o, l){
    if(o < 0) caml_call1(Stdlib[1], cst_Z_signed_extract_negative_);
    if(l < 1) caml_call1(Stdlib[1], cst_Z_signed_extract_nonpositi);
    return testbit(x, (o + l | 0) - 1 | 0)
            ? lognot(extract(lognot(x), o, l))
            : extract(x, o, l);
   }
   function log2(x){
    return 0 < runtime.ml_z_sign(x)
            ? runtime.ml_z_numbits(x) - 1 | 0
            : caml_call1(Stdlib[1], cst_Z_log2);
   }
   function log2up(x){
    return 0 < runtime.ml_z_sign(x)
            ? runtime.ml_z_numbits(pred(x))
            : caml_call1(Stdlib[1], cst_Z_log2up);
   }
   function round_to_float(x, exact){
    var
     m = runtime.ml_z_to_int64(x),
     m$0 = exact ? m : runtime.caml_int64_or(m, _a_);
    return caml_int64_to_float(m$0);
   }
   function to_float(x){
    if(typeof x === "number") return x;
    var n = runtime.ml_z_numbits(x);
    if(63 >= n) return caml_int64_to_float(runtime.ml_z_to_int64(x));
    var
     n$0 = n - 55 | 0,
     top = shift_right(x, n$0),
     exact = runtime.ml_z_equal(x, shift_left(top, n$0));
    return runtime.caml_ldexp_float(round_to_float(top, exact), n$0);
   }
   function print(x){
    var _l_ = runtime.ml_z_format(cst_d, x);
    return caml_call1(Stdlib[42], _l_);
   }
   function output(chan, x){
    var _k_ = runtime.ml_z_format(cst_d, x);
    return caml_call2(Stdlib[66], chan, _k_);
   }
   function sprint(param, x){return runtime.ml_z_format(cst_d, x);}
   function bprint(b, x){
    var _j_ = runtime.ml_z_format(cst_d, x);
    return caml_call2(Stdlib_Buffer[16], b, _j_);
   }
   function pp_print(f, x){
    var _i_ = runtime.ml_z_format(cst_d, x);
    return caml_call2(Stdlib_Format[13], f, _i_);
   }
   function raw_bits_random(rng, nbits){
    var accu = zero, n = 0;
    for(;;){
     if(nbits <= n) return [0, accu, n];
     if(rng)
      var r = rng[1], i = caml_call1(Stdlib_Random[15][4], r);
     else
      var i = caml_call1(Stdlib_Random[4], 0);
     var n$0 = n + 30 | 0, accu$0 = logxor(shift_left(accu, 30), i);
     accu = accu$0;
     n = n$0;
    }
   }
   function raw_bits_from_bytes(fill, nbits){
    var
     nbytes = (nbits + 7 | 0) / 8 | 0,
     buf = runtime.caml_create_bytes(nbytes);
    caml_call3(fill, buf, 0, nbytes);
    return [0,
            runtime.ml_z_of_bits(caml_call1(Stdlib_Bytes[6], buf)),
            nbytes * 8 | 0];
   }
   function random_bits_aux(f, nbits){
    if(nbits < 0) caml_call1(Stdlib[1], cst_random_bits_number_of_bits);
    var x = caml_call1(f, nbits)[1];
    return extract(x, 0, nbits);
   }
   function random_int_aux(f, bound){
    if(runtime.ml_z_sign(bound) <= 0)
     caml_call1(Stdlib[1], cst_random_int_bound_must_be_0);
    var nbits1 = log2up(bound);
    for(;;){
     var
      match = caml_call1(f, nbits1 + 4 | 0),
      nbits = match[2],
      x = match[1],
      y = rem(x, bound),
      _h_ = sub(shift_left(one, nbits), bound);
     if(leq(sub(x, y), _h_)) return y;
    }
   }
   function random_int(rng, bound){
    return random_int_aux
            (function(_g_){return raw_bits_random(rng, _g_);}, bound);
   }
   function random_bits(rng, nbits){
    return random_bits_aux
            (function(_f_){return raw_bits_random(rng, _f_);}, nbits);
   }
   function random_int_gen(fill, bound){
    return random_int_aux
            (function(_e_){return raw_bits_from_bytes(fill, _e_);}, bound);
   }
   function random_bits_gen(fill, nbits){
    return random_bits_aux
            (function(_d_){return raw_bits_from_bytes(fill, _d_);}, nbits);
   }
   function symbol(x){return x;}
   function symbol$0(_c_, _b_){return runtime.ml_z_equal(_c_, _b_);}
   function symbol$1(a, b){return 1 - runtime.ml_z_equal(a, b);}
   var
    Compare = [0, symbol$0, lt, gt, leq, geq, symbol$1],
    version = Zarith_version[1],
    Z =
      [0,
       Overflow,
       zero,
       one,
       minus_one,
       of_int32_unsigned,
       of_int64_unsigned,
       of_nativeint_unsigned,
       of_string,
       of_substring,
       of_string_base,
       succ,
       pred,
       abs,
       neg,
       add,
       sub,
       mul,
       div,
       rem,
       ediv_rem,
       ediv,
       erem,
       divexact,
       divisible,
       logand,
       logor,
       logxor,
       lognot,
       shift_left,
       shift_right,
       shift_right_trunc,
       testbit,
       to_int,
       to_float,
       to_string,
       print,
       output,
       sprint,
       bprint,
       pp_print,
       leq,
       geq,
       lt,
       gt,
       min,
       max,
       is_even,
       is_odd,
       hash,
       seeded_hash,
       gcdext,
       lcm,
       log2,
       log2up,
       extract,
       signed_extract,
       random_int,
       random_bits,
       random_int_gen,
       random_bits_gen,
       neg,
       symbol,
       add,
       sub,
       mul,
       div,
       divexact,
       rem,
       logand,
       logor,
       logxor,
       lognot,
       shift_left,
       shift_right,
       Compare,
       version,
       round_to_float];
   runtime.caml_register_global(23, Z, "Z");
   return;
  }
  (globalThis));

//# 5 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    Bitv = global_data.Bitv,
    Stdlib_Format = global_data.Stdlib__Format,
    Z = global_data.Z,
    _a_ = [0, [15, 0], "%a"],
    _b_ = [0, "lib/utils.ml", 12, 10];
   function pp_float(fmt, f){
    var _c_ = Stdlib_Obj[16];
    if(runtime.caml_obj_tag(f) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var i = runtime.caml_obj_raw_field(f, 0), v = caml_call1(Bitv[58], i);
    return caml_call4(Stdlib_Format[137], fmt, _a_, Bitv[38][3], v);
   }
   var
    Overflow = Z[1],
    zero = Z[2],
    one = Z[3],
    minus_one = Z[4],
    of_int32_unsigned = Z[5],
    of_int64_unsigned = Z[6],
    of_nativeint_unsigned = Z[7],
    of_string = Z[8],
    of_substring = Z[9],
    of_string_base = Z[10],
    succ = Z[11],
    pred = Z[12],
    abs = Z[13],
    neg = Z[14],
    add = Z[15],
    sub = Z[16],
    mul = Z[17],
    div = Z[18],
    rem = Z[19],
    ediv_rem = Z[20],
    ediv = Z[21],
    erem = Z[22],
    divexact = Z[23],
    divisible = Z[24],
    logand = Z[25],
    logor = Z[26],
    logxor = Z[27],
    lognot = Z[28],
    shift_left = Z[29],
    shift_right = Z[30],
    shift_right_trunc = Z[31],
    testbit = Z[32],
    to_int = Z[33],
    to_float = Z[34],
    to_string = Z[35],
    print = Z[36],
    output = Z[37],
    sprint = Z[38],
    bprint = Z[39],
    pp_print = Z[40],
    leq = Z[41],
    geq = Z[42],
    lt = Z[43],
    gt = Z[44],
    min = Z[45],
    max = Z[46],
    is_even = Z[47],
    is_odd = Z[48],
    hash = Z[49],
    seeded_hash = Z[50],
    gcdext = Z[51],
    lcm = Z[52],
    log2 = Z[53],
    log2up = Z[54],
    extract = Z[55],
    signed_extract = Z[56],
    random_int = Z[57],
    random_bits = Z[58],
    random_int_gen = Z[59],
    random_bits_gen = Z[60],
    symbol = Z[61],
    symbol$0 = Z[62],
    symbol$1 = Z[63],
    symbol$2 = Z[64],
    symbol$3 = Z[65],
    symbol$4 = Z[66],
    symbol$5 = Z[67],
    mod = Z[68],
    land = Z[69],
    lor = Z[70],
    lxor = Z[71],
    symbol$6 = Z[72],
    lsl = Z[73],
    asr = Z[74],
    Compare = Z[75],
    version = Z[76],
    round_to_float = Z[77];
   function pow10(n){return runtime.ml_z_pow(10, n);}
   var
    Z$0 =
      [0,
       Overflow,
       zero,
       one,
       minus_one,
       of_int32_unsigned,
       of_int64_unsigned,
       of_nativeint_unsigned,
       of_string,
       of_substring,
       of_string_base,
       succ,
       pred,
       abs,
       neg,
       add,
       sub,
       mul,
       div,
       rem,
       ediv_rem,
       ediv,
       erem,
       divexact,
       divisible,
       logand,
       logor,
       logxor,
       lognot,
       shift_left,
       shift_right,
       shift_right_trunc,
       testbit,
       to_int,
       to_float,
       to_string,
       print,
       output,
       sprint,
       bprint,
       pp_print,
       leq,
       geq,
       lt,
       gt,
       min,
       max,
       is_even,
       is_odd,
       hash,
       seeded_hash,
       gcdext,
       lcm,
       log2,
       log2up,
       extract,
       signed_extract,
       random_int,
       random_bits,
       random_int_gen,
       random_bits_gen,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       mod,
       land,
       lor,
       lxor,
       symbol$6,
       lsl,
       asr,
       Compare,
       version,
       round_to_float,
       pow10],
    Utils = [0, pp_float, Z$0];
   runtime.caml_register_global(7, Utils, "Utils");
   return;
  }
  (globalThis));

//# 205 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    reset = "\x1b[0m",
    grey = "\x1b[2m",
    dgrey = "\x1b[30m",
    red = "\x1b[31m",
    green = "\x1b[32m",
    yellow = "\x1b[33m",
    blue = "\x1b[34m",
    purple = "\x1b[35m",
    cyen = "\x1b[36m",
    bold = "\x1b[1m",
    italic = "\x1b[3m",
    uline = "\x1b[4m",
    uuline = "\x1b[21m",
    blink = "\x1b[5m",
    backgrd = "\x1b[7m",
    dashed = "\x1b[9m",
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sign =
      caml_call4
       (Stdlib_Printf[4],
        [0,
         [2, 0, [2, 0, [11, "\xe2\x9a\xa0 ", [2, 0, 0]]]],
         "%s%s\xe2\x9a\xa0 %s"],
        red,
        blink,
        reset),
    tick =
      caml_call4
       (Stdlib_Printf[4],
        [0,
         [2, 0, [2, 0, [11, "\xe2\x9c\x93", [2, 0, 0]]]],
         "%s%s\xe2\x9c\x93%s"],
        green,
        bold,
        reset),
    cross =
      caml_call4
       (Stdlib_Printf[4],
        [0,
         [2, 0, [2, 0, [11, "\xe2\x9c\x95", [2, 0, 0]]]],
         "%s%s\xe2\x9c\x95%s"],
        red,
        bold,
        reset);
   function pp_effect(fmt, effect){
    switch(effect){
      case 0:
       var str_color = reset; break;
      case 1:
       var str_color = dgrey; break;
      case 2:
       var str_color = grey; break;
      case 3:
       var str_color = red; break;
      case 4:
       var str_color = green; break;
      case 5:
       var str_color = yellow; break;
      case 6:
       var str_color = blue; break;
      case 7:
       var str_color = purple; break;
      case 8:
       var str_color = cyen; break;
      case 9:
       var str_color = bold; break;
      case 10:
       var str_color = italic; break;
      case 11:
       var str_color = uline; break;
      case 12:
       var str_color = uuline; break;
      case 13:
       var str_color = backgrd; break;
      default: var str_color = dashed;
    }
    return caml_call3(Stdlib_Format[17], fmt, 0, str_color);
   }
   var
    Color =
      [0,
       reset,
       grey,
       dgrey,
       red,
       green,
       yellow,
       blue,
       purple,
       cyen,
       bold,
       italic,
       uline,
       uuline,
       blink,
       backgrd,
       dashed,
       sign,
       tick,
       cross,
       pp_effect];
   runtime.caml_register_global(21, Color, "Color");
   return;
  }
  (globalThis));

//# 330 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$3 = "", cst$2 = "\n";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$3,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    Color = global_data.Color;
   function to_int(param){
    switch(param){
      case 0:
       return 11;
      case 1:
       return 10;
      case 2:
       return 9;
      case 3:
       return 8;
      case 4:
       return 7;
      case 5:
       return 6;
      case 6:
       return 5;
      case 7:
       return 4;
      default: return 0;
    }
   }
   var
    printed_level = [0, 6],
    _a_ =
      [0, [15, [15, [11, "[FATAL]", [15, [12, 32, 0]]]]], "%a%a[FATAL]%a "],
    _b_ =
      [0, [15, [15, [11, "[TODO ]", [15, [12, 32, 0]]]]], "%a%a[TODO ]%a "],
    _c_ =
      [0, [15, [15, [11, "[ERROR]", [15, [12, 32, 0]]]]], "%a%a[ERROR]%a "],
    _d_ =
      [0, [15, [15, [11, "[ OK  ]", [15, [12, 32, 0]]]]], "%a%a[ OK  ]%a "],
    _e_ =
      [0, [15, [15, [11, "[WARN ]", [15, [12, 32, 0]]]]], "%a%a[WARN ]%a "],
    _f_ =
      [0, [15, [15, [11, "[INFO ]", [15, [12, 32, 0]]]]], "%a%a[INFO ]%a "],
    _g_ =
      [0, [15, [15, [11, "[PROGR]", [15, [12, 32, 0]]]]], "%a%a[PROGR]%a "],
    _h_ = [0, [15, [11, "[DEBUG]", [15, [12, 32, 0]]]], "%a[DEBUG]%a "];
   function printable(lvl){
    var _l_ = to_int(printed_level[1]);
    return _l_ <= to_int(lvl) ? 1 : 0;
   }
   function make_prefix(param){
    switch(param){
      case 0:
       return cst;
      case 1:
       return caml_call7
               (Stdlib_Format[141],
                _a_,
                Color[20],
                3,
                Color[20],
                9,
                Color[20],
                0);
      case 2:
       return caml_call7
               (Stdlib_Format[141],
                _b_,
                Color[20],
                3,
                Color[20],
                9,
                Color[20],
                0);
      case 3:
       return caml_call7
               (Stdlib_Format[141],
                _c_,
                Color[20],
                3,
                Color[20],
                9,
                Color[20],
                0);
      case 4:
       return caml_call7
               (Stdlib_Format[141],
                _d_,
                Color[20],
                4,
                Color[20],
                9,
                Color[20],
                0);
      case 5:
       return caml_call7
               (Stdlib_Format[141],
                _e_,
                Color[20],
                5,
                Color[20],
                9,
                Color[20],
                0);
      case 6:
       return caml_call7
               (Stdlib_Format[141],
                _f_,
                Color[20],
                6,
                Color[20],
                9,
                Color[20],
                0);
      case 7:
       return caml_call7
               (Stdlib_Format[141],
                _g_,
                Color[20],
                2,
                Color[20],
                9,
                Color[20],
                0);
      default:
       return caml_call5(Stdlib_Format[141], _h_, Color[20], 9, Color[20], 0);
    }
   }
   function get_out_channel(param){return param ? Stdlib[40] : Stdlib[39];}
   var
    LogLevel =
      [0, to_int, printed_level, printable, make_prefix, get_out_channel];
   function out(s, index, len){return 0;}
   function flush(param){return 0;}
   var
    null_formatter = caml_call2(Stdlib_Format[120], out, flush),
    cst_Exit = "Exit";
   function make_prefixed_multiline_format(out_channel, prefix){
    function out(s, index, len){
     var _j_ = len - 1 | 0, _i_ = 0;
     if(_j_ >= 0){
      var i = _i_;
      for(;;){
       var c = runtime.caml_string_get(s, index + i | 0);
       if(10 === c){
        caml_call2(Stdlib[66], out_channel, cst$0);
        caml_call2(Stdlib[66], out_channel, prefix);
       }
       else
        caml_call2(Stdlib[65], out_channel, c);
       var _k_ = i + 1 | 0;
       if(_j_ === i) break;
       i = _k_;
      }
     }
     return 0;
    }
    function flush(param){return caml_call1(Stdlib[63], out_channel);}
    return caml_call2(Stdlib_Format[120], out, flush);
   }
   function logk(k, lvl, fmt){
    if(! caml_call1(LogLevel[3], lvl))
     return caml_call3(Stdlib_Format[146], k, null_formatter, fmt);
    var
     out = caml_call1(LogLevel[5], lvl),
     prfx = caml_call1(LogLevel[4], lvl);
    if(prfx !== cst$3) caml_call2(Stdlib[66], out, prfx);
    var formatter = make_prefixed_multiline_format(out, prfx);
    return caml_call3(Stdlib_Format[144], k, formatter, fmt);
   }
   function flush_fmt(formatter){
    caml_call2(Stdlib_Format[38], formatter, 0);
    caml_call2(Stdlib[66], Stdlib[40], cst$1);
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   function log_exit(lvl, fmt){
    function flush_exit(fmt){
     flush_fmt(fmt);
     return caml_call1(Stdlib[2], cst_Exit);
    }
    return logk(flush_exit, lvl, fmt);
   }
   function output(fmt){return logk(flush_fmt, 0, fmt);}
   function fail(fmt){return log_exit(1, fmt);}
   function todo(fmt){return log_exit(2, fmt);}
   function error(fmt){return logk(flush_fmt, 3, fmt);}
   function success(fmt){return logk(flush_fmt, 4, fmt);}
   function warn(fmt){return logk(flush_fmt, 5, fmt);}
   function info(fmt){return logk(flush_fmt, 6, fmt);}
   function debug(fmt){return logk(flush_fmt, 8, fmt);}
   function log(fmt){return logk(flush_fmt, 7, fmt);}
   var
    Log =
      [0,
       LogLevel,
       null_formatter,
       make_prefixed_multiline_format,
       logk,
       flush_fmt,
       log_exit,
       output,
       fail,
       todo,
       error,
       success,
       warn,
       info,
       debug,
       log];
   runtime.caml_register_global(16, Log, "Log");
   return;
  }
  (globalThis));

//# 575 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_v_0 = "<v 0>",
    cst$0 = "@ ",
    cst_Unexpected_Overflow_in_dec = "Unexpected Overflow in decrement exp ",
    cst_Unexpected_Overflowx_in_in = "Unexpected Overflowx in increment exp",
    cst_lib_floats_ml = "lib/floats.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) === 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) === 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [17, [0, cst$0, 1, 0], [2, 0, [17, 0, 0]]],
    cst = "",
    Stdlib_Format = global_data.Stdlib__Format,
    Bitv = global_data.Bitv,
    Assert_failure = global_data.Assert_failure,
    Log = global_data.Log,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_String = global_data.Stdlib__String,
    Color = global_data.Color,
    Stdlib_Sys = global_data.Stdlib__Sys,
    _a_ =
      [0,
       [11,
        "exp: ",
        [4,
         3,
         [0, 1, 3],
         0,
         [11,
          " (biais: ",
          [4, 3, [0, 1, 10], 0, [11, ") mantissa: ", [4, 3, 0, 0, 0]]]]]],
       "exp: %3i (biais: %10i) mantissa: %i"];
   function pp_float_precision(fmt, param){
    var biais = param[3], exp = param[2], mantissa = param[1];
    return caml_call5(Stdlib_Format[137], fmt, _a_, exp, biais, mantissa);
   }
   function length(param){
    var exp = param[2], mantissa = param[1];
    return (1 + mantissa | 0) + exp | 0;
   }
   function build_precision(opt, mantissa, _O_, exp){
    if(opt) var sth = opt[1], name = sth; else var name = cst;
    if(_O_) var sth$0 = _O_[1], biais = sth$0; else var biais = 0;
    if(biais)
     var biais$0 = biais[1], biais$1 = biais$0;
    else
     var biais$1 = (1 << (exp - 1 | 0)) - 1 | 0;
    return [0, mantissa, exp, biais$1, name];
   }
   var
    mini = build_precision([0, "mini"], 3, 0, 4),
    half = build_precision([0, "half"], 10, 0, 5),
    single = build_precision([0, "single"], 23, 0, 8),
    double$0 = build_precision([0, "double"], 52, 0, 11),
    quadruple = build_precision([0, "quadruple"], 112, 0, 15),
    octuple = build_precision([0, "octuple"], 236, 0, 19),
    sz = Stdlib_Sys[9],
    cst_rounded = "rounded",
    cst_exact = "exact",
    _k_ = [0, cst_lib_floats_ml, 231, 13],
    _j_ =
      [0,
       [11, cst_Unexpected_Overflow_in_dec, 0],
       cst_Unexpected_Overflow_in_dec],
    _i_ = [0, cst_lib_floats_ml, 219, 13],
    _h_ =
      [0,
       [11, cst_Unexpected_Overflowx_in_in, 0],
       cst_Unexpected_Overflowx_in_in],
    cst_normal = "normal",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    cst_infinite = "infinite",
    cst_nan = "nan",
    _g_ = [0, cst_lib_floats_ml, 100, 11],
    _f_ = [0, cst_lib_floats_ml, 105, 11],
    _d_ = [0, [11, "+-+", [2, 0, [12, 43, [2, 0, [12, 43, 0]]]]], "+-+%s+%s+"],
    _e_ =
      [0,
       [18,
        [1, [0, [11, cst_v_0, 0], cst_v_0]],
        [2,
         0,
         [17,
          [0, cst$0, 1, 0],
          [12,
           124,
           [4, 3, 0, 0, [12, 124, [15, [12, 124, [15, [12, 124, partial]]]]]]]]]],
       "@[<v 0>%s@ |%i|%a|%a|@ %s@]"],
    _c_ = [0, [4, 3, 0, 0, [15, [15, [15, [15, 0]]]]], "%i%a%a%a%a"],
    _b_ = [0, [4, 3, 0, 0, [15, [15, 0]]], "%i%a%a"],
    _l_ =
      [0,
       [11, "Unknown word size: ", [4, 3, 0, 0, 0]],
       "Unknown word size: %i"],
    cst_Floats_Overflow = "Floats.Overflow",
    sys_precision =
      32 === sz ? single : 64 === sz ? double$0 : caml_call2(Log[8], _l_, sz);
   function copy(param){
    var
     m = param[4],
     e = param[3],
     s = param[2],
     p = param[1],
     e$0 = caml_call1(Bitv[10], e),
     m$0 = caml_call1(Bitv[10], m);
    return [0, p, s, e$0, m$0];
   }
   function pp(fmt, param){
    var
     m = param[4],
     e = param[3],
     s = param[2],
     _L_ = Bitv[37][3],
     _M_ = Bitv[38][3],
     _N_ = s ? 0 : 1;
    return caml_call7(Stdlib_Format[137], fmt, _b_, _N_, _M_, e, _L_, m);
   }
   function pp_ul(fmt, param){
    var
     m = param[4],
     e = param[3],
     s = param[2],
     _E_ = Bitv[37][3],
     _F_ = 0,
     _G_ = Color[20],
     _H_ = Bitv[38][3],
     _I_ = 11,
     _J_ = Color[20],
     _K_ = s ? 0 : 1;
    return caml_call11
            (Stdlib_Format[137],
             fmt,
             _c_,
             _K_,
             _J_,
             _I_,
             _H_,
             e,
             _G_,
             _F_,
             _E_,
             m);
   }
   function pp_boxed(fmt, param){
    var
     m = param[4],
     e = param[3],
     s = param[2],
     p = param[1],
     _z_ = caml_call2(Stdlib_String[1], p[1], 45),
     _A_ = caml_call2(Stdlib_String[1], p[2], 45),
     line = caml_call3(Stdlib_Format[141], _d_, _A_, _z_),
     _B_ = Bitv[37][3],
     _C_ = Bitv[38][3],
     _D_ = s ? 0 : 1;
    return caml_call9
            (Stdlib_Format[137], fmt, _e_, line, _D_, _C_, e, _B_, m, line);
   }
   function of_float(f){
    var _y_ = Stdlib_Obj[16];
    if(runtime.caml_obj_tag(f) !== _y_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     i = runtime.caml_obj_raw_field(f, 0),
     v = caml_call1(Bitv[58], i),
     l = length(sys_precision);
    if(caml_call1(Bitv[5], v) !== l)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     s = 1 - caml_call2(Bitv[4], v, l - 1 | 0),
     e =
       caml_call2
        (Bitv[2],
         sys_precision[2],
         function(i){return caml_call2(Bitv[4], v, sys_precision[1] + i | 0);}),
     m =
       caml_call2
        (Bitv[2],
         sys_precision[1],
         function(i){
          return caml_call2(Bitv[4], v, (sys_precision[1] - 1 | 0) - i | 0);
         });
    return [0, sys_precision, s, e, m];
   }
   function get_zero(opt, p){
    if(opt) var sth = opt[1], sign = sth; else var sign = 1;
    var e = caml_call2(Bitv[1], p[2], 0), m = caml_call2(Bitv[1], p[1], 0);
    return [0, p, sign, e, m];
   }
   function get_inf(sign, p){
    var e = caml_call2(Bitv[1], p[2], 1), m = caml_call2(Bitv[1], p[1], 0);
    return [0, p, sign, e, m];
   }
   function is_zero(param){
    var m = param[4], e = param[3], _x_ = caml_call1(Bitv[35], e);
    return _x_ ? caml_call1(Bitv[35], m) : _x_;
   }
   function is_nan(param){
    var
     m = param[4],
     e = param[3],
     _v_ = caml_call1(Bitv[36], e),
     _w_ = _v_ ? 1 - caml_call1(Bitv[35], m) : _v_;
    return _w_;
   }
   function is_inf(param){
    var m = param[4], e = param[3], _u_ = caml_call1(Bitv[36], e);
    return _u_ ? caml_call1(Bitv[35], m) : _u_;
   }
   function is_denormalized(param){
    var e = param[3];
    return caml_call1(Bitv[35], e);
   }
   function classify(param){
    var m = param[4], e = param[3];
    return caml_call1(Bitv[35], e)
            ? caml_call1(Bitv[35], m) ? 2 : 1
            : caml_call1(Bitv[36], e) ? caml_call1(Bitv[35], m) ? 3 : 4 : 0;
   }
   function pp_fpclass(fmt, param){
    switch(param){
      case 0:
       return caml_call2(Stdlib_Format[13], fmt, cst_normal);
      case 1:
       return caml_call2(Stdlib_Format[13], fmt, cst_subnormal);
      case 2:
       return caml_call2(Stdlib_Format[13], fmt, cst_zero);
      case 3:
       return caml_call2(Stdlib_Format[13], fmt, cst_infinite);
      default: return caml_call2(Stdlib_Format[13], fmt, cst_nan);
    }
   }
   var Overflow = [248, cst_Floats_Overflow, runtime.caml_fresh_oo_id(0)];
   function inc_mantissa(m){
    var i$1 = caml_call1(Bitv[5], m) - 1 | 0, i = i$1;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace(Overflow, 1);
     if(! caml_call2(Bitv[4], m, i)) return caml_call3(Bitv[3], m, i, 1);
     caml_call3(Bitv[3], m, i, 0);
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function dec_mantissa(m){
    var i$1 = caml_call1(Bitv[5], m) - 1 | 0, i = i$1;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace(Overflow, 1);
     if(caml_call2(Bitv[4], m, i)) return caml_call3(Bitv[3], m, i, 0);
     caml_call3(Bitv[3], m, i, 1);
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function inc_exp(e){
    var i = 0;
    for(;;){
     if(caml_call1(Bitv[5], e) <= i)
      throw caml_maybe_attach_backtrace(Overflow, 1);
     if(! caml_call2(Bitv[4], e, i)) return caml_call3(Bitv[3], e, i, 1);
     caml_call3(Bitv[3], e, i, 0);
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function dec_exp(e){
    var i = 0;
    for(;;){
     if(caml_call1(Bitv[5], e) <= i)
      throw caml_maybe_attach_backtrace(Overflow, 1);
     if(caml_call2(Bitv[4], e, i)) return caml_call3(Bitv[3], e, i, 0);
     caml_call3(Bitv[3], e, i, 1);
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function next_inf(f){
    var res = copy(f), m = res[4], e = res[3];
    if(is_inf(f)) return res;
    try{inc_mantissa(m); return res;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_ !== Overflow) throw caml_maybe_attach_backtrace(_q_, 0);
     if(! caml_call1(Bitv[35], m))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     try{inc_exp(e); return res;}
     catch(_t_){
      var _r_ = caml_wrap_exception(_t_);
      if(_r_ === Overflow) return caml_call1(Log[8], _h_);
      throw caml_maybe_attach_backtrace(_r_, 0);
     }
    }
   }
   function next_zero(f){
    var res = copy(f), m = res[4], e = res[3], s = res[2];
    if(is_zero(f)) return [0, res[1], 1 - s, res[3], res[4]];
    try{dec_mantissa(m); return res;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_ !== Overflow) throw caml_maybe_attach_backtrace(_m_, 0);
     if(! caml_call1(Bitv[36], m))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
     try{dec_exp(e); return res;}
     catch(_p_){
      var _n_ = caml_wrap_exception(_p_);
      if(_n_ === Overflow) return caml_call1(Log[8], _j_);
      throw caml_maybe_attach_backtrace(_n_, 0);
     }
    }
   }
   function succ(f){
    return is_zero(f)
            ? next_inf([0, f[1], 1, f[3], f[4]])
            : f[2] ? next_inf(f) : next_zero(f);
   }
   function pred(f){
    return is_zero(f)
            ? next_inf([0, f[1], 0, f[3], f[4]])
            : f[2] ? next_zero(f) : next_inf(f);
   }
   function pp_conversion_info(fmt, param){
    return param
            ? caml_call2(Stdlib_Format[13], fmt, cst_rounded)
            : caml_call2(Stdlib_Format[13], fmt, cst_exact);
   }
   var
    Floats =
      [0,
       pp_float_precision,
       length,
       build_precision,
       mini,
       half,
       single,
       double$0,
       quadruple,
       octuple,
       sys_precision,
       copy,
       pp,
       pp_ul,
       pp_boxed,
       of_float,
       get_zero,
       get_inf,
       is_zero,
       is_nan,
       is_inf,
       is_denormalized,
       classify,
       pp_fpclass,
       Overflow,
       inc_mantissa,
       dec_mantissa,
       inc_exp,
       dec_exp,
       next_inf,
       next_zero,
       succ,
       pred,
       pp_conversion_info];
   runtime.caml_register_global(35, Floats, "Floats");
   return;
  }
  (globalThis));

//# 983 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_0_ii = "%%0%ii",
    cst$1 = "+",
    cst$2 = "-",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$2,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Utils = global_data.Utils,
    Stdlib_Format = global_data.Stdlib__Format,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, "lib/decimal.ml", 35, 2],
    _b_ = [0, [12, 43, 0], cst$1],
    _c_ = [0, [12, 37, [12, 48, [4, 3, 0, 0, [12, 105, 0]]]], cst_0_ii],
    _d_ = [0, [12, 46, [2, 0, 0]], ".%s"],
    _e_ = [0, [12, 45, 0], cst$2],
    _f_ = [0, [0, [11, "0.0", 0]], "%c0.0"],
    _g_ =
      [0,
       [0, [0, [12, 46, [2, 0, [12, 101, [4, 3, 0, 0, 0]]]]]],
       "%c%c.%se%i"],
    _h_ = [0, [12, 37, [12, 48, [4, 3, 0, 0, [12, 105, 0]]]], cst_0_ii],
    _i_ = [0, [2, 0, [2, 0, 0]], "%s%s"];
   function extend_frac(d, size){
    if(d[4] > size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    if(size === d[4]) return d;
    var
     padd = caml_call1(Utils[2][78], size - d[4] | 0),
     frac_part = caml_call2(Utils[2][17], d[3], padd);
    return [0, d[1], d[2], frac_part, size];
   }
   function propagate_sign(d){
    var frac_part = d[3], int_part = d[2], sign = d[1];
    if(sign) return d;
    var
     int_part$0 = caml_call1(Utils[2][14], int_part),
     frac_part$0 = caml_call1(Utils[2][14], frac_part);
    return [0, d[1], int_part$0, frac_part$0, d[4]];
   }
   function add(d1, d2){
    var
     size_frac = caml_call2(Stdlib[17], d1[4], d2[4]),
     d1$0 = propagate_sign(extend_frac(d1, size_frac)),
     d2$0 = propagate_sign(extend_frac(d2, size_frac)),
     int_part = caml_call2(Utils[2][15], d1$0[2], d2$0[2]),
     frac_part = caml_call2(Utils[2][15], d1$0[3], d2$0[3]),
     fact = caml_call1(Utils[2][78], size_frac),
     match = runtime.ml_z_div_rem(frac_part, fact),
     frac_part$0 = match[2],
     overflow = match[1],
     int_part$0 = caml_call2(Utils[2][15], int_part, overflow),
     match$0 = caml_call2(Utils[2][42], int_part$0, Utils[2][2]),
     match$1 = caml_call2(Utils[2][42], frac_part$0, Utils[2][2]);
    if(match$0)
     if(match$1)
      var sign = 1, frac_part$1 = frac_part$0, int_part$1 = int_part$0;
     else if(runtime.ml_z_equal(int_part$0, Utils[2][2]))
      var
       sign = 0,
       frac_part$1 = caml_call1(Utils[2][14], frac_part$0),
       int_part$1 = int_part$0;
     else
      var
       int_part$2 = caml_call1(Utils[2][12], int_part$0),
       frac_part$2 = caml_call2(Utils[2][15], fact, frac_part$0),
       sign = 1,
       frac_part$1 = frac_part$2,
       int_part$1 = int_part$2;
    else if(match$1)
     var
      int_part$3 = caml_call1(Utils[2][12], int_part$0),
      frac_part$3 = caml_call2(Utils[2][16], fact, frac_part$0),
      sign = 0,
      frac_part$1 = frac_part$3,
      int_part$1 = caml_call1(Utils[2][14], int_part$3);
    else
     var
      frac_part$4 = caml_call1(Utils[2][14], frac_part$0),
      int_part$4 = caml_call1(Utils[2][14], int_part$0),
      sign = 0,
      frac_part$1 = frac_part$4,
      int_part$1 = int_part$4;
    return [0, sign, int_part$1, frac_part$1, size_frac];
   }
   function sub(d1, d2){
    var d2$0 = [0, 1 - d2[1], d2[2], d2[3], d2[4]];
    return add(d1, d2$0);
   }
   function pp(fmt, d){
    if(d[1])
     caml_call2(Stdlib_Format[137], fmt, _b_);
    else
     caml_call2(Stdlib_Format[137], fmt, _e_);
    caml_call2(Utils[2][40], fmt, d[2]);
    if(runtime.ml_z_equal(Utils[2][2], d[3])) return 0;
    var
     _t_ = d[3],
     _u_ = runtime.ml_z_format(caml_call2(Stdlib_Format[140], _c_, d[4]), _t_);
    return caml_call3(Stdlib_Format[137], fmt, _d_, _u_);
   }
   function pp_scientific(significand, fmt, d){
    if(caml_equal(d[2], Utils[2][2]) && caml_equal(d[3], Utils[2][2])){
     var _m_ = d[1] ? 43 : 45;
     return caml_call3(Stdlib_Format[137], fmt, _f_, _m_);
    }
    if(caml_equal(d[2], Utils[2][2]))
     var
      str = caml_call1(Utils[2][35], d[3]),
      str$0 = str,
      pow = ((- d[4] | 0) - 1 | 0) + caml_ml_string_length(str) | 0;
    else
     var
      int_str = caml_call1(Utils[2][35], d[2]),
      pow$0 = caml_ml_string_length(int_str) - 1 | 0,
      _r_ = d[3],
      _s_ =
        runtime.ml_z_format(caml_call2(Stdlib_Format[140], _h_, d[4]), _r_),
      str$1 = caml_call3(Stdlib_Format[141], _i_, int_str, _s_),
      str$0 = str$1,
      pow = pow$0;
    if(significand)
     var
      i = significand[1],
      _n_ =
        0 < i
         ? caml_call2(Stdlib[16], i, caml_ml_string_length(str$0) - 1 | 0)
         : caml_ml_string_length(str$0) - 1 | 0,
      len = _n_;
    else
     var len = caml_ml_string_length(str$0) - 1 | 0;
    var
     _o_ = caml_call3(Stdlib_String[16], str$0, 1, len),
     _p_ = runtime.caml_string_get(str$0, 0),
     _q_ = d[1] ? 43 : 45;
    return caml_call6(Stdlib_Format[137], fmt, _g_, _q_, _p_, _o_, pow);
   }
   function from_int(i){
    if(0 <= i)
     var i$0 = i, sign = 1;
    else
     var i$1 = - i | 0, i$0 = i$1, sign = 0;
    return [0, sign, i$0, Utils[2][2], 0];
   }
   function _j_(str){
    var l = caml_ml_string_length(str);
    if(caml_call2(Stdlib_String[11], cst, str))
     var pos = 1, sign = 1;
    else if(caml_call2(Stdlib_String[11], cst$0, str))
     var pos = 1, sign = 0;
    else
     var pos = 0, sign = 1;
    var match = caml_call2(Stdlib_String[37], str, 46);
    if(match){
     var
      i = match[1],
      int_part = caml_call3(Utils[2][9], str, pos, i - pos | 0),
      size_frac = (l - i | 0) - 1 | 0,
      frac_part = caml_call3(Utils[2][9], str, i + 1 | 0, (l - i | 0) - 1 | 0);
     return [0, sign, int_part, frac_part, size_frac];
    }
    var int_part$0 = caml_call3(Utils[2][9], str, pos, l - pos | 0);
    return [0, sign, int_part$0, Utils[2][2], 0];
   }
   function pow10(d, p){
    if(0 === p) return d;
    if(0 < p){
     var
      size_frac = caml_call2(Stdlib[17], 0, d[4] - p | 0),
      fact = caml_call1(Utils[2][78], size_frac),
      match = runtime.ml_z_div_rem(d[3], fact),
      frac_part = match[2],
      div = match[1],
      fact_int = caml_call1(Utils[2][78], p),
      _k_ = caml_call2(Utils[2][17], d[2], fact_int),
      int_part = caml_call2(Utils[2][15], div, _k_);
     return [0, d[1], int_part, frac_part, size_frac];
    }
    var
     p$0 = - p | 0,
     size_frac$0 = p$0 + d[4] | 0,
     fact$0 = caml_call1(Utils[2][78], p$0),
     match$0 = runtime.ml_z_div_rem(d[2], fact$0),
     rem = match$0[2],
     int_part$0 = match$0[1],
     fact_frac = caml_call1(Utils[2][78], d[4]),
     _l_ = caml_call2(Utils[2][17], fact_frac, rem),
     frac_part$0 = caml_call2(Utils[2][15], d[3], _l_);
    return [0, d[1], int_part$0, frac_part$0, size_frac$0];
   }
   function from_string(s){
    var match = caml_call2(Stdlib_String[37], s, 101);
    if(! match) return _j_(s);
    var
     idx = match[1],
     significand = caml_call3(Stdlib_String[16], s, 0, idx),
     exponent =
       caml_call3
        (Stdlib_String[16],
         s,
         idx + 1 | 0,
         (caml_ml_string_length(s) - idx | 0) - 1 | 0),
     d = _j_(significand);
    return pow10(d, runtime.caml_int_of_string(exponent));
   }
   var
    Decimal =
      [0,
       extend_frac,
       propagate_sign,
       add,
       sub,
       pp,
       pp_scientific,
       from_int,
       pow10,
       from_string];
   runtime.caml_register_global(16, Decimal, "Decimal");
   return;
  }
  (globalThis));

//# 1236 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Bitv = global_data.Bitv,
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    _a_ = [0, [12, 46, [15, 0]], ".%a"],
    _b_ = [0, [2, 0, [12, 40, [15, [11, ")*", 0]]]], "%s(%a)*"];
   function pp(fmt, param){
    var
     repeating = param[4],
     fractional = param[3],
     integer = param[2],
     sign = param[1];
    if(1 - sign) caml_call2(Stdlib_Format[23], fmt, 45);
    if(0 < caml_call1(Bitv[5], integer))
     caml_call2(Bitv[38][3], fmt, integer);
    else
     caml_call2(Stdlib_Format[23], fmt, 48);
    caml_call4(Stdlib_Format[137], fmt, _a_, Bitv[37][3], fractional);
    var _t_ = 0 < caml_call1(Bitv[5], repeating) ? 1 : 0;
    return _t_
            ? caml_call5
              (Stdlib_Format[137], fmt, _b_, cst, Bitv[37][3], repeating)
            : _t_;
   }
   function from_int(x){
    if(0 <= x)
     var x$0 = x, sign = 1;
    else
     var x$1 = - x | 0, x$0 = x$1, sign = 0;
    var
     integer = caml_call1(Bitv[48], x$0),
     fractional = caml_call2(Bitv[1], 0, 0);
    return [0, sign, integer, fractional, fractional];
   }
   var zero = from_int(0);
   function get_bit(bin, i){
    if(0 <= i)
     return i < caml_call1(Bitv[5], bin[2])
             ? caml_call2(Bitv[4], bin[2], i)
             : 0;
    var i$0 = (- i | 0) - 1 | 0, len_under = caml_call1(Bitv[5], bin[3]);
    if(i$0 < len_under) return caml_call2(Bitv[4], bin[3], i$0);
    var i$1 = i$0 - len_under | 0, len_repeat = caml_call1(Bitv[5], bin[4]);
    if(0 === len_repeat) return 0;
    var _s_ = runtime.caml_mod(i$1, len_repeat);
    return caml_call2(Bitv[4], bin[4], _s_);
   }
   var Found = [248, "Binary.Found", runtime.caml_fresh_oo_id(0)];
   function get_first_non_null(bin){
    try{
     var _j_ = caml_call1(Bitv[5], bin[2]) - 1 | 0;
     if(_j_ >= 0){
      var i$2 = _j_;
      for(;;){
       if(caml_call2(Bitv[4], bin[2], i$2))
        throw caml_maybe_attach_backtrace([0, Found, i$2], 1);
       var _r_ = i$2 - 1 | 0;
       if(0 === i$2) break;
       i$2 = _r_;
      }
     }
     var _l_ = caml_call1(Bitv[5], bin[3]) - 1 | 0, _k_ = 0;
     if(_l_ >= 0){
      var i$1 = _k_;
      for(;;){
       if(caml_call2(Bitv[4], bin[3], i$1))
        throw caml_maybe_attach_backtrace([0, Found, - (i$1 + 1 | 0) | 0], 1);
       var _q_ = i$1 + 1 | 0;
       if(_l_ === i$1) break;
       i$1 = _q_;
      }
     }
     var _n_ = caml_call1(Bitv[5], bin[4]) - 1 | 0, _m_ = 0;
     if(_n_ >= 0){
      var i$0 = _m_;
      for(;;){
       if(caml_call2(Bitv[4], bin[4], i$0))
        throw caml_maybe_attach_backtrace
               ([0,
                 Found,
                 - ((i$0 + caml_call1(Bitv[5], bin[3]) | 0) + 1 | 0) | 0],
                1);
       var _p_ = i$0 + 1 | 0;
       if(_n_ === i$0) break;
       i$0 = _p_;
      }
     }
     var _o_ = 0;
     return _o_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found) throw caml_maybe_attach_backtrace(exn, 0);
     var i = exn[2];
     return [0, i];
    }
   }
   function is_null_after(b, bit){
    var
     _f_ = caml_call1(Bitv[5], b[3]),
     thresh = - ((caml_call1(Bitv[5], b[4]) + _f_ | 0) + 1 | 0) | 0,
     i = bit;
    for(;;){
     var _g_ = i < thresh ? 1 : 0;
     if(_g_)
      var _h_ = _g_;
     else{
      var _i_ = 1 - get_bit(b, i);
      if(_i_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _h_ = _i_;
     }
     return _h_;
    }
   }
   function compare(b1, b2){
    var _c_ = b2[1];
    if(b1[1]){if(! _c_) return -1;} else if(_c_) return 1;
    var match = get_first_non_null(b1), match$0 = get_first_non_null(b2);
    if(! match) return match$0 ? b1[1] ? -1 : 1 : 0;
    var i1 = match[1];
    if(! match$0) return b1[1] ? 1 : -1;
    var i2 = match$0[1];
    if(i1 !== i2) return b1[1] ? i1 - i2 | 0 : i2 - i1 | 0;
    var
     _d_ = caml_call1(Bitv[5], b1[3]),
     _e_ = caml_call1(Bitv[5], b1[3]),
     lim = caml_call2(Stdlib[17], _e_, _d_),
     lim$0 = - lim | 0,
     i = i1;
    for(;;){
     if(i < lim$0) return 0;
     var match$1 = get_bit(b1, i), match$2 = get_bit(b2, i);
     if(match$1){
      if(! match$2) return b1[1] ? 1 : -1;
     }
     else if(match$2) return b1[1] ? -1 : 1;
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   var
    Binary =
      [0,
       pp,
       from_int,
       zero,
       get_bit,
       Found,
       get_first_non_null,
       is_null_after,
       compare];
   runtime.caml_register_global(8, Binary, "Binary");
   return;
  }
  (globalThis));

//# 1423 "../lib/.FloatView.objs/jsoo/default/FloatView.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Exceeding_fractional_limit = "Exceeding fractional limite search",
    cst_Implement_conversion_for_r = "Implement conversion for repeating part",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Floats = global_data.Floats,
    Binary = global_data.Binary,
    Bitv = global_data.Bitv,
    Stdlib = global_data.Stdlib,
    Log = global_data.Log,
    Z = global_data.Z,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    frac_lim = 5000,
    _a_ =
      [0,
       [11, cst_Exceeding_fractional_limit, 0],
       cst_Exceeding_fractional_limit],
    _b_ =
      [0,
       [11, cst_Implement_conversion_for_r, 0],
       cst_Implement_conversion_for_r],
    _c_ =
      [0, [11, "Impossible Overflow: ", [15, 0]], "Impossible Overflow: %a"];
   function dec_to_bin(d){
    var
     i = [0, d[2]],
     _o_ = runtime.ml_z_numbits(d[2]),
     integer =
       caml_call2
        (Bitv[2],
         _o_,
         function(param){
          var res = caml_call1(Z[48], i[1]);
          i[1] = caml_call2(Z[31], i[1], 1);
          return res;
         });
    if(0 === d[4]){
     var fractional = caml_call2(Bitv[1], 0, 0);
     return [0, d[1], integer, fractional, fractional];
    }
    var
     tbl = caml_call2(Stdlib_Hashtbl[1], 0, 50),
     fractional$0 = caml_call2(Bitv[1], frac_lim, 0),
     _p_ = runtime.ml_z_pow(10, d[4] - 1 | 0),
     divisor = caml_call2(Z[17], 5, _p_),
     rem$1 = d[3],
     i$0 = 0,
     rem = rem$1;
    for(;;){
     if(5000 <= i$0){
      caml_call1(Log[12], _a_);
      var match$0 = [0, i$0, i$0];
     }
     else if(runtime.ml_z_equal(Z[2], rem))
      var match$0 = [0, i$0, i$0];
     else{
      caml_call3(Stdlib_Hashtbl[5], tbl, rem, i$0);
      var b = caml_call2(Z[42], rem, divisor);
      if(b)
       var
        _q_ = caml_call2(Z[16], rem, divisor),
        rem$0 = caml_call2(Z[29], _q_, 1);
      else
       var rem$0 = caml_call2(Z[29], rem, 1);
      caml_call3(Bitv[3], fractional$0, i$0, b);
      var match = caml_call2(Stdlib_Hashtbl[7], tbl, rem$0);
      if(! match){var i$1 = i$0 + 1 | 0; i$0 = i$1; rem = rem$0; continue;}
      var j = match[1], match$0 = [0, j, i$0 + 1 | 0];
     }
     var
      lim_rep = match$0[2],
      lim_frac = match$0[1],
      repeating =
        caml_call3(Bitv[13], fractional$0, lim_frac, lim_rep - lim_frac | 0),
      fractional$1 = caml_call3(Bitv[13], fractional$0, 0, lim_frac);
     return [0, d[1], integer, fractional$1, repeating];
    }
   }
   function bin_to_dec(b){
    if(0 !== caml_call1(Bitv[5], b[4])) caml_call1(Log[9], _b_);
    var
     int_part =
       caml_call3
        (Bitv[21],
         function(bi, acc){
          var acc$0 = caml_call2(Z[29], acc, 1);
          return bi ? caml_call1(Z[11], acc$0) : acc$0;
         },
         b[2],
         Z[2]),
     ten = 10,
     five = 5,
     match =
       caml_call3
        (Bitv[20],
         function(param, b){
          var
           i = param[3],
           pow = param[2],
           acc = param[1],
           acc$0 = caml_call2(Z[17], acc, ten),
           pow$0 = caml_call2(Z[17], pow, five),
           acc$1 = b ? caml_call2(Z[15], acc$0, pow$0) : acc$0;
          return [0, acc$1, pow$0, i + 1 | 0];
         },
         [0, Z[2], Z[3], 0],
         b[3]),
     size_frac = match[3],
     frac_part = match[1];
    return [0, b[1], int_part, frac_part, size_frac];
   }
   function bin_to_float_info(p, bin){
    var sign = bin[1], match = caml_call1(Binary[6], bin);
    if(! match) return [0, caml_call2(Floats[16], [0, sign], p), 0];
    var is = match[1], exp = [0, is + p[3] | 0];
    if(0 >= exp[1]){
     if(0 >= (exp[1] + p[1] | 0))
      return [0, caml_call2(Floats[16], [0, bin[1]], p), 1];
     var
      e$0 = caml_call2(Bitv[1], p[2], 0),
      m$0 =
        caml_call2
         (Bitv[2],
          p[1],
          function(i){
           return caml_call2(Binary[4], bin, (- p[3] | 0) - i | 0);
          }),
      s = bin[1],
      rnd$0 =
        caml_call2(Binary[7], bin, ((- p[3] | 0) - p[1] | 0) + 1 | 0) ? 0 : 1;
     return [0, [0, p, s, e$0, m$0], rnd$0];
    }
    var e = caml_call2(Bitv[1], p[2], 0), _i_ = p[2] - 1 | 0, _h_ = 0;
    if(_i_ >= 0){
     var i = _h_;
     for(;;){
      if(0 !== (exp[1] % 2 | 0)) caml_call3(Bitv[3], e, i, 1);
      exp[1] = exp[1] / 2 | 0;
      var _l_ = i + 1 | 0;
      if(_i_ === i) break;
      i = _l_;
     }
    }
    if(0 >= exp[1] && ! caml_call1(Bitv[36], e)){
     var
      m =
        caml_call2
         (Bitv[2],
          p[1],
          function(i){
           return caml_call2(Binary[4], bin, (is - i | 0) - 1 | 0);
          }),
      round = caml_call2(Binary[4], bin, (is - p[1] | 0) - 1 | 0);
     if(round)
      try{caml_call1(Floats[25], m);}
      catch(_m_){
       var _j_ = caml_wrap_exception(_m_);
       if(_j_ !== Floats[24]) throw caml_maybe_attach_backtrace(_j_, 0);
       try{caml_call1(Floats[27], e);}
       catch(_n_){
        var _k_ = caml_wrap_exception(_n_);
        if(_k_ !== Floats[24]) throw caml_maybe_attach_backtrace(_k_, 0);
        caml_call3(Log[14], _c_, Floats[13], [0, p, sign, e, m]);
       }
      }
     var rnd = caml_call2(Binary[7], bin, (is - p[1] | 0) - 1 | 0) ? 0 : 1;
     return [0, [0, p, sign, e, m], rnd];
    }
    return [0, caml_call2(Floats[17], bin[1], p), 1];
   }
   function bin_to_float(p, bin){
    var res = bin_to_float_info(p, bin)[1];
    return res;
   }
   var
    IsInf = [248, "Convert.IsInf", caml_fresh_oo_id(0)],
    IsNan = [248, "Convert.IsNan", caml_fresh_oo_id(0)];
   function float_to_bin(f){
    var sign = f[2];
    if(caml_call1(Floats[18], f)){
     var _d_ = Binary[3];
     return [0, sign, _d_[2], _d_[3], _d_[4]];
    }
    if(caml_call1(Bitv[36], f[3])){
     if(caml_call1(Bitv[35], f[4]))
      throw caml_maybe_attach_backtrace([0, IsInf, f[2]], 1);
     throw caml_maybe_attach_backtrace(IsNan, 1);
    }
    var exp = caml_call1(Bitv[49], f[3]), exp$0 = exp - f[1][3] | 0;
    if(0 <= exp$0)
     var
      len_frac = caml_call2(Stdlib[17], 0, f[1][1] - exp$0 | 0),
      len_int = exp$0 + 1 | 0;
    else
     var
      len_frac$0 = (- exp$0 | 0) + f[1][1] | 0,
      len_frac = len_frac$0,
      len_int = 0;
    var
     integer = caml_call2(Bitv[1], len_int, 0),
     fractional = caml_call2(Bitv[1], len_frac, 0),
     _f_ = f[1][1],
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      var
       b =
         0 === i
          ? 1 - caml_call1(Floats[21], f)
          : caml_call2(Bitv[4], f[4], i - 1 | 0);
      if(0 <= exp$0)
       if(i < len_int)
        caml_call3(Bitv[3], integer, (len_int - i | 0) - 1 | 0, b);
       else
        caml_call3(Bitv[3], fractional, i - len_int | 0, b);
      else
       caml_call3(Bitv[3], fractional, ((- exp$0 | 0) + i | 0) - 1 | 0, b);
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    var repeating = caml_call2(Bitv[1], 0, 0);
    return [0, sign, integer, fractional, repeating];
   }
   var
    Convert =
      [0,
       frac_lim,
       dec_to_bin,
       bin_to_dec,
       bin_to_float_info,
       bin_to_float,
       IsInf,
       IsNan,
       float_to_bin];
   runtime.caml_register_global(12, Convert, "Convert");
   return;
  }
  (globalThis));

//# 5 "../.js/default/ojs/ojs.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_to_js$0 = "to_js",
    caml_js_from_string = runtime.caml_js_from_string,
    caml_js_get = runtime.caml_js_get,
    caml_js_set = runtime.caml_js_set,
    caml_js_to_bool = runtime.caml_js_to_bool,
    caml_js_to_string = runtime.caml_js_to_string;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    shared = [0, cst_to_js$0],
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_Array = global_data.Stdlib__Array;
   function type_of(x){return caml_js_to_string(typeof x);}
   function instance_of(x, constr){return (x instanceof constr ? 1 : 0) | 0;}
   var null$0 = null, undefined$0 = undefined, global = globalThis;
   function array_make(n){return new global.Array(n);}
   var
    array_get = caml_js_get,
    array_set = caml_js_set,
    cst_to_js = cst_to_js$0;
   function array_of_js_from(f, objs, start){
    var n = objs.length;
    return caml_call2
            (Stdlib_Array[1],
             n - start | 0,
             function(i){
              var i$0 = start + i | 0;
              return caml_call1(f, objs[i$0]);
             });
   }
   function array_of_js(f, objs){return array_of_js_from(f, objs, 0);}
   function array_to_js(f, arr){
    var n = arr.length - 1, a = array_make(n), _C_ = n - 1 | 0, _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var x = caml_call1(f, runtime.caml_check_bound(arr, i)[1 + i]);
      a[i] = x;
      var _D_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _D_;
     }
    }
    return a;
   }
   function list_of_js_from(f, objs, start){
    var _A_ = array_of_js_from(f, objs, start);
    return caml_call1(Stdlib_Array[9], _A_);
   }
   function list_of_js(f, objs){return list_of_js_from(f, objs, 0);}
   function list_to_js(f, l){
    return array_to_js(f, caml_call1(Stdlib_Array[10], l));
   }
   function option_of_js(f, x){
    return x == null$0 ? 0 : [0, caml_call1(f, x)];
   }
   function option_to_js(f, param){
    if(! param) return null$0;
    var x = param[1];
    return caml_call1(f, x);
   }
   function unit_to_js(param){return undefined$0;}
   function unit_of_js(param){return 0;}
   var
    obj =
      caml_call2
       (CamlinternalOO[19],
        shared,
        function(_t_){
         var
          _u_ = caml_call2(CamlinternalOO[3], _t_, cst),
          _v_ = caml_call2(CamlinternalOO[7], _t_, cst_to_js);
         caml_call3
          (CamlinternalOO[10],
           _t_,
           _v_,
           function(self_1){return self_1[1 + _u_];});
         return function(_y_, _x_, _w_){
          var _z_ = caml_call2(CamlinternalOO[24], _x_, _t_);
          _z_[1 + _u_] = _w_;
          return _z_;};
        });
   function has_property(o, x){
    var _q_ = type_of(o) === "object" ? 1 : 0;
    if(_q_)
     var
      _r_ = o !== null$0 ? 1 : 0,
      _s_ = _r_ ? o[caml_js_from_string(x)] !== undefined$0 ? 1 : 0 : _r_;
    else
     var _s_ = _q_;
    return _s_;
   }
   function empty_obj(param){return new global.Object;}
   function iter_properties(x, f){
    return runtime.caml_ojs_iterate_properties
            (x,
             runtime.caml_js_wrap_callback_strict
              (1, function(x){return caml_call1(f, caml_js_to_string(x));}));
   }
   function apply_arr(o, arr){return o.apply(null$0, arr);}
   function call_arr(o, s, arr){
    return o[caml_js_from_string(s)].apply(o, arr);
   }
   function is_null(x){return x == null$0 ? 1 : 0;}
   function obj_type(x){
    return caml_js_to_string(Object.prototype.toString.call(x));
   }
   function t_to_js(_p_){return _p_;}
   function t_of_js(_o_){return _o_;}
   var
    Int = [0, t_to_js, t_of_js],
    t_to_js$0 = caml_js_from_string,
    t_of_js$0 = caml_js_to_string,
    String = [0, t_to_js$0, t_of_js$0],
    t_to_js$1 = runtime.caml_js_from_bool,
    t_of_js$1 = caml_js_to_bool,
    Bool = [0, t_to_js$1, t_of_js$1];
   function t_to_js$2(_n_){return _n_;}
   function t_of_js$2(_m_){return _m_;}
   var Float = [0, t_to_js$2, t_of_js$2];
   function Array(A){
    var _i_ = A[1];
    function t_to_js(_l_){return array_to_js(_i_, _l_);}
    var _j_ = A[2];
    function t_of_js(_k_){return array_of_js(_j_, _k_);}
    return [0, t_to_js, t_of_js];
   }
   function List(A){
    var _e_ = A[1];
    function t_to_js(_h_){return list_to_js(_e_, _h_);}
    var _f_ = A[2];
    function t_of_js(_g_){return list_of_js(_f_, _g_);}
    return [0, t_to_js, t_of_js];
   }
   function Option(A){
    var _a_ = A[1];
    function t_to_js(_d_){return option_to_js(_a_, _d_);}
    var _b_ = A[2];
    function t_of_js(_c_){return option_of_js(_b_, _c_);}
    return [0, t_to_js, t_of_js];
   }
   var
    Ojs =
      [0,
       array_of_js,
       array_to_js,
       list_of_js,
       list_to_js,
       array_of_js_from,
       list_of_js_from,
       option_of_js,
       option_to_js,
       unit_of_js,
       unit_to_js,
       empty_obj,
       has_property,
       iter_properties,
       call_arr,
       apply_arr,
       array_make,
       array_get,
       array_set,
       global,
       null$0,
       type_of,
       instance_of,
       obj,
       is_null,
       obj_type,
       Int,
       String,
       Bool,
       Float,
       Array,
       List,
       Option];
   runtime.caml_register_global(16, Ojs, "Ojs");
   return;
  }
  (globalThis));

//# 5 "bindings/.js_core.objs/jsoo/default/js_core.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_body = "body",
    cst_input$0 = "input",
    cst_table$0 = "table",
    cst_tbody$0 = "tbody",
    cst_td$0 = "td",
    cst_thead$0 = "thead",
    cst_tr$0 = "tr",
    caml_js_from_string = runtime.caml_js_from_string,
    caml_js_to_string = runtime.caml_js_to_string,
    caml_js_wrap_callback_strict = runtime.caml_js_wrap_callback_strict,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ojs = global_data.Ojs,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure;
   function unknown_of_js(x2){return x2;}
   function unknown_to_js(x1){return x1;}
   function element_of_js(x4){return x4;}
   function element_to_js(x3){return x3;}
   function text_of_js(x6){return x6;}
   function text_to_js(x5){return x5;}
   function comment_of_js(x8){return x8;}
   function comment_to_js(x7){return x7;}
   function processing_instruction_node_of(x10){return x10;}
   function processing_instruction_node_to(x9){return x9;}
   function document_of_js(x12){return x12;}
   function document_to_js(x11){return x11;}
   function document_type_of_js(x14){return x14;}
   function document_type_to_js(x13){return x13;}
   function document_fragment_of_js(x16){return x16;}
   function document_fragment_to_js(x15){return x15;}
   function deprecated_of_js(x18){return x18;}
   function deprecated_to_js(x17){return x17;}
   var
    Node =
      [0,
       element_of_js,
       element_to_js,
       text_of_js,
       text_to_js,
       comment_of_js,
       comment_to_js,
       processing_instruction_node_of,
       processing_instruction_node_to,
       document_of_js,
       document_to_js,
       document_type_of_js,
       document_type_to_js,
       document_fragment_of_js,
       document_fragment_to_js,
       deprecated_of_js,
       deprecated_to_js];
   function body_of_js(x20){return x20;}
   function body_to_js(x19){return x19;}
   function input_of_js(x22){return x22;}
   function input_to_js(x21){return x21;}
   function table_of_js(x24){return x24;}
   function table_to_js(x23){return x23;}
   function tbody_of_js(x26){return x26;}
   function tbody_to_js(x25){return x25;}
   function td_of_js(x28){return x28;}
   function td_to_js(x27){return x27;}
   function th_of_js(x30){return x30;}
   function th_to_js(x29){return x29;}
   function thead_of_js(x32){return x32;}
   function thead_to_js(x31){return x31;}
   function tr_of_js(x34){return x34;}
   function tr_to_js(x33){return x33;}
   var
    Html =
      [0,
       body_of_js,
       body_to_js,
       input_of_js,
       input_to_js,
       table_of_js,
       table_to_js,
       tbody_of_js,
       tbody_to_js,
       td_of_js,
       td_to_js,
       th_of_js,
       th_to_js,
       thead_of_js,
       thead_to_js,
       tr_of_js,
       tr_to_js],
    Kinds = [0, unknown_of_js, unknown_to_js, Node, Html];
   function untyped_of_js(x36){return x36;}
   function append_child(x38, x37){x38.appendChild(x37); return 0;}
   function parent_node(x39){var x36 = x39.parentNode; return x36;}
   function base_URI(x40){return caml_js_to_string(x40.baseURI);}
   function clone_node(x41){var x36 = x41.cloneNode; return x36;}
   function first_child(x42){
    return caml_call2(Ojs[7], untyped_of_js, x42.firstChild);
   }
   function has_child_nodes(x44){return x44.hasChildNodes | 0;}
   function last_child(x45){
    return caml_call2(Ojs[7], untyped_of_js, x45.lastChild);
   }
   function children(x47){
    return caml_call2(Ojs[1], untyped_of_js, x47.children);
   }
   function remove_child(x51, x50){x51.removeChild(x50); return 0;}
   function set_text_content(x52, x53){
    return x52.textContent = caml_js_from_string(x53);
   }
   function text_content(x54){return caml_js_to_string(x54.textContent);}
   function t_of_js(param, x36){return x36;}
   function t_to_js(param, x35){return x35;}
   function node_type(x49){
    var switcher = x49.nodeType - 1 | 0;
    if(10 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return [0, -744106340, x49];
       case 2:
        return [0, 936573133, x49];
       case 6:
        return [0, -3153068, x49];
       case 7:
        return [0, -826170817, x49];
       case 8:
        return [0, -188437701, x49];
       case 9:
        return [0, -595819627, x49];
       case 10:
        return [0, 1059191339, x49];
     }
    return [0, -86768749, x49];
   }
   var
    Node$0 =
      [0,
       t_of_js,
       t_to_js,
       append_child,
       parent_node,
       base_URI,
       clone_node,
       first_child,
       has_child_nodes,
       last_child,
       children,
       remove_child,
       set_text_content,
       text_content,
       node_type];
   function untyped_of_js$0(x57){
    return caml_call2(Node$0[1], Kinds[3][1], x57);
   }
   function untyped_to_js(x55){
    return caml_call2(Node$0[2], Kinds[3][2], x55);
   }
   function has_attribute(x60, x59){
    var _N_ = caml_js_from_string(x59);
    return untyped_to_js(x60).hasAttribute(_N_) | 0;
   }
   function set_attribute(x63, x61, x62){
    var _L_ = caml_js_from_string(x62), _M_ = caml_js_from_string(x61);
    untyped_to_js(x63).setAttribute(_M_, _L_);
    return 0;
   }
   function get_attribute(x65, x64){
    var _K_ = caml_js_from_string(x64);
    return caml_js_to_string(untyped_to_js(x65).getAttribute(_K_));
   }
   function has_attribute_n_s(x68, x66, x67){
    var _I_ = caml_js_from_string(x67), _J_ = caml_js_from_string(x66);
    return untyped_to_js(x68).hasAttributeNS(_J_, _I_) | 0;
   }
   function set_attribute_n_s(x72, x69, x70, x71){
    var
     _F_ = caml_js_from_string(x71),
     _G_ = caml_js_from_string(x70),
     _H_ = caml_js_from_string(x69);
    untyped_to_js(x72).setAttributeNS(_H_, _G_, _F_);
    return 0;
   }
   function get_attribute_n_s(x75, x73, x74){
    var _D_ = caml_js_from_string(x74), _E_ = caml_js_from_string(x73);
    return caml_js_to_string(untyped_to_js(x75).getAttributeNS(_E_, _D_));
   }
   function remove_attribute(x77, x76){
    var _C_ = caml_js_from_string(x76);
    untyped_to_js(x77).removeAttribute(_C_);
    return 0;
   }
   function set_class_name(x78, x79){
    var _B_ = caml_js_from_string(x79);
    return untyped_to_js(x78).className = _B_;
   }
   function get_class_name(x80){
    return caml_js_to_string(untyped_to_js(x80).getClassName);
   }
   function set_innerHTML(x81, x82){
    var _A_ = caml_js_from_string(x82);
    return untyped_to_js(x81).innerHTML = _A_;
   }
   function inner_HTML(x83){
    return caml_js_to_string(untyped_to_js(x83).innerHTML);
   }
   function set_outer_HTML(x84, x85){
    var _z_ = caml_js_from_string(x85);
    return untyped_to_js(x84).outerHTML = _z_;
   }
   function outer_HTML(x86){
    return caml_js_to_string(untyped_to_js(x86).outerHTML);
   }
   function set_onclick(x87, x88){
    return untyped_to_js(x87).onclick =
            caml_js_wrap_callback_strict
             (1, function(x89){return caml_call1(x88, untyped_of_js$0(x89));});
   }
   function set_ondbclick(x90, x91){
    return untyped_to_js(x90).ondbclick =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x91, 0);});
   }
   function set_onblur(x92, x93){
    return untyped_to_js(x92).onblur =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x93, 0);});
   }
   function set_onfocus(x94, x95){
    return untyped_to_js(x94).onfocus =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x95, 0);});
   }
   function set_onchange(x96, x97){
    return untyped_to_js(x96).onchange =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x97, 0);});
   }
   function set_onmouseover(x98, x99){
    return untyped_to_js(x98).onmouseover =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x99, 0);});
   }
   function set_onkeyup(x100, x101){
    return untyped_to_js(x100).onkeyup =
            caml_js_wrap_callback_strict
             (1,
              function(x102){return caml_call1(x101, untyped_of_js$0(x102));});
   }
   function set_oninput(x103, x104){
    return untyped_to_js(x103).oninput =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x104, 0);});
   }
   function tag_name(x105){
    return caml_js_to_string(untyped_to_js(x105).tagName);
   }
   function content_editable(x106){
    return untyped_to_js(x106).contentEditable | 0;
   }
   function set_content_editable(x107, x108){
    return untyped_to_js(x107).contentEditable = ! ! x108;
   }
   function options(x109){
    var _y_ = untyped_to_js(x109).options;
    return caml_call2(Ojs[1], untyped_of_js$0, _y_);
   }
   function selected_index(x111){return untyped_to_js(x111).selectedIndex;}
   function key(x112){return caml_js_to_string(untyped_to_js(x112).key);}
   function detail(x113){return untyped_to_js(x113).detail;}
   function t_of_js$0(param, x){return untyped_of_js$0(x);}
   function t_to_js$0(param, x){return untyped_to_js(x);}
   function unsafe_cast(x){return x;}
   var
    Element =
      [0,
       t_of_js$0,
       t_to_js$0,
       has_attribute,
       set_attribute,
       get_attribute,
       has_attribute_n_s,
       set_attribute_n_s,
       get_attribute_n_s,
       remove_attribute,
       set_class_name,
       get_class_name,
       set_innerHTML,
       inner_HTML,
       set_outer_HTML,
       outer_HTML,
       set_onclick,
       set_ondbclick,
       set_onblur,
       set_onfocus,
       set_onchange,
       set_onmouseover,
       set_onkeyup,
       set_oninput,
       key,
       detail,
       unsafe_cast,
       tag_name,
       options,
       selected_index,
       content_editable,
       set_content_editable],
    cst_input = cst_input$0,
    cst_table = cst_table$0,
    cst_tr = cst_tr$0,
    cst_td = cst_td$0,
    cst_th = "th",
    cst_tbody = cst_tbody$0,
    cst_thead = cst_thead$0;
   function t_of_js$1(x116){return caml_call2(Node$0[1], Kinds[3][9], x116);}
   function t_to_js$1(x114){return caml_call2(Node$0[2], Kinds[3][10], x114);}
   function set_title(x118, x119){
    var _x_ = caml_js_from_string(x119);
    return t_to_js$1(x118).title = _x_;
   }
   function title(x120){return caml_js_to_string(t_to_js$1(x120).title);}
   function get_element_by_id(x122, x121){
    var
     _v_ = caml_js_from_string(x121),
     _w_ = t_to_js$1(x122).getElementById(_v_);
    return caml_call2
            (Ojs[7],
             function(x123){return caml_call2(Element[1], Kinds[1], x123);},
             _w_);
   }
   function get_elements_by_class_name(x126, x125){
    var
     _t_ = caml_js_from_string(x125),
     _u_ = t_to_js$1(x126).getElementsByClassName(_t_);
    return caml_call2
            (Ojs[1],
             function(x127){return caml_call2(Element[1], Kinds[1], x127);},
             _u_);
   }
   function create_element(x130, x129){
    var
     _r_ = caml_js_from_string(x129),
     _s_ = t_to_js$1(x130).createElement(_r_);
    return caml_call2(Element[1], Kinds[1], _s_);
   }
   function create_element_n_s(x134, x132, x133){
    var
     _o_ = caml_js_from_string(x133),
     _p_ = caml_js_from_string(x132),
     _q_ = t_to_js$1(x134).createElementNS(_p_, _o_);
    return caml_call2(Element[1], Kinds[1], _q_);
   }
   function create_text_node(x137, x136){
    var
     _m_ = caml_js_from_string(x136),
     _n_ = t_to_js$1(x137).createTextNode(_m_);
    return caml_call2(Node$0[1], Kinds[3][3], _n_);
   }
   function body(x139){
    var _l_ = t_to_js$1(x139).body;
    return caml_call2(Element[1], Kinds[4][1], _l_);
   }
   function height(x141){return t_to_js$1(x141).height;}
   function width(x142){return t_to_js$1(x142).width;}
   function create_html_input(document){
    var _k_ = create_element(document, cst_input);
    return caml_call1(Element[26], _k_);
   }
   function create_html_table(document){
    var _j_ = create_element(document, cst_table);
    return caml_call1(Element[26], _j_);
   }
   function create_html_tr(document){
    var _i_ = create_element(document, cst_tr);
    return caml_call1(Element[26], _i_);
   }
   function create_html_td(document){
    var _h_ = create_element(document, cst_td);
    return caml_call1(Element[26], _h_);
   }
   function create_html_th(document){
    var _g_ = create_element(document, cst_th);
    return caml_call1(Element[26], _g_);
   }
   function create_html_tbody(document){
    var _f_ = create_element(document, cst_tbody);
    return caml_call1(Element[26], _f_);
   }
   function create_html_thead(document){
    var _e_ = create_element(document, cst_thead);
    return caml_call1(Element[26], _e_);
   }
   var
    Document =
      [0,
       t_of_js$1,
       t_to_js$1,
       set_title,
       title,
       get_element_by_id,
       get_elements_by_class_name,
       create_element,
       create_element_n_s,
       create_text_node,
       body,
       height,
       width,
       create_html_input,
       create_html_table,
       create_html_tr,
       create_html_td,
       create_html_th,
       create_html_tbody,
       create_html_thead];
   function t_of_js$2(x144){return x144;}
   function t_to_js$2(x143){return x143;}
   function document(x145){return caml_call1(Document[1], x145.document);}
   function inner_height(x146){return x146.innerHeight;}
   function inner_width(x147){return x147.innerWidth;}
   function set_onload(x148, x149){
    return x148.onload =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x149, 0);});
   }
   var
    Window =
      [0,
       t_of_js$2,
       t_to_js$2,
       document,
       inner_height,
       inner_width,
       set_onload];
   function t_of_js$3(x151){return x151;}
   function t_to_js$3(x150){return x150;}
   function log(x153, x152){x153.log(x152); return 0;}
   function log_string(x155, x154){
    x155.log(caml_js_from_string(x154));
    return 0;
   }
   var Console = [0, t_of_js$3, t_to_js$3, log, log_string];
   function parse(x156){return Ojs[19].JSON.parse(caml_js_from_string(x156));}
   function stringify(x157){
    return caml_js_to_string(Ojs[19].JSON.stringify(x157));
   }
   var JSON = [0, parse, stringify];
   function t_of_js$4(x159){return x159;}
   function t_to_js$4(x158){return x158;}
   function name(x160){return caml_js_to_string(x160.name);}
   var File = [0, t_of_js$4, t_to_js$4, name];
   function t_of_js$5(x162){return x162;}
   function t_to_js$5(x161){return x161;}
   function item(x164, x163){
    var _d_ = x164.item(x163);
    return caml_call2(Ojs[7], File[1], _d_);
   }
   function length(x166){return x166.length;}
   var
    FileList = [0, t_of_js$5, t_to_js$5, item, length],
    _a_ = [0, "_none_", 0, -1];
   function state_of_js(x168){
    if(2 < x168 >>> 0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    switch(x168){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function state_to_js(x167){
    switch(x167){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function t_of_js$6(x171){return x171;}
   function t_to_js$6(x170){return x170;}
   function new_file_reader(param){
    var x171 = new Ojs[19].FileReader;
    return x171;
   }
   function ready_state(x172){return state_of_js(x172.readyState);}
   function result(x173){
    return caml_call2(Ojs[7], caml_js_to_string, x173.result);
   }
   function set_onload$0(x175, x176){
    return x175.onload =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x176, 0);});
   }
   function read_as_text(x178, x177){
    x178.readAsText(caml_call1(File[2], x177));
    return 0;
   }
   var
    FileReader =
      [0,
       state_of_js,
       state_to_js,
       t_of_js$6,
       t_to_js$6,
       new_file_reader,
       ready_state,
       result,
       set_onload$0,
       read_as_text];
   function t_of_js$7(x181){return caml_call2(Element[1], Kinds[4][3], x181);}
   function t_to_js$7(x179){return caml_call2(Element[2], Kinds[4][4], x179);}
   function files(x183){
    var _c_ = t_to_js$7(x183).files;
    return caml_call1(FileList[1], _c_);
   }
   function value(x184){return caml_js_to_string(t_to_js$7(x184).value);}
   var Input = [0, t_of_js$7, t_to_js$7, files, value];
   function retype(x){
    var
     _b_ = caml_call1(Element[27], x),
     match = caml_call1(Stdlib_String[27], _b_);
    return match !== cst_body
            ? match
              !== cst_input$0
              ? match
                !== cst_table$0
                ? match
                  !== cst_tbody$0
                  ? match
                    !== cst_td$0
                    ? match
                      !== cst_thead$0
                      ? match
                        !== cst_tr$0
                        ? 785140586
                        : [0, 18846, caml_call1(Element[26], x)]
                      : [0, 582214516, caml_call1(Element[26], x)]
                    : [0, 18832, caml_call1(Element[26], x)]
                  : [0, 516175094, caml_call1(Element[26], x)]
                : [0, 504440814, caml_call1(Element[26], x)]
              : [0, -783600662, caml_call1(Element[26], x)]
            : [0, 737453762, caml_call1(Element[26], x)];
   }
   var
    Html$0 = [0, Input, retype],
    window = caml_call1(Window[1], Ojs[19].window);
   function alert(x185){Ojs[19].alert(caml_js_from_string(x185)); return 0;}
   var
    console = caml_call1(Console[1], Ojs[19].console),
    GlobalVariables = [0, window, alert, console],
    Js_core =
      [0,
       Kinds,
       Node$0,
       Element,
       Document,
       Window,
       Console,
       JSON,
       File,
       FileList,
       FileReader,
       Html$0,
       GlobalVariables];
   runtime.caml_register_global(91, Js_core, "Js_core");
   return;
  }
  (globalThis));

//# 4 ".floatview_js.eobjs/jsoo/dune__exe.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dune_exe = [0];
   runtime.caml_register_global(0, Dune_exe, "Dune__exe");
   return;
  }
  (globalThis));

//# 5 ".floatview_js.eobjs/jsoo/dune__exe__Log.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Js_core = global_data.Js_core,
    cst_Exit = "Exit";
   function make_prefixed_multiline_format(chan){
    var buffer = caml_call1(Stdlib_Buffer[1], 80);
    function out(s, param, _a_){
     return caml_call2(Stdlib_Buffer[16], buffer, s);
    }
    function flush(param){
     var string = caml_call1(Stdlib_Buffer[2], buffer);
     return chan
             ? caml_call1(Js_core[12][2], string)
             : caml_call2(Js_core[6][4], Js_core[12][3], string);
    }
    return caml_call2(Stdlib_Format[120], out, flush);
   }
   function logk(chan, k, fmt){
    var formatter = make_prefixed_multiline_format(chan);
    return caml_call3(Stdlib_Format[144], k, formatter, fmt);
   }
   function flush_fmt(formatter){
    return caml_call2(Stdlib_Format[38], formatter, 0);
   }
   function log(fmt){return logk(0, flush_fmt, fmt);}
   function error(fmt){
    function flush_exit(fmt){
     flush_fmt(fmt);
     return caml_call1(Stdlib[2], cst_Exit);
    }
    return logk(1, flush_exit, fmt);
   }
   var
    log_obj = caml_call1(Js_core[6][3], Js_core[12][3]),
    Dune_exe_Log =
      [0,
       make_prefixed_multiline_format,
       logk,
       flush_fmt,
       log,
       error,
       log_obj];
   runtime.caml_register_global(5, Dune_exe_Log, "Dune__exe__Log");
   return;
  }
  (globalThis));

//# 5 ".floatview_js.eobjs/jsoo/dune__exe__Helper.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_style$2 = "style";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Js_core = global_data.Js_core,
    Dune_exe_Log = global_data.Dune__exe__Log,
    document = caml_call1(Js_core[5][3], Js_core[12][1]),
    cst_style = cst_style$2,
    cst_id = "id",
    _a_ =
      [0,
       [11, "Element of id '", [2, 0, [11, "' not found", 0]]],
       "Element of id '%s' not found"],
    cst_display_none = "display: none",
    cst_style$0 = cst_style$2,
    cst_style$1 = cst_style$2;
   function removeAll(element){
    for(;;){
     var match = caml_call1(Js_core[2][9], element);
     if(match){
      var child = match[1];
      caml_call2(Js_core[2][11], element, child);
      var _b_ = 1;
     }
     else
      var _b_ = 0;
     if(! _b_) return 0;
    }
   }
   function create(text, class_name, style, id, name){
    var element = caml_call2(Js_core[4][7], document, name);
    if(text){
     var text$0 = text[1];
     caml_call2(Js_core[2][12], element, text$0);
    }
    if(style){
     var style$0 = style[1];
     caml_call3(Js_core[3][4], element, cst_style, style$0);
    }
    if(id){
     var id$0 = id[1];
     caml_call3(Js_core[3][4], element, cst_id, id$0);
    }
    if(class_name){
     var class_name$0 = class_name[1];
     caml_call2(Js_core[3][10], element, class_name$0);
    }
    return element;
   }
   function element_of_id(id){
    var match = caml_call2(Js_core[4][5], document, id);
    if(! match) return caml_call2(Dune_exe_Log[5], _a_, id);
    var element = match[1];
    return element;
   }
   function hide(element){
    return caml_call3(Js_core[3][4], element, cst_style$0, cst_display_none);
   }
   function show(element){
    return caml_call2(Js_core[3][9], element, cst_style$1);
   }
   var
    Helper = [0, document, removeAll, create, element_of_id, hide, show],
    Dune_exe_Helper = [0, Helper];
   runtime.caml_register_global(8, Dune_exe_Helper, "Dune__exe__Helper");
   return;
  }
  (globalThis));

//# 5 ".floatview_js.eobjs/jsoo/dune__exe__Utils.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function remove_whitespaces(str){
    var
     bytes = runtime.caml_create_bytes(runtime.caml_ml_string_length(str)),
     i =
       caml_call3
        (Stdlib_String[20],
         function(i, c){
          if(32 !== c && 10 !== c && 9 !== c){
           runtime.caml_bytes_set(bytes, i, c);
           return i + 1 | 0;
          }
          return i;
         },
         0,
         str);
    return caml_call3(Stdlib_Bytes[8], bytes, 0, i);
   }
   var Dune_exe_Utils = [0, remove_whitespaces];
   runtime.caml_register_global(2, Dune_exe_Utils, "Dune__exe__Utils");
   return;
  }
  (globalThis));

//# 5 ".floatview_js.eobjs/jsoo/dune__exe__Floatview_js.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_a = "%a",
    cst_Inf$3 = "+Inf",
    cst_Inf$4 = "-Inf",
    cst_0$6 = "0",
    cst_1$4 = "1",
    cst_Enter = "Enter",
    cst_Nan$1 = "Nan",
    cst_container = "container",
    cst_dec_in$0 = "dec_in",
    cst_dec_out$0 = "dec_out",
    cst_dec_output = "dec_output",
    cst_div$11 = "div",
    cst_err_out$0 = "err_out",
    cst_float = "float",
    cst_float_repr$1 = "float_repr",
    cst_input = "input",
    cst_pre$1 = "pre",
    cst_status$4 = "status",
    cst_td$2 = "td",
    cst_th_bit = "th bit\n",
    cst_title$5 = "title",
    cst_usage = "usage",
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    available_precisions =
      [0, "mini", [0, "half", [0, "single", [0, "double", 0]]]],
    Dune_exe_Helper = global_data.Dune__exe__Helper,
    Js_core = global_data.Js_core,
    Dune_exe_Utils = global_data.Dune__exe__Utils,
    Decimal = global_data.Decimal,
    Convert = global_data.Convert,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Dune_exe_Log = global_data.Dune__exe__Log,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    Floats = global_data.Floats,
    Bitv = global_data.Bitv,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Map = global_data.Stdlib__Map,
    StringMap = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]);
   function add_precision(p, map){
    return caml_call3(StringMap[2], p[4], p, map);
   }
   var
    _S_ = add_precision(Floats[4], StringMap[1]),
    _T_ = add_precision(Floats[5], _S_),
    _U_ = add_precision(Floats[6], _T_),
    precisions = add_precision(Floats[7], _U_),
    current_precision = [0, Floats[5]],
    current_dec = [0, caml_call1(Decimal[7], 0)],
    current_float = [0, caml_call2(Floats[16], [0, 0], current_precision[1])],
    pp_dec = [0, caml_call1(Decimal[6], [0, 10])],
    cst_dec_out = cst_dec_out$0,
    cst_err_out = cst_err_out$0,
    cst_Inf = cst_Inf$3,
    cst_Inf$0 = cst_Inf$3,
    cst_Inf$1 = cst_Inf$4,
    cst_Inf$2 = cst_Inf$4,
    cst_Nan = cst_Nan$1,
    cst_Nan$0 = cst_Nan$1,
    _a_ = [0, [15, 0], cst_a],
    _b_ = [0, [15, 0], cst_a],
    _c_ =
      [0,
       [11,
        "Cannot update bit ",
        [4, 3, 0, 0, [11, " of float with size ", [4, 3, 0, 0, 0]]]],
       "Cannot update bit %i of float with size %i"],
    cst_tr = "tr",
    _d_ = [0, cst_float],
    cst_1 = cst_1$4,
    cst_status = cst_status$4,
    cst_0 = cst_0$6,
    cst_1$0 = cst_1$4,
    cst_status$0 = cst_status$4,
    cst_0$0 = cst_0$6,
    cst_0$1 = cst_0$6,
    cst_td = cst_td$2,
    _e_ = [0, "sign"],
    cst_status$1 = cst_status$4,
    _f_ = [0, [4, 3, 0, 0, [11, "th bit\nsign bit", 0]], "%ith bit\nsign bit"],
    cst_title = cst_title$5,
    cst_1$1 = cst_1$4,
    cst_td$0 = cst_td$2,
    _g_ = [0, "exp"],
    _h_ =
      [0,
       [4,
        3,
        0,
        0,
        [11, cst_th_bit, [4, 3, 0, 0, [11, "th exponent bit", 0]]]],
       "%ith bit\n%ith exponent bit"],
    cst_title$0 = cst_title$5,
    cst_status$2 = cst_status$4,
    cst_0$2 = cst_0$6,
    cst_1$2 = cst_1$4,
    cst_td$1 = cst_td$2,
    _i_ = [0, "mantissa"],
    _j_ =
      [0,
       [4,
        3,
        0,
        0,
        [11, cst_th_bit, [4, 3, 0, 0, [11, "th mantissa bit", 0]]]],
       "%ith bit\n%ith mantissa bit"],
    cst_title$1 = cst_title$5,
    cst_status$3 = cst_status$4,
    cst_0$3 = cst_0$6,
    cst_1$3 = cst_1$4,
    cst_div = cst_div$11,
    _k_ = [0, cst_container],
    cst_div$0 = cst_div$11,
    _l_ = [0, cst_usage],
    _m_ = [0, cst_input],
    cst_div$1 = cst_div$11,
    _n_ = [0, cst_dec_in$0],
    _o_ = [0, "dec_input"],
    _p_ = [0, cst_0$6],
    cst_0$4 = cst_0$6,
    _q_ = [0, [11, "Error: ", [2, 0, 0]], "Error: %s"],
    cst_float_repr = cst_float_repr$1,
    cst_div$2 = cst_div$11,
    _r_ = [0, cst_container],
    cst_div$3 = cst_div$11,
    _s_ = [0, cst_usage],
    _t_ = [0, "Decimal value"],
    cst_pre = cst_pre$1,
    _u_ = [0, cst_dec_out$0],
    _v_ = [0, cst_dec_output],
    _w_ = [0, [15, 0], cst_a],
    cst_div$4 = cst_div$11,
    _x_ = [0, cst_container],
    cst_div$5 = cst_div$11,
    _y_ = [0, cst_usage],
    _z_ = [0, "Error value"],
    cst_error_value_input = "error = value - input",
    cst_title$2 = cst_title$5,
    cst_pre$0 = cst_pre$1,
    _A_ = [0, cst_err_out$0],
    _B_ = [0, cst_dec_output],
    _C_ = [0, [15, 0], cst_a],
    cst_div$6 = cst_div$11,
    _D_ = [0, cst_container],
    cst_div$7 = cst_div$11,
    _E_ = [0, cst_usage],
    _F_ = [0, "Select precision"],
    cst_select = "select",
    _G_ = [0, "precision"],
    cst_option = "option",
    _H_ =
      [0,
       [11,
        "mantissa: ",
        [4,
         3,
         0,
         0,
         [11,
          " bits\nexponent: ",
          [4, 3, 0, 0, [11, " bits\nbiais: ", [4, 3, 0, 0, 0]]]]]],
       "mantissa: %i bits\nexponent: %i bits\nbiais: %i"],
    cst_title$3 = cst_title$5,
    cst_dec_in = cst_dec_in$0,
    cst_0$5 = cst_0$6,
    _I_ =
      [0,
       [11, "Issue with setting value ", [2, 0, 0]],
       "Issue with setting value %s"],
    cst_float_repr$0 = cst_float_repr$1,
    cst_div$8 = cst_div$11,
    _J_ = [0, cst_container],
    cst_div$9 = cst_div$11,
    _K_ = [0, cst_usage],
    _L_ = [0, "Significand digits"],
    cst_number_of_significand_digi =
      "number of significand digit in the decimal output\nUse 0 for unlimited significand\nUse -1 to not use scientific notation",
    cst_title$4 = cst_title$5,
    cst_div$10 = cst_div$11,
    _M_ = [0, "significand"],
    _N_ = [0, cst_input],
    _O_ = [0, "10"],
    cst_button = "button",
    _P_ = [0, "update"],
    cst_main = "main",
    cst_table = "table",
    _Q_ = [0, cst_float_repr$1],
    _R_ = [0, cst_float];
   function update_decimal(param){
    var
     n_dec = caml_call1(Dune_exe_Helper[1][4], cst_dec_out),
     n_err = caml_call1(Dune_exe_Helper[1][4], cst_err_out);
    try{
     var
      b = caml_call1(Convert[8], current_float[1]),
      d = caml_call1(Convert[3], b),
      txt = caml_call3(Stdlib_Format[141], _a_, pp_dec[1], d);
     caml_call2(Js_core[2][12], n_dec, txt);
     var
      d_err = caml_call2(Decimal[4], d, current_dec[1]),
      txt$0 = caml_call3(Stdlib_Format[141], _b_, pp_dec[1], d_err),
      _ap_ = caml_call2(Js_core[2][12], n_err, txt$0);
     return _ap_;
    }
    catch(_aq_){
     var _ao_ = caml_wrap_exception(_aq_);
     if(_ao_[1] === Convert[6])
      return _ao_[2]
              ? (caml_call2
                 (Js_core[2][12], n_dec, cst_Inf),
                caml_call2(Js_core[2][12], n_err, cst_Inf$0))
              : (caml_call2
                 (Js_core[2][12], n_dec, cst_Inf$1),
                caml_call2(Js_core[2][12], n_err, cst_Inf$2));
     if(_ao_ !== Convert[7]) throw caml_maybe_attach_backtrace(_ao_, 0);
     caml_call2(Js_core[2][12], n_dec, cst_Nan);
     return caml_call2(Js_core[2][12], n_err, cst_Nan$0);
    }
   }
   function add_float(table){
    var tr = caml_call5(Dune_exe_Helper[1][3], 0, _d_, 0, 0, cst_tr);
    function dbclick(td, param){
     var
      txt = caml_call1(Js_core[2][13], td),
      txt$0 = txt === cst_0$6 ? cst_1 : cst_0,
      children = caml_call1(Js_core[2][10], tr);
     caml_call2
      (Stdlib_Array[11],
       function(n){
        caml_call3(Js_core[3][4], n, cst_status, txt$0);
        return caml_call2(Js_core[2][12], n, txt$0);
       },
       children);
     var
      bool = txt$0 === cst_1$4 ? 1 : 0,
      match = current_float[1],
      m = match[4],
      e = match[3],
      p = match[1],
      s = 1 - bool;
     caml_call4(Bitv[14], e, 0, p[2], bool);
     caml_call4(Bitv[14], m, 0, p[1], bool);
     var _an_ = current_float[1];
     current_float[1] = [0, _an_[1], s, _an_[3], _an_[4]];
     return update_decimal(0);
    }
    function click(td, i$1, e$0){
     if(1 < caml_call1(Js_core[3][25], e$0)) return dbclick(td, 0);
     var
      txt = caml_call1(Js_core[2][13], td),
      txt$0 = txt === cst_0$6 ? cst_1$0 : cst_0$0;
     caml_call2(Js_core[2][12], td, txt$0);
     caml_call3(Js_core[3][4], td, cst_status$0, txt$0);
     var
      match = current_float[1],
      m = match[4],
      e = match[3],
      s = match[2],
      p = match[1],
      len = caml_call1(Floats[2], p);
     a:
     {
      if(0 <= i$1 && len > i$1){
       if(i$1 === (len - 1 | 0)){
        var s$0 = 1 - s, _ak_ = current_float[1];
        current_float[1] = [0, _ak_[1], s$0, _ak_[3], _ak_[4]];
        break a;
       }
       if(i$1 < p[1]){
        var
         i = (p[1] - i$1 | 0) - 1 | 0,
         _al_ = 1 - caml_call2(Bitv[4], m, i);
        caml_call3(Bitv[3], m, i, _al_);
        break a;
       }
       var i$0 = i$1 - p[1] | 0, _am_ = 1 - caml_call2(Bitv[4], e, i$0);
       caml_call3(Bitv[3], e, i$0, _am_);
       break a;
      }
      caml_call3(Dune_exe_Log[5], _c_, i$1, len);
     }
     return update_decimal(0);
    }
    caml_call1(Dune_exe_Helper[1][2], table);
    var
     f = current_float[1],
     text = f[2] ? cst_0$1 : cst_1$3,
     td_sign = caml_call5(Dune_exe_Helper[1][3], [0, text], _e_, 0, 0, cst_td);
    caml_call3(Js_core[3][4], td_sign, cst_status$1, text);
    var
     _aa_ = caml_call1(Floats[2], f[1]) - 1 | 0,
     _ab_ = caml_call2(Stdlib_Format[140], _f_, _aa_);
    caml_call3(Js_core[3][4], td_sign, cst_title, _ab_);
    var _ac_ = f[1][2] + f[1][1] | 0;
    caml_call2
     (Js_core[3][16],
      td_sign,
      function(_aj_){return click(td_sign, _ac_, _aj_);});
    caml_call2(Js_core[2][3], tr, td_sign);
    var
     last =
       caml_call3
        (Bitv[21],
         function(v, i){
          var
           text = v ? cst_1$1 : cst_0$2,
           td =
             caml_call5(Dune_exe_Helper[1][3], [0, text], _g_, 0, 0, cst_td$0),
           _ag_ = caml_call3(Stdlib_Format[140], _h_, i, i - f[1][1] | 0);
          caml_call3(Js_core[3][4], td, cst_title$0, _ag_);
          caml_call3(Js_core[3][4], td, cst_status$2, text);
          caml_call2
           (Js_core[3][16], td, function(_ai_){return click(td, i, _ai_);});
          caml_call2
           (Js_core[3][17], td, function(_ah_){return dbclick(td, _ah_);});
          caml_call2(Js_core[2][3], tr, td);
          return i - 1 | 0;
         },
         f[3],
         (f[1][2] + f[1][1] | 0) - 1 | 0);
    caml_call3
     (Bitv[20],
      function(i, v){
       var
        text = v ? cst_1$2 : cst_0$3,
        td = caml_call5(Dune_exe_Helper[1][3], [0, text], _i_, 0, 0, cst_td$1),
        _ad_ = caml_call3(Stdlib_Format[140], _j_, i, i);
       caml_call3(Js_core[3][4], td, cst_title$1, _ad_);
       caml_call3(Js_core[3][4], td, cst_status$3, text);
       caml_call2
        (Js_core[3][16], td, function(_af_){return click(td, i, _af_);});
       caml_call2
        (Js_core[3][17], td, function(_ae_){return dbclick(td, _ae_);});
       caml_call2(Js_core[2][3], tr, td);
       return i - 1 | 0;
      },
      last,
      f[4]);
    return caml_call2(Js_core[2][3], table, tr);
   }
   function onload(param){
    var
     main = caml_call1(Dune_exe_Helper[1][4], cst_main),
     container$2 = caml_call5(Dune_exe_Helper[1][3], 0, _D_, 0, 0, cst_div$6),
     usage$2 = caml_call5(Dune_exe_Helper[1][3], _F_, _E_, 0, 0, cst_div$7),
     select = caml_call5(Dune_exe_Helper[1][3], 0, 0, 0, _G_, cst_select);
    caml_call2
     (Stdlib_List[18],
      function(p){
       var
        option =
          caml_call5(Dune_exe_Helper[1][3], [0, p], 0, 0, 0, cst_option),
        p$0 = caml_call2(StringMap[17], p, precisions),
        title = caml_call4(Stdlib_Format[141], _H_, p$0[1], p$0[2], p$0[3]);
       caml_call3(Js_core[3][4], option, cst_title$3, title);
       return caml_call2(Js_core[2][3], select, option);
      },
      available_precisions);
    caml_call2(Js_core[2][3], container$2, usage$2);
    caml_call2(Js_core[2][3], container$2, select);
    caml_call2(Js_core[2][3], main, container$2);
    function change(param){
     var
      idx = caml_call1(Js_core[3][29], select),
      options = caml_call1(Js_core[3][28], select),
      option = runtime.caml_check_bound(options, idx)[1 + idx],
      text = caml_call1(Js_core[2][13], option),
      precision = caml_call2(StringMap[17], text, precisions),
      decimal = caml_call1(Dune_exe_Helper[1][4], cst_dec_in),
      str = caml_call1(Js_core[2][13], decimal);
     try{
      var
       d = caml_call1(Decimal[9], str),
       b = caml_call1(Convert[2], d),
       f = caml_call2(Convert[5], precision, b);
      current_precision[1] = precision;
      current_float[1] = f;
      var table = caml_call1(Dune_exe_Helper[1][4], cst_float_repr$0);
      add_float(table);
      var _$_ = update_decimal(0);
      return _$_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      caml_call2(Js_core[2][12], decimal, cst_0$5);
      var ___ = caml_call1(Stdlib_Printexc[1], exn);
      return caml_call2(Dune_exe_Log[5], _I_, ___);
     }
    }
    caml_call2(Js_core[3][20], select, change);
    var
     container = caml_call5(Dune_exe_Helper[1][3], 0, _k_, 0, 0, cst_div),
     usage = caml_call5(Dune_exe_Helper[1][3], _m_, _l_, 0, 0, cst_div$0);
    caml_call2(Js_core[2][3], container, usage);
    var
     input = caml_call5(Dune_exe_Helper[1][3], _p_, _o_, 0, _n_, cst_div$1);
    function click(param){return caml_call2(Js_core[3][31], input, 1);}
    function blur(a){
     var code = caml_call1(Js_core[3][24], a);
     if(code !== cst_Enter && code !== "Escape") return 0;
     var
      str = caml_call1(Js_core[2][13], input),
      str$0 = caml_call1(Dune_exe_Utils[1], str);
     caml_call2(Js_core[2][12], input, str$0);
     try{
      var d = caml_call1(Decimal[9], str$0);
      current_dec[1] = d;
      var
       b = caml_call1(Convert[2], d),
       f = caml_call2(Convert[5], current_precision[1], b);
      current_float[1] = f;
      var table = caml_call1(Dune_exe_Helper[1][4], cst_float_repr);
      add_float(table);
      var _Z_ = update_decimal(0);
      return _Z_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      caml_call2(Js_core[2][12], input, cst_0$4);
      var _Y_ = caml_call1(Stdlib_Printexc[1], exn);
      return caml_call2(Dune_exe_Log[5], _q_, _Y_);
     }
    }
    caml_call2(Js_core[3][16], input, click);
    caml_call2(Js_core[3][22], input, blur);
    caml_call2(Js_core[2][3], container, input);
    caml_call2(Js_core[2][3], main, container);
    var table = caml_call5(Dune_exe_Helper[1][3], 0, _R_, 0, _Q_, cst_table);
    caml_call2(Js_core[2][3], main, table);
    add_float(table);
    var
     container$0 = caml_call5(Dune_exe_Helper[1][3], 0, _r_, 0, 0, cst_div$2),
     usage$0 = caml_call5(Dune_exe_Helper[1][3], _t_, _s_, 0, 0, cst_div$3);
    caml_call2(Js_core[2][3], container$0, usage$0);
    var
     pre_decimal = caml_call5(Dune_exe_Helper[1][3], 0, _v_, 0, _u_, cst_pre),
     _V_ = caml_call1(Convert[8], current_float[1]),
     d = caml_call1(Convert[3], _V_),
     _W_ = caml_call3(Stdlib_Format[141], _w_, Decimal[5], d);
    caml_call2(Js_core[2][12], pre_decimal, _W_);
    caml_call2(Js_core[2][3], container$0, pre_decimal);
    caml_call2(Js_core[2][3], main, container$0);
    var
     container$1 = caml_call5(Dune_exe_Helper[1][3], 0, _x_, 0, 0, cst_div$4),
     usage$1 = caml_call5(Dune_exe_Helper[1][3], _z_, _y_, 0, 0, cst_div$5);
    caml_call3(Js_core[3][4], usage$1, cst_title$2, cst_error_value_input);
    caml_call2(Js_core[2][3], container$1, usage$1);
    var
     pre_error = caml_call5(Dune_exe_Helper[1][3], 0, _B_, 0, _A_, cst_pre$0),
     err = caml_call2(Decimal[4], d, current_dec[1]),
     _X_ = caml_call3(Stdlib_Format[141], _C_, Decimal[5], err);
    caml_call2(Js_core[2][12], pre_error, _X_);
    caml_call2(Js_core[2][3], container$1, pre_error);
    caml_call2(Js_core[2][3], main, container$1);
    var
     parent = caml_call5(Dune_exe_Helper[1][3], 0, _J_, 0, 0, cst_div$8),
     usage$3 = caml_call5(Dune_exe_Helper[1][3], _L_, _K_, 0, 0, cst_div$9);
    caml_call3
     (Js_core[3][4], usage$3, cst_title$4, cst_number_of_significand_digi);
    var
     area = caml_call5(Dune_exe_Helper[1][3], _O_, _N_, 0, _M_, cst_div$10);
    caml_call2(Js_core[3][31], area, 1);
    function update_significand(i){
     if(0 <= i)
      if(0 === i){
       var arg = Decimal[6];
       pp_dec[1] = function(eta){return caml_call2(arg, 0, eta);};
      }
      else
       pp_dec[1] = caml_call1(Decimal[6], [0, i]);
     else
      pp_dec[1] = Decimal[5];
     return update_decimal(0);
    }
    function update_enter(e){
     var code = caml_call1(Js_core[3][24], e);
     if(code !== cst_Enter) return 0;
     var
      str = caml_call1(Js_core[2][13], area),
      str$0 = caml_call1(Dune_exe_Utils[1], str);
     caml_call2(Js_core[2][12], area, str$0);
     var var$0 = caml_int_of_string(str$0);
     return update_significand(var$0);
    }
    caml_call2(Js_core[3][22], area, update_enter);
    var button = caml_call5(Dune_exe_Helper[1][3], _P_, 0, 0, 0, cst_button);
    function update(param){
     var
      txt = caml_call1(Js_core[2][13], area),
      var$0 = caml_int_of_string(txt);
     return update_significand(var$0);
    }
    caml_call2(Js_core[3][16], button, update);
    caml_call2(Js_core[2][3], parent, usage$3);
    caml_call2(Js_core[2][3], parent, area);
    caml_call2(Js_core[2][3], parent, button);
    return caml_call2(Js_core[2][3], main, parent);
   }
   caml_call2(Js_core[5][6], Js_core[12][1], onload);
   var Dune_exe_Floatview_js = [0];
   runtime.caml_register_global
    (126, Dune_exe_Floatview_js, "Dune__exe__Floatview_js");
   return;
  }
  (globalThis));

//# 5 "../.js/default/stdlib/std_exit.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib;
   caml_call1(Stdlib[103], 0);
   var Std_exit = [0];
   runtime.caml_register_global(1, Std_exit, "Std_exit");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvYXR2aWV3X2pzLmJjLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjozLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5mbG9hdHZpZXdfanMuZW9ianMvanNvby9mbG9hdHZpZXdfanMuYmMucnVudGltZS5qcyIsIm5hbWVzIjpbImNzdF9Bc3NlcnRfZmFpbHVyZSIsImNzdF9EaXZpc2lvbl9ieV96ZXJvIiwiY3N0X0VuZF9vZl9maWxlIiwiY3N0X0ZhaWx1cmUiLCJjc3RfSW52YWxpZF9hcmd1bWVudCIsImNzdF9NYXRjaF9mYWlsdXJlIiwiY3N0X05vdF9mb3VuZCIsImNzdF9PdXRfb2ZfbWVtb3J5IiwiY3N0X1N0YWNrX292ZXJmbG93IiwiY3N0X1N5c19ibG9ja2VkX2lvIiwiY3N0X1N5c19lcnJvciIsImNzdF9VbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L2h0bWwvZXh0cmFfcnVudGltZS5qcyIsIi9idWlsdGluLyttbEJ5dGVzLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rc3luYy5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytlZmZlY3QuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvYnVpbHRpbi8rZG9tYWluLmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK3J1bnRpbWVfZXZlbnRzLmpzIiwiL2J1aWx0aW4vK3pzdGQuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK3BybmcuanMiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vanMvb2pzX3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL3phcml0aF9zdHVic19qcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK3N0ci5qcyJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQTtBQUFBO0FBQUEsR0FBQTtBQUFBO0FBQUE7QUFBQSxRQUFBO0FBQUEsU0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBO0FBQUEsSUFBQTtBQUFBLElBQUE7QUFBQSxHQUFBO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElDVUU7QUFBQSxJQUNBLFFBQVE7QUFBQSxHQUNWO0FBQUEsRURaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUUwRlE7QUFBQSxJQUNOLCtDQUFnRCxPQUFPLGdCQUFnQjtBQUFBLFlBQ2pFO0FBQUEsSUFDTjtBQUFBLEtBQ0UsS0FBSyxjQUFjLGtCQUFrQjtBQUFBLElBQ3ZDLFFBQVE7QUFBQSxHQUNWO0FBQUE7QUFBQSxJQXFhRSxPQUFPLCtDQUEr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QUVGO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQTtBQUFBO0FBQUEsU0FNRTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUE7QUFBQSxRQUVGLGlCQUNFLDJCQUNBO0FBQUE7QUFBQSxRQUtGO0FBQUEsU0FDRTtBQUFBLFNBQ0E7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUE7QUFBQTtBQUFBLFdBTUUsc0JBQXVCO0FBQUEsV0FDdkI7QUFBQSxXQUNBO0FBQUE7QUFBQTtBQUFBLFdBRUEsc0JBQXVCO0FBQUEsV0FDdkI7QUFBQSxZQUNFLHNCQUF1QjtBQUFBLFlBQ3ZCLHdCQUF3QjtBQUFBO0FBQUEsV0FHMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBSUosNkJBQ0Usd0JBQXdCO0FBQUEsU0FDMUIsc0JBQXVCO0FBQUEsU0FDdkI7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBO0FBQUE7QUFBQSxRQUtGLDBCQUNBLGdCQUFpQjtBQUFBO0FBQUEsUUFJakI7QUFBQSxTQUNFO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxRQUNBLDZCQUNFLHFCQUNBO0FBQUE7QUFBQSxRQUtGO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBSUEsc0JBQXVCO0FBQUEsZ0JBQ2pCO0FBQUEsUUFDTjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFBQTtBQUFBLFNBTUU7QUFBQTtBQUFBLFNBQ0c7QUFBQSxRQUNMLDZCQUNFLHFCQUNBO0FBQUE7QUFBQSxRQUtGLCtCQUNBO0FBQUE7QUFBQSxRQUdBO0FBQUEsUUFDQTtBQUFBLGtCQUNRO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxTQUFjO0FBQUEsUUFJZDtBQUFBLFFBQ0E7QUFBQSxnQkFHQSx3QkFBd0I7QUFBQTtBQUFBLElBSTlCO0FBQUEsSUFDQTtBQUFBLElB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLHFCTjNZQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiLypcbiAqIFRoaXMgRmlsZSBpcyBwYXJ0IG9mIHRoZSBGbG9hdFZpZXcgcmVwb3NpdG9yeS5cbiAqIFRoaXMgZmlsZSB3YXMgcGFydCBvZiB0aGUgbGFuZG1hcmtzLXZpZXdlciBwcm9qZWN0LlxuICogQ29weXJpZ2h0IChDKSAyMDE2IC0gTGV4aUZpLiAodW5kZXIgTUlUIGxpY2Vuc2UpXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjUgLSBKb3NzZWxpbiBHaWV0XG4gKlxuICogVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGUgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIGNhbWxfaGlnaHJlc19jbG9jayhuKSB7XG4gIGNvbnNvbGUubG9nKFwiSGlnaHJlcyBjbG9jayBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtcbiAgICByZXR1cm4gcy5yZXBlYXQobik7XG4gIH0gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsXG4gICAgbCA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsIDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseShudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LCBsZW4gLT0gMTAyNClcbiAgICBzICs9IGYuYXBwbHkobnVsbCwgYS5zbGljZShpLCBpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1Yl91aW50OF9hcnJheV90b19qc2J5dGVzKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5KG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsIGxlbiAtPSAxMDI0KVxuICAgIHMgKz0gZi5hcHBseShudWxsLCBhLnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHtcbiAgICAgICAgdC5zbGljZSgwLCAxKTtcbiAgICAgICAgYiArPSB0O1xuICAgICAgICB0ID0gXCJcIjtcbiAgICAgICAgYiArPSBzLnNsaWNlKGksIGopO1xuICAgICAgfSBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgMHg4MCB8IChjICYgMHgzZiksXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID49IDB4ZGJmZiB8fFxuICAgICAgaSArIDEgPT09IGwgfHxcbiAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHxcbiAgICAgIGQgPiAweGRmZmZcbiAgICApIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAweDgwIHwgKGMgJiAweDNmKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgIHQuc2xpY2UoMCwgMSk7XG4gICAgICBiICs9IHQ7XG4gICAgICB0ID0gXCJcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGIgKyB0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbCAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikge1xuICAgICAgICB0LnNsaWNlKDAsIDEpO1xuICAgICAgICBiICs9IHQ7XG4gICAgICAgIHQgPSBcIlwiO1xuICAgICAgICBiICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICB9IGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgrK2kgPCBsICYmICgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PT0gMTI4KSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgrK2kgPCBsICYmICgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PT0gMTI4KSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKHYgPCAweDgwMCB8fCAodiA+PSAweGQ3ZmYgJiYgdiA8IDB4ZTAwMCkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKytpIDwgbCAmJlxuICAgICAgICAgICAgICAoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT09IDEyOCAmJlxuICAgICAgICAgICAgICBjMSA8IDB4ZjVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkge1xuICAgICAgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M2ZmKSk7XG4gICAgZWxzZSB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge1xuICAgICAgdC5zbGljZSgwLCAxKTtcbiAgICAgIGIgKz0gdDtcbiAgICAgIHQgPSBcIlwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYiArIHQ7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0NvbnRyb2xDaGFyYWN0ZXJzSW5SZWdleDogZXhwZWN0ZWRcbiAgZWxzZSByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICAgIGNhc2UgMCAvKiBCWVRFUyAqLzpcbiAgICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgICBjYXNlIDIgLyogUEFSVElBTCAqLzpcbiAgICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICAgIGNhc2UgNCAvKiBBUlJBWSAqLzpcbiAgICAgIHJldHVybiBzLmNbaV07XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0KHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSxcbiAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDgpIHwgYjE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpLFxuICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4KSB8IGIxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpLFxuICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSksXG4gICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAyKSxcbiAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0KSB8IChiMyA8PCAxNikgfCAoYjIgPDwgOCkgfCBiMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSksXG4gICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpLFxuICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSxcbiAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQpIHwgKGIzIDw8IDE2KSB8IChiMiA8PCA4KSB8IGIxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLCBpLCBpMTYpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweGZmICYgKGkxNiA+PiA4KSxcbiAgICBiMSA9IDB4ZmYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLCBpLCBpMzIpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweGZmICYgKGkzMiA+PiAyNCksXG4gICAgYjMgPSAweGZmICYgKGkzMiA+PiAxNiksXG4gICAgYjIgPSAweGZmICYgKGkzMiA+PiA4KSxcbiAgICBiMSA9IDB4ZmYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsIGksIGk2NCkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgKHRhZyA9IDgpIC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCAocyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQgPSB0YWc7XG4gIHRoaXMuYyA9IGNvbnRlbnRzO1xuICB0aGlzLmwgPSBsZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgY2FzZSA4IC8qQllURVMgfCBOT1RfQVNDSUkqLzpcbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIGNhc2UgMiAvKiBQQVJUSUFMICovOlxuICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMCAvKkJZVEVTIHwgVU5LT1dOKi86XG4gICAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgZWxzZSB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYgKHRoaXMudCA9PT0gOSkgcmV0dXJuIHI7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59O1xuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsIGNvbnRlbnQsIHRoaXMubCk7XG59O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09PSAyIC8qIFBBUlRJQUwgKi8pIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgXCJcXDBcIik7XG4gIGVsc2Ugcy5jID0gY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlcyhzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KHMubCk7XG4gIHZhciBiID0gcy5jLFxuICAgIGwgPSBiLmxlbmd0aCxcbiAgICBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKSB7XG4gIGlmIChzLnQgIT09IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyhzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuID8gMiA6IDksIFwiXCIsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbiA/IDIgOiA5LCBcIlwiLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheShhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLCAwLCBhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheShhKSB7XG4gIHJldHVybiBjYW1sX3N1Yl91aW50OF9hcnJheV90b19qc2J5dGVzKGEsIDAsIGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGEpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoYS5zbGljZSgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheShhKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCwgYSwgYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGEpIHtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsIGEsIGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgczEudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIHMyLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gczEuYyA8IHMyLmMgPyAtMSA6IHMxLmMgPiBzMi5jID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYgKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHMxLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICBzMi50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIHMxLmMgPT09IHMyLmMgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gMSAtIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIDEgLSBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICBzMS50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgczIudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiBzMS5jIDw9IHMyLmMgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICBzMS50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgczIudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiBzMS5jIDwgczIuYyA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLCBzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09PSAwICYmIChsID49IHMubCB8fCAocy50ID09PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gbCA9PT0gcy5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChcbiAgICBpMiA9PT0gMCAmJlxuICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpXG4gICkge1xuICAgIHMyLmMgPVxuICAgICAgczEudCA9PT0gNCAvKiBBUlJBWSAqL1xuICAgICAgICA/IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbilcbiAgICAgICAgOiBpMSA9PT0gMCAmJiBzMS5jLmxlbmd0aCA9PT0gbGVuXG4gICAgICAgICAgPyBzMS5jXG4gICAgICAgICAgOiBzMS5jLnNsaWNlKGkxLCBpMSArIGxlbik7XG4gICAgczIudCA9IHMyLmMubGVuZ3RoID09PSBzMi5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPVxuICAgICAgczEudCA9PT0gNCAvKiBBUlJBWSAqL1xuICAgICAgICA/IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbilcbiAgICAgICAgOiBpMSA9PT0gMCAmJiBzMS5jLmxlbmd0aCA9PT0gbGVuXG4gICAgICAgICAgPyBzMS5jXG4gICAgICAgICAgOiBzMS5jLnNsaWNlKGkxLCBpMSArIGxlbik7XG4gICAgczIudCA9IHMyLmMubGVuZ3RoID09PSBzMi5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLFxuICAgICAgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzJbaTIgKyBpXSA9IGMxW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyW2kyICsgaV0gPSBjMVtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMltpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSwgYiwgYywgZCwgZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksIGIsIGMsIGQsIGUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbmNhdChhLCBiKSB7XG4gIHJldHVybiBhICsgYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBNbEJ5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb25jYXQoczEsIHMyKSB7XG4gIHMxLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICBzMi50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHMxLnQsIHMxLmMgKyBzMi5jLCBzMS5sICsgczIubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIHMxIDwgczIgPyAtMSA6IHMxID4gczIgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmIChzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIHMxIDw9IHMyID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gczEgPCBzMiA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIHMudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkge1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcygwLCBzLCBzLmxlbmd0aCk7XG59XG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcy50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIHMudG9VdGYxNigpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgTWxCeXRlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JldHVybnMgYSAoZnVsbCkgc3RyaW5nIG9mIGJ5dGVzIG9yIGFuIGFycmF5XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2NvbnRlbnQocykge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgICBjYXNlIDIgLyogUEFSVElBTCAqLzpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgICByZXR1cm4gcy5jO1xuICAgIGRlZmF1bHQ6IC8qIEJZVEVTIG9yIEFSUkFZICovXG4gICAgICByZXR1cm4gcy5jO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0NvbnRyb2xDaGFyYWN0ZXJzSW5SZWdleDogZXhwZWN0ZWRcbiAgcmV0dXJuIHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX3N0cmluZ19vZl9qc2J5dGVzXSBpbnN0ZWFkXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9EZXByZWNhdGVkOiBVc2UgW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXSBpbnN0ZWFkXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL0RlcHJlY2F0ZWQ6IFVzZSBbY2FtbF9qc3N0cmluZ19vZl9zdHJpbmddIGluc3RlYWRcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX3N0cmluZ19vZl9qc3N0cmluZ10gaW5zdGVhZFxuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuLy9EZXByZWNhdGVkOiBVc2UgW2NhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXSBpbnN0ZWFkXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyh4KSB7XG4gIHJldHVybiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuLy9EZXByZWNhdGVkOiBVc2UgW2NhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNdIGluc3RlYWRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2ZfYnl0ZXMoeCkge1xuICByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0RlcHJlY2F0ZWQ6IFVzZSBbY2FtbF9zdHJpbmdfb2ZfanNieXRlc10gaW5zdGVhZFxuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5wYWNrRmxvYXQxNlxudmFyIGNhbWxfdW5wYWNrRmxvYXQxNiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBwb3cgPSBNYXRoLnBvdztcblxuICB2YXIgRVhQX01BU0sxNiA9IDMxOyAvLyAyICoqIDUgLSAxXG4gIHZhciBTSUdOSUZJQ0FORF9NQVNLMTYgPSAxMDIzOyAvLyAyICoqIDEwIC0gMVxuICB2YXIgTUlOX1NVQk5PUk1BTDE2ID0gcG93KDIsIC0yNCk7IC8vIDIgKiogLTEwICogMiAqKiAtMTRcbiAgdmFyIFNJR05JRklDQU5EX0RFTk9NMTYgPSAwLjAwMDk3NjU2MjU7IC8vIDIgKiogLTEwXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChieXRlcykge1xuICAgIHZhciBzaWduID0gYnl0ZXMgPj4+IDE1O1xuICAgIHZhciBleHBvbmVudCA9IChieXRlcyA+Pj4gMTApICYgRVhQX01BU0sxNjtcbiAgICB2YXIgc2lnbmlmaWNhbmQgPSBieXRlcyAmIFNJR05JRklDQU5EX01BU0sxNjtcbiAgICBpZiAoZXhwb25lbnQgPT09IEVYUF9NQVNLMTYpXG4gICAgICByZXR1cm4gc2lnbmlmaWNhbmQgPT09IDBcbiAgICAgICAgPyBzaWduID09PSAwXG4gICAgICAgICAgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICA6IE51bWJlci5OYU47XG4gICAgaWYgKGV4cG9uZW50ID09PSAwKVxuICAgICAgcmV0dXJuIHNpZ25pZmljYW5kICogKHNpZ24gPT09IDAgPyBNSU5fU1VCTk9STUFMMTYgOiAtTUlOX1NVQk5PUk1BTDE2KTtcbiAgICB2YXIgciA9XG4gICAgICBwb3coMiwgZXhwb25lbnQgLSAxNSkgKlxuICAgICAgKHNpZ24gPT09IDBcbiAgICAgICAgPyAxICsgc2lnbmlmaWNhbmQgKiBTSUdOSUZJQ0FORF9ERU5PTTE2XG4gICAgICAgIDogLTEgLSBzaWduaWZpY2FuZCAqIFNJR05JRklDQU5EX0RFTk9NMTYpO1xuICAgIHJldHVybiByO1xuICB9O1xufSkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9wYWNrRmxvYXQxNlxudmFyIGNhbWxfcGFja0Zsb2F0MTYgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBJTlZFUlNFX09GX0VQU0lMT04gPSAxIC8gTnVtYmVyLkVQU0lMT047XG5cbiAgZnVuY3Rpb24gcm91bmRUaWVzVG9FdmVuKG51bSkge1xuICAgIHJldHVybiBudW0gKyBJTlZFUlNFX09GX0VQU0lMT04gLSBJTlZFUlNFX09GX0VQU0lMT047XG4gIH1cblxuICBjb25zdCBGTE9BVDE2X01JTl9WQUxVRSA9IDYuMTAzNTE1NjI1ZS01O1xuICBjb25zdCBGTE9BVDE2X01BWF9WQUxVRSA9IDY1NTA0O1xuICBjb25zdCBGTE9BVDE2X0VQU0lMT04gPSAwLjAwMDk3NjU2MjU7XG5cbiAgY29uc3QgRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUgPVxuICAgIEZMT0FUMTZfRVBTSUxPTiAqIEZMT0FUMTZfTUlOX1ZBTFVFO1xuICBjb25zdCBGTE9BVDE2X0VQU0lMT05fREVWSURFRF9CWV9FUFNJTE9OID1cbiAgICBGTE9BVDE2X0VQU0lMT04gKiBJTlZFUlNFX09GX0VQU0lMT047XG5cbiAgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTYobnVtKSB7XG4gICAgY29uc3QgbnVtYmVyID0gK251bTtcblxuICAgIC8vIE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSwgMCwgLTBcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShudW1iZXIpIHx8IG51bWJlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvLyBmaW5pdGUgZXhjZXB0IDAsIC0wXG4gICAgY29uc3Qgc2lnbiA9IG51bWJlciA+IDAgPyAxIDogLTE7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBNYXRoLmFicyhudW1iZXIpO1xuXG4gICAgLy8gc21hbGwgbnVtYmVyXG4gICAgaWYgKGFic29sdXRlIDwgRkxPQVQxNl9NSU5fVkFMVUUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHNpZ24gKlxuICAgICAgICByb3VuZFRpZXNUb0V2ZW4oXG4gICAgICAgICAgYWJzb2x1dGUgLyBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRSxcbiAgICAgICAgKSAqXG4gICAgICAgIEZMT0FUMTZfRVBTSUxPTl9NVUxUSVBMSUVEX0JZX0ZMT0FUMTZfTUlOX1ZBTFVFXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRlbXAgPSAoMSArIEZMT0FUMTZfRVBTSUxPTl9ERVZJREVEX0JZX0VQU0lMT04pICogYWJzb2x1dGU7XG4gICAgY29uc3QgcmVzdWx0ID0gdGVtcCAtICh0ZW1wIC0gYWJzb2x1dGUpO1xuXG4gICAgLy8gbGFyZ2UgbnVtYmVyXG4gICAgaWYgKHJlc3VsdCA+IEZMT0FUMTZfTUFYX1ZBTFVFIHx8IE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbiAqIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGJhc2UgYWxnb3JpdGhtOiBodHRwOi8vZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcblxuICBjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDE2QXJyYXkoNTEyKTtcbiAgY29uc3Qgc2hpZnRUYWJsZSA9IG5ldyBVaW50OEFycmF5KDUxMik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGNvbnN0IGUgPSBpIC0gMTI3O1xuXG4gICAgLy8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuICAgIGlmIChlIDwgLTI0KSB7XG4gICAgICBiYXNlVGFibGVbaV0gPSAweDAwMDA7XG4gICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ODAwMDtcbiAgICAgIHNoaWZ0VGFibGVbaV0gPSAyNDtcbiAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDI0O1xuXG4gICAgICAvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcbiAgICB9IGVsc2UgaWYgKGUgPCAtMTQpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSA9IDB4MDQwMCA+PiAoLWUgLSAxNCk7XG4gICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICAgIHNoaWZ0VGFibGVbaV0gPSAtZSAtIDE7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAtZSAtIDE7XG5cbiAgICAgIC8vIG5vcm1hbCBudW1iZXJcbiAgICB9IGVsc2UgaWYgKGUgPD0gMTUpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSA9IChlICsgMTUpIDw8IDEwO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoKGUgKyAxNSkgPDwgMTApIHwgMHg4MDAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSA9IDEzO1xuICAgICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMTM7XG5cbiAgICAgIC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcbiAgICB9IGVsc2UgaWYgKGUgPCAxMjgpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSA9IDB4N2MwMDtcbiAgICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSA9IDI0O1xuICAgICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cbiAgICAgIC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVRhYmxlW2ldID0gMHg3YzAwO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgICBzaGlmdFRhYmxlW2ldID0gMTM7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIGNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgY29uc3QgdWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAobnVtKSB7XG4gICAgZmxvYXRWaWV3WzBdID0gcm91bmRUb0Zsb2F0MTYobnVtKTtcbiAgICBjb25zdCBmID0gdWludDMyVmlld1swXTtcbiAgICBjb25zdCBlID0gKGYgPj4gMjMpICYgMHgxZmY7XG4gICAgcmV0dXJuIGJhc2VUYWJsZVtlXSArICgoZiAmIDB4MDA3ZmZmZmYpID4+IHNoaWZ0VGFibGVbZV0pO1xuICB9O1xufSkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSB7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgNzpcbiAgICBjYXNlIDEwOlxuICAgIGNhc2UgMTE6XG4gICAgICByZXR1cm4gMjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKSB7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2aWV3ID0gRmxvYXQzMkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgdmlldyA9IEZsb2F0NjRBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHZpZXcgPSBJbnQ4QXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICB2aWV3ID0gVWludDhBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHZpZXcgPSBJbnQxNkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgdmlldyA9IFVpbnQxNkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA2OlxuICAgICAgdmlldyA9IEludDMyQXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDc6XG4gICAgICB2aWV3ID0gSW50MzJBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgODpcbiAgICAgIHZpZXcgPSBJbnQzMkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA5OlxuICAgICAgdmlldyA9IEludDMyQXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOlxuICAgICAgdmlldyA9IEZsb2F0MzJBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTE6XG4gICAgICB2aWV3ID0gRmxvYXQ2NEFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIHZpZXcgPSBVaW50OEFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHZpZXcgPSBVaW50MTZBcnJheTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiO1xuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbi8vUmVxdWlyZXM6IGNhbWxfcGFja0Zsb2F0MTYsIGNhbWxfdW5wYWNrRmxvYXQxNlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kID0ga2luZDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT09IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZiAodGhpcy5sYXlvdXQgPT09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gb2ZzICogdGhpcy5kaW1zW2ldICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pIHtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gb2ZzICogdGhpcy5kaW1zW2ldICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICBjYXNlIDc6XG4gICAgICAvLyBJbnQ2NFxuICAgICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsIGgpO1xuICAgIGNhc2UgMTA6XG4gICAgY2FzZSAxMTpcbiAgICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gICAgY2FzZSAxMzpcbiAgICAgIHJldHVybiBjYW1sX3VucGFja0Zsb2F0MTYodGhpcy5kYXRhW29mc10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW29mc107XG4gIH1cbn07XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLCB2KSB7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgY2FzZSA3OlxuICAgICAgLy8gSW50NjRcbiAgICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDExOlxuICAgICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEzOlxuICAgICAgdGhpcy5kYXRhW29mc10gPSBjYW1sX3BhY2tGbG9hdDE2KHYpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgIGNhc2UgNzpcbiAgICAgIC8vIEludDY0XG4gICAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGkgJSAyID09PSAwID8gYSA6IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgY2FzZSAxMTpcbiAgICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgICB2YXIgaW0gPSB2WzFdO1xuICAgICAgdmFyIHJlID0gdlsyXTtcbiAgICAgIGlmIChpbSA9PT0gcmUpIHtcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBpICUgMiA9PT0gMCA/IGltIDogcmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICB0aGlzLmRhdGEuZmlsbChjYW1sX3BhY2tGbG9hdDE2KHYpKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT09IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9IGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9PSBiLmRpbXNbaV0pIHJldHVybiB0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0gPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICBjYXNlIDEwOlxuICAgIGNhc2UgMTE6XG4gICAgICAvLyBGbG9hdHNcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh4ICE9PSB5KSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oeCkpIHJldHVybiAxO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHkpKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNzpcbiAgICAgIC8vIEludDY0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPCBiLmRhdGFbaSArIDFdKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID4gYi5kYXRhW2kgKyAxXSkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPj4+IDAgPCBiLmRhdGFbaV0gPj4+IDApIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+Pj4gMCA+IGIuZGF0YVtpXSA+Pj4gMCkgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEzOlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFhID0gY2FtbF91bnBhY2tGbG9hdDE2KHRoaXMuZGF0YVtpXSk7XG4gICAgICAgIHZhciBiYiA9IGNhbWxfdW5wYWNrRmxvYXQxNihiLmRhdGFbaV0pO1xuICAgICAgICBpZiAoYWEgPCBiYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYWEgPiBiYikgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICBjYXNlIDU6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgODpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMjpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSkgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgPSBraW5kO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKTtcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoID09PSAxKSBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufTtcblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufTtcblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsIHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMDtcbn07XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwO1xufTtcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSwgYiwgdG90YWwpIHtcbiAgcmV0dXJuIGEuY29tcGFyZShiLCB0b3RhbCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpIHtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZiAoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZiAoXG4gICAgbGF5b3V0ID09PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgZGltcy5sZW5ndGggPT09IDEgJiYgLy8gQXJyYXkxXG4gICAgc2l6ZV9wZXJfZWxlbWVudCA9PT0gMSAmJlxuICAgIGtpbmQgIT09IDEzIC8vIGZsb2F0MTZcbiAgKVxuICAgIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZiAoYmEubGF5b3V0ID09PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gYjEgfCAoYjIgPDwgOCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzICsgMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcyArIDIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzICsgMyk7XG4gIHJldHVybiAoYjEgPDwgMCkgfCAoYjIgPDwgOCkgfCAoYjMgPDwgMTYpIHwgKGI0IDw8IDI0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmIChvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMgKyAwKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzICsgMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMgKyAzKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcyArIDQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzICsgNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMgKyA2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcyArIDcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsIGI3LCBiNiwgYjUsIGI0LCBiMywgYjIsIGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsIGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCwgaTEsIGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzICsgMCwgdiAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYgKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyArIDAsIHYgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyArIDEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmIChvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMgKyBpLCB2WzcgLSBpXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsIGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCwgaTEsIGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT09IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIDE7IGkrKykgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKykgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKykgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkoXG4gICAgb2ZzICogc2l6ZV9wZXJfZWxlbWVudCxcbiAgICAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50LFxuICApO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT09IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFja0Zsb2F0MTZcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKTtcbiAgaWYgKGJhLmNhbWxfY3VzdG9tID09PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJhLmRpbXNbaV0gPCAweGZmZmYpIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gIHN3aXRjaCAoYmEua2luZCkge1xuICAgIGNhc2UgMjogLy9JbnQ4QXJyYXlcbiAgICBjYXNlIDM6IC8vVWludDhBcnJheVxuICAgIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gSW50MTZBcnJheVxuICAgIGNhc2UgNTogLy8gVWludDE2QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA2OiAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OiAvLyBJbnQzMkFycmF5IChpbnQpXG4gICAgY2FzZSA5OiAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNzogLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOiAvLyBGbG9hdDY0QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzogLy8gRmxvYXQxNkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDogLy8gRmxvYXQzMkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSg4LCBiW2pdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX3VucGFja0Zsb2F0MTZcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSkge1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZjtcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdO1xuICBpZiAobmFtZSA9PT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZiAoc2l6ZV9kaW0gPT09IDB4ZmZmZikge1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZiAoc2l6ZV9kaW1faGkgIT09IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgMjogLy9JbnQ4QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vVWludDhBcnJheVxuICAgIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gSW50MTZBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6IC8vIFVpbnQxNkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjogLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgODogLy8gSW50MzJBcnJheSAoaW50KVxuICAgIGNhc2UgOTogLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgaWYgKHNpeHR5KVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgIFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIixcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgICBiYS5zZXQoaSwgaW50NjQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOiAvLyBGbG9hdDY0QXJyYXlcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgICBiYS5zZXQoaSwgZik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEzOiAvLyBGbG9hdDE2QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOiAvLyBGbG9hdDMyQXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgICBiYS5zZXQoaSwgZik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgICBiYS5zZXQoaSwgWzI1NCwgcmUsIGltXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgICAgYmEuc2V0KGksIFsyNTQsIHJlLCBpbV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpIHtcbiAgaWYgKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT09IDIpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXG4gICAgICBcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX3VucGFja0Zsb2F0MTYsIGNhbWxfaGFzaF9taXhfZmxvYXQxNlxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKSB7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoIChiYS5raW5kKSB7XG4gICAgY2FzZSAyOiAvL0ludDhBcnJheVxuICAgIGNhc2UgMzogLy9VaW50OEFycmF5XG4gICAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgICBpZiAobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgICAgdmFyIHcgPSAwLFxuICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgdyA9XG4gICAgICAgICAgYmEuZGF0YVtpICsgMF0gfFxuICAgICAgICAgIChiYS5kYXRhW2kgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgKGJhLmRhdGFbaSArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgKGJhLmRhdGFbaSArIDNdIDw8IDI0KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgICAgfVxuICAgICAgdyA9IDA7XG4gICAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICAgIHcgPSBiYS5kYXRhW2kgKyAyXSA8PCAxNjtcbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgICB3IHw9IGJhLmRhdGFbaSArIDFdIDw8IDg7XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB3IHw9IGJhLmRhdGFbaSArIDBdO1xuICAgICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gSW50MTZBcnJheVxuICAgIGNhc2UgNTogLy8gVWludDE2QXJyYXlcbiAgICAgIGlmIChudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgICB2YXIgdyA9IDAsXG4gICAgICAgIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gYmEuZGF0YVtpICsgMF0gfCAoYmEuZGF0YVtpICsgMV0gPDwgMTYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgICB9XG4gICAgICBpZiAoKG51bV9lbHRzICYgMSkgIT09IDApIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjogLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OiAvLyBJbnQzMkFycmF5IChpbnQpXG4gICAgY2FzZSA5OiAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA3OiAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgICAgbnVtX2VsdHMgKj0gMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIG51bV9lbHRzICo9IDI7XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIDA6IC8vIEZsb2F0MzJBcnJheVxuICAgICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICBudW1fZWx0cyAqPSAyO1xuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgY2FzZSAxOiAvLyBGbG9hdDY0QXJyYXlcbiAgICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0MTYoaCwgYmEuZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdDE2XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdDE2KGhhc2gsIGQpIHtcbiAgLyogTm9ybWFsaXplIE5hTnMgKi9cbiAgaWYgKChkICYgMHg3YzAwKSA9PT0gMHg3YzAwICYmIChkICYgMHgwM2ZmKSAhPT0gMCkge1xuICAgIGQgPSAweDdjMDE7XG4gIH0gZWxzZSBpZiAoZCA9PT0gMHg4MDAwKSB7XG4gICAgLyogTm9ybWFsaXplIC0wIGludG8gKzAgKi9cbiAgICBkID0gMDtcbiAgfVxuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQoaGFzaCwgZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSkge1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKSB7XG4gIHZhciBraW5kO1xuICBpZiAodGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkga2luZCA9IDQ7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXk6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHJldHVybiBraW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSh0YSkge1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHZhciB0YSA9XG4gICAgLyogTmVlZGVkIHRvIGF2b2lkIHVuc2lnbmVkIHNldHRlcnMgb3ZlcmZsb3dpbmdcbiAgICAgICAgIHRoZSByYW5nZSBvZiBPQ2FtbCBbaW50MzJdIHZhbHVlcy4gKi9cbiAgICB0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgICA/IG5ldyBJbnQzMkFycmF5KHRhLmJ1ZmZlciwgdGEuYnl0ZU9mZnNldCwgdGEubGVuZ3RoKVxuICAgICAgOiB0YTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6IDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6IDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6IDB4MjAsXG4gIENPREVfSU5UODogMHgwMCxcbiAgQ09ERV9JTlQxNjogMHgwMSxcbiAgQ09ERV9JTlQzMjogMHgwMixcbiAgQ09ERV9JTlQ2NDogMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAweDA2LFxuICBDT0RFX0JMT0NLMzI6IDB4MDgsXG4gIENPREVfQkxPQ0s2NDogMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAweDA5LFxuICBDT0RFX1NUUklORzMyOiAweDBhLFxuICBDT0RFX0RPVUJMRV9CSUc6IDB4MGIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogMHgwYyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogMHgwZCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogMHgwZSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6IDB4MGYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogMHgxMSxcbiAgQ09ERV9DVVNUT006IDB4MTIsXG4gIENPREVfQ1VTVE9NX0xFTjogMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6IDB4MTksXG59O1xuXG4vL1Byb3ZpZGVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gVUludDhBcnJheVJlYWRlcihzLCBpKSB7XG4gIHRoaXMucyA9IHM7XG4gIHRoaXMuaSA9IGk7XG59XG5VSW50OEFycmF5UmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc1t0aGlzLmkrK107XG4gIH0sXG4gIHJlYWQ4czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5zW3RoaXMuaSsrXSA8PCAyNCkgPj4gMjQ7XG4gIH0sXG4gIHJlYWQxNnU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzW2ldIDw8IDgpIHwgc1tpICsgMV07XG4gIH0sXG4gIHJlYWQxNnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuICgoc1tpXSA8PCAyNCkgPj4gMTYpIHwgc1tpICsgMV07XG4gIH0sXG4gIHJlYWQzMnU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoc1tpXSA8PCAyNCkgfCAoc1tpICsgMV0gPDwgMTYpIHwgKHNbaSArIDJdIDw8IDgpIHwgc1tpICsgM10pID4+PiAwO1xuICB9LFxuICByZWFkMzJzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoc1tpXSA8PCAyNCkgfCAoc1tpICsgMV0gPDwgMTYpIHwgKHNbaSArIDJdIDw8IDgpIHwgc1tpICsgM107XG4gIH0sXG4gIHJlYWRzdHI6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheSh0aGlzLnMuc3ViYXJyYXkoaSwgaSArIGxlbikpO1xuICB9LFxuICByZWFkdWludDhhcnJheTogZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIHRoaXMucy5zdWJhcnJheShpLCBpICsgbGVuKTtcbiAgfSxcbn07XG5cbi8vUHJvdmlkZXM6IE1sU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbFN0cmluZ1JlYWRlcihzLCBpKSB7XG4gIHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHRoaXMuaSA9IGk7XG59XG5NbFN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7XG4gIH0sXG4gIHJlYWQ4czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0KSA+PiAyNDtcbiAgfSxcbiAgcmVhZDE2dTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQxNnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoXG4gICAgICAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfFxuICAgICAgICAocy5jaGFyQ29kZUF0KGkgKyAxKSA8PCAxNikgfFxuICAgICAgICAocy5jaGFyQ29kZUF0KGkgKyAyKSA8PCA4KSB8XG4gICAgICAgIHMuY2hhckNvZGVBdChpICsgMykpID4+PlxuICAgICAgMFxuICAgICk7XG4gIH0sXG4gIHJlYWQzMnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChcbiAgICAgIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSArIDEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAyKSA8PCA4KSB8XG4gICAgICBzLmNoYXJDb2RlQXQoaSArIDMpXG4gICAgKTtcbiAgfSxcbiAgcmVhZHN0cjogZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnNsaWNlKGksIGkgKyBsZW4pKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgYltqXSA9IHMuY2hhckNvZGVBdChpICsgaik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGI7XG4gIH0sXG59O1xuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIoYnMsIGkpIHtcbiAgdGhpcy5zID0gYnM7XG4gIHRoaXMuaSA9IGk7XG59XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIHRoaXMuaSsrKTtcbiAgfSxcbiAgcmVhZDhzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHRoaXMucywgdGhpcy5pKyspIDw8IDI0KSA+PiAyNDtcbiAgfSxcbiAgcmVhZDE2dTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocywgaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsIGkgKyAxKTtcbiAgfSxcbiAgcmVhZDE2czogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsIGkpIDw8IDI0KSA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsIGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKFxuICAgICAgKChjYW1sX2JhX2dldF8xKHMsIGkpIDw8IDI0KSB8XG4gICAgICAgIChjYW1sX2JhX2dldF8xKHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgICAoY2FtbF9iYV9nZXRfMShzLCBpICsgMikgPDwgOCkgfFxuICAgICAgICBjYW1sX2JhX2dldF8xKHMsIGkgKyAzKSkgPj4+XG4gICAgICAwXG4gICAgKTtcbiAgfSxcbiAgcmVhZDMyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYmFfZ2V0XzEocywgaSArIDMpXG4gICAgKTtcbiAgfSxcbiAgcmVhZHN0cjogZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChpKTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheShcbiAgICAgIHRoaXMucy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSxcbiAgICApO1xuICB9LFxuICByZWFkdWludDhhcnJheTogZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChpKTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiB0aGlzLnMuZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIH0sXG59O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLCBvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlcihzLCB0eXBlb2Ygb2ZzID09PSBcIm51bWJlclwiID8gb2ZzIDogb2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocywgb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIoXG4gICAgY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocyksXG4gICAgdHlwZW9mIG9mcyA9PT0gXCJudW1iZXJcIiA/IG9mcyA6IG9mc1swXSxcbiAgKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKSB7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4O1xuICBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpIHtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycygpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpIHtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1KCkpIHtcbiAgICBjYXNlIDE6XG4gICAgICBzaXplWzBdID0gNDtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDMycygpO1xuICAgIGNhc2UgMjpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPSB7XG4gIF9qOiB7XG4gICAgZGVzZXJpYWxpemU6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgIHNlcmlhbGl6ZTogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgIGZpeGVkX2xlbmd0aDogOCxcbiAgICBjb21wYXJlOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgaGFzaDogY2FtbF9pbnQ2NF9oYXNoLFxuICB9LFxuICBfaToge1xuICAgIGRlc2VyaWFsaXplOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICBmaXhlZF9sZW5ndGg6IDQsXG4gIH0sXG4gIF9uOiB7XG4gICAgZGVzZXJpYWxpemU6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICBmaXhlZF9sZW5ndGg6IDQsXG4gIH0sXG4gIF9iaWdhcnJheToge1xuICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAocmVhZGVyLCBzeikge1xuICAgICAgcmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgXCJfYmlnYXJyYXlcIik7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgIGNvbXBhcmU6IGNhbWxfYmFfY29tcGFyZSxcbiAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gIH0sXG4gIF9iaWdhcnIwMjoge1xuICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAocmVhZGVyLCBzeikge1xuICAgICAgcmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgXCJfYmlnYXJyMDJcIik7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgIGNvbXBhcmU6IGNhbWxfYmFfY29tcGFyZSxcbiAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gIH0sXG59O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX3NldF9vb19pZFxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICBmdW5jdGlvbiByZWFkdmxxKG92ZXJmbG93KSB7XG4gICAgdmFyIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3ZjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPT0gMCkge1xuICAgICAgYyA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9PSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N2YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB2YXIgbWFnaWMgPSByZWFkZXIucmVhZDMydSgpO1xuICBzd2l0Y2ggKG1hZ2ljKSB7XG4gICAgY2FzZSAweDg0OTVhNmJlIC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSAwO1xuICAgICAgdmFyIGRhdGFfbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgIHZhciB1bmNvbXByZXNzZWRfZGF0YV9sZW4gPSBkYXRhX2xlbjtcbiAgICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZCAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IHJlYWRlci5yZWFkOHUoKSAmIDB4M2Y7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IDE7XG4gICAgICB2YXIgb3ZlcmZsb3cgPSBbZmFsc2VdO1xuICAgICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICB2YXIgdW5jb21wcmVzc2VkX2RhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICB2YXIgbnVtX29iamVjdHMgPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICAgIHZhciBfc2l6ZV8zMiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgICAgdmFyIF9zaXplXzY0ID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICBpZiAob3ZlcmZsb3dbMF0pIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcbiAgICAgICAgICBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqLzpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgIFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gYSAzMi1iaXQgcGxhdGZvcm1cIixcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IGJhZCBvYmplY3RcIik7XG4gICAgICBicmVhaztcbiAgfVxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIG9iamVjdHMgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSBudW1fb2JqZWN0cyA+IDAgPyBbXSA6IG51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMocmVhZGVyKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweGY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBpZiAodGFnID09PSAyNDgpIG9iamVjdHMucHVzaCh2KTtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2UgcmV0dXJuIGNvZGUgJiAweDNmO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFmO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzKCk7XG4gICAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzKCk7XG4gICAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc2VkID09PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICBpZiAodGFnID09PSAyNDgpIG9iamVjdHMucHVzaCh2KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyKGxlbik7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MGE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIobGVuKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgwYzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MGI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MGU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgY2FzZSAweDBkOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgY2FzZSAweDBmOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICAgIHMgPSBcIlwiO1xuICAgICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSgpKSAhPT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgICAgaWYgKCFvcHMpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgICAgICBpZiAoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgICAgICAgICAgICBcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRfc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChleHBlY3RlZF9zaXplICE9PSBzaXplWzBdKVxuICAgICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgICAgICAgICAgICBcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIGlmIChjYW1sX2RlY29tcHJlc3NfaW5wdXQpIHtcbiAgICAgIHZhciBkYXRhID0gcmVhZGVyLnJlYWR1aW50OGFycmF5KGRhdGFfbGVuKTtcbiAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWRfZGF0YV9sZW4pO1xuICAgICAgdmFyIHJlcyA9IGNhbWxfZGVjb21wcmVzc19pbnB1dChkYXRhLCByZXMpO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKHJlcywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY29tcHJlc3NlZCBvYmplY3QsIGNhbm5vdCBkZWNvbXByZXNzXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyhyZWFkZXIpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyhyZWFkZXIpO1xuICB9XG4gIHdoaWxlIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgeCA9IG9iamVjdHMucG9wKCk7XG4gICAgaWYgKHhbMl0gPj0gMCkgY2FtbF9zZXRfb29faWQoeCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246IDwgNS4xLjBcbnZhciBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgPSAyMDtcblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246ID49IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMTY7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUocywgb2ZzKSB7XG4gIHZhciByID0gbmV3IFVJbnQ4QXJyYXlSZWFkZXIoY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKSwgb2ZzKTtcbiAgZnVuY3Rpb24gcmVhZHZscShvdmVyZmxvdykge1xuICAgIHZhciBjID0gci5yZWFkOHUoKTtcbiAgICB2YXIgbiA9IGMgJiAweDdmO1xuICAgIHdoaWxlICgoYyAmIDB4ODApICE9PSAwKSB7XG4gICAgICBjID0gci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9PSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N2YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHN3aXRjaCAoci5yZWFkMzJ1KCkpIHtcbiAgICBjYXNlIDB4ODQ5NWE2YmUgLyogSW50ZXh0X21hZ2ljX251bWJlcl9zbWFsbCAqLzpcbiAgICAgIHZhciBoZWFkZXJfbGVuID0gMjA7XG4gICAgICB2YXIgZGF0YV9sZW4gPSByLnJlYWQzMnUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZCAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IHIucmVhZDh1KCkgJiAweDNmO1xuICAgICAgdmFyIG92ZXJmbG93ID0gW2ZhbHNlXTtcbiAgICAgIHZhciBkYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgICAgaWYgKG92ZXJmbG93WzBdKSB7XG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgICAgXCJNYXJzaGFsLmRhdGFfc2l6ZTogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gdGhpcyBwbGF0Zm9ybVwiLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDg0OTVhNmJmIC8qIEludGV4dF9tYWdpY19udW1iZXJfYmlnICovOlxuICAgICAgY2FtbF9mYWlsd2l0aChcbiAgICAgICAgXCJNYXJzaGFsLmRhdGFfc2l6ZTogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gYSAzMi1iaXQgcGxhdGZvcm1cIixcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcl9sZW4gLSBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgKyBkYXRhX2xlbjtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMuTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIE1sT2JqZWN0VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qIHBvbHlmaWxsICh1c2luZyBsaW5lYXIgc2VhcmNoKSAqL1xuICAgIGZ1bmN0aW9uIE5haXZlTG9va3VwKG9ianMpIHtcbiAgICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgfVxuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdO1xuICAgICAgdGhpcy5sb29rdXAgPSBuZXcgTmFpdmVMb29rdXAodGhpcy5vYmpzKTtcbiAgICB9O1xuICB9KSgpO1xufSBlbHNlIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgdGhpcy5vYmpzID0gW107XG4gICAgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5NYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufTtcblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiBpID09PSB1bmRlZmluZWRcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7IC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbnZhciBjYW1sX291dHB1dF92YWwgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXcml0ZXIoKSB7XG4gICAgdGhpcy5jaHVuayA9IFtdO1xuICB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OiAyMCxcbiAgICBibG9ja19sZW46IDAsXG4gICAgb2JqX2NvdW50ZXI6IDAsXG4gICAgc2l6ZV8zMjogMCxcbiAgICBzaXplXzY0OiAwLFxuICAgIHdyaXRlOiBmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODsgaSA+PSAwOyBpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweGZmO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6IGZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4OyBpID49IDA7IGkgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweGZmO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTogZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODsgaSA+PSAwOyBpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweGZmO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgMSA8PCA4KVxuICAgICAgICB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8IDEgPDwgMTYpXG4gICAgICAgIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rX2lkeDtcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlKDMyLCAweDg0OTVhNmJlKTtcbiAgICAgIHRoaXMud3JpdGUoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9LFxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSBmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xLFxuICAgICAgY2xvc3VyZXMgPSBmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMTtcbiAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiLFxuICAgICAgKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7XG4gICAgICAgIHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLCAwXTtcbiAgICAgICAgaWYgKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9PSB3cml0ZXIucG9zKCkgLSBvbGRfcG9zKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcbiAgICAgICAgICAgICAgXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHZbMF0gPT09ICh2WzBdIHwgMCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUoXG4gICAgICAgICAgICA4LFxuICAgICAgICAgICAgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSkgPDwgNCksXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKFxuICAgICAgICAgICAgMzIsXG4gICAgICAgICAgICAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLFxuICAgICAgICAgICAgKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICAgIGlmICghY2FtbF9pc19tbF9ieXRlcyhjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgICAgICBcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKSB3cml0ZXIud3JpdGUoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDA5IC8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDBhIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHYsIGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCkgfCAwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCkgfCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApIHdyaXRlci53cml0ZSg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDkgLypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2Ugd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MGEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHYsIGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCkgfCAwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCkgfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9PSAodiB8IDApKSB7XG4gICAgICAgICAgdmFyIHR5cGVfb2ZfdiA9IHR5cGVvZiB2O1xuICAgICAgICAgIGlmICh0eXBlX29mX3YgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIgKyB0eXBlX29mX3YgKyBcIilcIik7XG4gICAgICAgICAgLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgLy8gKEpzX29mX29jYW1sIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIHR5cGUgb2YgYW4gaW50ZWdlciBudW1iZXIgaXNcbiAgICAgICAgICAvLyBmbG9hdCBvciBpbnRlZ2VyLikgVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgY3Jhc2hlcyB3aGVuXG4gICAgICAgICAgLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS5cbiAgICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICAgIHZhciB0ID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQodikpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAweDBjIC8qY3N0LkNPREVfRE9VQkxFX0xJVFRMRSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIHRbNyAtIGldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMztcbiAgICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgMSA8PCA3KVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAxIDw8IDE1KVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod3JpdGVyLmNodW5rKTtcbiAgfTtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGNhbWxfb3V0cHV0X3ZhbCh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGNhbWxfb3V0cHV0X3ZhbCh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkodCksIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmRzXG52YXIgY2FtbF9zeXNfZmRzID0gbmV3IEFycmF5KDMpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICB2YXIgeCA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmICh4KSB7XG4gICAgeC5maWxlLmNsb3NlKCk7XG4gICAgZGVsZXRlIGNhbWxfc3lzX2Zkc1tmZF07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sQ2hhbmlkXG5mdW5jdGlvbiBNbENoYW5pZChpZCkge1xuICB0aGlzLmlkID0gaWQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL1JlcXVpcmVzOiBNbENoYW5pZFxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlLCBpZHgpIHtcbiAgdmFyIGNoYW5pZDtcbiAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWR4ID0gY2FtbF9zeXNfZmRzLmxlbmd0aDtcbiAgICBjaGFuaWQgPSBuZXcgTWxDaGFuaWQoaWR4KTtcbiAgfSBlbHNlIGlmIChjYW1sX3N5c19mZHNbaWR4XSkge1xuICAgIGNoYW5pZCA9IGNhbWxfc3lzX2Zkc1tpZHhdLmNoYW5pZDtcbiAgfSBlbHNlIGNoYW5pZCA9IG5ldyBNbENoYW5pZChpZHgpO1xuICBjYW1sX3N5c19mZHNbaWR4XSA9IHsgZmlsZTogZmlsZSwgY2hhbmlkOiBjaGFuaWQgfTtcbiAgcmV0dXJuIGlkeCB8IDA7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuKG5hbWUsIGZsYWdzLCBwZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZSAoZmxhZ3MpIHtcbiAgICBzd2l0Y2ggKGZsYWdzWzFdKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGYucmRvbmx5ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGYud3Jvbmx5ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGYuYXBwZW5kID0gMTtcbiAgICAgICAgZi53cml0ZW9ubHkgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZi5jcmVhdGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgZi50cnVuY2F0ZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBmLmV4Y2wgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgZi5iaW5hcnkgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgZi50ZXh0ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDg6XG4gICAgICAgIGYubm9uYmxvY2sgPSAxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZmxhZ3MgPSBmbGFnc1syXTtcbiAgfVxuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LCBmLCBwZXJtcyk7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUsIHVuZGVmaW5lZCk7XG59XG4oZnVuY3Rpb24gKCkge1xuICB2YXIgaXNfbm9kZSA9IGZzX25vZGVfc3VwcG9ydGVkKCk7XG4gIGZ1bmN0aW9uIGZpbGUoZmQsIGZsYWdzKSB7XG4gICAgaWYgKGlzX25vZGUpIHtcbiAgICAgIHJldHVybiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyk7XG4gICAgfSBlbHNlIHJldHVybiBuZXcgTWxGYWtlRmRfb3V0KGZkLCBmbGFncyk7XG4gIH1cbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChcbiAgICBmaWxlKDAsIHsgcmRvbmx5OiAxLCBhbHRuYW1lOiBcIi9kZXYvc3RkaW5cIiwgaXNDaGFyYWN0ZXJEZXZpY2U6IHRydWUgfSksXG4gICAgMCxcbiAgKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChcbiAgICBmaWxlKDEsIHsgYnVmZmVyZWQ6IGlzX25vZGUgPyAxIDogMiwgd3Jvbmx5OiAxLCBpc0NoYXJhY3RlckRldmljZTogdHJ1ZSB9KSxcbiAgICAxLFxuICApO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKFxuICAgIGZpbGUoMiwgeyBidWZmZXJlZDogaXNfbm9kZSA/IDEgOiAyLCB3cm9ubHk6IDEsIGlzQ2hhcmFjdGVyRGV2aWNlOiB0cnVlIH0pLFxuICAgIDIsXG4gICk7XG59KSgpO1xuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZShjaGFuaWQsIG5hbWUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4ubmFtZSA9IG5hbWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBNbENoYW5pZFxuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsc19zdGF0ZSgpIHtcbiAgdGhpcy5tYXAgPSBuZXcgZ2xvYmFsVGhpcy5XZWFrTWFwKCk7XG4gIHRoaXMub3BlbmVkID0gbmV3IGdsb2JhbFRoaXMuU2V0KCk7XG59XG5jYW1sX21sX2NoYW5uZWxzX3N0YXRlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjaGFuaWQpIHtcbiAgdGhpcy5vcGVuZWQuZGVsZXRlKGNoYW5pZCk7XG59O1xuY2FtbF9tbF9jaGFubmVsc19zdGF0ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGNoYW5pZCkge1xuICByZXR1cm4gdGhpcy5tYXAuZ2V0KGNoYW5pZCk7XG59O1xuY2FtbF9tbF9jaGFubmVsc19zdGF0ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGNoYW5pZCwgdmFsKSB7XG4gIGlmICh2YWwub3BlbmVkKSB0aGlzLm9wZW5lZC5hZGQoY2hhbmlkKTtcbiAgcmV0dXJuIHRoaXMubWFwLnNldChjaGFuaWQsIHZhbCk7XG59O1xuY2FtbF9tbF9jaGFubmVsc19zdGF0ZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5vcGVuZWQudmFsdWVzKCk7XG59O1xuXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBjYW1sX21sX2NoYW5uZWxzX3N0YXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9nZXQoaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHMuZ2V0KGlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3JlZGlyZWN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3QoY2FwdHVyZWQsIGludG8pIHtcbiAgdmFyIHRvX3Jlc3RvcmUgPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNhcHR1cmVkKTtcbiAgdmFyIG5ld18gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGludG8pO1xuICBjYW1sX21sX2NoYW5uZWxzLnNldChjYXB0dXJlZCwgbmV3Xyk7XG4gIHJldHVybiB0b19yZXN0b3JlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfcmVzdG9yZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUoY2FwdHVyZWQsIHRvX3Jlc3RvcmUpIHtcbiAgY2FtbF9tbF9jaGFubmVscy5zZXQoY2FwdHVyZWQsIHRvX3Jlc3RvcmUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCgpIHtcbiAgdmFyIGwgPSAwO1xuICB2YXIga2V5cyA9IGNhbWxfbWxfY2hhbm5lbHMuYWxsKCk7XG4gIGZvciAodmFyIGsgb2Yga2V5cykge1xuICAgIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChrKTtcbiAgICBpZiAoY2hhbi5vcGVuZWQgJiYgY2hhbi5vdXQpIGwgPSBbMCwgaywgbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9zeXNfb3BlblxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0KGZkKSB7XG4gIHZhciBmZF9kZXNjID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYgKGZkX2Rlc2MgPT09IHVuZGVmaW5lZClcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiICsgZmQgKyBcIiBkb2Vzbid0IGV4aXN0XCIpO1xuICB2YXIgZmlsZSA9IGZkX2Rlc2MuZmlsZTtcbiAgdmFyIGNoYW5pZCA9IGZkX2Rlc2MuY2hhbmlkO1xuICB2YXIgYnVmZmVyZWQgPSBmaWxlLmZsYWdzLmJ1ZmZlcmVkICE9PSB1bmRlZmluZWQgPyBmaWxlLmZsYWdzLmJ1ZmZlcmVkIDogMTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTogZmlsZSxcbiAgICBvZmZzZXQ6IGZpbGUub2Zmc2V0LFxuICAgIGZkOiBmZCxcbiAgICBvcGVuZWQ6IHRydWUsXG4gICAgb3V0OiB0cnVlLFxuICAgIGJ1ZmZlcl9jdXJyOiAwLFxuICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIGJ1ZmZlcmVkOiBidWZmZXJlZCxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVscy5zZXQoY2hhbmlkLCBjaGFubmVsKTtcbiAgcmV0dXJuIGNoYW5pZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luKGZkKSB7XG4gIHZhciBmZF9kZXNjID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYgKGZkX2Rlc2MgPT09IHVuZGVmaW5lZClcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiICsgZmQgKyBcIiBkb2Vzbid0IGV4aXN0XCIpO1xuICB2YXIgZmlsZSA9IGZkX2Rlc2MuZmlsZTtcbiAgdmFyIGNoYW5pZCA9IGZkX2Rlc2MuY2hhbmlkO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTogZmlsZSxcbiAgICBvZmZzZXQ6IGZpbGUub2Zmc2V0LFxuICAgIGZkOiBmZCxcbiAgICBvcGVuZWQ6IHRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICBidWZmZXJfY3VycjogMCxcbiAgICBidWZmZXJfbWF4OiAwLFxuICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIHJlZmlsbDogcmVmaWxsLFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzLnNldChjaGFuaWQsIGNoYW5uZWwpO1xuICByZXR1cm4gY2hhbmlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbl93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3MoZmQsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRfd2l0aF9mbGFncyhmZCwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dChmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL0FsaWFzOiB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWxcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsIG1vZGUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4uZmlsZS5mbGFncy50ZXh0ID0gIW1vZGU7XG4gIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkgPSBtb2RlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfaXNfYmluYXJ5X21vZGUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5maWxlLmZsYWdzLmJpbmFyeTtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub3BlbmVkKSB7XG4gICAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgICBjYW1sX21sX2NoYW5uZWxzLmNsb3NlKGNoYW5pZCk7XG4gICAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZCk7XG4gICAgY2hhbi5mZCA9IC0xO1xuICAgIGNoYW4uYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCwgZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5vdXRwdXQgPSBmdW5jdGlvbiAocykge1xuICAgIGYocyk7XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLCBmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JlZmlsbChjaGFuKSB7XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSB7XG4gICAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gICAgdmFyIHN0cl9hID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyX2EubGVuZ3RoID09PSAwKSB7XG4gICAgICBjaGFuLnJlZmlsbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFuLmJ1ZmZlci5sZW5ndGggPCBjaGFuLmJ1ZmZlcl9tYXggKyBzdHJfYS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9tYXggKyBzdHJfYS5sZW5ndGgpO1xuICAgICAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgICAgIGNoYW4uYnVmZmVyID0gYjtcbiAgICAgIH1cbiAgICAgIGNoYW4uYnVmZmVyLnNldChzdHJfYSwgY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIGNoYW4ub2Zmc2V0ICs9IHN0cl9hLmxlbmd0aDtcbiAgICAgIGNoYW4uYnVmZmVyX21heCArPSBzdHJfYS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChjaGFuLmZkID09PSAtMSkge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJCYWQgZmlsZSBkZXNjcmlwdG9yXCIpO1xuICAgIH1cbiAgICB2YXIgbnJlYWQgPSBjaGFuLmZpbGUucmVhZChcbiAgICAgIGNoYW4uYnVmZmVyLFxuICAgICAgY2hhbi5idWZmZXJfbWF4LFxuICAgICAgY2hhbi5idWZmZXIubGVuZ3RoIC0gY2hhbi5idWZmZXJfbWF4LFxuICAgICk7XG4gICAgY2hhbi5vZmZzZXQgKz0gbnJlYWQ7XG4gICAgY2hhbi5idWZmZXJfbWF4ICs9IG5yZWFkO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQoY2hhbmlkLCBiLCBpLCBsKSB7XG4gIHZhciBiYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYik7XG4gIHJldHVybiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5XG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9iaWdhcnJheShjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF9iYV90b190eXBlZF9hcnJheShiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciBuID0gbDtcbiAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgaWYgKGwgPD0gYXZhaWwpIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VyciwgY2hhbi5idWZmZXJfY3VyciArIGwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGw7XG4gIH0gZWxzZSBpZiAoYXZhaWwgPiAwKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsIGNoYW4uYnVmZmVyX2N1cnIgKyBhdmFpbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYXZhaWw7XG4gICAgbiA9IGF2YWlsO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgICBpZiAobiA+IGF2YWlsKSBuID0gYXZhaWw7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsIGNoYW4uYnVmZmVyX2N1cnIgKyBuKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBuO1xuICB9XG4gIHJldHVybiBuIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9ieXRlc19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yZWZpbGwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciBoZWFkZXIgPSBuZXcgVWludDhBcnJheShjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBmdW5jdGlvbiBibG9jayhidWZmZXIsIG9mZnNldCwgbikge1xuICAgIHZhciByID0gMDtcbiAgICB3aGlsZSAociA8IG4pIHtcbiAgICAgIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCkge1xuICAgICAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgICAgICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpIGJyZWFrO1xuICAgICAgYnVmZmVyW29mZnNldCArIHJdID0gY2hhbi5idWZmZXJbY2hhbi5idWZmZXJfY3Vycl07XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyKys7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHZhciByID0gYmxvY2soaGVhZGVyLCAwLCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBpZiAociA9PT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICBlbHNlIGlmIChyIDwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdHJ1bmNhdGVkIG9iamVjdFwiKTtcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUoY2FtbF9ieXRlc19vZl91aW50OF9hcnJheShoZWFkZXIpLCAwKTtcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbiArIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGJ1Zi5zZXQoaGVhZGVyLCAwKTtcbiAgdmFyIHIgPSBibG9jayhidWYsIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSwgbGVuKTtcbiAgaWYgKHIgPCBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdHJ1bmNhdGVkIG9iamVjdCBcIiArIHIgKyBcIiAgXCIgKyBsZW4pO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoYnVmKSwgMCk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwXG4vL1JlcXVpcmVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwKGMpIHtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWUoYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9yZWZpbGxcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhcihjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gIH1cbiAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgY2hhbi5idWZmZXJfY3VycisrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9jaGFyLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHJlcyA9ICgocmVzIDw8IDgpICsgY2FtbF9tbF9pbnB1dF9jaGFyKGNoYW5pZCkpIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmIChcbiAgICBwb3MgPj0gY2hhbi5vZmZzZXQgLSBjaGFuLmJ1ZmZlcl9tYXggJiZcbiAgICBwb3MgPD0gY2hhbi5vZmZzZXQgJiZcbiAgICBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5XG4gICkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uZmlsZS5zZWVrKHBvcywgMCk7XG4gICAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQsIHBvcykge1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQsIHBvcykge1xuICB2YXIgcG9zID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfcG9zX2luKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4ub2Zmc2V0IC0gKGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19pblxuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfcG9zX2luKGNoYW5pZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9yZWZpbGxcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBkbyB7XG4gICAgaWYgKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZiAoY2hhbi5idWZmZXJfY3VyciA+IDApIHtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIpLCAwKTtcbiAgICAgICAgcCAtPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLWNoYW4uYnVmZmVyX21heCB8IDA7XG4gICAgICB9XG4gICAgICB2YXIgcHJldl9tYXggPSBjaGFuLmJ1ZmZlcl9tYXg7XG4gICAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICAgIGlmIChwcmV2X21heCA9PT0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICAgIHJldHVybiAtY2hhbi5idWZmZXJfbWF4IHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT09IDEwKTtcbiAgcmV0dXJuIChwIC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmICghY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmICghY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXJfY3VyciA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChjaGFuLm91dHB1dCkge1xuICAgIGNoYW4ub3V0cHV0KFxuICAgICAgY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlcyhjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3VyciksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBjaGFuLmJ1ZmZlcl9jdXJyOyApIHtcbiAgICAgIHBvcyArPSBjaGFuLmZpbGUud3JpdGUoY2hhbi5idWZmZXIsIHBvcywgY2hhbi5idWZmZXJfY3VyciAtIHBvcyk7XG4gICAgfVxuICB9XG4gIGNoYW4ub2Zmc2V0ICs9IGNoYW4uYnVmZmVyX2N1cnI7XG4gIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfdGFcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmICghY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBpZiAoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGggPiBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgY2hhbi5idWZmZXIgPSBiO1xuICB9XG4gIHN3aXRjaCAoY2hhbi5idWZmZXJlZCkge1xuICAgIGNhc2UgMDogLy8gVW5idWZmZXJlZFxuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6IC8vIEJ1ZmZlcmVkICh0aGUgZGVmYXVsdClcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKSBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6IC8vIEJ1ZmZlcmVkIChvbmx5IGZvciBzdGRvdXQgYW5kIHN0ZGVycilcbiAgICAgIHZhciBpZCA9IGJ1ZmZlci5sYXN0SW5kZXhPZigxMCk7XG4gICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aCkgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBpZCArIDE7XG4gICAgICAgIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoIC0gaWQgLSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLCBidWZmZXIsIG9mZnNldCwgbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF9tbF9vdXRwdXRfdGFcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9iaWdhcnJheShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pIHtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCwgYnVmZmVyLCBvZmZzZXQsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCwgYnVmZmVyLCBvZmZzZXQsIGxlbikge1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoXG4gICAgY2hhbmlkLFxuICAgIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksXG4gICAgb2Zmc2V0LFxuICAgIGxlbixcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIoY2hhbmlkLCBjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLCBzLCAwLCAxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUoY2hhbmlkLCB2LCBmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5maWxlLnNlZWsocG9zLCAwKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3NlZWtfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKSB7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLCBwb3MpIHtcbiAgdmFyIHBvcyA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfcG9zX291dChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLm9mZnNldCArIGNoYW4uYnVmZmVyX2N1cnI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50KGNoYW5pZCwgaSkge1xuICB2YXIgYXJyID0gWyhpID4+IDI0KSAmIDB4ZmYsIChpID4+IDE2KSAmIDB4ZmYsIChpID4+IDgpICYgMHhmZiwgaSAmIDB4ZmZdO1xuICBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIG5ldyBVaW50OEFycmF5KGFyciksIDAsIDQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYnVmZmVyZWQoY2hhbmlkLCB2KSB7XG4gIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA9IHY7XG4gIGlmICghdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvcihtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9BbGlhczogY2FtbF91bml4X2V4aXRcbi8vQWxpYXM6IHVuaXhfZXhpdFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdChjb2RlKSB7XG4gIGlmIChnbG9iYWxUaGlzLnF1aXQpIGdsb2JhbFRoaXMucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYgKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdClcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG4pIHtcbiAgc3dpdGNoIChleG5bMl0pIHtcbiAgICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gICAgY2FzZSAtMTE6IC8vIEFzc2VydF9mYWlsdXJlXG4gICAgY2FzZSAtMTI6IC8vIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG4gICAgICByZXR1cm4gMTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXhuKSB7XG4gIHZhciByID0gXCJcIjtcbiAgaWYgKGV4blswXSA9PT0gMCkge1xuICAgIHIgKz0gZXhuWzFdWzFdO1xuICAgIGlmIChcbiAgICAgIGV4bi5sZW5ndGggPT09IDMgJiZcbiAgICAgIGV4blsyXVswXSA9PT0gMCAmJlxuICAgICAgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG5bMV0pXG4gICAgKSB7XG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMjtcbiAgICAgIHZhciBidWNrZXQgPSBleG47XG4gICAgfVxuICAgIHIgKz0gXCIoXCI7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IHN0YXJ0KSByICs9IFwiLCBcIjtcbiAgICAgIHZhciB2ID0gYnVja2V0W2ldO1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSByICs9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgIHIgKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHIgKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9IGVsc2UgciArPSBcIl9cIjtcbiAgICB9XG4gICAgciArPSBcIilcIjtcbiAgfSBlbHNlIGlmIChleG5bMF0gPT09IDI0OCkge1xuICAgIHIgKz0gZXhuWzFdO1xuICB9XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9mb3JtYXRfZXhjZXB0aW9uLCBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyKSAmJiAoZXJyWzBdID09PSAwIHx8IGVyclswXSA9PT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYgKGhhbmRsZXIpIGNhbWxfY2FsbGJhY2soaGFuZGxlciwgW2VyciwgZmFsc2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmIChhdF9leGl0KSBjYW1sX2NhbGxiYWNrKGF0X2V4aXQsIFswXSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIiArIG1zZyk7XG4gICAgICBpZiAoZXJyLmpzX2Vycm9yKSB0aHJvdyBlcnIuanNfZXJyb3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3N0YXRpY19lbnZcbnZhciBqc29vX3N0YXRpY19lbnYgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuLy9SZXF1aXJlczoganNvb19zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssIHYpIHtcbiAganNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc29vX3N0YXRpY19lbnZcbmZ1bmN0aW9uIGpzb29fc3lzX2dldGVudihuKSB7XG4gIGlmIChqc29vX3N0YXRpY19lbnZbbl0pIHJldHVybiBqc29vX3N0YXRpY19lbnZbbl07XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICAvL25vZGVqcyBlbnZcbiAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbbl0gIT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbl07XG4gIGlmIChnbG9iYWxUaGlzLmpzb29fZW52ICYmIHR5cGVvZiBnbG9iYWxUaGlzLmpzb29fZW52W25dID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuanNvb19lbnZbbl07XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52KG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnZcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfdW5zYWZlX2dldGVudihuYW1lKSB7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYobmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX2FyZ3YgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW107XG5cbiAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5hcmd2ICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV07XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2KGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndihhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZykge1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSkge1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKSB7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJub2RlOmNoaWxkX3Byb2Nlc3NcIik7XG4gICAgaWYgKGNoaWxkX3Byb2Nlc3MgJiYgY2hpbGRfcHJvY2Vzcy5leGVjU3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY21kLCB7IHN0ZGlvOiBcImluaGVyaXRcIiB9KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICB9IGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpIHtcbiAgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSgpIHtcbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCgpIHtcbiAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdmFyIGEgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IEludDMyQXJyYXkoNCkpO1xuICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICB2YXIgYSA9IG5ldyBJbnQzMkFycmF5KGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS5idWZmZXIpO1xuICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vdyBeICgweGZmZmZmZmZmICogTWF0aC5yYW5kb20oKSk7XG4gIHJldHVybiBbMCwgeF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4oKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSgpIHtcbiAgcmV0dXJuIDMyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUoKSB7XG4gIHJldHVybiAzMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplKCkge1xuICByZXR1cm4gKDB4N2ZmZmZmZmYgLyA0KSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCgpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiVW5peFwiID8gMSA6IDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMigpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiV2luMzJcIiA/IDEgOiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbigpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiQ3lnd2luXCIgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogb3NfdHlwZVxudmFyIG9zX3R5cGUgPVxuICBnbG9iYWxUaGlzLnByb2Nlc3MgJiZcbiAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiXG4gICAgPyBcIldpbjMyXCJcbiAgICA6IFwiVW5peFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMob3NfdHlwZSksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3hkZ19kZWZhdWx0c1xuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfeGRnX2RlZmF1bHRzKF91bml0KSB7XG4gIHJldHVybiAwOyAvLyBlbXB0eSBsaXN0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGUobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuaXNGaWxlKHJvb3QucmVzdCk7XG59XG4vL0Fsd2F5c1xuLy9SZXF1aXJlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbi8vSWY6ICF3YXNtXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5vbikge1xuICAgIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBmdW5jdGlvbiAoZXJyLCBvcmlnaW4pIHtcbiAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycik7XG4gICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZXJyb3IpIHtcbiAgICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZyA9IEZMQUcoXCJ3aXRoLWpzLWVycm9yXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IGpzb29fc3lzX2dldGVudihcIk9DQU1MUlVOUEFSQU1cIik7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbCA9IHIuc3BsaXQoXCIsXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxbaV0gPT09IFwiYlwiKSB7XG4gICAgICAgIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZyA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChsW2ldLnN0YXJ0c1dpdGgoXCJiPVwiKSkge1xuICAgICAgICBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWcgPSArbFtpXS5zbGljZSgyKTtcbiAgICAgIH0gZWxzZSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWdcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZ1xudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcgPSBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWc7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfcnVudGltZV9mbGFnXG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcgPyAxIDogMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlKCkge1xuICByZXR1cm4gWzBdO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfcnVudGltZV9mbGFnXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UoYikge1xuICBjYW1sX3JlY29yZF9iYWNrdHJhY2VfcnVudGltZV9mbGFnID0gYjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UoKSB7XG4gIHJldHVybiBbMF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkge1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkge1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjaygpIHtcbiAgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiAhZWZmZWN0c1xuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09PSAwKSByZXR1cm4gZiguLi5hcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgZyA9IGYoLi4uYXJncy5zbGljZSgwLCBuKSk7XG4gICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBnO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsIGFyZ3Muc2xpY2UobikpO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDEpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICAgIHJldHVybiBmKC4uLm5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKyspIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgICByZXR1cm4gZiguLi5uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncy5jb25jYXQoZXh0cmFfYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBnLmwgPSBkO1xuICAgIHJldHVybiBnO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UobiAtIDEpO1xuICAgIHZhciBrID0gYXJnc1thcmdzTGVuIC0gMV07XG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgbik7XG4gICAgYXJnc1tuIC0gMV0gPSBmdW5jdGlvbiAoZykge1xuICAgICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBrKGcpO1xuICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBrO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZiguLi5hcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzTGVuLS07XG4gICAgdmFyIGsgPSBhcmdzW2FyZ3NMZW5dO1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDIpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgICAgcmV0dXJuIGYoLi4ubmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAzKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKykgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAyXSA9IHo7XG4gICAgICAgICAgcmV0dXJuIGYoLi4ubmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgYXJncy5sZW5ndGggPSBhcmdzTGVuO1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncy5jb25jYXQoZXh0cmFfYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBnLmwgPSBkICsgMTtcbiAgICByZXR1cm4gayhnKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX2Nwc1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG52YXIgY2FtbF9jYWxsX2dlbl9jcHMgPSBjYW1sX2NhbGxfZ2VuO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX3R1cGxlIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfY3BzX2Nsb3N1cmVcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG52YXIgY2FtbF9jYWxsX2dlbl90dXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGNhbWxfY2FsbF9nZW5fZGlyZWN0KGYsIGFyZ3MpIHtcbiAgICB2YXIgbiA9IGYubCA+PSAwID8gZi5sIDogKGYubCA9IGYubGVuZ3RoKTtcbiAgICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gICAgaWYgKGQgPT09IDApIHtcbiAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICAgIHZhciBnID0gZiguLi5hcmdzLnNsaWNlKDAsIG4pKTtcbiAgICAgIGlmICh0eXBlb2YgZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZztcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2RpcmVjdChnLCBhcmdzLnNsaWNlKG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IFJlc3RvcmUgdGhlIG9wdGltaXphdGlvbiBvZiBoYW5kbGluZyBzcGVjaWFsbHkgZCA9IDEgb3IgMlxuICAgICAgdmFyIGFyZ3NfID0gYXJncy5zbGljZSgpO1xuICAgICAgYXJnc18ubGVuZ3RoID0gYXJnc0xlbjtcbiAgICAgIHZhciByZXQgPSBjYW1sX2Nwc19jbG9zdXJlKFxuICAgICAgICBmdW5jdGlvbiAoLi4uZXh0cmFfYXJncykge1xuICAgICAgICAgIGlmIChleHRyYV9hcmdzLmxlbmd0aCA9PT0gMCkgZXh0cmFfYXJncyA9IFt1bmRlZmluZWRdO1xuICAgICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2RpcmVjdChmLCBhcmdzLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fY3BzKGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmV0LmwgPSBkO1xuICAgICAgcmV0LmNwcy5sID0gZCArIDE7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW1sX2NhbGxfZ2VuX2NwcyhmLCBhcmdzKSB7XG4gICAgaWYgKCFmLmNwcykge1xuICAgICAgdmFyIGsgPSBhcmdzLnBvcCgpO1xuICAgICAgcmV0dXJuIGsoY2FtbF9jYWxsX2dlbl9kaXJlY3QoZiwgYXJncykpO1xuICAgIH1cbiAgICB2YXIgbiA9IGYuY3BzLmwgPj0gMCA/IGYuY3BzLmwgOiAoZi5jcHMubCA9IGYuY3BzLmxlbmd0aCk7XG4gICAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgICB2YXIgZCA9IG4gLSBhcmdzTGVuO1xuICAgIGlmIChkID09PSAwKSB7XG4gICAgICByZXR1cm4gZi5jcHMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChkIDwgMCkge1xuICAgICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKG4gLSAxKTtcbiAgICAgIHZhciBrID0gYXJnc1thcmdzTGVuIC0gMV07XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBuKTtcbiAgICAgIGFyZ3NbbiAtIDFdID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGs7XG4gICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2NwcyhnLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZi5jcHMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NMZW4tLTtcbiAgICAgIHZhciBhcmdzXyA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgIGFyZ3NfLmxlbmd0aCA9IGFyZ3NMZW47XG4gICAgICB2YXIgY29udCA9IGNhbWxfY3BzX2Nsb3N1cmUoXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fZGlyZWN0KGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fY3BzKGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdmFyIGsgPSBhcmdzW2FyZ3NMZW5dO1xuICAgICAgY29udC5sID0gZDtcbiAgICAgIGNvbnQuY3BzLmwgPSBkICsgMTtcbiAgICAgIHJldHVybiBrKGNvbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2NhbWxfY2FsbF9nZW5fZGlyZWN0LCBjYW1sX2NhbGxfZ2VuX2Nwc107XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuX3R1cGxlXG4vL0lmOiBlZmZlY3RzXG4vL0lmOiBkb3VibGV0cmFuc2xhdGVcbi8vV2Vha2RlZlxudmFyIGNhbWxfY2FsbF9nZW4gPSBjYW1sX2NhbGxfZ2VuX3R1cGxlWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX2Nwc1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbl90dXBsZVxuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG4vL1dlYWtkZWZcbnZhciBjYW1sX2NhbGxfZ2VuX2NwcyA9IGNhbWxfY2FsbF9nZW5fdHVwbGVbMV07XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLCB2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9idWlsZF9zeW1ib2xzXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9idWlsZF9zeW1ib2xzKHN5bWIpIHtcbiAgdmFyIHIgPSB7fTtcbiAgdmFyIG1heCA9IC0xO1xuICBpZiAoc3ltYikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3ltYi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkeCA9IHN5bWJbaV1bMl07XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGlkeCk7XG4gICAgICByW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN5bWJbaV1bMV0pXSA9IGlkeDtcbiAgICB9XG4gIH1cbiAgci5uZXh0X2lkeCA9IG1heCArIDE7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3RvcGxldmVsX3JlbG9jXG52YXIganNvb190b3BsZXZlbF9yZWxvYyA9IHVuZGVmaW5lZDtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfY2FsbGJhY2ssIGNhbWxfYnVpbGRfc3ltYm9sc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczoganNvb190b3BsZXZlbF9yZWxvY1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYgKG5hbWVfb3B0KSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lX29wdDtcbiAgICBpZiAoanNvb190b3BsZXZlbF9yZWxvYykge1xuICAgICAgbiA9IGNhbWxfY2FsbGJhY2soanNvb190b3BsZXZlbF9yZWxvYywgW25hbWVdKTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scykge1xuICAgICAgaWYgKCFjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCkge1xuICAgICAgICBjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCA9IGNhbWxfYnVpbGRfc3ltYm9scyhjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHMpO1xuICAgICAgfVxuICAgICAgdmFyIG5pZCA9IGNhbWxfZ2xvYmFsX2RhdGEuc3ltaWR4W25hbWVdO1xuICAgICAgaWYgKG5pZCA+PSAwKSBuID0gbmlkO1xuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSB1bml0IGlzIHVua25vd24sIHRoaXMgY2FuIGhhcHBlbiB3aGVuIGR5bmxpbmtpbmcgYSBwcmVjb21waWxlZCBqcyxcbiAgICAgICAgLy8gbGV0J3MgYWxsb2NhdGUgYSBmcmVzaCBpZHguXG4gICAgICAgIHZhciBuID0gY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHgubmV4dF9pZHgrKztcbiAgICAgICAgY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHhbbmFtZV0gPSBuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmIChuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSgpIHtcbiAgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHtcbiAgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX3ByaW50X3N0YXRzXG5mdW5jdGlvbiBjYW1sX21heWJlX3ByaW50X3N0YXRzKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHJvY2Vzc19wZW5kaW5nX2FjdGlvbnNfd2l0aF9yb290XG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9wcm9jZXNzX3BlbmRpbmdfYWN0aW9uc193aXRoX3Jvb3QoZXh0cmFfcm9vdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIoZikge1xuICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbMF0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLCBmLCB2KSB7XG4gIG9bZl0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sIGYpIHtcbiAgcmV0dXJuIG9bZl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLCBmKSB7XG4gIGRlbGV0ZSBvW2ZdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobywgYykge1xuICByZXR1cm4gbyBpbnN0YW5jZW9mIGMgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2Yobykge1xuICByZXR1cm4gdHlwZW9mIG87XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUgKHJlcyAmJiByZXMuam9vX3RyYW1wKSB7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZiwgYXJncywgZGlyZWN0KSB7XG4gIHJldHVybiB7IGpvb190cmFtcDogZiwgam9vX2FyZ3M6IGFyZ3MsIGpvb19kaXJlY3Q6IGRpcmVjdCB9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gIHJldHVybiAtLWNhbWxfc3RhY2tfZGVwdGggPiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxiYWNrXG4vL0lmOiAhZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX2NhbGxfZ2VuXG52YXIgY2FtbF9jYWxsYmFjayA9IGNhbWxfY2FsbF9nZW47XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6IGVmZmVjdHNcbi8vSWY6ICFkb3VibGV0cmFuc2xhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RhY2tfZGVwdGgsIGNhbWxfY2FsbF9nZW4sIGNhbWxfd3JhcF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9zdGFja1xuZnVuY3Rpb24gY2FtbF9jYWxsYmFjayhmLCBhcmdzKSB7XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9jdXJyZW50X3N0YWNrID0gY2FtbF9jdXJyZW50X3N0YWNrO1xuICB0cnkge1xuICAgIGNhbWxfY3VycmVudF9zdGFjayA9IHsgazogMCwgeDogMCwgaDogMCwgZTogMCB9O1xuICAgIHZhciByZXMgPSB7XG4gICAgICBqb29fdHJhbXA6IGYsXG4gICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9KSxcbiAgICB9O1xuICAgIGRvIHtcbiAgICAgIGNhbWxfc3RhY2tfZGVwdGggPSA0MDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGNhbWxfY2FsbF9nZW4ocmVzLmpvb190cmFtcCwgcmVzLmpvb19hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogSGFuZGxlIGV4Y2VwdGlvbiBjb21pbmcgZnJvbSBKYXZhU2NyaXB0IG9yIGZyb20gdGhlIHJ1bnRpbWUuICovXG4gICAgICAgIGlmICghY2FtbF9jdXJyZW50X3N0YWNrLngpIHRocm93IGU7XG4gICAgICAgIHZhciBoYW5kbGVyID0gY2FtbF9jdXJyZW50X3N0YWNrLnguaDtcbiAgICAgICAgY2FtbF9jdXJyZW50X3N0YWNrLnggPSBjYW1sX2N1cnJlbnRfc3RhY2sueC50O1xuICAgICAgICByZXMgPSB7IGpvb190cmFtcDogaGFuZGxlciwgam9vX2FyZ3M6IFtjYW1sX3dyYXBfZXhjZXB0aW9uKGUpXSB9O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHJlcyAmJiByZXMuam9vX2FyZ3MpO1xuICB9IGZpbmFsbHkge1xuICAgIGNhbWxfc3RhY2tfZGVwdGggPSBzYXZlZF9zdGFja19kZXB0aDtcbiAgICBjYW1sX2N1cnJlbnRfc3RhY2sgPSBzYXZlZF9jdXJyZW50X3N0YWNrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxudmFyIGNhbWxfY2FsbGJhY2sgPSBjYW1sX2NhbGxfZ2VuO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nKHVuaXQpIHtcbiAgcmV0dXJuIEZMQUcoXCJ1c2UtanMtc3RyaW5nXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHModW5pdCkge1xuICByZXR1cm4gQ09ORklHKFwiZWZmZWN0c1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAobXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmIChGTEFHKFwiZXhjd3JhcFwiKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSByZXR1cm4gZTtcbiAgICB2YXIgZXhuO1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gICAgaWYgKFxuICAgICAgZ2xvYmFsVGhpcy5SYW5nZUVycm9yICYmXG4gICAgICBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yICYmXG4gICAgICBlLm1lc3NhZ2UgJiZcbiAgICAgIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpXG4gICAgKVxuICAgICAgZXhuID0gY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdztcbiAgICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gICAgZWxzZSBpZiAoXG4gICAgICBnbG9iYWxUaGlzLkludGVybmFsRXJyb3IgJiZcbiAgICAgIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3IgJiZcbiAgICAgIGUubWVzc2FnZSAmJlxuICAgICAgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSlcbiAgICApXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgICBlbHNlIGlmIChlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICAgIGV4biA9IFswLCBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSwgZV07XG4gICAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gICAgZWxzZVxuICAgICAgZXhuID0gWzAsIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoU3RyaW5nKGUpKV07XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGF0IGhhbmQsIGxldCdzIHVzZSBpdC5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpIGV4bi5qc19lcnJvciA9IGU7XG4gICAgcmV0dXJuIGV4bjtcbiAgfSBlbHNlIHJldHVybiBlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWdcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vIEJhY2t0cmFjZXMgYXJlIHZlcnkgZXhwZW5zaXZlLCB3ZSBvbmx5IGVuYWJsZSB0aGVtIHdoZW4gZXhwbGljaXRseSByZXF1ZXN0ZWRcbiAgLy8gYXQgY29tcGlsZS10aW1lICgtLWVuYWJsZSB3aXRoLWpzLWVycm9yKSBvciBhdCBzdGFydHVwIHdpdGggT0NBTUxSVU5QQVJBTT1iPTEuXG4gIC8vIExpYnJhcmllcyBzdWNoIGFzIEJhc2UgdW5jb25kaXRpb25hbGx5IGVuYWJsZSBiYWNrdHJhY2VzIChwcm9ncmFtbWF0aWNhbGx5KSBidXRcbiAgLy8gaXQncyB3YXkgdG8gc2xvdy4gSGVyZSwgd2UgZm9yY2UgdGhlIGVuZC11c2VyIHRvIG9wdC1pbiB0byBiYWNrdHJhY2VzLlxuICBpZiAoY2FtbF9yZWNvcmRfYmFja3RyYWNlX2Vudl9mbGFnICYmIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcpXG4gICAgcmV0dXJuIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpO1xuICBlbHNlIHJldHVybiBleG47XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYgKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09PSAyNDgpXG4gICAgZXhuLmpzX2Vycm9yID0gbmV3IGdsb2JhbFRoaXMuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZiAoZXhuLmpzX2Vycm9yKSB7XG4gICAgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7XG4gIHJldHVybiAhIXg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbi8vQWxpYXM6IGNhbWxfanNfZnJvbV9pbnQzMlxuLy9BbGlhczogY2FtbF9qc19mcm9tX25hdGl2ZWludFxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkge1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9faW50MzIgY29uc3QgKGNvbnN0KVxuLy9BbGlhczogY2FtbF9qc190b19uYXRpdmVpbnRcbmZ1bmN0aW9uIGNhbWxfanNfdG9faW50MzIoeCkge1xuICByZXR1cm4geCB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgYlswXSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGJbaSArIDFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLCBlLCBsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpIHtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yICg7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmICgheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnY2FtbF9qc192YXI6IFwiJyArXG4gICAgICAgIHggK1xuICAgICAgICAnXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLicsXG4gICAgKTtcbiAgICAvL2NvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zZWN1cml0eS9ub0dsb2JhbEV2YWw6XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHtcbiAgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmKCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGYoYVsxXSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSk7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSk7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGYoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBuZXcgYygpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBuZXcgYyhhWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gbmV3IGMoYVsxXSwgYVsyXSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBuZXcgYyhhWzFdLCBhWzJdLCBhWzNdLCBhWzRdKTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gbmV3IGMoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0pO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBuZXcgYyhhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkge1xuICAgIHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG4gIH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGKCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gbmV3IGMoKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gbmV3IGMoYVswXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMF0sIGFbMV0pO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBuZXcgYyhhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gbmV3IGMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0pO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBuZXcgYyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gbmV3IGMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHtcbiAgICByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTtcbiAgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEYoKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFyZ3MgPSBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gICAgcmV0dXJuIHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gY2FtbF9qc193cmFwX2NhbGxiYWNrKHJlcykgOiByZXM7XG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbYXJnc10pO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBhcmdzLmxlbmd0aCA9IGFyaXR5O1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZik7XG4gICAgYXJncy5sZW5ndGggPSBsZW47XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpIDogcmVzO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFt0aGlzLCBhcmdzXSk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBhcmdzLmxlbmd0aCA9IGFyaXR5O1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICB2YXIgbGVuID0gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgYXJncy5sZW5ndGggPSBsZW47XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgcmV0dXJuIGYubCA+PSAwID8gZi5sIDogKGYubCA9IGYubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgcmV0dXJuIGYubCA+PSAwID8gZi5sIDogKGYubCA9IGYubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIC8vIEZ1bmN0aW9ucyBoYXZlIGFuIGFkZGl0aW9uYWwgY29udGludWF0aW9uIHBhcmFtZXRlci4gVGhpcyBzaG91bGRcbiAgLy8gbm90IGJlIHZpc2libGUgd2hlbiBjYWxsaW5nIHRoZW0gZnJvbSBKYXZhU2NyaXB0XG4gIHJldHVybiAoZi5sID49IDAgPyBmLmwgOiAoZi5sID0gZi5sZW5ndGgpKSAtIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzKHgsIHkpIHtcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0RvdWJsZUVxdWFsczpcbiAgcmV0dXJuICsoeCA9PSB5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zdHJpY3RfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc3RyaWN0X2VxdWFscyh4LCB5KSB7XG4gIHJldHVybiArKHggPT09IHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nKHMpIHtcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc2VjdXJpdHkvbm9HbG9iYWxFdmFsOlxuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zZWN1cml0eS9ub0dsb2JhbEV2YWw6XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByKHMpIHtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3NlY3VyaXR5L25vR2xvYmFsRXZhbDpcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50KHRhZykge1xuICB0aHJvdyB0YWc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnKHRhZywgYXJnKSB7XG4gIHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnLCBhcmddKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyh0YWcsIGFyZ3MpIHtcbiAgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLCB0YWddLmNvbmNhdChhcmdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aChtc2cpIHtcbiAgaWYgKCFjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlID0gWzI0OCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIkZhaWx1cmVcIiksIC0zXTtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5KCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF90aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZSgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FtbF91bml4X2dldHRpbWVvZmRheSgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dtdGltZVxuLy9BbGlhczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9nbXRpbWUodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSBuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIGQuZ2V0VVRDTWludXRlcygpLFxuICAgIGQuZ2V0VVRDSG91cnMoKSxcbiAgICBkLmdldFVUQ0RhdGUoKSxcbiAgICBkLmdldFVUQ01vbnRoKCksXG4gICAgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICBkLmdldFVUQ0RheSgpLFxuICAgIGRveSxcbiAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8sXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbG9jYWx0aW1lKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgamFuLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAganVsLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICk7XG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGQuZ2V0U2Vjb25kcygpLFxuICAgIGQuZ2V0TWludXRlcygpLFxuICAgIGQuZ2V0SG91cnMoKSxcbiAgICBkLmdldERhdGUoKSxcbiAgICBkLmdldE1vbnRoKCksXG4gICAgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICBkLmdldERheSgpLFxuICAgIGRveSxcbiAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHxcbiAgICAgIDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8sXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbWt0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWt0aW1lKHRtKSB7XG4gIHZhciBkID0gbmV3IERhdGUodG1bNl0gKyAxOTAwLCB0bVs1XSwgdG1bNF0sIHRtWzNdLCB0bVsyXSwgdG1bMV0pLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IGNhbWxfdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLCB0LCB0bTIpO1xufVxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXJ0dXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9zdGFydHVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbGVhbnVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fY2xlYW51cFxuZnVuY3Rpb24gY2FtbF91bml4X2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIGNvbnN0XG4vL0FsaWFzOiB3aW5faGFuZGxlX2ZkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkLCBjYW1sX3VuaXhfbG9va3VwX2ZpbGVcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZkKSB7XG4gIGlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoXCJub2RlOnR0eVwiKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQpLmZkKSA/IDEgOiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2Vycm9yXG52YXIgdW5peF9lcnJvciA9IFtcbiAgLyogPT09VW5peC5lcnJvcj09PVxuICAgKlxuICAgKiBUaGlzIGFycmF5IGlzIGluIG9yZGVyIG9mIHRoZSB2YXJpYW50IGluIE9DYW1sXG4gICAqL1xuICBcIkUyQklHXCIsXG4gIFwiRUFDQ0VTXCIsXG4gIFwiRUFHQUlOXCIsXG4gIFwiRUJBREZcIixcbiAgXCJFQlVTWVwiLFxuICBcIkVDSElMRFwiLFxuICBcIkVERUFETEtcIixcbiAgXCJFRE9NXCIsXG4gIFwiRUVYSVNUXCIsXG4gIFwiRUZBVUxUXCIsXG4gIFwiRUZCSUdcIixcbiAgXCJFSU5UUlwiLFxuICBcIkVJTlZBTFwiLFxuICBcIkVJT1wiLFxuICBcIkVJU0RJUlwiLFxuICBcIkVNRklMRVwiLFxuICBcIkVNTElOS1wiLFxuICBcIkVOQU1FVE9PTE9OR1wiLFxuICBcIkVORklMRVwiLFxuICBcIkVOT0RFVlwiLFxuICBcIkVOT0VOVFwiLFxuICBcIkVOT0VYRUNcIixcbiAgXCJFTk9MQ0tcIixcbiAgXCJFTk9NRU1cIixcbiAgXCJFTk9TUENcIixcbiAgXCJFTk9TWVNcIixcbiAgXCJFTk9URElSXCIsXG4gIFwiRU5PVEVNUFRZXCIsXG4gIFwiRU5PVFRZXCIsXG4gIFwiRU5YSU9cIixcbiAgXCJFUEVSTVwiLFxuICBcIkVQSVBFXCIsXG4gIFwiRVJBTkdFXCIsXG4gIFwiRVJPRlNcIixcbiAgXCJFU1BJUEVcIixcbiAgXCJFU1JDSFwiLFxuICBcIkVYREVWXCIsXG4gIFwiRVdPVUxEQkxPQ0tcIixcbiAgXCJFSU5QUk9HUkVTU1wiLFxuICBcIkVBTFJFQURZXCIsXG4gIFwiRU5PVFNPQ0tcIixcbiAgXCJFREVTVEFERFJSRVFcIixcbiAgXCJFTVNHU0laRVwiLFxuICBcIkVQUk9UT1RZUEVcIixcbiAgXCJFTk9QUk9UT09QVFwiLFxuICBcIkVQUk9UT05PU1VQUE9SVFwiLFxuICBcIkVTT0NLVE5PU1VQUE9SVFwiLFxuICBcIkVPUE5PVFNVUFBcIixcbiAgXCJFUEZOT1NVUFBPUlRcIixcbiAgXCJFQUZOT1NVUFBPUlRcIixcbiAgXCJFQUREUklOVVNFXCIsXG4gIFwiRUFERFJOT1RBVkFJTFwiLFxuICBcIkVORVRET1dOXCIsXG4gIFwiRU5FVFVOUkVBQ0hcIixcbiAgXCJFTkVUUkVTRVRcIixcbiAgXCJFQ09OTkFCT1JURURcIixcbiAgXCJFQ09OTlJFU0VUXCIsXG4gIFwiRU5PQlVGU1wiLFxuICBcIkVJU0NPTk5cIixcbiAgXCJFTk9UQ09OTlwiLFxuICBcIkVTSFVURE9XTlwiLFxuICBcIkVUT09NQU5ZUkVGU1wiLFxuICBcIkVUSU1FRE9VVFwiLFxuICBcIkVDT05OUkVGVVNFRFwiLFxuICBcIkVIT1NURE9XTlwiLFxuICBcIkVIT1NUVU5SRUFDSFwiLFxuICBcIkVMT09QXCIsXG4gIFwiRU9WRVJGTE9XXCIsXG5dO1xuXG4vL1Byb3ZpZGVzOiBtYWtlX3VuaXhfZXJyX2FyZ3Ncbi8vUmVxdWlyZXM6IHVuaXhfZXJyb3IsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBtYWtlX3VuaXhfZXJyX2FyZ3MoY29kZSwgc3lzY2FsbCwgcGF0aCwgZXJybm8pIHtcbiAgdmFyIHZhcmlhbnQgPSB1bml4X2Vycm9yLmluZGV4T2YoY29kZSk7XG4gIGlmICh2YXJpYW50IDwgMCkge1xuICAgIC8vIERlZmF1bHQgaWYgdW5kZWZpbmVkXG4gICAgaWYgKGVycm5vID09IG51bGwpIHtcbiAgICAgIGVycm5vID0gLTk5OTk7XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgLy8gZXJybm8gaXMgZXhwZWN0ZWQgdG8gYmUgcG9zaXRpdmVcbiAgICB2YXJpYW50ID0gQkxPQ0soMCwgLWVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKSxcbiAgXTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KFxuICAgIHJvb3QucmVzdCxcbiAgICAvKiBsYXJnZSAqLyBmYWxzZSxcbiAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUsXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XzY0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdF82NChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3RhdF82NDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KFxuICAgIHJvb3QucmVzdCxcbiAgICAvKiBsYXJnZSAqLyB0cnVlLFxuICAgIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9sc3RhdFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbHN0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubHN0YXQoXG4gICAgcm9vdC5yZXN0LFxuICAgIC8qIGxhcmdlICovIGZhbHNlLFxuICAgIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XzY0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9sc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbHN0YXRfNjQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubHN0YXQoXG4gICAgcm9vdC5yZXN0LFxuICAgIC8qIGxhcmdlICovIHRydWUsXG4gICAgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3Jcbi8vQWxpYXM6IHVuaXhfcmVuYW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVuYW1lKG8sIG4pIHtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmIChvX3Jvb3QuZGV2aWNlICE9PSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gMSwgXCJFWERFVlwiLCBcInJlbmFtZVwiKTtcbiAgaWYgKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSkgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ta2RpclxuZnVuY3Rpb24gY2FtbF91bml4X21rZGlyKG5hbWUsIHBlcm0pIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ta2Rpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbWtkaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JtZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcm1kaXIobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJtZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9ybWRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ybWRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zeW1saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vQWxpYXM6IHVuaXhfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3N5bWxpbmsodG9fZGlyLCBzcmMsIGRzdCkge1xuICB2YXIgZHN0X3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkc3QpO1xuICBpZiAoIWRzdF9yb290LmRldmljZS5zeW1saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zeW1saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGRzdF9yb290LmRldmljZS5zeW1saW5rKFxuICAgIHRvX2RpcixcbiAgICBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzcmMpLFxuICAgIGRzdF9yb290LnJlc3QsXG4gICAgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JlYWRsaW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF91bmxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3VubGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3VubGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudW5saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3V0aW1lc1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfdXRpbWVzXG5mdW5jdGlvbiBjYW1sX3VuaXhfdXRpbWVzKG5hbWUsIGF0aW1lLCBtdGltZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnV0aW1lcykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfdXRpbWVzOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcm9vdC5kZXZpY2UudXRpbWVzKHJvb3QucmVzdCwgYXRpbWUsIG10aW1lLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3RydW5jYXRlXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF90cnVuY2F0ZVxuZnVuY3Rpb24gY2FtbF91bml4X3RydW5jYXRlKG5hbWUsIGxlbikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnRydW5jYXRlKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF90cnVuY2F0ZTogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJvb3QuZGV2aWNlLnRydW5jYXRlKHJvb3QucmVzdCwgbGVuLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3RydW5jYXRlXzY0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9pbnQ2NF90b19mbG9hdFxuLy9BbGlhczogdW5peF90cnVuY2F0ZV82NFxuZnVuY3Rpb24gY2FtbF91bml4X3RydW5jYXRlXzY0KG5hbWUsIGxlbikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnRydW5jYXRlKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF90cnVuY2F0ZV82NDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJvb3QuZGV2aWNlLnRydW5jYXRlKFxuICAgIHJvb3QucmVzdCxcbiAgICBjYW1sX2ludDY0X3RvX2Zsb2F0KGxlbiksXG4gICAgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlLFxuICApO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X29wZW5cbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3N5c19mZHMsIE1sQ2hhbmlkXG4vL0FsaWFzOiB1bml4X29wZW5cbmZ1bmN0aW9uIGNhbWxfdW5peF9vcGVuKG5hbWUsIGZsYWdzLCBwZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZSAoZmxhZ3MpIHtcbiAgICBzd2l0Y2ggKGZsYWdzWzFdKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGYucmRvbmx5ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGYud3Jvbmx5ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGYucmR3ciA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmLm5vbmJsb2NrID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGYuYXBwZW5kID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIGYuY3JlYXRlID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIGYudHJ1bmNhdGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgZi5leGNsID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDg6XG4gICAgICAgIGYubm9jdHR5ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk6XG4gICAgICAgIGYuZHN5bmMgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGYuc3luYyA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmbGFncyA9IGZsYWdzWzJdO1xuICB9XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsIGYsIHBlcm1zLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICB2YXIgaWR4ID0gY2FtbF9zeXNfZmRzLmxlbmd0aDtcbiAgdmFyIGNoYW5pZCA9IG5ldyBNbENoYW5pZChpZHgpO1xuICBjYW1sX3N5c19mZHNbaWR4XSA9IHsgZmlsZTogZmlsZSwgY2hhbmlkOiBjaGFuaWQgfTtcbiAgcmV0dXJuIGlkeCB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzLCBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvclxuZnVuY3Rpb24gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBjbWQpIHtcbiAgdmFyIGZkX2Rlc2MgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZiAoZmRfZGVzYyA9PT0gdW5kZWZpbmVkKVxuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gMSwgXCJFQkFERlwiLCBjbWQpO1xuICByZXR1cm4gZmRfZGVzYy5maWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZnN0YXRcbi8vQWxpYXM6IHVuaXhfZnN0YXRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF91bml4X2ZzdGF0KGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImZzdGF0XCIpO1xuICBpZiAoIWZpbGUuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfZnN0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gZmlsZS5zdGF0KC8qIGxhcmdlICovIGZhbHNlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZzdGF0XzY0XG4vL0FsaWFzOiB1bml4X2ZzdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfdW5peF9mc3RhdF82NChmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJmc3RhdFwiKTtcbiAgaWYgKCFmaWxlLnN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2ZzdGF0NjQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gZmlsZS5zdGF0KC8qIGxhcmdlICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfd3JpdGVcbi8vQWxpYXM6IHVuaXhfd3JpdGVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF91bml4X3dyaXRlKGZkLCBidWYsIHBvcywgbGVuKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIndyaXRlXCIpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgdmFyIHdyaXR0ZW4gPSAwO1xuICB3aGlsZSAobGVuID4gMCkge1xuICAgIHZhciBuID0gZmlsZS53cml0ZShhLCBwb3MsIGxlbiwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbiAgICB3cml0dGVuICs9IG47XG4gICAgcG9zICs9IG47XG4gICAgbGVuIC09IG47XG4gIH1cbiAgcmV0dXJuIHdyaXR0ZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF93cml0ZV9iaWdhcnJheVxuLy9BbGlhczogY2FtbF91bml4X2xvb2t1cF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX3VuaXhfbG9va3VwX2ZpbGVcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX3VuaXhfd3JpdGVfYmlnYXJyYXkoZmQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgdmFyIGEgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1Zik7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIndyaXRlXCIpO1xuICB2YXIgd3JpdHRlbiA9IDA7XG4gIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgdmFyIG4gPSBmaWxlLndyaXRlKGEsIHBvcywgbGVuLCAvKiByYWlzZSB1bml4X2Vycm9yICovIDEpO1xuICAgIHdyaXR0ZW4gKz0gbjtcbiAgICBwb3MgKz0gbjtcbiAgICBsZW4gLT0gbjtcbiAgfVxuICByZXR1cm4gd3JpdHRlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRcbi8vQWxpYXM6IHVuaXhfcmVhZFxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZChmZCwgYnVmLCBwb3MsIGxlbikge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJyZWFkXCIpO1xuICByZXR1cm4gZmlsZS5yZWFkKFxuICAgIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmKSxcbiAgICBwb3MsXG4gICAgbGVuLFxuICAgIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRfYmlnYXJyYXlcbi8vQWxpYXM6IHVuaXhfcmVhZF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF91bml4X2xvb2t1cF9maWxlXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRfYmlnYXJyYXkoZmQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgdmFyIGEgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1Zik7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcInJlYWRcIik7XG4gIHJldHVybiBmaWxlLnJlYWQoYSwgcG9zLCBsZW4sIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc2Vla1xuLy9BbGlhczogdW5peF9sc2Vla1xuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlXG5mdW5jdGlvbiBjYW1sX3VuaXhfbHNlZWsoZmQsIGxlbiwgd2hlbmNlKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImxzZWVrXCIpO1xuICByZXR1cm4gZmlsZS5zZWVrKGxlbiwgd2hlbmNlLCAvKiByYWlzZSB1bml4X2Vycm9yICovIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHNlZWtfNjRcbi8vQWxpYXM6IHVuaXhfbHNlZWtfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9pbnQ2NF90b19mbG9hdFxuZnVuY3Rpb24gY2FtbF91bml4X2xzZWVrXzY0KGZkLCBsZW4sIHdoZW5jZSkge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJsc2Vla1wiKTtcbiAgcmV0dXJuIGZpbGUuc2VlayhjYW1sX2ludDY0X3RvX2Zsb2F0KGxlbiksIHdoZW5jZSwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2Z0cnVuY2F0ZVxuLy9BbGlhczogdW5peF9mdHJ1bmNhdGVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF91bml4X2Z0cnVuY2F0ZShmZCwgbGVuKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImZ0cnVuY2F0ZVwiKTtcbiAgaWYgKCFmaWxlLnRydW5jYXRlKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9mdHJ1bmNhdGU6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBmaWxlLnRydW5jYXRlKGxlbiwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9mdHJ1bmNhdGVfNjRcbi8vQWxpYXM6IHVuaXhfZnRydW5jYXRlXzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfZmFpbHdpdGgsIGNhbWxfaW50NjRfdG9fZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9mdHJ1bmNhdGVfNjQoZmQsIGxlbikge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJmdHJ1bmNhdGVcIik7XG4gIGlmICghZmlsZS50cnVuY2F0ZSkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfZnRydW5jYXRlXzY0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZmlsZS50cnVuY2F0ZShjYW1sX2ludDY0X3RvX2Zsb2F0KGxlbiksIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xvc2Vcbi8vQWxpYXM6IHVuaXhfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZVxuZnVuY3Rpb24gY2FtbF91bml4X2Nsb3NlKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImNsb3NlXCIpO1xuICBmaWxlLmNsb3NlKC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaW5jaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogdW5peF9pbmNoYW5uZWxfb2ZfZmlsZWRlc2NyXG4vL0FsaWFzOiB3aW5faW5jaGFubmVsX29mX2ZpbGVkZXNjclxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlLCBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuZnVuY3Rpb24gY2FtbF91bml4X2luY2hhbm5lbF9vZl9maWxlZGVzY3IoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQsIFwib3V0X2NoYW5uZWxfb2ZfZGVzY3JcIik7XG4gIGZpbGUuY2hlY2tfc3RyZWFtX3NlbWFudGljcyhcImluX2NoYW5uZWxfb2ZfZGVzY3JcIik7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vdXRjaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogdW5peF9vdXRjaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogd2luX291dGNoYW5uZWxfb2ZfZmlsZWRlc2NyXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuZnVuY3Rpb24gY2FtbF91bml4X291dGNoYW5uZWxfb2ZfZmlsZWRlc2NyKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIm91dF9jaGFubmVsX29mX2Rlc2NyXCIpO1xuICBmaWxlLmNoZWNrX3N0cmVhbV9zZW1hbnRpY3MoXCJvdXRfY2hhbm5lbF9vZl9kZXNjclwiKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dChmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR1aWRcbi8vQWxpYXM6IHVuaXhfZ2V0dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYgKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQoKTtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHB3dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXRwd3VpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9oYXNfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCkgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X29wZW5kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X29wZW5kaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShwYXRoKTtcbiAgaWYgKCFyb290LmRldmljZS5vcGVuZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9vcGVuZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgdmFyIGRpcl9oYW5kbGUgPSByb290LmRldmljZS5vcGVuZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbiAgcmV0dXJuIHsgcG9pbnRlcjogZGlyX2hhbmRsZSwgcGF0aDogcGF0aCB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG4vL0FsaWFzOiB1bml4X3JlYWRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpIHtcbiAgdmFyIGVudHJ5O1xuICB0cnkge1xuICAgIGVudHJ5ID0gZGlyX2hhbmRsZS5wb2ludGVyLnJlYWRTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcigvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIFwiRUJBREZcIiwgXCJyZWFkZGlyXCIpO1xuICB9XG4gIGlmIChlbnRyeSA9PT0gbnVsbCkge1xuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZW50cnkubmFtZSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2Nsb3NlZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvclxuLy9BbGlhczogdW5peF9jbG9zZWRpclxuZnVuY3Rpb24gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpIHtcbiAgdHJ5IHtcbiAgICBkaXJfaGFuZGxlLnBvaW50ZXIuY2xvc2VTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcigvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIFwiRUJBREZcIiwgXCJjbG9zZWRpclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmV3aW5kZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXIsIGNhbWxfdW5peF9vcGVuZGlyXG4vL0FsaWFzOiB1bml4X3Jld2luZGRpclxuZnVuY3Rpb24gY2FtbF91bml4X3Jld2luZGRpcihkaXJfaGFuZGxlKSB7XG4gIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKTtcbiAgdmFyIG5ld19kaXJfaGFuZGxlID0gY2FtbF91bml4X29wZW5kaXIoZGlyX2hhbmRsZS5wYXRoKTtcbiAgZGlyX2hhbmRsZS5wb2ludGVyID0gbmV3X2Rpcl9oYW5kbGUucG9pbnRlcjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kZmlyc3Rcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91bml4X29wZW5kaXIsIGNhbWxfdW5peF9yZWFkZGlyXG4vL0FsaWFzOiB3aW5fZmluZGZpcnN0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZGZpcnN0KHBhdGgpIHtcbiAgLy8gVGhlIFdpbmRvd3MgY29kZSBhZGRzIHRoaXMgZ2xvYiB0byB0aGUgcGF0aCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXRcbiAgdmFyIHBhdGhfanMgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKTtcbiAgcGF0aF9qcyA9IHBhdGhfanMucmVwbGFjZSgvKF58W1xcXFwvXSlcXCpcXC5cXCokLywgXCJcIik7XG4gIHBhdGggPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoX2pzKTtcbiAgLy8gKi4qIGlzIG5vdyBzdHJpcHBlZFxuICB2YXIgZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpO1xuICB2YXIgZmlyc3RfZW50cnkgPSBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKTtcbiAgLy8gVGhlIFdpbmRvd3MgYmluZGluZ3MgdHlwZSBkaXJfaGFuZGxlIGFzIGFuIGBpbnRgIGJ1dCBpdCdzIG5vdCBpbiBKU1xuICByZXR1cm4gWzAsIGZpcnN0X2VudHJ5LCBkaXJfaGFuZGxlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRuZXh0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRuZXh0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZG5leHQoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9BbGlhczogd2luX2ZpbmRjbG9zZVxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRjbG9zZShkaXJfaGFuZGxlKSB7XG4gIHJldHVybiBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIGNvbnN0XG4vL0FsaWFzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihyYWlzZV91bml4LCBjb2RlLCBjbWQsIG1zZywgcGF0aCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpXG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIGNtZCwgcGF0aCkpO1xuICBlbHNlIHtcbiAgICB2YXIgbXNnID0gY29kZSArIFwiOiBcIiArIG1zZyArIFwiLCBcIiArIGNtZDtcbiAgICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSBtc2cgKz0gXCIgJ1wiICsgcGF0aCArIFwiJ1wiO1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG1zZyk7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIiA/IG5hbWUgKyBcIi9cIiA6IG5hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG5lbHNlIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gXCIvc3RhdGljXCI7XG5jYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChjYW1sX2N1cnJlbnRfZGlyKTtcblxuLy9Qcm92aWRlczogY2FtbF9nZXRfcm9vdFxuLy9SZXF1aXJlczogcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfcm9vdChwYXRoKSB7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9XG4gIGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHxcbiAgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKSB7fVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCkge1xuICBmdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSBcIi9cIikgcmV0dXJuIFtcIlwiLCBwYXRoLnNsaWNlKDEpXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiB3aW4zMihwYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcbiAgICB2YXIgc3BsaXREZXZpY2VSZSA9XG4gICAgICAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8IFwiXCI7XG4gICAgdmFyIGlzVW5jID0gZGV2aWNlLmxlbmd0aCA+IDAgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gXCI6XCI7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChyZXN1bHRbMl0gfHwgaXNVbmMpIHtcbiAgICAgIHZhciByb290ID0gcmVzdWx0WzFdIHx8IFwiXCI7XG4gICAgICB2YXIgc2VwID0gcmVzdWx0WzJdIHx8IFwiXCI7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc2xpY2Uocm9vdC5sZW5ndGggKyBzZXAubGVuZ3RoKV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoXG4gICAgZnNfbm9kZV9zdXBwb3J0ZWQoKSAmJlxuICAgIGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybVxuICApIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIgPyB3aW4zMiA6IHBvc2l4O1xuICB9IGVsc2UgcmV0dXJuIHBvc2l4O1xufVxudmFyIHBhdGhfaXNfYWJzb2x1dGUgPSBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aChuYW1lKSB7XG4gIG5hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYgKCFwYXRoX2lzX2Fic29sdXRlKG5hbWUpKSBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoL1svXFxcXF0vKTtcbiAgdmFyIG5jb21wID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcC5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAoY29tcFtpXSkge1xuICAgICAgY2FzZSBcIi4uXCI6XG4gICAgICAgIGlmIChuY29tcC5sZW5ndGggPiAxKSBuY29tcC5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiLlwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuY29tcC5wdXNoKGNvbXBbaV0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbmNvbXAudW5zaGlmdChjb21wMFswXSk7XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW107XG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe1xuICAgIHBhdGg6IGNhbWxfcm9vdCxcbiAgICBkZXZpY2U6IG5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KSxcbiAgfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe1xuICAgIHBhdGg6IGNhbWxfcm9vdCxcbiAgICBkZXZpY2U6IG5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KSxcbiAgfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe1xuICBwYXRoOiBcIi9zdGF0aWMvXCIsXG4gIGRldmljZTogbmV3IE1sRmFrZURldmljZShcIi9zdGF0aWMvXCIpLFxufSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCkge1xuICB2YXIgcHJldiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXTtcbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSkge1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmIChcbiAgICAgIG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT09IDAgJiZcbiAgICAgICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpXG4gICAgKVxuICAgICAgcmVzID0ge1xuICAgICAgICBwYXRoOiBtLnBhdGgsXG4gICAgICAgIGRldmljZTogbS5kZXZpY2UsXG4gICAgICAgIHJlc3Q6IG5hbWUuc2xpY2UobS5wYXRoLmxlbmd0aCwgbmFtZS5sZW5ndGgpLFxuICAgICAgfTtcbiAgfVxuICBpZiAoIXJlcyAmJiBmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHJvb3QgPSBjYW1sX2dldF9yb290KG5hbWUpO1xuICAgIGlmIChyb290ICYmIHJvb3QubWF0Y2goL15bYS16QS1aXTpcXC8kLykpIHtcbiAgICAgIHZhciBtID0geyBwYXRoOiByb290LCBkZXZpY2U6IG5ldyBNbE5vZGVEZXZpY2Uocm9vdCkgfTtcbiAgICAgIGpzb29fbW91bnRfcG9pbnQucHVzaChtKTtcbiAgICAgIHJlcyA9IHtcbiAgICAgICAgcGF0aDogbS5wYXRoLFxuICAgICAgICBkZXZpY2U6IG0uZGV2aWNlLFxuICAgICAgICByZXN0OiBuYW1lLnNsaWNlKG0ucGF0aC5sZW5ndGgsIG5hbWUubGVuZ3RoKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsIGYpIHtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goeyBwYXRoOiBuYW1lLCBkZXZpY2U6IG5ldyBNbEZha2VEZXZpY2UobmFtZSwgZikgfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSkge1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmIChqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT09IG5hbWUpIGlkeCA9IGk7XG4gIGlmIChpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LCAxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmIChyb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KSkge1xuICAgIGlmIChyb290LnJlc3QpXG4gICAgICBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFxuICAgICAgXCJFTk9URElSOiBub3QgYSBkaXJlY3RvcnksIGNoZGlyICdcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGRpcikgKyBcIidcIixcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGRpcikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSwgcmFpc2VfdW5peCkge1xuICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICByYWlzZV91bml4LFxuICAgIFwiRU5PRU5UXCIsXG4gICAgXCJubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIsXG4gICAgbmFtZSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgbFtpICsgMV0gPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGEgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sIG4pIHtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmIChvX3Jvb3QuZGV2aWNlICE9PSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYgKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSkgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfbWtkaXIobmFtZSwgcGVybSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QsIHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19ybWRpcihuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfc3lzX2Zkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndiwgYXJnbikge1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLCBhcmd2WzFdLCBhcmd2WzJdLCBhcmd2WzNdLCBhcmd2WzRdLCBhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsIGNvbnRlbnQpIHtcbiAgaWYgKGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSkgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKG5hbWUsIGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuanNvb19mc190bXApIGdsb2JhbFRoaXMuanNvb19mc190bXAgPSBbXTtcbiAgICBnbG9iYWxUaGlzLmpzb29fZnNfdG1wLnB1c2goeyBuYW1lOiBuYW1lLCBjb250ZW50OiBjb250ZW50IH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGpzb29fY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCgpIHtcbiAgdmFyIHRtcCA9IGdsb2JhbFRoaXMuanNvb19mc190bXA7XG4gIGlmICh0bXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgICAganNvb19jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSwgdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUgPSBqc29vX2NyZWF0ZV9maWxlO1xuICBnbG9iYWxUaGlzLmpzb29fZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LCBjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlKG5hbWUsIGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhuYW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpO1xuICByZXR1cm4gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50KG5hbWUpIHtcbiAgdmFyIG5hbWUgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG5hbWUpIDogbmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCwgeyByZG9ubHk6IDEgfSk7XG4gICAgdmFyIGxlbiA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZmlsZS5yZWFkKGJ1ZiwgMCwgbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXkoYnVmKTtcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIE1sRmFrZUZkLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG5mdW5jdGlvbiBNbEZha2VEZXZpY2Uocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQgPSB7fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLnJvb3QgKyBuYW1lO1xufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUuY3JlYXRlX2Rpcl9pZl9uZWVkZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHJlcyArPSBjb21wW2ldICsgXCIvXCI7XG4gICAgaWYgKHRoaXMuY29udGVudFtyZXNdKSBjb250aW51ZTtcbiAgICB0aGlzLmNvbnRlbnRbcmVzXSA9IFN5bWJvbChcImRpcmVjdG9yeVwiKTtcbiAgfVxufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gL1xcLyQvLnRlc3QobmFtZSkgPyBuYW1lIDogbmFtZSArIFwiL1wiO1xufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oXG4gICAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyh0aGlzLnJvb3QpLFxuICAgICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobmFtZSksXG4gICAgKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gICAgfVxuICB9XG59O1xuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAobmFtZSwgZG9fbm90X2xvb2t1cCkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZiAobmFtZSA9PT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIGlmICghZG9fbm90X2xvb2t1cCkgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0gPyAxIDogMDtcbn07XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICh0aGlzLmV4aXN0cyhuYW1lKSAmJiAhdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kZSwgcmFpc2VfdW5peCkge1xuICBpZiAodGhpcy5leGlzdHMobmFtZSkpXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICByYWlzZV91bml4LFxuICAgICAgXCJFRVhJU1RcIixcbiAgICAgIFwibWtkaXJcIixcbiAgICAgIFwiZmlsZSBhbHJlYWR5IGV4aXN0c1wiLFxuICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICApO1xuICB2YXIgcGFyZW50ID0gL14oLiopXFwvW14vXSsvLmV4ZWMobmFtZSk7XG4gIHBhcmVudCA9IChwYXJlbnQgJiYgcGFyZW50WzFdKSB8fCBcIlwiO1xuICBpZiAoIXRoaXMuZXhpc3RzKHBhcmVudCkpXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICByYWlzZV91bml4LFxuICAgICAgXCJFTk9FTlRcIixcbiAgICAgIFwibWtkaXJcIixcbiAgICAgIFwibm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiLFxuICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICApO1xuICBpZiAoIXRoaXMuaXNfZGlyKHBhcmVudCkpXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICByYWlzZV91bml4LFxuICAgICAgXCJFTk9URElSXCIsXG4gICAgICBcIm1rZGlyXCIsXG4gICAgICBcIm5vdCBhIGRpcmVjdG9yeVwiLFxuICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICApO1xuICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbiAobmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgPT09IFwiXCIgPyBcIlwiIDogdGhpcy5zbGFzaChuYW1lKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgaWYgKCF0aGlzLmV4aXN0cyhuYW1lKSlcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgIHJhaXNlX3VuaXgsXG4gICAgICBcIkVOT0VOVFwiLFxuICAgICAgXCJybWRpclwiLFxuICAgICAgXCJubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIsXG4gICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICk7XG4gIGlmICghdGhpcy5pc19kaXIobmFtZSkpXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICByYWlzZV91bml4LFxuICAgICAgXCJFTk9URElSXCIsXG4gICAgICBcInJtZGlyXCIsXG4gICAgICBcIm5vdCBhIGRpcmVjdG9yeVwiLFxuICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICApO1xuICBmb3IgKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKVxuICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgIFwiRU5PVEVNUFRZXCIsXG4gICAgICAgIFwicm1kaXJcIixcbiAgICAgICAgXCJkaXJlY3Rvcnkgbm90IGVtcHR5XCIsXG4gICAgICAgIHRoaXMubm0obmFtZSksXG4gICAgICApO1xuICB9XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF07XG59O1xuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSBuYW1lID09PSBcIlwiID8gXCJcIiA6IHRoaXMuc2xhc2gobmFtZSk7XG4gIGlmICghdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gIH1cbiAgaWYgKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge307XG4gIHZhciBhID0gW107XG4gIGZvciAodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmIChtICYmICFzZWVuW21bMV1dKSB7XG4gICAgICBzZWVuW21bMV1dID0gdHJ1ZTtcbiAgICAgIGEucHVzaChtWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24gKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIGEgPSB0aGlzLnJlYWRkaXIobmFtZSk7XG4gIHZhciBjID0gZmFsc2U7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuIHtcbiAgICByZWFkU3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGMpXG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgICAgXCJFQkFERlwiLFxuICAgICAgICAgIFwicmVhZGRpclwiLFxuICAgICAgICAgIFwiYmFkIGZpbGUgZGVzY3JpcHRvclwiLFxuICAgICAgICApO1xuICAgICAgaWYgKGkgPT09IGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBlbnRyeSA9IGFbaV07XG4gICAgICBpKys7XG4gICAgICByZXR1cm4geyBuYW1lOiBlbnRyeSB9O1xuICAgIH0sXG4gICAgY2xvc2VTeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYylcbiAgICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgICBcIkVCQURGXCIsXG4gICAgICAgICAgXCJyZWFkZGlyXCIsXG4gICAgICAgICAgXCJiYWQgZmlsZSBkZXNjcmlwdG9yXCIsXG4gICAgICAgICk7XG4gICAgICBjID0gdHJ1ZTtcbiAgICAgIGEgPSBbXTtcbiAgICB9LFxuICB9O1xufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IFwiXCIpIHJldHVybiB0cnVlO1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0gPyAxIDogMDtcbn07XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uIChuYW1lLCByYWlzZV91bml4KSB7XG4gIGlmICghdGhpcy5leGlzdHMobmFtZSwgdHJ1ZSkpIHtcbiAgICAvLyBbdHJ1ZV0gbWVhbnMgbm8gXCJsb29rdXBcIiBpZiBub3QgZm91bmQuXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICByYWlzZV91bml4LFxuICAgICAgXCJFTk9FTlRcIixcbiAgICAgIFwidW5saW5rXCIsXG4gICAgICBcIm5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIixcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgfVxuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gMDtcbn07XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobmFtZSwgZiwgX3Blcm1zLCByYWlzZV91bml4KSB7XG4gIHZhciBmaWxlO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVJU0RJUlwiLFxuICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgXCJpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeVwiLFxuICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKVxuICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgIFwiRUVYSVNUXCIsXG4gICAgICAgIFwib3BlblwiLFxuICAgICAgICBcImZpbGUgYWxyZWFkeSBleGlzdHNcIixcbiAgICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICAgICk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZiAoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSh0aGlzLm5tKG5hbWUpLCByYWlzZV91bml4KTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbiAobmFtZSwgbGVuLCByYWlzZV91bml4KSB7XG4gIHZhciBmaWxlO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVJU0RJUlwiLFxuICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgXCJpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeVwiLFxuICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGZpbGUudHJ1bmNhdGUobGVuKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSh0aGlzLm5tKG5hbWUpLCByYWlzZV91bml4KTtcbiAgfVxufTtcbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgY29udGVudCkge1xuICB2YXIgZmlsZTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZiAoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSkgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZiAoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmIChjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoXG4gICAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpLFxuICAgICk7XG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBpZiAoZmlsZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gZmlsZTtcbiAgfSBlbHNlXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXG4gICAgICB0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIixcbiAgICApO1xufTtcblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZTtcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19vZl91aW50OF9hcnJheVxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KSB7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4gfCAwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59O1xuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYgKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl91aW50OF9hcnJheShidWYpLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gbGVuO1xufTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYgKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgbGVuID0gY2xlbiAtIG9mZnNldDtcbiAgfVxuICBpZiAobGVuKSB7XG4gICAgdmFyIGRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4gfCAwKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGRhdGEsIDAsIGxlbik7XG4gICAgYnVmLnNldChjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGRhdGEpLCBwb3MpO1xuICB9XG4gIHJldHVybiBsZW47XG59O1xuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG5mdW5jdGlvbiBNbEZha2VGZF9vdXQoZmQsIGZsYWdzKSB7XG4gIE1sRmFrZUZpbGUuY2FsbCh0aGlzLCBjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gIHRoaXMubG9nID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgaWYgKGZkID09PSAxICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmxvZyA9IGNvbnNvbGUubG9nO1xuICBlbHNlIGlmIChmZCA9PT0gMiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5lcnJvcjtcbiAgZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIpIHRoaXMubG9nID0gY29uc29sZS5sb2c7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMDtcbn07XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbiwgcmFpc2VfdW5peCkge1xuICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICByYWlzZV91bml4LFxuICAgIFwiRUlOVkFMXCIsXG4gICAgXCJmdHJ1bmNhdGVcIixcbiAgICBcImludmFsaWQgYXJndW1lbnRcIixcbiAgKTtcbn07XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1ZiwgcG9zLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHdyaXR0ZW4gPSBsZW47XG4gIGlmICh0aGlzLmxvZykge1xuICAgIGlmIChcbiAgICAgIGxlbiA+IDAgJiZcbiAgICAgIHBvcyA+PSAwICYmXG4gICAgICBwb3MgKyBsZW4gPD0gYnVmLmxlbmd0aCAmJlxuICAgICAgYnVmW3BvcyArIGxlbiAtIDFdID09PSAxMFxuICAgIClcbiAgICAgIGxlbi0tO1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIHZhciBzcmMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGJ1ZiksIHBvcywgc3JjLCAwLCBsZW4pO1xuICAgIHRoaXMubG9nKHNyYy50b1V0ZjE2KCkpO1xuICAgIHJldHVybiB3cml0dGVuO1xuICB9XG4gIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKHJhaXNlX3VuaXgsIFwiRUJBREZcIiwgXCJ3cml0ZVwiLCBcImJhZCBmaWxlIGRlc2NyaXB0b3JcIik7XG59O1xuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGJ1ZiwgcG9zLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IocmFpc2VfdW5peCwgXCJFQkFERlwiLCBcInJlYWRcIiwgXCJiYWQgZmlsZSBkZXNjcmlwdG9yXCIpO1xufTtcbk1sRmFrZUZkX291dC5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChsZW4sIHdoZW5jZSwgcmFpc2VfdW5peCkge1xuICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihyYWlzZV91bml4LCBcIkVTUElQRVwiLCBcImxzZWVrXCIsIFwiaWxsZWdhbCBzZWVrXCIpO1xufTtcbk1sRmFrZUZkX291dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG9nID0gdW5kZWZpbmVkO1xufTtcbk1sRmFrZUZkX291dC5wcm90b3R5cGUuY2hlY2tfc3RyZWFtX3NlbWFudGljcyA9IGZ1bmN0aW9uIChjbWQpIHt9O1xuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkKG5hbWUsIGZpbGUsIGZsYWdzKSB7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLnNlZWtlZCA9IGZhbHNlO1xufVxuXG5NbEZha2VGZC5wcm90b3R5cGUuZXJyX2Nsb3NlZCA9IGZ1bmN0aW9uIChjbWQsIHJhaXNlX3VuaXgpIHtcbiAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IocmFpc2VfdW5peCwgXCJFQkFERlwiLCBjbWQsIFwiYmFkIGZpbGUgZGVzY3JpcHRvclwiKTtcbn07XG5NbEZha2VGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLmxlbmd0aCgpO1xuICB0aGlzLmVycl9jbG9zZWQoXCJsZW5ndGhcIik7XG59O1xuTWxGYWtlRmQucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbiwgcmFpc2VfdW5peCkge1xuICBpZiAodGhpcy5maWxlKSB7XG4gICAgaWYgKCEodGhpcy5mbGFncy53cm9ubHkgfHwgdGhpcy5mbGFncy5yZHdyKSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVJTlZBTFwiLFxuICAgICAgICBcInRydW5jYXRlXCIsXG4gICAgICAgIFwiaW52YWxpZCBhcmd1bWVudFwiLFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5maWxlLnRydW5jYXRlKGxlbik7XG4gIH1cbiAgdGhpcy5lcnJfY2xvc2VkKFwidHJ1bmNhdGVcIiwgcmFpc2VfdW5peCk7XG59O1xuTWxGYWtlRmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1ZiwgcG9zLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgaWYgKHRoaXMuZmlsZSAmJiAodGhpcy5mbGFncy53cm9ubHkgfHwgdGhpcy5mbGFncy5yZHdyKSkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB0aGlzLm9mZnNldCArPSBsZW47XG4gICAgcmV0dXJuIHRoaXMuZmlsZS53cml0ZShvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICB9XG4gIHRoaXMuZXJyX2Nsb3NlZChcIndyaXRlXCIsIHJhaXNlX3VuaXgpO1xufTtcbk1sRmFrZUZkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGJ1ZiwgcG9zLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgaWYgKHRoaXMuZmlsZSAmJiAhdGhpcy5mbGFncy53cm9ubHkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICAgIHJldHVybiB0aGlzLmZpbGUucmVhZChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICB9XG4gIHRoaXMuZXJyX2Nsb3NlZChcInJlYWRcIiwgcmFpc2VfdW5peCk7XG59O1xuTWxGYWtlRmQucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0LCB3aGVuY2UsIHJhaXNlX3VuaXgpIHtcbiAgc3dpdGNoICh3aGVuY2UpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBvZmZzZXQgKz0gdGhpcy5vZmZzZXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmIChvZmZzZXQgPCAwKVxuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKHJhaXNlX3VuaXgsIFwiRUlOVkFMXCIsIFwibHNlZWtcIiwgXCJpbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgdGhpcy5zZWVrZWQgPSB0cnVlO1xufTtcbk1sRmFrZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmZpbGUpIHRoaXMuZXJyX2Nsb3NlZChcImNsb3NlXCIpO1xuICB0aGlzLmZpbGUgPSB1bmRlZmluZWQ7XG59O1xuTWxGYWtlRmQucHJvdG90eXBlLmNoZWNrX3N0cmVhbV9zZW1hbnRpY3MgPSBmdW5jdGlvbiAoY21kKSB7XG4gIGlmICghdGhpcy5maWxlKSByZXR1cm4gdGhpcy5lcnJfY2xvc2VkKGNtZCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyAxKTtcbn07XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0KGxvLCBtaSwgaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIjtcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLCB0aGlzLm1pLCB0aGlzLmhpKTtcbn07XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59O1xuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn07XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC10aGlzLmxvO1xuICB2YXIgbWkgPSAtdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC10aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPVxuICAgICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArXG4gICAgdGhpcy5oaSAqIHgubG8gK1xuICAgIHRoaXMubWkgKiB4Lm1pICtcbiAgICB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvIHwgdGhpcy5taSB8IHRoaXMuaGkpID09PSAwO1xufTtcbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaSA8PCAxNiA8IDA7XG59O1xuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gfCB4LmxvLCB0aGlzLm1pIHwgeC5taSwgdGhpcy5oaSB8IHguaGkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvIF4geC5sbywgdGhpcy5taSBeIHgubWksIHRoaXMuaGkgXiB4LmhpKTtcbn07XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgICAgdGhpcy5sbyA8PCBzLFxuICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSxcbiAgICApO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgICAgMCxcbiAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSksXG4gICAgKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICB0aGlzLmhpID4+IHMsXG4gICAgKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICB0aGlzLmhpID4+IChzIC0gMjQpLFxuICAgICAgMCxcbiAgICApO1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59O1xuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNixcbiAgICApO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpKSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYsXG4gICAgKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59O1xuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn07XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufTtcbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwgMCwgMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbysrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudDogcXVvdGllbnQsIG1vZHVsdXM6IG1vZHVsdXMgfTtcbn07XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn07XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59O1xuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufTtcbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSArIHRoaXMubG9cbiAgKTtcbn07XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW1xuICAgIHRoaXMuaGkgPj4gOCxcbiAgICB0aGlzLmhpICYgMHhmZixcbiAgICB0aGlzLm1pID4+IDE2LFxuICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICB0aGlzLm1pICYgMHhmZixcbiAgICB0aGlzLmxvID4+IDE2LFxuICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICB0aGlzLmxvICYgMHhmZixcbiAgXTtcbn07XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn07XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCwgeSkge1xuICByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgsIHksIHRvdGFsKSB7XG4gIHJldHVybiB4LmNvbXBhcmUoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyh4KSB7XG4gIHJldHVybiB4Lm5lZygpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQoeCwgeSkge1xuICByZXR1cm4geC5hZGQoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1Yih4LCB5KSB7XG4gIHJldHVybiB4LnN1Yih5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LCB5KSB7XG4gIHJldHVybiB4Lm11bCh5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkge1xuICByZXR1cm4gK3guaXNaZXJvKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkge1xuICByZXR1cm4gK3guaXNOZWcoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kKHgsIHkpIHtcbiAgcmV0dXJuIHguYW5kKHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yKHgsIHkpIHtcbiAgcmV0dXJuIHgub3IoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvcih4LCB5KSB7XG4gIHJldHVybiB4Lnhvcih5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQoeCwgcykge1xuICByZXR1cm4geC5zaGlmdF9sZWZ0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIHMpIHtcbiAgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQoeCwgcykge1xuICByZXR1cm4geC5zaGlmdF9yaWdodChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXZcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2KHgsIHkpIHtcbiAgcmV0dXJuIHguZGl2KHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QoeCwgeSkge1xuICByZXR1cm4geC5tb2QoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMih4KSB7XG4gIHJldHVybiB4LnRvSW50KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQoeCkge1xuICByZXR1cm4geC50b0Zsb2F0KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0KHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7XG4gICAgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSBcIiBcIjtcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQobiwgXCIwXCIpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZShzKTtcbiAgdmFyIGkgPSByWzBdLFxuICAgIHNpZ24gPSByWzFdLFxuICAgIGJhc2UgPSByWzJdLFxuICAgIHNpZ25lZG5lc3MgPSByWzNdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9IG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChcbiAgICBiYXNlNjQsXG4gICkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT09IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduZWRuZXNzICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmLFxuICApO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodikge1xuICByZXR1cm4gdi5sbzMyKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpIHtcbiAgcmV0dXJuIHYuaGkzMigpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIChhWzddIDw8IDApIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgKGFbNF0gPDwgMCkgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAoYVsxXSA8PCAwKSB8IChhWzBdIDw8IDgpLFxuICApO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7XG4gIHJldHVybiB4LnRvQXJyYXkoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godikge1xuICByZXR1cm4gdi5sbzMyKCkgXiB2LmhpMzIoKTtcbn1cbiIsIi8vUHJvdmlkZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIE1sTXV0ZXgoKSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbmV3XG4vL1JlcXVpcmVzOiBNbE11dGV4XG5mdW5jdGlvbiBjYW1sX21sX211dGV4X25ldyh1bml0KSB7XG4gIHJldHVybiBuZXcgTWxNdXRleCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X2xvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbG9jayh0KSB7XG4gIGlmICh0LmxvY2tlZCkgY2FtbF9mYWlsd2l0aChcIk11dGV4LmxvY2s6IG11dGV4IGFscmVhZHkgbG9ja2VkLiBDYW5ub3Qgd2FpdC5cIik7XG4gIGVsc2UgdC5sb2NrZWQgPSB0cnVlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF90cnlfbG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF90cnlfbG9jayh0KSB7XG4gIGlmICghdC5sb2NrZWQpIHtcbiAgICB0LmxvY2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X3VubG9jayh0KSB7XG4gIHQubG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiAwO1xufVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzLl9uYXQgPSB7XG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplX25hdCxcbiAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZV9uYXQsXG4gICAgaGFzaDogY2FtbF9oYXNoX25hdCxcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpIHtcbiAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoeCk7XG4gIC8vIEZvciBudW0gPCAxLjVcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC5cbiAgLy8gV2UgYWRkICsyIHRvIHRoZSBhcnJheSBsZW5ndGg6XG4gIC8vIC0gKzEgZm9yIHRoZSB0YWdcbiAgLy8gLSArMSBmb3IgdGhlIGN1c3RvbV9vcHMgc2xvdFxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyO1xufVxuXG5NbE5hdC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9uYXRcIjtcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogbGVuZ3RoX25hdFxuZnVuY3Rpb24gbGVuZ3RoX25hdCh4KSB7XG4gIHJldHVybiB4LmRhdGEubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCkge1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMgKyBpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSBuYXQyLmRhdGFbb2ZzMiArIGldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG5hdC5kYXRhW29mcyArIGldICE9PSAwKSByZXR1cm4gaSArIDE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmIChhICYgMHhmZmZmMDAwMCkge1xuICAgIGIgKz0gMTY7XG4gICAgYSA+Pj49IDE2O1xuICB9XG4gIGlmIChhICYgMHhmZjAwKSB7XG4gICAgYiArPSA4O1xuICAgIGEgPj4+PSA4O1xuICB9XG4gIGlmIChhICYgMHhmMCkge1xuICAgIGIgKz0gNDtcbiAgICBhID4+Pj0gNDtcbiAgfVxuICBpZiAoYSAmIDEyKSB7XG4gICAgYiArPSAyO1xuICAgIGEgPj4+PSAyO1xuICB9XG4gIGlmIChhICYgMikge1xuICAgIGIgKz0gMTtcbiAgICBhID4+Pj0gMTtcbiAgfVxuICBpZiAoYSAmIDEpIHtcbiAgICBiICs9IDE7XG4gIH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID09PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X25vcm1hbGl6ZWRcbmZ1bmN0aW9uIGlzX2RpZ2l0X25vcm1hbGl6ZWQobmF0LCBvZnMpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdICYgMSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbmNyX25hdFxuZnVuY3Rpb24gaW5jcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMgKyBpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQuZGF0YVtvZnMgKyBpXSA9IHggfCAwO1xuICAgIGlmICh4ID09PSB4ID4+PiAwKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogYWRkX25hdFxuLy9SZXF1aXJlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIgKyBpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMSArIGldID0geDtcbiAgICBpZiAoeCA9PT0geCA+Pj4gMCkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxICsgbGVuMiwgbGVuMSAtIGxlbjIsIGNhcnJ5KTtcbn1cblxuLy9Qcm92aWRlczogY29tcGxlbWVudF9uYXRcbmZ1bmN0aW9uIGNvbXBsZW1lbnRfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcyArIGldID0gKC0xID4+PiAwKSAtIChuYXQuZGF0YVtvZnMgKyBpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gY2FycnlfaW4gPT09IDEgPyAwIDogMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcyArIGldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMgKyBpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm9ycm93ID09PSAxID8gMCA6IDE7XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IHN1Yl9uYXRcbi8vUmVxdWlyZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBzdWJfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSBjYXJyeV9pbiA9PT0gMSA/IDAgOiAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyICsgaV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNyX25hdChuYXQxLCBvZnMxICsgbGVuMiwgbGVuMSAtIGxlbjIsIGJvcnJvdyA9PT0gMSA/IDAgOiAxKTtcbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1tvZnMzXVxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBtdWx0X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogYWRkX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBhID0gbmF0My5kYXRhW29mczNdID4+PiAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9XG4gICAgICAobmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCkgK1xuICAgICAgKG5hdDIuZGF0YVtvZnMyICsgaV0gPj4+IDApICogKGEgJiAweDAwMDBmZmZmKSArXG4gICAgICBjYXJyeTtcbiAgICB2YXIgeDIgPSAobmF0Mi5kYXRhW29mczIgKyBpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4MiAvIDY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSB4MztcbiAgICBjYXJyeSArPSBNYXRoLmZsb29yKHgzIC8gNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZiAobGVuMiA8IGxlbjEgJiYgY2FycnkpIHtcbiAgICByZXR1cm4gYWRkX25hdChcbiAgICAgIG5hdDEsXG4gICAgICBvZnMxICsgbGVuMixcbiAgICAgIGxlbjEgLSBsZW4yLFxuICAgICAgbmF0X29mX2FycmF5KFtjYXJyeV0pLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChcbiAgICAgIG5hdDEsXG4gICAgICBvZnMxICsgaSxcbiAgICAgIGxlbjEgLSBpLFxuICAgICAgbmF0MixcbiAgICAgIG9mczIsXG4gICAgICBsZW4yLFxuICAgICAgbmF0MyxcbiAgICAgIG9mczMgKyBpLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBuYXQxID0gMiAqIG5hdDEgKyBuYXQyICogbmF0MlxuLy8gbGVuMSA+PSAyICogbGVuMlxuLy9Qcm92aWRlczogc3F1YXJlX25hdFxuLy9SZXF1aXJlczogbXVsdF9uYXQsIGFkZF9uYXRcbmZ1bmN0aW9uIHNxdWFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgY2FycnkgPSAwO1xuICBjYXJyeSArPSBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDEsIG9mczEsIGxlbjEsIDApO1xuICBjYXJyeSArPSBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKTtcbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZiAobmJpdHMgPT09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEgKyBpXSA9IChhIDw8IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPj4+ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy8gQXNzdW1pbmcgYyA+IGEsIHJldHVybnMgW3F1b3RpZW50LCByZW1haW5kZXJdIG9mIChhPDwzMiArIGIpL2Ncbi8vUHJvdmlkZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9oZWxwZXIoYSwgYiwgYykge1xuICB2YXIgeCA9IGEgKiA2NTUzNiArIChiID4+PiAxNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4IC8gYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwZmZmZik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3IodyAvIGMpLCB3ICUgY107XG59XG5cbi8vIG5hdDFbb2ZzMStsZW5dIDwgbmF0MltvZnMyXVxuLy9Qcm92aWRlczogZGl2X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2RpZ2l0X25hdChuYXRxLCBvZnNxLCBuYXRyLCBvZnNyLCBuYXQxLCBvZnMxLCBsZW4sIG5hdDIsIG9mczIpIHtcbiAgdmFyIHJlbSA9IG5hdDEuZGF0YVtvZnMxICsgbGVuIC0gMV0gPj4+IDA7XG4gIC8vIG5hdHFbb2ZzcStsZW4tMV0gaXMgZ3VhcmFudGVlZCB0byBiZSB6ZXJvIChkdWUgdG8gdGhlIE1TRCByZXF1aXJlbWVudCksXG4gIC8vIGFuZCBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8uXG4gIGZvciAodmFyIGkgPSBsZW4gLSAyOyBpID49IDA7IGktLSkge1xuICAgIHZhciB4ID0gZGl2X2hlbHBlcihyZW0sIG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDAsIG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCk7XG4gICAgbmF0cS5kYXRhW29mc3EgKyBpXSA9IHhbMF07XG4gICAgcmVtID0geFsxXTtcbiAgfVxuICBuYXRyLmRhdGFbb2Zzcl0gPSByZW07XG4gIHJldHVybiAwO1xufVxuXG4vLyBuYXQxW25hdDI6XSA6PSBuYXQxIC8gbmF0MlxuLy8gbmF0MVs6bmF0Ml0gOj0gbmF0MSAlIG5hdDJcbi8vIGxlbjEgPiBsZW4yLCBuYXQyW29mczIrbGVuMi0xXSA+IG5hdDFbb2ZzMStsZW4xLTFdXG4vL1Byb3ZpZGVzOiBkaXZfbmF0XG4vL1JlcXVpcmVzOiBkaXZfZGlnaXRfbmF0LCBkaXZfaGVscGVyLCBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQsIHNoaWZ0X2xlZnRfbmF0LCBzaGlmdF9yaWdodF9uYXQsIGNyZWF0ZV9uYXQsIHNldF90b196ZXJvX25hdCwgbXVsdF9kaWdpdF9uYXQsIHN1Yl9uYXQsIGNvbXBhcmVfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIGRpdl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICBpZiAobGVuMiA9PT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSArIDEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMiArIGxlbjIgLSAxKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIgKyBsZW4yIC0gMV0gPj4+IDApICsgMTtcbiAgdmFyIGEgPSBjcmVhdGVfbmF0KGxlbjIgKyAxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID1cbiAgICAgIGQgPT09IDQyOTQ5NjcyOTZcbiAgICAgICAgPyBuYXQxLmRhdGFbb2ZzMSArIGldID4+PiAwXG4gICAgICAgIDogZGl2X2hlbHBlcihcbiAgICAgICAgICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDAsXG4gICAgICAgICAgICBuYXQxLmRhdGFbb2ZzMSArIGkgLSAxXSA+Pj4gMCxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgKVswXTtcbiAgICBzZXRfdG9femVyb19uYXQoYSwgMCwgbGVuMiArIDEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIgKyAxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEgKyBpIC0gbGVuMiwgbGVuMiArIDEsIGEsIDAsIGxlbjIgKyAxLCAxKTtcblxuICAgIHdoaWxlIChcbiAgICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gIT09IDAgfHxcbiAgICAgIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEgKyBpIC0gbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMFxuICAgICkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMSArIGkgLSBsZW4yLCBsZW4yICsgMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEgKyBpXSA9IHF1bztcbiAgfVxuXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHNoaWZ0IHJlbWFpbmRlclxuICBzaGlmdF9yaWdodF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyByZXN0b3JlXG4gIHJldHVybiAwO1xufVxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmIChuYml0cyA9PT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSBuYXQxLmRhdGFbb2ZzMSArIGldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYgKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmIChuYXQxLmRhdGFbb2ZzMV0gPCBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0XG4vL1JlcXVpcmVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgYSA9IG51bV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIGxlbjEpO1xuICB2YXIgYiA9IG51bV9kaWdpdHNfbmF0KG5hdDIsIG9mczIsIGxlbjIpO1xuICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChuYXQxLmRhdGFbb2ZzMSArIGldID4+PiAwID4gbmF0Mi5kYXRhW29mczIgKyBpXSA+Pj4gMCkgcmV0dXJuIDE7XG4gICAgaWYgKG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDAgPCBuYXQyLmRhdGFbb2ZzMiArIGldID4+PiAwKSByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxhbmRfZGlnaXRfbmF0XG5mdW5jdGlvbiBsYW5kX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSAmPSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBsb3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBsb3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIHw9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGx4b3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBseG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSBePSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeikge1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3opIHtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCJcbiAgKTtcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZkLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yLCBmc19ub2RlX3N0YXRzX2Zyb21fanNcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKFwibm9kZTpmc1wiKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5yb290ICsgbmFtZTtcbn07XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKSA/IDEgOiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0ZpbGUoKSA/IDEgOiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn07XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24gKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLCB7IG1vZGU6IG1vZGUgfSk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn07XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24gKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufTtcbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uIChuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn07XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKSA/IDEgOiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn07XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uIChuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51dGltZXMgPSBmdW5jdGlvbiAobmFtZSwgYXRpbWUsIG10aW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgaWYgKGF0aW1lID09PSAwICYmIG10aW1lID09PSAwKSB7XG4gICAgICBhdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgIG10aW1lID0gYXRpbWU7XG4gICAgfVxuICAgIHRoaXMuZnMudXRpbWVzU3luYyh0aGlzLm5tKG5hbWUpLCBhdGltZSwgbXRpbWUpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uIChuYW1lLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnRydW5jYXRlU3luYyh0aGlzLm5tKG5hbWUpLCBsZW4gfCAwKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufTtcbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChuYW1lLCBmLCBwZXJtcywgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZShcIm5vZGU6Y29uc3RhbnRzXCIpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcInJkb25seVwiOlxuICAgICAgICByZXMgfD0gY29uc3RzLk9fUkRPTkxZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3cm9ubHlcIjpcbiAgICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmR3clwiOlxuICAgICAgICByZXMgfD0gY29uc3RzLk9fUkRXUjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXBwZW5kXCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19BUFBFTkQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNyZWF0ZVwiOlxuICAgICAgICByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRydW5jYXRlXCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19UUlVOQztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXhjbFwiOlxuICAgICAgICByZXMgfD0gY29uc3RzLk9fRVhDTDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19CSU5BUlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgcmVzIHw9IGNvbnN0cy5PX1RFWFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5vbmJsb2NrXCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19OT05CTE9DSztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibm9jdHR5XCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19OT0NUVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRzeW5jXCI6XG4gICAgICAgIHJlcyB8PSBjb25zdHMuT19EU1lOQztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3luY1wiOlxuICAgICAgICByZXMgfD0gY29uc3RzLk9fU1lOQztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMsIHBlcm1zKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufTtcblxuaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8ucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICBNbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uIChvLCBuLCByYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLm5tKG4pO1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMubm0obyk7XG4gICAgICB2YXIgdGFyZ2V0X3N0YXRzLCBzb3VyY2Vfc3RhdHM7XG4gICAgICBpZiAoXG4gICAgICAgICh0YXJnZXRfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRhcmdldCwgeyB0aHJvd0lmTm9FbnRyeTogZmFsc2UgfSkpICYmXG4gICAgICAgIChzb3VyY2Vfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHNvdXJjZSwgeyB0aHJvd0lmTm9FbnRyeTogZmFsc2UgfSkpICYmXG4gICAgICAgIHNvdXJjZV9zdGF0cy5pc0RpcmVjdG9yeSgpXG4gICAgICApIHtcbiAgICAgICAgaWYgKHRhcmdldF9zdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgaWYgKCF0YXJnZXQuc3RhcnRzV2l0aChzb3VyY2UpKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5mcy5ybWRpclN5bmModGFyZ2V0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYEVOT1RESVI6IG5vdCBhIGRpcmVjdG9yeSwgcmVuYW1lICcke3NvdXJjZX0nIC0+ICcke3RhcmdldH0nYCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oZXJyLCB7XG4gICAgICAgICAgICBlcnJubzogLTIwLFxuICAgICAgICAgICAgY29kZTogXCJFTk9URElSXCIsXG4gICAgICAgICAgICBzeXNjYWxsOiBcInJlbmFtZVwiLFxuICAgICAgICAgICAgcGF0aDogdGFyZ2V0LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIE1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24gKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH07XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uIChuYW1lLCBsYXJnZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIGZzX25vZGVfc3RhdHNfZnJvbV9qcyhqc19zdGF0cywgbGFyZ2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5sc3RhdCA9IGZ1bmN0aW9uIChuYW1lLCBsYXJnZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiBmc19ub2RlX3N0YXRzX2Zyb21fanMoanNfc3RhdHMsIGxhcmdlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufTtcbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uICh0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmMoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLm5tKHBhdGgpLFxuICAgICAgdG9fZGlyID09PSAwID8gbnVsbCA6IHRvX2RpclsxXSA/IFwiZGlyXCIgOiBcImZpbGVcIixcbiAgICApO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uIChuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCBcInV0ZjhcIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24gKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5vcGVuZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufTtcblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZTtcblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdGF0c19mcm9tX2pzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBmc19ub2RlX3N0YXRzX2Zyb21fanMoanNfc3RhdHMsIGxhcmdlKSB7XG4gIC8qID09PVVuaXguZmlsZV9raW5kPT09XG4gICAqIHR5cGUgZmlsZV9raW5kID1cbiAgICogICAgIFNfUkVHICAgICAgICAgICAgICAgICAgICAgICAoKiogUmVndWxhciBmaWxlICopXG4gICAqICAgfCBTX0RJUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIERpcmVjdG9yeSAqKVxuICAgKiAgIHwgU19DSFIgICAgICAgICAgICAgICAgICAgICAgICgqKiBDaGFyYWN0ZXIgZGV2aWNlICopXG4gICAqICAgfCBTX0JMSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIEJsb2NrIGRldmljZSAqKVxuICAgKiAgIHwgU19MTksgICAgICAgICAgICAgICAgICAgICAgICgqKiBTeW1ib2xpYyBsaW5rICopXG4gICAqICAgfCBTX0ZJRk8gICAgICAgICAgICAgICAgICAgICAgKCoqIE5hbWVkIHBpcGUgKilcbiAgICogICB8IFNfU09DSyAgICAgICAgICAgICAgICAgICAgICAoKiogU29ja2V0ICopXG4gICAqL1xuICB2YXIgZmlsZV9raW5kO1xuICBpZiAoanNfc3RhdHMuaXNGaWxlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAwO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBmaWxlX2tpbmQgPSAxO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAyO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQmxvY2tEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDM7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGZpbGVfa2luZCA9IDQ7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNGSUZPKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA1O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU29ja2V0KCkpIHtcbiAgICBmaWxlX2tpbmQgPSA2O1xuICB9XG4gIC8qID09PVVuaXguc3RhdHM9PT1cbiAgICogdHlwZSBzdGF0cyA9XG4gICAqICB7IHN0X2RldiA6IGludDsgICAgICAgICAgICAgICAoKiogRGV2aWNlIG51bWJlciAqKVxuICAgKiAgICBzdF9pbm8gOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIElub2RlIG51bWJlciAqKVxuICAgKiAgICBzdF9raW5kIDogZmlsZV9raW5kOyAgICAgICAgKCoqIEtpbmQgb2YgdGhlIGZpbGUgKilcbiAgICogICAgc3RfcGVybSA6IGZpbGVfcGVybTsgICAgICAgICgqKiBBY2Nlc3MgcmlnaHRzICopXG4gICAqICAgIHN0X25saW5rIDogaW50OyAgICAgICAgICAgICAoKiogTnVtYmVyIG9mIGxpbmtzICopXG4gICAqICAgIHN0X3VpZCA6IGludDsgICAgICAgICAgICAgICAoKiogVXNlciBpZCBvZiB0aGUgb3duZXIgKilcbiAgICogICAgc3RfZ2lkIDogaW50OyAgICAgICAgICAgICAgICgqKiBHcm91cCBJRCBvZiB0aGUgZmlsZSdzIGdyb3VwICopXG4gICAqICAgIHN0X3JkZXYgOiBpbnQ7ICAgICAgICAgICAgICAoKiogRGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpICopXG4gICAqICAgIHN0X3NpemUgOiBpbnQ7ICAgICAgICAgICAgICAoKiogU2l6ZSBpbiBieXRlcyAqKVxuICAgKiAgICBzdF9hdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgYWNjZXNzIHRpbWUgKilcbiAgICogICAgc3RfbXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IG1vZGlmaWNhdGlvbiB0aW1lICopXG4gICAqICAgIHN0X2N0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBzdGF0dXMgY2hhbmdlIHRpbWUgKilcbiAgICogIH1cbiAgICovXG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGpzX3N0YXRzLmRldixcbiAgICBqc19zdGF0cy5pbm8gfCAwLFxuICAgIGZpbGVfa2luZCxcbiAgICBqc19zdGF0cy5tb2RlLFxuICAgIGpzX3N0YXRzLm5saW5rLFxuICAgIGpzX3N0YXRzLnVpZCxcbiAgICBqc19zdGF0cy5naWQsXG4gICAganNfc3RhdHMucmRldixcbiAgICBsYXJnZSA/IGNhbWxfaW50NjRfb2ZfZmxvYXQoanNfc3RhdHMuc2l6ZSkgOiBqc19zdGF0cy5zaXplIHwgMCxcbiAgICBqc19zdGF0cy5hdGltZU1zIC8gMTAwMCxcbiAgICBqc19zdGF0cy5tdGltZU1zIC8gMTAwMCxcbiAgICBqc19zdGF0cy5jdGltZU1zIC8gMTAwMCxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2UoKSB7fVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vZGVqc19lcnJvciwgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IsIGZzX25vZGVfc3RhdHNfZnJvbV9qc1xuZnVuY3Rpb24gTWxOb2RlRmQoZmQsIGZsYWdzKSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKFwibm9kZTpmc1wiKTtcbiAgdGhpcy5mZCA9IGZkO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIHZhciBzdGF0cyA9IHRoaXMuZnMuZnN0YXRTeW5jKGZkKTtcbiAgZmxhZ3Mubm9TZWVrID1cbiAgICBzdGF0cy5pc0NoYXJhY3RlckRldmljZSgpIHx8IHN0YXRzLmlzRklGTygpIHx8IHN0YXRzLmlzU29ja2V0KCk7XG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5mbGFncy5hcHBlbmQgPyBzdGF0cy5zaXplIDogMDtcbiAgdGhpcy5zZWVrZWQgPSBmYWxzZTtcbn1cbk1sTm9kZUZkLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUoKTtcbk1sTm9kZUZkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZkO1xuXG5NbE5vZGVGZC5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbiAobGVuLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsIGxlbiB8IDApO1xuICAgIGlmICh0aGlzLm9mZnNldCA+IGxlbikgdGhpcy5vZmZzZXQgPSBsZW47XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn07XG5NbE5vZGVGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn07XG5NbE5vZGVGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmLCBidWZfb2Zmc2V0LCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5mbGFncy5ub1NlZWsgfHwgIXRoaXMuc2Vla2VkKVxuICAgICAgdmFyIHdyaXR0ZW4gPSB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbik7XG4gICAgZWxzZVxuICAgICAgdmFyIHdyaXR0ZW4gPSB0aGlzLmZzLndyaXRlU3luYyhcbiAgICAgICAgdGhpcy5mZCxcbiAgICAgICAgYnVmLFxuICAgICAgICBidWZfb2Zmc2V0LFxuICAgICAgICBsZW4sXG4gICAgICAgIHRoaXMub2Zmc2V0LFxuICAgICAgKTtcbiAgICB0aGlzLm9mZnNldCArPSB3cml0dGVuO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG4gIHJldHVybiB3cml0dGVuO1xufTtcbk1sTm9kZUZkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGEsIGJ1Zl9vZmZzZXQsIGxlbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIGlmICh0aGlzLmZsYWdzLm5vU2VlayB8fCAhdGhpcy5zZWVrZWQpXG4gICAgICB2YXIgcmVhZCA9IHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYSwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4sIHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCArPSByZWFkO1xuICAgIHJldHVybiByZWFkO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRmQucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0LCB3aGVuY2UsIHJhaXNlX3VuaXgpIHtcbiAgaWYgKHRoaXMuZmxhZ3Mubm9TZWVrKVxuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKHJhaXNlX3VuaXgsIFwiRVNQSVBFXCIsIFwibHNlZWtcIiwgXCJpbGxlZ2FsIHNlZWtcIik7XG4gIHN3aXRjaCAod2hlbmNlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgb2Zmc2V0ICs9IHRoaXMub2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoKCk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAob2Zmc2V0IDwgMClcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihyYWlzZV91bml4LCBcIkVJTlZBTFwiLCBcImxzZWVrXCIsIFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIHRoaXMuc2Vla2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0O1xufTtcbk1sTm9kZUZkLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gKGxhcmdlKSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCk7XG4gICAgcmV0dXJuIGZzX25vZGVfc3RhdHNfZnJvbV9qcyhqc19zdGF0cywgbGFyZ2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gMSk7XG4gIH1cbn07XG5NbE5vZGVGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAocmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59O1xuTWxOb2RlRmQucHJvdG90eXBlLmNoZWNrX3N0cmVhbV9zZW1hbnRpY3MgPSBmdW5jdGlvbiAoY21kKSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgLyogcmFpc2UgVW5peF9lcnJvciAqLyAxLCBjbWQpO1xuICB9XG4gIGlmIChcbiAgICAhKFxuICAgICAganNfc3RhdHMuaXNGaWxlKCkgfHxcbiAgICAgIGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgIGpzX3N0YXRzLmlzRklGTygpIHx8XG4gICAgICBqc19zdGF0cy5pc1NvY2tldCgpXG4gICAgKVxuICApXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIDEsXG4gICAgICBcIkVJTlZBTFwiLFxuICAgICAgY21kLFxuICAgICAgXCJpbnZhbGlkIGFyZ3VtZW50XCIsXG4gICAgKTtcbn07XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVGZCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vUmVxdWlyZXM6IE1sTm9kZUZkXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncykge1xuICBpZiAoZmxhZ3MuYWx0bmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKFwibm9kZTpmc1wiKTtcbiAgICAgIHZhciBmZDIgPSBmcy5vcGVuU3luYyhmbGFncy5hbHRuYW1lLCBcInJzXCIpO1xuICAgICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZDIsIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiBuZXcgTWxOb2RlRmQoZmQsIGZsYWdzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncywgbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4LCBjbWQpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoXG4gICAgICBlcnIuY29kZSxcbiAgICAgIGNtZCB8fCBlcnIuc3lzY2FsbCxcbiAgICAgIGVyci5wYXRoLFxuICAgICAgZXJyLmVycm5vLFxuICAgICk7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShcbiAgICBiYS5idWZmZXIsXG4gICAgYmEuYnl0ZU9mZnNldCxcbiAgICBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSwgcG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMiwgcG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKSB7XG4gIGlmICgxMiAhPT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYgKDEyICE9PSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmIChvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmIChvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsIG9mczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UsIHBvczIpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pIHtcbiAgaWYgKDEyICE9PSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYgKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYgKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc3ViYXJyYXkocG9zMSwgcG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSwgb2ZzMik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKSB7XG4gIGlmICgxMiAhPT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmIChwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYgKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zdWJhcnJheShwb3MxLCBwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLCBvZnMyKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKSB7XG4gIGlmICgxMiAhPT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmIChvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmIChwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLCBvZnMxICsgbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCwgdG9yZWFkKSB7XG4gIHZhciBjdHggPSBjYW1sX01ENUluaXQoKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDQwOTYpO1xuICBpZiAodG9yZWFkIDwgMCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYgKHJlYWQgPT09IDApIGJyZWFrO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LCBidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAodG9yZWFkID4gMCkge1xuICAgICAgdmFyIHJlYWQgPSBjYW1sX21sX2lucHV0X2Jsb2NrKFxuICAgICAgICBjaGFuaWQsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgMCxcbiAgICAgICAgdG9yZWFkID4gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5sZW5ndGggOiB0b3JlYWQsXG4gICAgICApO1xuICAgICAgaWYgKHJlYWQgPT09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCwgYnVmZmVyLnN1YmFycmF5KDAsIHJlYWQpLCByZWFkKTtcbiAgICAgIHRvcmVhZCAtPSByZWFkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksIG9mcywgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVUcmFuc2Zvcm1cbnZhciBjYW1sX01ENVRyYW5zZm9ybSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gICAgcmV0dXJuICh4ICsgeSkgfCAwO1xuICB9XG4gIGZ1bmN0aW9uIHh4KHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKH5iICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiB4eChjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh3LCBidWZmZXIpIHtcbiAgICB2YXIgYSA9IHdbMF0sXG4gICAgICBiID0gd1sxXSxcbiAgICAgIGMgPSB3WzJdLFxuICAgICAgZCA9IHdbM107XG5cbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzBdLCA3LCAweGQ3NmFhNDc4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzFdLCAxMiwgMHhlOGM3Yjc1Nik7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsyXSwgMTcsIDB4MjQyMDcwZGIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbM10sIDIyLCAweGMxYmRjZWVlKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzRdLCA3LCAweGY1N2MwZmFmKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzVdLCAxMiwgMHg0Nzg3YzYyYSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcls2XSwgMTcsIDB4YTgzMDQ2MTMpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbN10sIDIyLCAweGZkNDY5NTAxKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzhdLCA3LCAweDY5ODA5OGQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzldLCAxMiwgMHg4YjQ0ZjdhZik7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMF0sIDE3LCAweGZmZmY1YmIxKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzExXSwgMjIsIDB4ODk1Y2Q3YmUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbMTJdLCA3LCAweDZiOTAxMTIyKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzEzXSwgMTIsIDB4ZmQ5ODcxOTMpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNywgMHhhNjc5NDM4ZSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNV0sIDIyLCAweDQ5YjQwODIxKTtcblxuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbMV0sIDUsIDB4ZjYxZTI1NjIpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbNl0sIDksIDB4YzA0MGIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNCwgMHgyNjVlNWE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclswXSwgMjAsIDB4ZTliNmM3YWEpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbNV0sIDUsIDB4ZDYyZjEwNWQpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWzE1XSwgMTQsIDB4ZDhhMWU2ODEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbNF0sIDIwLCAweGU3ZDNmYmM4KTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzldLCA1LCAweDIxZTFjZGU2KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzE0XSwgOSwgMHhjMzM3MDdkNik7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclszXSwgMTQsIDB4ZjRkNTBkODcpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbOF0sIDIwLCAweDQ1NWExNGVkKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNSwgMHhhOWUzZTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsyXSwgOSwgMHhmY2VmYTNmOCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcls3XSwgMTQsIDB4Njc2ZjAyZDkpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbMTJdLCAyMCwgMHg4ZDJhNGM4YSk7XG5cbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWzVdLCA0LCAweGZmZmEzOTQyKTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzhdLCAxMSwgMHg4NzcxZjY4MSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMV0sIDE2LCAweDZkOWQ2MTIyKTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzE0XSwgMjMsIDB4ZmRlNTM4MGMpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbMV0sIDQsIDB4YTRiZWVhNDQpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbNF0sIDExLCAweDRiZGVjZmE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWzddLCAxNiwgMHhmNmJiNGI2MCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMF0sIDIzLCAweGJlYmZiYzcwKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNCwgMHgyODliN2VjNik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclswXSwgMTEsIDB4ZWFhMTI3ZmEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbM10sIDE2LCAweGQ0ZWYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzZdLCAyMywgMHgwNDg4MWQwNSk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcls5XSwgNCwgMHhkOWQ0ZDAzOSk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMl0sIDExLCAweGU2ZGI5OWU1KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWzE1XSwgMTYsIDB4MWZhMjdjZjgpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMl0sIDIzLCAweGM0YWM1NjY1KTtcblxuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbMF0sIDYsIDB4ZjQyOTIyNDQpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbN10sIDEwLCAweDQzMmFmZjk3KTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTUsIDB4YWI5NDIzYTcpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbNV0sIDIxLCAweGZjOTNhMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNiwgMHg2NTViNTljMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclszXSwgMTAsIDB4OGYwY2NjOTIpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNSwgMHhmZmVmZjQ3ZCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsxXSwgMjEsIDB4ODU4NDVkZDEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbOF0sIDYsIDB4NmZhODdlNGYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTVdLCAxMCwgMHhmZTJjZTZlMCk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcls2XSwgMTUsIDB4YTMwMTQzMTQpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbMTNdLCAyMSwgMHg0ZTA4MTFhMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcls0XSwgNiwgMHhmNzUzN2U4Mik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMV0sIDEwLCAweGJkM2FmMjM1KTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzJdLCAxNSwgMHgyYWQ3ZDJiYik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcls5XSwgMjEsIDB4ZWI4NmQzOTEpO1xuXG4gICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgIHdbMl0gPSBhZGQoYywgd1syXSk7XG4gICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgfTtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1SW5pdFxuZnVuY3Rpb24gY2FtbF9NRDVJbml0KCkge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY0KTtcbiAgdmFyIGIzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB2YXIgYjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4ge1xuICAgIGxlbjogMCxcbiAgICB3OiBuZXcgVWludDMyQXJyYXkoWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZdKSxcbiAgICBiMzI6IGIzMixcbiAgICBiODogYjgsXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VXBkYXRlXG4vL1JlcXVpcmVzOiBjYW1sX01ENVRyYW5zZm9ybVxuZnVuY3Rpb24gY2FtbF9NRDVVcGRhdGUoY3R4LCBpbnB1dCwgaW5wdXRfbGVuKSB7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgdmFyIGlucHV0X3BvcyA9IDA7XG4gIGN0eC5sZW4gKz0gaW5wdXRfbGVuO1xuICBpZiAoaW5fYnVmKSB7XG4gICAgdmFyIG1pc3NpbmcgPSA2NCAtIGluX2J1ZjtcbiAgICBpZiAoaW5wdXRfbGVuIDwgbWlzc2luZykge1xuICAgICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLCBpbnB1dF9sZW4pLCBpbl9idWYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KDAsIG1pc3NpbmcpLCBpbl9idWYpO1xuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBpbnB1dF9sZW4gLT0gbWlzc2luZztcbiAgICBpbnB1dF9wb3MgKz0gbWlzc2luZztcbiAgfVxuICB3aGlsZSAoaW5wdXRfbGVuID49IDY0KSB7XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsIGlucHV0X3BvcyArIDY0KSwgMCk7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSA2NDtcbiAgICBpbnB1dF9wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGlucHV0X2xlbilcbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KGlucHV0X3BvcywgaW5wdXRfcG9zICsgaW5wdXRfbGVuKSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1RmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENUZpbmFsKGN0eCkge1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIGN0eC5iOFtpbl9idWZdID0gMHg4MDtcbiAgaW5fYnVmKys7XG4gIGlmIChpbl9idWYgPiA1Nikge1xuICAgIGZvciAodmFyIGogPSBpbl9idWY7IGogPCA2NDsgaisrKSB7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA1NjsgaisrKSB7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gaW5fYnVmOyBqIDwgNTY7IGorKykge1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH1cbiAgY3R4LmIzMlsxNF0gPSBjdHgubGVuIDw8IDM7XG4gIGN0eC5iMzJbMTVdID0gKGN0eC5sZW4gPj4gMjkpICYgMHgxZmZmZmZmZjtcbiAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHRbaSAqIDQgKyBqXSA9IChjdHgud1tpXSA+PiAoOCAqIGopKSAmIDB4ZmY7XG4gIHJldHVybiB0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1SW5pdCwgY2FtbF9NRDVVcGRhdGUsIGNhbWxfTUQ1RmluYWxcbmZ1bmN0aW9uIGNhbWxfbWQ1X2J5dGVzKHMsIG9mcywgbGVuKSB7XG4gIHZhciBjdHggPSBjYW1sX01ENUluaXQoKTtcbiAgdmFyIGEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHMpO1xuICBjYW1sX01ENVVwZGF0ZShjdHgsIGEuc3ViYXJyYXkob2ZzLCBvZnMgKyBsZW4pLCBsZW4pO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRlMzA3KSA9PT0gMTAyMDtcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmIChsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpO1xuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09PSAwKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBpZiAoeCA+PSAxKSB7XG4gICAgd2hpbGUgKHggPj0gMikge1xuICAgICAgeCAvPSAyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA8IDEpIHtcbiAgICAgIHggKj0gMjtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApO1xuICAgIGVsc2UgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMCk7XG4gIH1cbiAgdmFyIHNpZ24gPVxuICAgIHggPT09IDAgJiYgMSAvIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgPyAweDgwMDBcbiAgICAgIDogeCA+PSAwXG4gICAgICAgID8gMFxuICAgICAgICA6IDB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwgLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMiwgZXhwIC0gMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyO1xuICAgICAgZXhwIC09IDE7XG4gICAgfVxuICAgIGlmIChleHAgPT09IDApIHtcbiAgICAgIHggLz0gMjtcbiAgICB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLCAyNCk7XG4gIHZhciByMyA9IHggfCAwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4IHwgMDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geCB8IDA7XG4gIHIzID0gKHIzICYgMHhmKSB8IHNpZ24gfCAoZXhwIDw8IDQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHggPiAwID8gXCJpbmZpbml0eVwiIDogXCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSB4ID09PSAwICYmIDEgLyB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAxIDogeCA+PSAwID8gMCA6IDE7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PT0gMCkge1xuICB9IGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSB7XG4gICAgICB4ICo9IDI7XG4gICAgICBleHAtLTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikge1xuICAgICAgeCAvPSAyO1xuICAgICAgZXhwKys7XG4gICAgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyBcIlwiIDogXCIrXCI7XG4gIHZhciBzaWduX3N0ciA9IFwiXCI7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9IFwiLVwiO1xuICBlbHNlIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlIDQzIC8qICcrJyAqLzpcbiAgICAgICAgc2lnbl9zdHIgPSBcIitcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMyIC8qICcgJyAqLzpcbiAgICAgICAgc2lnbl9zdHIgPSBcIiBcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLCBwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmIChwcmVjID49IDApIHtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHhfc3RyICs9IFwiLlwiICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsIFwiMFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHggKyAxICsgcHJlYztcbiAgICAgIGlmICh4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgXCIwXCIpO1xuICAgICAgZWxzZSB4X3N0ciA9IHhfc3RyLnNsaWNlKDAsIHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXG4gICAgc2lnbl9zdHIgKyBcIjB4XCIgKyB4X3N0ciArIFwicFwiICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT09IDIwNDcpIHtcbiAgICBpZiAoKGxvIHwgbWkgfCAoaGkgJiAweGYpKSA9PT0gMClcbiAgICAgIHJldHVybiBoaSAmIDB4ODAwMCA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBlbHNlIHJldHVybiBOdW1iZXIuTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwgLTI0KTtcbiAgdmFyIHJlcyA9IChsbyAqIGsgKyBtaSkgKiBrICsgKGhpICYgMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsIGV4cCAtIDEwMjcpO1xuICB9IGVsc2UgcmVzICo9IE1hdGgucG93KDIsIC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCh4LCB5KSB7XG4gIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgTnVtYmVyLmlzTmFOKHkpKSByZXR1cm4gTnVtYmVyLk5hTjtcbiAgaWYgKHggPT09IHkpIHJldHVybiB5O1xuICBpZiAoeCA9PT0gMCkge1xuICAgIGlmICh5IDwgMCkgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NCk7XG4gICAgZWxzZSByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpO1xuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKHggPCB5ID09PSB4ID4gMCkgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSk7XG4gIGVsc2UgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSk7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCh4KSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9PSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gTnVtYmVyLmlzTmFOKHgpID8gNCA6IDM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCh4KSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB2YXIgbmVnID0gMSAvIHggPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7XG4gICAgICBpID0gLWk7XG4gICAgICBmID0gLWY7XG4gICAgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTih4KSkgcmV0dXJuIFswLCBOdW1iZXIuTmFOLCBOdW1iZXIuTmFOXTtcbiAgcmV0dXJuIFswLCAxIC8geCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0KHgsIGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7XG4gICAgICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQoeCkge1xuICBpZiAoeCA9PT0gMCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAteDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLCAtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAteDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICghTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gMTtcbiAgaWYgKCFOdW1iZXIuaXNOYU4oeSkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQoeCwgeSkge1xuICBpZiAoeSA9PT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiB5IDwgMCA/IC14IDogeDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG4vL0FsaWFzOiBjYW1sX3NpZ25iaXRcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiB4IDwgMCA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwbTEoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2V4cDJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwMl9mbG9hdCh4KSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCB4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5sb2cxcCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nMih4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQoeCwgeSkge1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguY29zaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYWNvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYWNvc2hfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hY29zaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguc2luaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYXNpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXNpbmhfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hc2luaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGgudGFuaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYXRhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXRhbmhfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hdGFuaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQoeCkge1xuICBpZiAoeCA+PSAwKSB7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKHgpO1xuICAgIHJldHVybiB4IC0geSA+PSAwLjUgPyB5ICsgMSA6IHk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHkgPSBNYXRoLmNlaWwoeCk7XG4gICAgcmV0dXJuIHkgLSB4ID49IDAuNSA/IHkgLSAxIDogeTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jYnJ0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NicnRfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5jYnJ0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9lcmZfZmxvYXQoeCkge1xuICB2YXIgYTEgPSAwLjI1NDgyOTU5MjtcbiAgdmFyIGEyID0gLTAuMjg0NDk2NzM2O1xuICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcbiAgdmFyIGE0ID0gLTEuNDUzMTUyMDI3O1xuICB2YXIgYTUgPSAxLjA2MTQwNTQyOTtcbiAgdmFyIHAgPSAwLjMyNzU5MTE7XG5cbiAgdmFyIHNpZ24gPSAxO1xuICBpZiAoeCA8IDApIHtcbiAgICBzaWduID0gLTE7XG4gIH1cbiAgeCA9IE1hdGguYWJzKHgpO1xuICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHZhciB5ID1cbiAgICAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZtYV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbWFfZmxvYXQoeCwgeSwgeikge1xuICB2YXIgU1BMSVQgPSBNYXRoLnBvdygyLCAyNykgKyAxO1xuICB2YXIgTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEwMjIpO1xuICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gIHZhciBDID0gNDE2O1xuICB2YXIgQSA9IE1hdGgucG93KDIsICtDKTtcbiAgdmFyIEIgPSBNYXRoLnBvdygyLCAtQyk7XG5cbiAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9IGFoaSAqIGJoaSAtIHAgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIHYgPSBzIC0gYTtcbiAgICB2YXIgZSA9IGEgLSAocyAtIHYpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGUsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdCh4LCB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgJiYgeSAhPT0gMCAmJiBTUExJVCAqIHggLSAoU1BMSVQgKiB4IC0geCkgPT09IHhcbiAgICAgID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pXG4gICAgICA6IHg7XG4gIH1cblxuICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwIHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDE7XG4gIHdoaWxlIChNYXRoLmFicyh4KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHggKj0gQjtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB5ICo9IEI7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAxIC8gMCkge1xuICAgIHJldHVybiB4ICogeSAqIHNjYWxlO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh4KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHggKj0gQTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB5ICo9IEE7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgeHMgPSB4O1xuICB2YXIgeXMgPSB5O1xuICB2YXIgenMgPSB6IC8gc2NhbGU7XG5cbiAgaWYgKE1hdGguYWJzKHpzKSA+IChNYXRoLmFicyh4cyAqIHlzKSAqIDQpIC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCAoKChNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04pIC8gNCkgKiBFUFNJTE9OKSAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LCBkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gTnVtYmVyLnBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdChcIitcIilbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLCBlKTtcbiAgICAgICAgeCArPSBuZXcgQXJyYXkoZSArIDEpLmpvaW4oXCIwXCIpO1xuICAgICAgICBpZiAoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyBcIi5cIiArIG5ldyBBcnJheShkcCArIDEpLmpvaW4oXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH1cbiAgfVxuICB2YXIgcyxcbiAgICBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSBmLnByZWMgPCAwID8gNiA6IGYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09PSAwICYmIDEgLyB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKSB7XG4gICAgZi5zaWduID0gLTE7XG4gICAgeCA9IC14O1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oeCkpIHtcbiAgICBzID0gXCJuYW5cIjtcbiAgICBmLmZpbGxlciA9IFwiIFwiO1xuICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICBzID0gXCJpbmZcIjtcbiAgICBmLmZpbGxlciA9IFwiIFwiO1xuICB9IGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT09IFwiZVwiKVxuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgLSAxKSArIFwiMFwiICsgcy5zbGljZShpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgcHJlYyA9IHByZWMgPyBwcmVjIDogMTtcbiAgICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICAgIHZhciBqID0gcy5pbmRleE9mKFwiZVwiKTtcbiAgICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IGogLSAxO1xuICAgICAgICAgIHdoaWxlIChzLmNoYXJBdChpKSA9PT0gXCIwXCIpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT09IFwiLlwiKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PT0gXCJlXCIpXG4gICAgICAgICAgICBzID0gcy5zbGljZSgwLCBpIC0gMSkgKyBcIjBcIiArIHMuc2xpY2UoaSAtIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgICBpZiAoZXhwIDwgMCkge1xuICAgICAgICAgICAgcCAtPSBleHAgKyAxO1xuICAgICAgICAgICAgcyA9IHgudG9GaXhlZChwKTtcbiAgICAgICAgICB9IGVsc2Ugd2hpbGUgKCgocyA9IHgudG9GaXhlZChwKSksIHMubGVuZ3RoID4gcHJlYyArIDEpKSBwLS07XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHMuY2hhckF0KGkpID09PSBcIjBcIikgaS0tO1xuICAgICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09PSBcIi5cIikgaS0tO1xuICAgICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHZhciByX2Zsb2F0ID0gL14gKlstK10/KD86XFxkKlxcLj9cXGQrfFxcZCtcXC4/XFxkKikoPzpbZUVdWy0rXT9cXGQrKT8kLztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHJlcyA9ICtzO1xuICAvL0Zhc3QgcGF0aFxuICBpZiAoIU51bWJlci5pc05hTihyZXMpICYmIHJfZmxvYXQudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLCBcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoIU51bWJlci5pc05hTihyZXMpICYmIHJfZmxvYXQudGVzdChzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKVxuICAgIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8kL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA1XG4gIGlmIChtKSB7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCBcIlwiKTtcbiAgICB2YXIgbWFudGlzc2EgPSBOdW1iZXIucGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9ICgrbVs1XSB8fCAwKSAtIDQgKiBtMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgaWYgKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkoeCwgeSkge1xuICBpZiAoeS5mdW4pIHtcbiAgICB4LmZ1biA9IHkuZnVuO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgeC5mdW4gPSB5O1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBpID0geS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19kdW1teV9pbmZpeFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9hbGxvY19kdW1teV9pbmZpeCgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYoeCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBbeF0pO1xuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2soeCkge1xuICByZXR1cm4gK0FycmF5LmlzQXJyYXkoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyh4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHgpICYmIHhbMF0gPT09IHhbMF0gPj4+IDApIHJldHVybiB4WzBdO1xuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKSByZXR1cm4gMjUyO1xuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSkgcmV0dXJuIDI1MjtcbiAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAyNDc7XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSkgcmV0dXJuIDI1NTtcbiAgZWxzZSByZXR1cm4gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnKHgsIHRhZykge1xuICB4WzBdID0gdGFnO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrKHRhZywgc2l6ZSkge1xuICAvLyBUT0RPOiBmYWlsIGZvciB2YWx1ZSB0aGF0IGFyZSBub3QgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXlcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSArIDEpO1xuICBvWzBdID0gdGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZywgeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsOyBpKyspIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSh4LCBzKSB7XG4gIGlmIChzIDw9IDAgfHwgcyArIDEgPiB4Lmxlbmd0aCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT09IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQoYiwgdikge1xuICBiWzBdID0gMjUwO1xuICBiWzFdID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX29ial9jb21wYXJlX2FuZF9zd2FwKHgsIGksIG9sZCwgbikge1xuICBpZiAoeFtpICsgMV0gPT09IG9sZCkge1xuICAgIHhbaSArIDFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfc2hhcmVkKHgpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkKHYpIHtcbiAgcmV0dXJuIFsyNTAsIHZdO1xufVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2Qob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsXG4gICAgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLFxuICAgIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaSArIGhpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pICsgMV0pIGhpID0gbWkgLSAyO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gdGFnID09PSBtZXRoc1tsaSArIDFdID8gbWV0aHNbbGldIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQoYikge1xuICBiWzJdID0gY2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobywgaSkge1xuICByZXR1cm4gb1tpICsgMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF9yYXdfZmllbGQobywgaSwgdikge1xuICByZXR1cm4gKG9baSArIDFdID0gdik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2FkZF9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfb2JqX2FkZF9vZmZzZXQodiwgb2Zmc2V0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJPYmouYWRkX29mZnNldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial91cGRhdGVfdGFnXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9vYmpfdXBkYXRlX3RhZyhiLCBvLCBuKSB7XG4gIGlmIChiWzBdID09PSBvKSB7XG4gICAgYlswXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZ1xuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyhvKSB7XG4gIGlmIChcbiAgICBBcnJheS5pc0FycmF5KG8pICYmXG4gICAgb1swXSA9PT0gb1swXSA+Pj4gMCAmJlxuICAgIGNhbWxfb2JqX3VwZGF0ZV90YWcobywgMjQ2LCAyNDQpXG4gICkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZChvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywgMjQ0LCAyNTApO1xuICByZXR1cm4gMDsgLy8gdW5pdFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eVxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZXNldF90b19sYXp5KG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLCAyNDQsIDI0Nik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVhZF9yZXN1bHRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3RhZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZWFkX3Jlc3VsdChvKSB7XG4gIHJldHVybiBjYW1sX29ial90YWcobykgPT09IDI1MCA/IG9bMV0gOiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPCA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiB0ID09PSAyNDUgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21faWRlbnRpZmllclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3VzdG9tX2lkZW50aWZpZXIobykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoby5jYW1sX2N1c3RvbSk7XG59XG4iLCIvKlxuVG8gZGVhbCB3aXRoIGVmZmVjdHMsIHRoZSBleGVjdXRpb24gY29udGV4dCBpcyBpbnR1aXRpdmVseSBjb21wb3NlZCBvZlxuYSBzdGFjayBvZiBmaWJlcnMuIEVhY2ggZmliZXIgaGFzIGEgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4ob25lLWFyZ3VtZW50IEphdmFTY3JpcHQgZnVuY3Rpb24pLCBhIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmRcbmEgdHJpcGxlIG9mIGhhbmRsZXJzLCB3aGljaCBhcmUgaW52b2tlZCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzXG4oZWl0aGVyIHdpdGggYSB2YWx1ZSBvciBhbiBleGNlcHRpb24pIG9yIHdoZW4gYW4gZWZmZWN0IGlzIHBlcmZvcm1lZC5cblRoZSBsb3ctbGV2ZWwgY29udGludWF0aW9uIG9mIHRoZSB0b3Btb3N0IGZpYmVyICh3aGljaCBpcyBjdXJyZW50bHlcbmV4ZWN1dGluZykgaXMgcGFzc2VkIGZyb20gZnVuY3Rpb24gdG8gZnVuY3Rpb24gYXMgYW4gYWRkaXRpb25hbFxuYXJndW1lbnQuIEl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgaXMgc3RvcmVkIGluXG5bY2FtbF9jdXJyZW50X3N0YWNrLnhdLlxuRXhjZXB0aW9uIGhhbmRsZXJzIGFyZSBwdXNoZWQgaW50byB0aGlzIHN0YWNrXG53aGVuIGVudGVyaW5nIGEgW3RyeSAuLi4gd2l0aCAuLi5dIGFuZCBwb3BwZWQgb24gZXhpdC5cbkhhbmRsZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfY3VycmVudF9zdGFjay5oXVxuYW5kIHRoZSByZW1haW5pbmcgZmliZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfY3VycmVudF9zdGFjay5lXS5cblRvIGluc3RhbGwgYW4gZWZmZWN0IGhhbmRsZXIsIHdlIHB1c2ggYSBuZXcgZmliZXIgaW50byB0aGUgZXhlY3V0aW9uIGNvbnRleHQuXG5cbldlIGhhdmUgYmFzaWNhbGx5IHRoZSBmb2xsb3dpbmcgdHlwZSBmb3IgcmVpZmllZCBjb250aW51YXRpb25zICh0eXBlXG5bY29udGludWF0aW9uXSBpbiBtb2R1bGUgW0VmZmVjdF0gb2YgdGhlIHN0YW5kYXJkIGxpYnJhcnkpOlxuXG4gIHR5cGUgKCdhLCAnYikgY29udGludWF0aW9uID0gKCdhLCAnYikgc3RhY2sgcmVmXG5cbiAgYW5kIChfLCBfKSBzdGFjayA9XG4gICAgICBDb25zIDogKCdiIC0+IHVuaXQpICogICAgICAgICAgICAgKCogbG93LWxldmVsIGNvbnRpbnVhdGlvbiAqKVxuICAgICAgICAgICAgIChleG4gLT4gdW5pdCkgbGlzdCAqICAgICAgICgqIGV4Y2VwdGlvbiBoYW5kbGVycyAqKVxuICAgICAgICAgICAgICgnYiwgJ2MpIGhhbmRsZXIgKlxuICAgICAgICAgICAgICgnYSwgJ2IpIHN0YWNrXG4gICAgICAgICAgICAgLT4gKCdhLCAnYykgc3RhY2tcbiAgICB8IEVtcHR5IDogKCdhLCAnYSkgc3RhY2tcblxuICBhbmQgKCdhLCdiKSBoYW5kbGVyID0gICAoKiBBcyBpbiBtb2R1bGUgRWZmZWN0IGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgRWZmZWN0LnQgLT4gKCgnYywnYikgY29udGludWF0aW9uIC0+ICdiKSBvcHRpb24gfVxuXG5Db250aW51YXRpb25zIGFyZSBvbmUtc2hvdC4gQSBjb250aW51YXRpb24gW3JlZiBFbXB0eV0gaGFzIGFscmVhZHlcbmJlZW4gcmVzdW1lZC5cblxuQSBjb250aW51YXRpb24gaXMgYmFzaWNhbGx5IGNvbXBvc2VkIG9mIGEgbGlzdCBvZiBmaWJlcnMsIHdoaWNoIGVhY2hcbmhhcyBpdHMgbG93LWxldmVsIGNvbnRpbnVhdGlvbiwgaXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmQgYVxudHJpcGxlIG9mIGhhbmRsZXJzIHRvIGRlYWwgd2l0aCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzIG9yIGFuXG5lZmZlY3QgaXMgcGVyZm9ybWVkLiBXaGVuIHJlc3VtaW5nIGEgY29udGludWF0aW9uLCB0aGUgaW5uZXJtb3N0IGZpYmVyXG5pcyByZXN1bWVkIGZpcnN0LlxuXG5UaGUgaGFuZGxlcnMgYXJlIENQUy10cmFuc2Zvcm1lZCBmdW5jdGlvbnM6IHRoZXkgYWN0dWFsbHkgdGFrZSBhblxuYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIGN1cnJlbnQgbG93LWxldmVsIGNvbnRpbnVhdGlvbi5cbiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBoYXMgdGhlIHNoYXBlIHtrLCB4LCBoLCBlfSB3aGVyZVxuLy8gLSBoIGlzIGEgdHJpcGxlIG9mIGhhbmRsZXJzIChzZWUgZWZmZWN0Lm1sKVxuLy8gLSBrIGlzIHRoZSBsb3cgbGV2ZWwgY29udGludWF0aW9uXG4vLyAtIHggaXMgdGhlIGV4Y2VwdGlvbiBzdGFja1xuLy8gLSBlIGlzIHRoZSBmaWJlciBzdGFjayBvZiB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNhbWxfY3VycmVudF9zdGFjayA9IHsgazogMCwgeDogMCwgaDogMCwgZTogMCB9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1c2hfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3B1c2hfdHJhcChoYW5kbGVyKSB7XG4gIGNhbWxfY3VycmVudF9zdGFjay54ID0geyBoOiBoYW5kbGVyLCB0OiBjYW1sX2N1cnJlbnRfc3RhY2sueCB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX3RyYXAoKSB7XG4gIGlmICghY2FtbF9jdXJyZW50X3N0YWNrLngpXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aHJvdyB4O1xuICAgIH07XG4gIHZhciBoID0gY2FtbF9jdXJyZW50X3N0YWNrLnguaDtcbiAgY2FtbF9jdXJyZW50X3N0YWNrLnggPSBjYW1sX2N1cnJlbnRfc3RhY2sueC50O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV91bmhhbmRsZWRcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV91bmhhbmRsZWRfZWZmZWN0X2V4blxuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfdW5oYW5kbGVkKGVmZikge1xuICB2YXIgZXhuID0gY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuKGVmZik7XG4gIHRocm93IGV4bjtcbn1cblxuLy9Qcm92aWRlczpjYW1sX3Jlc3VtZV9zdGFja1xuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV9jb25zdGFudFxuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmVzdW1lX3N0YWNrKHN0YWNrLCBsYXN0LCBrKSB7XG4gIGlmICghc3RhY2spXG4gICAgY2FtbF9yYWlzZV9jb25zdGFudChcbiAgICAgIGNhbWxfbmFtZWRfdmFsdWUoXCJFZmZlY3QuQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFwiKSxcbiAgICApO1xuICBpZiAobGFzdCA9PT0gMCkge1xuICAgIGxhc3QgPSBzdGFjaztcbiAgICAvLyBQcmUgT0NhbWwgNS4yLCBsYXN0L2NvbnRbMl0gd2FzIG5vdCBwb3B1bGF0ZWQuXG4gICAgd2hpbGUgKGxhc3QuZSAhPT0gMCkgbGFzdCA9IGxhc3QuZTtcbiAgfVxuICBjYW1sX2N1cnJlbnRfc3RhY2suayA9IGs7XG4gIGxhc3QuZSA9IGNhbWxfY3VycmVudF9zdGFjaztcbiAgY2FtbF9jdXJyZW50X3N0YWNrID0gc3RhY2s7XG4gIHJldHVybiBzdGFjay5rO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF9maWJlclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X3N0YWNrXG4vL0lmOiBlZmZlY3RzXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9wb3BfZmliZXIoKSB7XG4gIC8vIE1vdmUgdG8gdGhlIHBhcmVudCBmaWJlciwgcmV0dXJuaW5nIHRoZSBwYXJlbnQncyBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4gIHZhciBjID0gY2FtbF9jdXJyZW50X3N0YWNrLmU7XG4gIGNhbWxfY3VycmVudF9zdGFjay5lID0gMDtcbiAgY2FtbF9jdXJyZW50X3N0YWNrID0gYztcbiAgcmV0dXJuIGMuaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2ZyZXNoX29vX2lkXG4vL0lmOiBlZmZlY3RzXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuKGVmZikge1xuICB2YXIgZXhuID0gY2FtbF9uYW1lZF92YWx1ZShcIkVmZmVjdC5VbmhhbmRsZWRcIik7XG4gIGlmIChleG4pIGV4biA9IFswLCBleG4sIGVmZl07XG4gIGVsc2Uge1xuICAgIGV4biA9IFtcbiAgICAgIDI0OCxcbiAgICAgIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJFZmZlY3QuVW5oYW5kbGVkXCIpLFxuICAgICAgY2FtbF9mcmVzaF9vb19pZCgwKSxcbiAgICBdO1xuICB9XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGVyZm9ybV9lZmZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoLCBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfdW5oYW5kbGVkX2VmZmVjdF9leG4sIGNhbWxfY3VycmVudF9zdGFja1xuLy9SZXF1aXJlczogY2FtbF9nZXRfY3BzX2Z1blxuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcGVyZm9ybV9lZmZlY3QoZWZmLCBrMCkge1xuICBpZiAoY2FtbF9jdXJyZW50X3N0YWNrLmUgPT09IDApIHtcbiAgICB2YXIgZXhuID0gY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuKGVmZik7XG4gICAgdGhyb3cgZXhuO1xuICB9XG4gIC8vIEdldCBjdXJyZW50IGVmZmVjdCBoYW5kbGVyXG4gIHZhciBoYW5kbGVyID0gY2FtbF9jdXJyZW50X3N0YWNrLmhbM107XG4gIHZhciBsYXN0X2ZpYmVyID0gY2FtbF9jdXJyZW50X3N0YWNrO1xuICBsYXN0X2ZpYmVyLmsgPSBrMDtcbiAgdmFyIGNvbnQgPSBbMjQ1IC8qY29udGludWF0aW9uKi8sIGxhc3RfZmliZXIsIDBdO1xuICAvLyBNb3ZlIHRvIHBhcmVudCBmaWJlciBhbmQgZXhlY3V0ZSB0aGUgZWZmZWN0IGhhbmRsZXIgdGhlcmVcbiAgLy8gVGhlIGhhbmRsZXIgaXMgZGVmaW5lZCBpbiBTdGRsaWIuRWZmZWN0LCBzbyB3ZSBrbm93IHRoYXQgdGhlIGFyaXR5IG1hdGNoZXNcbiAgdmFyIGsxID0gY2FtbF9wb3BfZmliZXIoKTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKVxuICAgID8gY2FtbF9nZXRfY3BzX2Z1bihoYW5kbGVyKShlZmYsIGNvbnQsIGxhc3RfZmliZXIsIGsxKVxuICAgIDogY2FtbF90cmFtcG9saW5lX3JldHVybihoYW5kbGVyLCBbZWZmLCBjb250LCBsYXN0X2ZpYmVyLCBrMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlcGVyZm9ybV9lZmZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoLCBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfdW5oYW5kbGVkX2VmZmVjdF9leG4sIGNhbWxfY3VycmVudF9zdGFja1xuLy9SZXF1aXJlczogY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuLy9SZXF1aXJlczogY2FtbF9nZXRfY3BzX2Z1blxuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmVwZXJmb3JtX2VmZmVjdChlZmYsIGNvbnQsIGxhc3QsIGswKSB7XG4gIGlmIChjYW1sX2N1cnJlbnRfc3RhY2suZSA9PT0gMCkge1xuICAgIHZhciBleG4gPSBjYW1sX21ha2VfdW5oYW5kbGVkX2VmZmVjdF9leG4oZWZmKTtcbiAgICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gICAgY2FtbF9yZXN1bWVfc3RhY2soc3RhY2ssIGxhc3QsIGswKTtcbiAgICB0aHJvdyBleG47XG4gIH1cbiAgLy8gR2V0IGN1cnJlbnQgZWZmZWN0IGhhbmRsZXJcbiAgdmFyIGhhbmRsZXIgPSBjYW1sX2N1cnJlbnRfc3RhY2suaFszXTtcbiAgdmFyIGxhc3RfZmliZXIgPSBjYW1sX2N1cnJlbnRfc3RhY2s7XG4gIGxhc3RfZmliZXIuayA9IGswO1xuICBsYXN0LmUgPSBsYXN0X2ZpYmVyO1xuICAvLyBNb3ZlIHRvIHBhcmVudCBmaWJlciBhbmQgZXhlY3V0ZSB0aGUgZWZmZWN0IGhhbmRsZXIgdGhlcmVcbiAgLy8gVGhlIGhhbmRsZXIgaXMgZGVmaW5lZCBpbiBTdGRsaWIuRWZmZWN0LCBzbyB3ZSBrbm93IHRoYXQgdGhlIGFyaXR5IG1hdGNoZXNcbiAgdmFyIGsxID0gY2FtbF9wb3BfZmliZXIoKTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKVxuICAgID8gY2FtbF9nZXRfY3BzX2Z1bihoYW5kbGVyKShlZmYsIGNvbnQsIGxhc3RfZmliZXIsIGsxKVxuICAgIDogY2FtbF90cmFtcG9saW5lX3JldHVybihoYW5kbGVyLCBbZWZmLCBjb250LCBsYXN0X2ZpYmVyLCBrMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jcHNfZnVuXG4vL0lmOiBlZmZlY3RzXG4vL0lmOiAhZG91YmxldHJhbnNsYXRlXG5mdW5jdGlvbiBjYW1sX2dldF9jcHNfZnVuKGYpIHtcbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2Nwc19mdW5cbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfY3BzX2Z1bihmKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIHRvIGdldCB0aGUgZWZmZWN0IGhhbmRsZXIuIElmIHRoZVxuICAvLyBlZmZlY3QgaGFuZGxlciBoYXMgbm8gQ1BTIGZ1bmN0aW9uLCB3ZSBrbm93IHRoYXQgd2UgY2FuIGRpcmVjdGx5XG4gIC8vIGNhbGwgdGhlIGRpcmVjdCB2ZXJzaW9uIGluc3RlYWQuXG4gIHJldHVybiBmLmNwcyA/IGYuY3BzIDogZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfY2FsbF9nZW4sIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgsIGNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5fY3BzLCBjYW1sX2N1cnJlbnRfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrX2NhbGwoZiwgeCkge1xuICB2YXIgYXJncyA9IFt4LCBjYW1sX3BvcF9maWJlcigpXTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKVxuICAgID8gY2FtbF9jYWxsX2dlbl9jcHMoZiwgYXJncylcbiAgICA6IGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZiwgYXJncywgMCk7XG59XG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrX2h2YWwoeCkge1xuICAvLyBDYWxsIFtodl0gaW4gdGhlIHBhcmVudCBmaWJlclxuICB2YXIgZiA9IGNhbWxfY3VycmVudF9zdGFjay5oWzFdO1xuICByZXR1cm4gY2FtbF9hbGxvY19zdGFja19jYWxsKGYsIHgpO1xufVxuZnVuY3Rpb24gY2FtbF9hbGxvY19zdGFja19oZXhuKGUpIHtcbiAgLy8gQ2FsbCBbaHhdIGluIHRoZSBwYXJlbnQgZmliZXJcbiAgdmFyIGYgPSBjYW1sX2N1cnJlbnRfc3RhY2suaFsyXTtcbiAgcmV0dXJuIGNhbWxfYWxsb2Nfc3RhY2tfY2FsbChmLCBlKTtcbn1cbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICB2YXIgaGFuZGxlcnMgPSBbMCwgaHYsIGh4LCBoZl07XG4gIHJldHVybiB7XG4gICAgazogY2FtbF9hbGxvY19zdGFja19odmFsLFxuICAgIHg6IHsgaDogY2FtbF9hbGxvY19zdGFja19oZXhuLCB0OiAwIH0sXG4gICAgaDogaGFuZGxlcnMsXG4gICAgZTogMCxcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9JZjogIWVmZmVjdHNcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Yyhjb250KSB7XG4gIHZhciBzdGFjayA9IGNvbnRbMV07XG4gIGNvbnRbMV0gPSAwO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGNcbi8vUmVxdWlyZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMoXG4gIGNvbnQsXG4gIGh2YWwsXG4gIGhleG4sXG4gIGhlZmYsXG4pIHtcbiAgdmFyIHN0YWNrID0gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpO1xuICBpZiAoc3RhY2sgPT09IDApIHJldHVybiBzdGFjaztcbiAgdmFyIGxhc3QgPSBjb250WzJdO1xuICBpZiAobGFzdCA9PT0gMCkge1xuICAgIGxhc3QgPSBzdGFjaztcbiAgICAvLyBQcmUgT0NhbWwgNS4yLCBsYXN0L2NvbnRbMl0gd2FzIG5vdCBwb3B1bGF0ZWQuXG4gICAgd2hpbGUgKGxhc3QuZSAhPT0gMCkgbGFzdCA9IGxhc3QuZTtcbiAgfVxuICBsYXN0LmhbMV0gPSBodmFsO1xuICBsYXN0LmhbMl0gPSBoZXhuO1xuICBsYXN0LmhbM10gPSBoZWZmO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrKCkge1xuICByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl9uZXdcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9uZXcodW5pdCkge1xuICByZXR1cm4geyBjb25kaXRpb246IDEgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fd2FpdFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX3dhaXQodCwgbXV0ZXh0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3Rcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKHQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIUlmOiBlZmZlY3RzXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24ganNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIkVmZmVjdCBoYW5kbGVycyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZXN1bWVcbi8vUmVxdWlyZXM6Y2FtbF9zdGFja19kZXB0aCwgY2FtbF9jYWxsX2dlbl9jcHMsIGNhbWxfY3VycmVudF9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmVzdW1lKGYsIGFyZywgc3RhY2ssIGxhc3QpIHtcbiAgdmFyIHNhdmVkX3N0YWNrX2RlcHRoID0gY2FtbF9zdGFja19kZXB0aDtcbiAgdmFyIHNhdmVkX2N1cnJlbnRfc3RhY2sgPSBjYW1sX2N1cnJlbnRfc3RhY2s7XG4gIHRyeSB7XG4gICAgY2FtbF9jdXJyZW50X3N0YWNrID0geyBrOiAwLCB4OiAwLCBoOiAwLCBlOiAwIH07XG4gICAgdmFyIGsgPSBjYW1sX3Jlc3VtZV9zdGFjayhzdGFjaywgbGFzdCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0pO1xuICAgIC8qIE5vdGU6IGYgaXMgbm90IGFuIG9yZGluYXJ5IGZ1bmN0aW9uIGJ1dCBhIChkaXJlY3Qtc3R5bGUsIENQUykgY2xvc3VyZSBwYWlyICovXG4gICAgdmFyIHJlcyA9IHsgam9vX3RyYW1wOiBmLCBqb29fYXJnczogW2FyZywga10sIGpvb19kaXJlY3Q6IDAgfTtcbiAgICBkbyB7XG4gICAgICAvKiBBdm9pZHMgdHJhbXBvbGluaW5nIHRvbyBvZnRlbiB3aGlsZSBzdGlsbCBhdm9pZGluZyBzdGFjayBvdmVyZmxvdy4gU2VlXG4gICAgICAgICBbY2FtbF9jYWxsYmFja10uICovXG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSByZXMuam9vX2RpcmVjdFxuICAgICAgICAgID8gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpXG4gICAgICAgICAgOiBjYW1sX2NhbGxfZ2VuX2NwcyhyZXMuam9vX3RyYW1wLCByZXMuam9vX2FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBIYW5kbGUgZXhjZXB0aW9uIGNvbWluZyBmcm9tIEphdmFTY3JpcHQgb3IgZnJvbSB0aGUgcnVudGltZS4gKi9cbiAgICAgICAgaWYgKCFjYW1sX2N1cnJlbnRfc3RhY2sueCkgdGhyb3cgZTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYW1sX2N1cnJlbnRfc3RhY2sueC5oO1xuICAgICAgICBjYW1sX2N1cnJlbnRfc3RhY2sueCA9IGNhbWxfY3VycmVudF9zdGFjay54LnQ7XG4gICAgICAgIHJlcyA9IHtcbiAgICAgICAgICBqb29fdHJhbXA6IGhhbmRsZXIsXG4gICAgICAgICAgam9vX2FyZ3M6IFtjYW1sX3dyYXBfZXhjZXB0aW9uKGUpXSxcbiAgICAgICAgICBqb29fZGlyZWN0OiAxLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHJlcyAmJiByZXMuam9vX2FyZ3MpO1xuICAgIHJldHVybiByZXM7XG4gIH0gZmluYWxseSB7XG4gICAgY2FtbF9zdGFja19kZXB0aCA9IHNhdmVkX3N0YWNrX2RlcHRoO1xuICAgIGNhbWxfY3VycmVudF9zdGFjayA9IHNhdmVkX2N1cnJlbnRfc3RhY2s7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcHNfY2xvc3VyZVxuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG5mdW5jdGlvbiBjYW1sX2Nwc19jbG9zdXJlKGRpcmVjdF9mLCBjcHNfZikge1xuICBkaXJlY3RfZi5jcHMgPSBjcHNfZjtcbiAgcmV0dXJuIGRpcmVjdF9mO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Fzc3VtZV9ub19wZXJmb3JtXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL0lmOiBlZmZlY3RzXG4vL0lmOiAhZG91YmxldHJhbnNsYXRlXG5mdW5jdGlvbiBjYW1sX2Fzc3VtZV9ub19wZXJmb3JtKGYpIHtcbiAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgWzBdKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgYTJbMF0gPSAwO1xuICBmb3IgKHZhciBpMiA9IDEsIGkxID0gaSArIDE7IGkyIDw9IGxlbjsgaTIrKywgaTErKykge1xuICAgIGEyW2kyXSA9IGFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X3N1YiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X3N1YlxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9zdWIoYSwgaSwgbGVuKSB7XG4gIHJldHVybiBjYW1sX2FycmF5X3N1YihhLCBpLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaWZvcm1fYXJyYXlfc3ViIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfc3ViXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF91bmlmb3JtX2FycmF5X3N1YihhLCBpLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfc3ViKGEsIGksIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsXG4gICAgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDEgKyBsMiAtIDE7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLFxuICAgIGogPSAxO1xuICBmb3IgKDsgaSA8IGwxOyBpKyspIGFbaV0gPSBhMVtpXTtcbiAgZm9yICg7IGkgPCBsOyBpKyssIGorKykgYVtpXSA9IGEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2FwcGVuZCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2FwcGVuZFxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHJldHVybiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaWZvcm1fYXJyYXlfYXBwZW5kIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYXBwZW5kXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF91bmlmb3JtX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bmlmb3JtX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfdW5pZm9ybV9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKTtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0KGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCArIDFdID0gbmV3dmFsO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCArIDFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5W29mcyArIGkgKyAxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9maWxsXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2ZpbGxcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfZmlsbF91bmJveGVkXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2ZpbGxcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfZmlsbF91bmJveGVkKGFycmF5LCBvZnMsIGxlbiwgdikge1xuICByZXR1cm4gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5pZm9ybV9hcnJheV9maWxsXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2ZpbGxcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX3VuaWZvcm1fYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9tYWtlIGNvbnN0IChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfbWFrZShsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA+Pj4gMCA+PSAoKDB4N2ZmZmZmZmYgLyA0KSB8IDApKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSAobGVuICsgMSkgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfdmVjdCBjb25zdCAoY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X21ha2VcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0KGxlbiwgaW5pdCkge1xuICByZXR1cm4gY2FtbF9hcnJheV9tYWtlKGxlbiwgaW5pdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbikge1xuICBpZiAobGVuID4+PiAwID49ICgoMHg3ZmZmZmZmZiAvIDgpIHwgMCkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IChsZW4gKyAxKSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF0gPSAyNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jcmVhdGVfZmxvYXQgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY3JlYXRlX2Zsb2F0KGxlbikge1xuICBpZiAobGVuID4+PiAwID49ICgoMHg3ZmZmZmZmZiAvIDgpIHwgMCkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IChsZW4gKyAxKSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF0gPSAyNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pIHtcbiAgaWYgKGxlbiA+Pj4gMCA+PSAoKDB4N2ZmZmZmZmYgLyA4KSB8IDApKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSAobGVuICsgMSkgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdID0gMjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9tYWtlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfbWFrZShsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA+Pj4gMCA+PSAoKDB4N2ZmZmZmZmYgLyA4KSB8IDApKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSAobGVuICsgMSkgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdID0gMjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9tYWtlX3VuYm94ZWQgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mbG9hdGFycmF5X21ha2Vcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfbWFrZV91bmJveGVkKGxlbiwgaW5pdCkge1xuICByZXR1cm4gY2FtbF9mbG9hdGFycmF5X21ha2UobGVuLCBpbml0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bmlmb3JtX2FycmF5X21ha2UgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9tYWtlXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF91bmlmb3JtX2FycmF5X21ha2UobGVuLCBpbml0KSB7XG4gIHJldHVybiBjYW1sX2FycmF5X21ha2UobGVuLCBpbml0KTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc1xuLy9WZXJzaW9uOiA+PSA1XG52YXIgY2FtbF9kb21haW5fZGxzID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX3NldChhKSB7XG4gIGNhbWxfZG9tYWluX2RscyA9IGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXQob2xkLCBuKSB7XG4gIGlmIChjYW1sX2RvbWFpbl9kbHMgIT09IG9sZCkgcmV0dXJuIDA7XG4gIGNhbWxfZG9tYWluX2RscyA9IG47XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX2dldCh1bml0KSB7XG4gIHJldHVybiBjYW1sX2RvbWFpbl9kbHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2xvYWRcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9hdG9taWNfbG9hZChyZWYpIHtcbiAgcmV0dXJuIHJlZlsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2NhcyhyZWYsIG8sIG4pIHtcbiAgaWYgKHJlZlsxXSA9PT0gbykge1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZFxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2F0b21pY19mZXRjaF9hZGQocmVmLCBpKSB7XG4gIHZhciBvbGQgPSByZWZbMV07XG4gIHJlZlsxXSArPSBpO1xuICByZXR1cm4gb2xkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19leGNoYW5nZVxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2F0b21pY19leGNoYW5nZShyZWYsIHYpIHtcbiAgdmFyIHIgPSByZWZbMV07XG4gIHJlZlsxXSA9IHY7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19tYWtlX2NvbnRlbmRlZFxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkKGEpIHtcbiAgcmV0dXJuIFswLCBhXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXG4vL1ZlcnNpb246ID49IDUuMCwgPCA1LjJcbnZhciBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fID0gWzBdO1xuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuKHVuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50KHVuaXQpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2luZGV4XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuLy9WZXJzaW9uOiA+PSA1LjAzXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9pbmRleCh1bml0KSB7XG4gIHJldHVybiBjYW1sX2RvbWFpbl9pZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5faWRcbi8vVmVyc2lvbjogPj0gNVxudmFyIGNhbWxfZG9tYWluX2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fc3Bhd25cbi8vUmVxdWlyZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuLy9WZXJzaW9uOiA+PSA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMTtcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX3NwYXduKGYsIHRlcm1fc3luYykge1xuICB2YXIgaWQgPSBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4Kys7XG4gIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZiwgWzBdKTtcbiAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKHRlcm1fc3luY1syXSk7XG4gIC8vVE9ETzogZml4IGV4biBjYXNlXG4gIHRlcm1fc3luY1sxXSA9IFswLCBbMCwgcmVzXV07XG4gIHJldHVybiBpZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fc3Bhd25cbi8vUmVxdWlyZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuLy9WZXJzaW9uOiA+PSA1LjAsIDwgNS4yXG52YXIgY2FtbF9kb21haW5fbGF0ZXN0X2lkeCA9IDE7XG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9zcGF3bihmLCBtdXRleCkge1xuICB2YXIgaWQgPSBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4Kys7XG4gIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZiwgWzBdKTtcbiAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKG11dGV4KTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9pZCh1bml0KSB7XG4gIHJldHVybiBjYW1sX2RvbWFpbl9pZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4XG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT09IFwiJWRcIilcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiICsgaSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgaWYgKGYuc2lnbmVkY29udikge1xuICAgICAgZi5zaWduID0gLTE7XG4gICAgICBpID0gLWk7XG4gICAgfSBlbHNlIGkgPj4+PSAwO1xuICB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9IFwiIFwiO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0KG4sIFwiMFwiKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Uocykge1xuICB2YXIgaSA9IDAsXG4gICAgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLFxuICAgIGJhc2UgPSAxMCxcbiAgICBzaWduID0gMSxcbiAgICBzaWduZWRuZXNzID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkpIHtcbiAgICAgIGNhc2UgNDU6XG4gICAgICAgIGkrKztcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDM6XG4gICAgICAgIGkrKztcbiAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgICAgY2FzZSAxMjA6XG4gICAgICBjYXNlIDg4OlxuICAgICAgICBzaWduZWRuZXNzID0gMDtcbiAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMTE6XG4gICAgICBjYXNlIDc5OlxuICAgICAgICBzaWduZWRuZXNzID0gMDtcbiAgICAgICAgYmFzZSA9IDg7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk4OlxuICAgICAgY2FzZSA2NjpcbiAgICAgICAgc2lnbmVkbmVzcyA9IDA7XG4gICAgICAgIGJhc2UgPSAyO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMTc6XG4gICAgICBjYXNlIDg1OlxuICAgICAgICBzaWduZWRuZXNzID0gMDtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZSwgc2lnbmVkbmVzc107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlKHMpO1xuICB2YXIgaSA9IHJbMF0sXG4gICAgc2lnbiA9IHJbMV0sXG4gICAgYmFzZSA9IHJbMl0sXG4gICAgc2lnbmVkbmVzcyA9IHJbM107XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSBpIDwgbGVuID8gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA6IDA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKzsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmIChzaWduZWRuZXNzICYmIChyZXMgfCAwKSAhPT0gcmVzKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguaW11bChhLCBiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgsIHkpIHtcbiAgaWYgKHkgPT09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgcmV0dXJuICh4IC8geSkgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCwgeSkge1xuICBpZiAoeSA9PT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICByZXR1cm4geCAlIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoeCAmIDB4MDBmZikgPDwgOCkgfCAoKHggJiAweGZmMDApID4+IDgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoXG4gICAgKCh4ICYgMHgwMDAwMDBmZikgPDwgMjQpIHxcbiAgICAoKHggJiAweDAwMDBmZjAwKSA8PCA4KSB8XG4gICAgKCh4ICYgMHgwMGZmMDAwMCkgPj4+IDgpIHxcbiAgICAoKHggJiAweGZmMDAwMDAwKSA+Pj4gMjQpXG4gICk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9WZXJzaW9uOiA8IDQuMTJcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eChvYmopIHtcbiAgICBsaW1pdC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09IChvYmpbMF0gfCAwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTA6XG4gICAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICAgIGxpbWl0Kys7XG4gICAgICAgICAgaGFzaF9hdXgob2JqKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXgob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KG9iaik7XG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYiA9IGNvbnRlbnQsIGwgPSBiLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gY29udGVudCwgbCA9IGEubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhvYmopKSB7XG4gICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmogfCAwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiZcbiAgICAgICAgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaFxuICAgICAgKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzZmZmZmZmZjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCwgZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MSB8IDApO1xuICBkID0gKGQgPDwgMTUpIHwgKGQgPj4+ICgzMiAtIDE1KSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKGggPDwgMTMpIHwgKGggPj4+ICgzMiAtIDEzKSk7IC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSkgfCAwKSArICgweGU2NTQ2YjY0IHwgMCkpIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwoaCwgMHg4NWViY2E2YiB8IDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwoaCwgMHhjMmIyYWUzNSB8IDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLFxuICAgIGksXG4gICAgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID1cbiAgICAgIHMuY2hhckNvZGVBdChpKSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAxKSA8PCA4KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAyKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpICsgMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gICAgY2FzZSAzOlxuICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgdyA9IHMuY2hhckNvZGVBdChpICsgMikgPDwgMTY7XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIDI6XG4gICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICB3IHw9IHMuY2hhckNvZGVBdChpICsgMSkgPDwgODtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMTpcbiAgICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCxcbiAgICBpLFxuICAgIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV0gfCAoc1tpICsgMV0gPDwgOCkgfCAoc1tpICsgMl0gPDwgMTYpIHwgKHNbaSArIDNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICAgIGNhc2UgMzpcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIHcgPSBzW2kgKyAyXSA8PCAxNjtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMjpcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIHcgfD0gc1tpICsgMV0gPDwgODtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMTpcbiAgICAgIHcgfD0gc1tpXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY29udGVudCk7XG4gIC8qIEFSUkFZICovIGVsc2UgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG5mdW5jdGlvbiBjYW1sX2hhc2goY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTtcbiAgcmQgPSAwO1xuICB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYgKFxuICAgICAgICBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiZcbiAgICAgICAgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2hcbiAgICAgICkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGhoKTtcbiAgICAgICAgbnVtLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHZbMF0gPT09ICh2WzBdIHwgMCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgICBjYXNlIDI0ODpcbiAgICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgICAgbnVtLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUwOlxuICAgICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSkge1xuICAgICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdik7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdik7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHYpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodiB8IDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdiArIHYgKyAxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCB2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNmZmZmZmZmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsLCBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2hhc2goaCwgdikge1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpO1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzZmZmZmZmZjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSkge1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpXG4gICAgcmV0dXJuIDI1MjsgLy8gc3RyaW5nX3RhZ1xuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhhKSlcbiAgICByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBhWzBdID09PSBhWzBdID4+PiAwICYmIGFbMF0gPD0gMjU1KSB7XG4gICAgLy8gTG9vayBsaWtlIGFuIG9jYW1sIGJsb2NrXG4gICAgdmFyIHRhZyA9IGFbMF0gfCAwO1xuICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnIGJlY2F1c2Ugd2UgY2Fubm90IGFjY3VyYXRlbHkgc2V0XG4gICAgLy8gdGhpcyB0YWcgd2hlbiB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgZmxvYXQuXG4gICAgcmV0dXJuIHRhZyA9PT0gMjU0ID8gMCA6IHRhZztcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKVxuICAgIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE51bWJlcilcbiAgICByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpXG4gICAgcmV0dXJuIDEyNTY7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAxMjQ3OyAvLyBsaWtlIGNsb3N1cmVfdGFnICgyNDcpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSkge1xuICByZXR1cm4gKFxuICAgIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0uY29tcGFyZVxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZiAoY29tcCkge1xuICAgIHZhciB4ID0gc3dhcCA+IDAgPyBjb21wKGN1c3RvbSwgbnVtLCB0b3RhbCkgOiBjb21wKG51bSwgY3VzdG9tLCB0b3RhbCk7XG4gICAgaWYgKHRvdGFsICYmIE51bWJlci5pc05hTih4KSkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmIChOdW1iZXIuaXNOYU4oK3gpKSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmICgoeCB8IDApICE9PSAwKSByZXR1cm4geCB8IDA7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbChhLCBiLCB0b3RhbCkge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmICh0YWdfYSA9PT0gMjUwKSB7XG4gICAgICAgIGEgPSBhWzFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZiAodGFnX2IgPT09IDI1MCkge1xuICAgICAgICBiID0gYlsxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhZ3MgYXJlIGRpZmZlcmVudFxuICAgICAgaWYgKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZiAodGFnX2EgPT09IDEwMDApIHtcbiAgICAgICAgICBpZiAodGFnX2IgPT09IDEyNTUpIHtcbiAgICAgICAgICAgIC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGEsIGIsIC0xLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnX2IgPT09IDEwMDApIHtcbiAgICAgICAgICBpZiAodGFnX2EgPT09IDEyNTUpIHtcbiAgICAgICAgICAgIC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGIsIGEsIDEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ19hIDwgdGFnX2IgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICAvLyB0YWdfYSA9IHRhZ19iXG4gICAgICBzd2l0Y2ggKHRhZ19hKSB7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSkgfCAwO1xuICAgICAgICAgIGlmICh4ICE9PSAwKSByZXR1cm4geDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEZvcndhcmRfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKSB8IDA7XG4gICAgICAgICAgICBpZiAoeCAhPT0gMCkgcmV0dXJuIHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgaW4gY2FtbF9jb21wYXJlX3ZhbF90YWdcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXG4gICAgICAgICAgICBcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgQ3VzdG9tX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICAgIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpO1xuICAgICAgICAgIGlmIChjb21wICE9PSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNhbWxfY3VzdG9tIDwgYi5jYW1sX2N1c3RvbSA/IC0xIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb21wKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgICB2YXIgeCA9IGNvbXAoYSwgYiwgdG90YWwpO1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsID8gLTEgOiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeCAhPT0gKHggfCAwKSkge1xuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4ICE9PSAwKSByZXR1cm4geCB8IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI1NjogLy8gY29tcGFyZSBmdW5jdGlvblxuICAgICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsIHRvdGFsKTtcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCA/IC0xIDogeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHggIT09ICh4IHwgMCkpIHtcbiAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeCAhPT0gMCkgcmV0dXJuIHggfCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICAgIGEgPSArYTtcbiAgICAgICAgICBiID0gK2I7XG4gICAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihhKSkgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihiKSkgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAgIC8vIEhlcmUgd2UgY2FuIGJlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAgIC8vIDMuIEphdmFTY3JpcHQgb2JqZWN0IHRoYW4gY2Fubm90IGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgICAgLy8gKDIpIHdpbGwgY29lcmNlIHRvIHByaW1pdGl2ZSB0eXBlcyB1c2luZyBbdmFsdWVPZl0gb3IgW3RvU3RyaW5nXVxuICAgICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgICAgLy8gLSBpZiBhIG9yIGIgYXJlIG5vdCBzdHJpbmdzLCBjb252ZXJ0IGEgYW5kIGIgdG8gbnVtYmVyXG4gICAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCA/IDEgOiBOdW1iZXIuTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjUxOiAvLyBKYXZhU2NyaXB0IFN5bWJvbCwgbm8gb3JkZXJpbmcuXG4gICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCA/IDEgOiBOdW1iZXIuTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjUyOiAvLyBvY2FtbCBzdHJpbmdzXG4gICAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgICAgdmFyIGEgPSBhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIExhenlfdGFnIG9yIEJsb2NrIHdpdGggb3RoZXIgdGFnXG4gICAgICAgICAgaWYgKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0YWdfYSkpIHtcbiAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gYS5sZW5ndGggPCBiLmxlbmd0aCA/IC0xIDogMTtcbiAgICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsKGEsIGIsIHRydWUpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gIGlmIChhID09PSBiKSByZXR1cm4gMDtcbiAgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwoeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSA9PT0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwoeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSAhPT0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCh4LCB5KSB7XG4gIHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCwgeSwgZmFsc2UpID49IDApO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuKHgsIHkpIHtcbiAgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LCB5LCBmYWxzZSkgPiAwKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsKHgsIHkpIHtcbiAgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LCB5LCBmYWxzZSkgPD0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4oeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSA8IDApO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9jdXN0b21fZXZlbnRfaW5kZXhcbi8vVmVyc2lvbjogPj0gNS4xXG52YXIgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXggPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4XG4vL1ZlcnNpb246ID49IDUuMVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyKGV2ZW50X25hbWUsIGV2ZW50X3RhZywgZXZlbnRfdHlwZSkge1xuICBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCArPSAxO1xuICByZXR1cm4gWzAsIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4LCBldmVudF9uYW1lLCBldmVudF90eXBlLCBldmVudF90YWddO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGVcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGUoZXZlbnQsIGV2ZW50X2NvbnRlbnQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3Jlc29sdmUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19zdGFydCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfc3RhcnRcbi8vVmVyc2lvbjogPj0gNS4wLCA8IDUuMlxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcGF1c2Vcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3BhdXNlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19wYXVzZVxuLy9WZXJzaW9uOiA+PSA1LjAsIDwgNS4yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3BhdXNlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19hcmVfYWN0aXZlXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19hcmVfYWN0aXZlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19yZXN1bWVcbi8vVmVyc2lvbjogPj01LjAsIDwgNS4yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3Jcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3IodGFyZ2V0KSB7XG4gIHJldHVybiB7fTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19mcmVlX2N1cnNvclxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfZnJlZV9jdXJzb3IoY3Vyc29yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3JlYWRfcG9sbFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKGN1cnNvciwgY2FsbGJhY2tzLCBudW0pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcGF0aCBjb25zdFxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfcGF0aChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxuICB2YXIgYWIgPSBBcnJheUJ1ZmZlcixcbiAgICB1OCA9IFVpbnQ4QXJyYXksXG4gICAgdTE2ID0gVWludDE2QXJyYXksXG4gICAgaTE2ID0gSW50MTZBcnJheSxcbiAgICB1MzIgPSBVaW50MzJBcnJheSxcbiAgICBpMzIgPSBJbnQzMkFycmF5O1xuICB2YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLnNsaWNlKSByZXR1cm4gdTgucHJvdG90eXBlLnNsaWNlLmNhbGwodiwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMCkgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpIGUgPSB2Lmxlbmd0aDtcbiAgICB2YXIgbiA9IG5ldyB1OChlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG4gIH07XG4gIHZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKSBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xuICB9O1xuICB2YXIgY3B3ID0gZnVuY3Rpb24gKHYsIHQsIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmNvcHlXaXRoaW4pXG4gICAgICByZXR1cm4gdTgucHJvdG90eXBlLmNvcHlXaXRoaW4uY2FsbCh2LCB0LCBzLCBlKTtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKSBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aCkgZSA9IHYubGVuZ3RoO1xuICAgIHdoaWxlIChzIDwgZSkge1xuICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAgICovXG4gIC8vIGVycm9yIGNvZGVzXG4gIHZhciBlYyA9IFtcbiAgICBcImludmFsaWQgenN0ZCBkYXRhXCIsXG4gICAgXCJ3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpXCIsXG4gICAgXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcbiAgICBcIkZTRSBhY2N1cmFjeSB0b28gaGlnaFwiLFxuICAgIFwibWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrXCIsXG4gICAgXCJ1bmV4cGVjdGVkIEVPRlwiLFxuICBdO1xuICB2YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKCFudCkgdGhyb3cgZTtcbiAgICByZXR1cm4gZTtcbiAgfTtcbiAgdmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICBvID0gMDtcbiAgICBmb3IgKDsgaSA8IG47ICsraSkgbyB8PSBkW2IrK10gPDwgKGkgPDwgMyk7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgcmV0dXJuIChkW2JdIHwgKGRbYiArIDFdIDw8IDgpIHwgKGRbYiArIDJdIDw8IDE2KSB8IChkW2IgKyAzXSA8PCAyNCkpID4+PiAwO1xuICB9O1xuICAvLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbiAgdmFyIHJ6ZmggPSBmdW5jdGlvbiAoZGF0LCB3KSB7XG4gICAgdmFyIG4zID0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSB8IChkYXRbMl0gPDwgMTYpO1xuICAgIGlmIChuMyA9PT0gMHgyZmI1MjggJiYgZGF0WzNdID09PSAyNTMpIHtcbiAgICAgIC8vIFpzdGFuZGFyZFxuICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgIC8vICAgIHNpbmdsZSBzZWdtZW50ICAgICAgIGNoZWNrc3VtICAgICAgICAgICAgIGRpY3QgZmxhZyAgICAgZnJhbWUgY29udGVudCBmbGFnXG4gICAgICB2YXIgc3MgPSAoZmxnID4+IDUpICYgMSxcbiAgICAgICAgY2MgPSAoZmxnID4+IDIpICYgMSxcbiAgICAgICAgZGYgPSBmbGcgJiAzLFxuICAgICAgICBmY2YgPSBmbGcgPj4gNjtcbiAgICAgIGlmIChmbGcgJiA4KSBlcnIoMCk7XG4gICAgICAvLyBieXRlXG4gICAgICB2YXIgYnQgPSA2IC0gc3M7XG4gICAgICAvLyBkaWN0IGJ5dGVzXG4gICAgICB2YXIgZGIgPSBkZiA9PT0gMyA/IDQgOiBkZjtcbiAgICAgIC8vIGRpY3Rpb25hcnkgaWRcbiAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgIGJ0ICs9IGRiO1xuICAgICAgLy8gZnJhbWUgc2l6ZSBieXRlc1xuICAgICAgdmFyIGZzYiA9IGZjZiA/IDEgPDwgZmNmIDogc3M7XG4gICAgICAvLyBmcmFtZSBzb3VyY2Ugc2l6ZVxuICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoZmNmID09PSAxICYmIDI1Nik7XG4gICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgdmFyIHdzID0gZnNzO1xuICAgICAgaWYgKCFzcykge1xuICAgICAgICAvLyB3aW5kb3cgZGVzY3JpcHRvclxuICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICB3cyA9IHdiICsgKHdiID4+IDMpICogKGRhdFs1XSAmIDcpO1xuICAgICAgfVxuICAgICAgaWYgKHdzID4gMjE0NTM4NjQ5NikgZXJyKDEpO1xuICAgICAgdmFyIGJ1ZiA9IG5ldyB1OCgodyA9PT0gMSA/IGZzcyB8fCB3cyA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgKGJ1ZlswXSA9IDEpLCAoYnVmWzRdID0gNCksIChidWZbOF0gPSA4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGI6IGJ0ICsgZnNiLFxuICAgICAgICB5OiAwLFxuICAgICAgICBsOiAwLFxuICAgICAgICBkOiBkaSxcbiAgICAgICAgdzogdyAmJiB3ICE9PSAxID8gdyA6IGJ1Zi5zdWJhcnJheSgxMiksXG4gICAgICAgIGU6IHdzLFxuICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICB1OiBmc3MsXG4gICAgICAgIGM6IGNjLFxuICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09PSAweDE4NGQyYTUpIHtcbiAgICAgIC8vIHNraXBwYWJsZVxuICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG4gIH07XG4gIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGZvciBub256ZXJvXG4gIHZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAxIDw8IGJpdHMgPD0gdmFsOyArK2JpdHMpO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbiAgfTtcbiAgLy8gcmVhZCBmaW5pdGUgc3RhdGUgZW50cm9weVxuICB2YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbCkgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LFxuICAgICAgc3ltID0gLTEsXG4gICAgICByZSA9IC0xLFxuICAgICAgaSA9IC0xLFxuICAgICAgaHQgPSBzejtcbiAgICAvLyBvcHRpbWl6YXRpb246IHNpbmdsZSBhbGxvY2F0aW9uIGlzIG11Y2ggZmFzdGVyXG4gICAgdmFyIGJ1ZiA9IG5ldyBhYig1MTIgKyAoc3ogPDwgMikpO1xuICAgIHZhciBmcmVxID0gbmV3IGkxNihidWYsIDAsIDI1Nik7XG4gICAgLy8gc2FtZSB2aWV3IGFzIGZyZXFcbiAgICB2YXIgZHN0YXRlID0gbmV3IHUxNihidWYsIDAsIDI1Nik7XG4gICAgdmFyIG5zdGF0ZSA9IG5ldyB1MTYoYnVmLCA1MTIsIHN6KTtcbiAgICB2YXIgYmIxID0gNTEyICsgKHN6IDw8IDEpO1xuICAgIHZhciBzeW1zID0gbmV3IHU4KGJ1ZiwgYmIxLCBzeik7XG4gICAgdmFyIG5iaXRzID0gbmV3IHU4KGJ1ZiwgYmIxICsgc3opO1xuICAgIHdoaWxlIChzeW0gPCAyNTUgJiYgcHJvYnMgPiAwKSB7XG4gICAgICB2YXIgYml0cyA9IG1zYihwcm9icyArIDEpO1xuICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgIC8vIG1hc2tcbiAgICAgIHZhciBtc2sgPSAoMSA8PCAoYml0cyArIDEpKSAtIDE7XG4gICAgICB2YXIgdmFsID1cbiAgICAgICAgKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj5cbiAgICAgICAgICAodHBvcyAmIDcpKSAmXG4gICAgICAgIG1zaztcbiAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgdmFyIG1zazFmYiA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICAgIC8vIG1heCBzbWFsbCB2YWx1ZVxuICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgIC8vIHNtYWxsIHZhbHVlXG4gICAgICB2YXIgc3ZhbCA9IHZhbCAmIG1zazFmYjtcbiAgICAgIGlmIChzdmFsIDwgbXN2KSAodHBvcyArPSBiaXRzKSwgKHZhbCA9IHN2YWwpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgIGlmICh2YWwgPiBtc2sxZmIpIHZhbCAtPSBtc3Y7XG4gICAgICB9XG4gICAgICBmcmVxWysrc3ltXSA9IC0tdmFsO1xuICAgICAgaWYgKHZhbCA9PT0gLTEpIHtcbiAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICBzeW1zWy0taHRdID0gc3ltO1xuICAgICAgfSBlbHNlIHByb2JzIC09IHZhbDtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyByZXBlYXQgYnl0ZVxuICAgICAgICAgIHZhciByYnQgPSB0cG9zID4+IDM7XG4gICAgICAgICAgcmUgPSAoKGRhdFtyYnRdIHwgKGRhdFtyYnQgKyAxXSA8PCA4KSkgPj4gKHRwb3MgJiA3KSkgJiAzO1xuICAgICAgICAgIHRwb3MgKz0gMjtcbiAgICAgICAgICBzeW0gKz0gcmU7XG4gICAgICAgIH0gd2hpbGUgKHJlID09PSAzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icykgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgdmFyIHNmID0gZnJlcVtzXTtcbiAgICAgIGlmIChzZiA8IDEpIHtcbiAgICAgICAgZHN0YXRlW3NdID0gLXNmO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgc3BsaXQgaW50byB0d28gbG9vcHMgaW4genN0ZCB0byBhdm9pZCBicmFuY2hpbmcsIGJ1dCBhcyBKUyBpcyBoaWdoZXItbGV2ZWwgdGhhdCBpcyB1bm5lY2Vzc2FyeVxuICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgc3ltc1tzeW1wb3NdID0gcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN5bXBvcyA9IChzeW1wb3MgKyBzc3RlcCkgJiBzbWFzaztcbiAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWZ0ZXIgc3ByZWFkaW5nIHN5bWJvbHMsIHNob3VsZCBiZSB6ZXJvIGFnYWluXG4gICAgaWYgKHN5bXBvcykgZXJyKDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzejsgKytpKSB7XG4gICAgICAvLyBuZXh0IHN0YXRlXG4gICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgIC8vIG51bSBiaXRzXG4gICAgICB2YXIgbmIgPSAobmJpdHNbaV0gPSBhbCAtIG1zYihucykpO1xuICAgICAgbnN0YXRlW2ldID0gKG5zIDw8IG5iKSAtIHN6O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgKHRwb3MgKyA3KSA+PiAzLFxuICAgICAge1xuICAgICAgICBiOiBhbCxcbiAgICAgICAgczogc3ltcyxcbiAgICAgICAgbjogbmJpdHMsXG4gICAgICAgIHQ6IG5zdGF0ZSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfTtcbiAgLy8gcmVhZCBodWZmbWFuXG4gIHZhciByaHUgPSBmdW5jdGlvbiAoZGF0LCBidCkge1xuICAgIC8vICBpbmRleCAgd2VpZ2h0IGNvdW50XG4gICAgdmFyIGkgPSAwLFxuICAgICAgd2MgPSAtMTtcbiAgICAvLyAgICBidWZmZXIgICAgICAgICAgICAgaGVhZGVyIGJ5dGVcbiAgICB2YXIgYnVmID0gbmV3IHU4KDI5MiksXG4gICAgICBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAvLyBlbmQgYnl0ZSwgZnNlIGRlY29kZSB0YWJsZVxuICAgICAgdmFyIF9hID0gcmZzZShkYXQsIGJ0ICsgMSwgNiksXG4gICAgICAgIGVidCA9IF9hWzBdLFxuICAgICAgICBmZHQgPSBfYVsxXTtcbiAgICAgIGJ0ICs9IGhiO1xuICAgICAgdmFyIGVwb3MgPSBlYnQgPDwgMztcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgIGlmICghbGIpIGVycigwKTtcbiAgICAgIC8vICBzdGF0ZTEgICBzdGF0ZTIgICBzdGF0ZTEgYml0cyAgIHN0YXRlMiBiaXRzXG4gICAgICB2YXIgc3QxID0gMCxcbiAgICAgICAgc3QyID0gMCxcbiAgICAgICAgYnRyMSA9IGZkdC5iLFxuICAgICAgICBidHIyID0gYnRyMTtcbiAgICAgIC8vIGZzZSBwb3NcbiAgICAgIC8vIHByZS1pbmNyZW1lbnQgdG8gYWNjb3VudCBmb3Igb3JpZ2luYWwgZGVmaWNpdCBvZiAxXG4gICAgICB2YXIgZnBvcyA9ICgrK2J0IDw8IDMpIC0gOCArIG1zYihsYik7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGZwb3MgLT0gYnRyMTtcbiAgICAgICAgaWYgKGZwb3MgPCBlcG9zKSBicmVhaztcbiAgICAgICAgdmFyIGNidCA9IGZwb3MgPj4gMztcbiAgICAgICAgc3QxICs9XG4gICAgICAgICAgKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChmcG9zICYgNykpICYgKCgxIDw8IGJ0cjEpIC0gMSk7XG4gICAgICAgIGh3Wysrd2NdID0gZmR0LnNbc3QxXTtcbiAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICBpZiAoZnBvcyA8IGVwb3MpIGJyZWFrO1xuICAgICAgICBjYnQgPSBmcG9zID4+IDM7XG4gICAgICAgIHN0MiArPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICBod1srK3djXSA9IGZkdC5zW3N0Ml07XG4gICAgICAgIGJ0cjEgPSBmZHQubltzdDFdO1xuICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICBidHIyID0gZmR0Lm5bc3QyXTtcbiAgICAgICAgc3QyID0gZmR0LnRbc3QyXTtcbiAgICAgIH1cbiAgICAgIGlmICgrK3djID4gMjU1KSBlcnIoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdjID0gaGIgLSAxMjc7XG4gICAgICBmb3IgKDsgaSA8IHdjOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBkYXRbKytidF07XG4gICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICBod1tpICsgMV0gPSBieXRlICYgMTU7XG4gICAgICB9XG4gICAgICArK2J0O1xuICAgIH1cbiAgICAvLyB3ZWlnaHQgZXhwb25lbnRpYWwgc3VtXG4gICAgdmFyIHdlcyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICAgIHZhciB3dCA9IGh3W2ldO1xuICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICBpZiAod3QgPiAxMSkgZXJyKDApO1xuICAgICAgd2VzICs9IHd0ICYmIDEgPDwgKHd0IC0gMSk7XG4gICAgfVxuICAgIC8vIG1heCBiaXRzXG4gICAgdmFyIG1iID0gbXNiKHdlcykgKyAxO1xuICAgIC8vIHRhYmxlIHNpemVcbiAgICB2YXIgdHMgPSAxIDw8IG1iO1xuICAgIC8vIHJlbWFpbmluZyBzdW1cbiAgICB2YXIgcmVtID0gdHMgLSB3ZXM7XG4gICAgLy8gbXVzdCBiZSBwb3dlciBvZiAyXG4gICAgaWYgKHJlbSAmIChyZW0gLSAxKSkgZXJyKDApO1xuICAgIGh3W3djKytdID0gbXNiKHJlbSkgKyAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICsrcmNbKGh3W2ldID0gd3QgJiYgbWIgKyAxIC0gd3QpXTtcbiAgICB9XG4gICAgLy8gaHVmIGJ1ZlxuICAgIHZhciBoYnVmID0gbmV3IHU4KHRzIDw8IDEpO1xuICAgIC8vICAgIHN5bWJvbHMgICAgICAgICAgICAgICAgICAgICAgbnVtIGJpdHNcbiAgICB2YXIgc3ltcyA9IGhidWYuc3ViYXJyYXkoMCwgdHMpLFxuICAgICAgbmIgPSBoYnVmLnN1YmFycmF5KHRzKTtcbiAgICByaVttYl0gPSAwO1xuICAgIGZvciAoaSA9IG1iOyBpID4gMDsgLS1pKSB7XG4gICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgIGZpbGwobmIsIGksIHB2LCAocmlbaSAtIDFdID0gcHYgKyByY1tpXSAqICgxIDw8IChtYiAtIGkpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT09IHRzKSBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICAgIHZhciBiaXRzID0gaHdbaV07XG4gICAgICBpZiAoYml0cykge1xuICAgICAgICB2YXIgY29kZSA9IHJpW2JpdHNdO1xuICAgICAgICBmaWxsKHN5bXMsIGksIGNvZGUsIChyaVtiaXRzXSA9IGNvZGUgKyAoMSA8PCAobWIgLSBiaXRzKSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGJ0LFxuICAgICAge1xuICAgICAgICBuOiBuYixcbiAgICAgICAgYjogbWIsXG4gICAgICAgIHM6IHN5bXMsXG4gICAgICB9LFxuICAgIF07XG4gIH07XG4gIC8vIFRhYmxlcyBnZW5lcmF0ZWQgdXNpbmcgdGhpczpcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAxYXJyb3d6L2E5Nzk0NTJkNDM1NTk5MmNiZjhmMjU3Y2JmZmM5ZWRkXG4gIC8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbiAgdmFyIGRsbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgICAgODEsIDE2LCA5OSwgMTQwLCA0OSwgMTk4LCAyNCwgOTksIDEyLCAzMywgMTk2LCAyNCwgOTksIDEwMiwgMTAyLCAxMzQsIDcwLFxuICAgICAgMTQ2LCA0LFxuICAgIF0pLFxuICAgIDAsXG4gICAgNixcbiAgKVsxXTtcbiAgLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbiAgdmFyIGRtbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgICAgMzMsIDIwLCAxOTYsIDI0LCA5OSwgMTQwLCAzMywgMTMyLCAxNiwgNjYsIDgsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDY4LFxuICAgICAgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA5LFxuICAgIF0pLFxuICAgIDAsXG4gICAgNixcbiAgKVsxXTtcbiAgLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxuICB2YXIgZG9jdCA9IC8qI19fUFVSRV9fICovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoWzMyLCAxMzIsIDE2LCA2NiwgMTAyLCA3MCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA3MywgMl0pLFxuICAgIDAsXG4gICAgNSxcbiAgKVsxXTtcbiAgLy8gYml0cyB0byBiYXNlbGluZVxuICB2YXIgYjJibCA9IGZ1bmN0aW9uIChiLCBzKSB7XG4gICAgdmFyIGxlbiA9IGIubGVuZ3RoLFxuICAgICAgYmwgPSBuZXcgaTMyKGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgYmxbaV0gPSBzO1xuICAgICAgcyArPSAxIDw8IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBibDtcbiAgfTtcbiAgLy8gbGl0ZXJhbCBsZW5ndGggYml0c1xuICB2YXIgbGxiID0gLyojX19QVVJFX18gKi8gbmV3IHU4KFxuICAgIC8qI19fUFVSRV9fICovIG5ldyBpMzIoW1xuICAgICAgMCwgMCwgMCwgMCwgMTY4NDMwMDksIDUwNTI4NzcwLCAxMzQ2NzgwMjAsIDIwMjA1MDA1NywgMjY5NDIyMDkzLFxuICAgIF0pLmJ1ZmZlcixcbiAgICAwLFxuICAgIDM2LFxuICApO1xuICAvLyBsaXRlcmFsIGxlbmd0aCBiYXNlbGluZVxuICB2YXIgbGxibCA9IC8qI19fUFVSRV9fICovIGIyYmwobGxiLCAwKTtcbiAgLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbiAgdmFyIG1sYiA9IC8qI19fUFVSRV9fICovIG5ldyB1OChcbiAgICAvKiNfX1BVUkVfXyAqLyBuZXcgaTMyKFtcbiAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsXG4gICAgICAyNTI1NzkwODQsIDE2LFxuICAgIF0pLmJ1ZmZlcixcbiAgICAwLFxuICAgIDUzLFxuICApO1xuICAvLyBtYXRjaCBsZW5ndGggYmFzZWxpbmVcbiAgdmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4gIC8vIGRlY29kZSBodWZmbWFuIHN0cmVhbVxuICB2YXIgZGh1ID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBodSkge1xuICAgIHZhciBsZW4gPSBkYXQubGVuZ3RoLFxuICAgICAgc3MgPSBvdXQubGVuZ3RoLFxuICAgICAgbGIgPSBkYXRbbGVuIC0gMV0sXG4gICAgICBtc2sgPSAoMSA8PCBodS5iKSAtIDEsXG4gICAgICBlYiA9IC1odS5iO1xuICAgIGlmICghbGIpIGVycigwKTtcbiAgICB2YXIgc3QgPSAwLFxuICAgICAgYnRyID0gaHUuYixcbiAgICAgIHBvcyA9IChsZW4gPDwgMykgLSA4ICsgbXNiKGxiKSAtIGJ0cixcbiAgICAgIGkgPSAtMTtcbiAgICB3aGlsZSAocG9zID4gZWIgJiYgaSA8IHNzKSB7XG4gICAgICB2YXIgY2J0ID0gcG9zID4+IDM7XG4gICAgICB2YXIgdmFsID1cbiAgICAgICAgKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICBzdCA9ICgoc3QgPDwgYnRyKSB8IHZhbCkgJiBtc2s7XG4gICAgICBvdXRbKytpXSA9IGh1LnNbc3RdO1xuICAgICAgcG9zIC09IGJ0ciA9IGh1Lm5bc3RdO1xuICAgIH1cbiAgICBpZiAocG9zICE9PSBlYiB8fCBpICsgMSAhPT0gc3MpIGVycigwKTtcbiAgfTtcbiAgLy8gZGVjb2RlIGh1ZmZtYW4gc3RyZWFtIDR4XG4gIC8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG4gIHZhciBkaHU0ID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBodSkge1xuICAgIHZhciBidCA9IDY7XG4gICAgdmFyIHNzID0gb3V0Lmxlbmd0aCxcbiAgICAgIHN6MSA9IChzcyArIDMpID4+IDIsXG4gICAgICBzejIgPSBzejEgPDwgMSxcbiAgICAgIHN6MyA9IHN6MSArIHN6MjtcbiAgICBkaHUoXG4gICAgICBkYXQuc3ViYXJyYXkoYnQsIChidCArPSBkYXRbMF0gfCAoZGF0WzFdIDw8IDgpKSksXG4gICAgICBvdXQuc3ViYXJyYXkoMCwgc3oxKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KFxuICAgICAgZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSkpLFxuICAgICAgb3V0LnN1YmFycmF5KHN6MSwgc3oyKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KFxuICAgICAgZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gZGF0WzRdIHwgKGRhdFs1XSA8PCA4KSkpLFxuICAgICAgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCksIG91dC5zdWJhcnJheShzejMpLCBodSk7XG4gIH07XG4gIC8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG4gIHZhciByemIgPSBmdW5jdGlvbiAoZGF0LCBzdCwgb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBidCA9IHN0LmI7XG4gICAgLy8gICAgYnl0ZSAwICAgICAgICBibG9jayB0eXBlXG4gICAgdmFyIGIwID0gZGF0W2J0XSxcbiAgICAgIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGJ0ID49IGRhdC5sZW5ndGgpIHJldHVybjtcbiAgICAgIHN0LmIgPSBidCArIDE7XG4gICAgICBpZiAob3V0KSB7XG4gICAgICAgIGZpbGwob3V0LCBkYXRbYnRdLCBzdC55LCAoc3QueSArPSBzeikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGwobmV3IHU4KHN6KSwgZGF0W2J0XSk7XG4gICAgfVxuICAgIGlmIChlYnQgPiBkYXQubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKGJ0eXBlID09PSAwKSB7XG4gICAgICBzdC5iID0gZWJ0O1xuICAgICAgaWYgKG91dCkge1xuICAgICAgICBvdXQuc2V0KGRhdC5zdWJhcnJheShidCwgZWJ0KSwgc3QueSk7XG4gICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xjKGRhdCwgYnQsIGVidCk7XG4gICAgfVxuICAgIGlmIChidHlwZSA9PT0gMikge1xuICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICB2YXIgYjMgPSBkYXRbYnRdLFxuICAgICAgICBsYnQgPSBiMyAmIDMsXG4gICAgICAgIHNmID0gKGIzID4+IDIpICYgMztcbiAgICAgIC8vIGxpdCBzcmMgc2l6ZSAgbGl0IGNtcCBzeiA0IHN0cmVhbXNcbiAgICAgIHZhciBsc3MgPSBiMyA+PiA0LFxuICAgICAgICBsY3MgPSAwLFxuICAgICAgICBzNCA9IDA7XG4gICAgICBpZiAobGJ0IDwgMikge1xuICAgICAgICBpZiAoc2YgJiAxKSBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8IChzZiAmIDIgJiYgZGF0WysrYnRdIDw8IDEyKTtcbiAgICAgICAgZWxzZSBsc3MgPSBiMyA+PiAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBzZjtcbiAgICAgICAgaWYgKHNmIDwgMilcbiAgICAgICAgICAobHNzIHw9IChkYXRbKytidF0gJiA2MykgPDwgNCksXG4gICAgICAgICAgICAobGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpKTtcbiAgICAgICAgZWxzZSBpZiAoc2YgPT09IDIpXG4gICAgICAgICAgKGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMikpLFxuICAgICAgICAgICAgKGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAobHNzIHw9IChkYXRbKytidF0gPDwgNCkgfCAoKGRhdFsrK2J0XSAmIDYzKSA8PCAxMikpLFxuICAgICAgICAgICAgKGxjcyA9IChkYXRbYnRdID4+IDYpIHwgKGRhdFsrK2J0XSA8PCAyKSB8IChkYXRbKytidF0gPDwgMTApKTtcbiAgICAgIH1cbiAgICAgICsrYnQ7XG4gICAgICAvLyBhZGQgbGl0ZXJhbHMgdG8gZW5kIC0gY2FuIG5ldmVyIG92ZXJsYXAgd2l0aCBiYWNrcmVmZXJlbmNlcyBiZWNhdXNlIHVudXNlZCBsaXRlcmFscyBhbHdheXMgYXBwZW5kZWRcbiAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgLy8gc3RhcnRpbmcgcG9pbnQgZm9yIGxpdGVyYWxzXG4gICAgICB2YXIgc3BsID0gYnVmLmxlbmd0aCAtIGxzcztcbiAgICAgIGlmIChsYnQgPT09IDApIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gbHNzKSksIHNwbCk7XG4gICAgICBlbHNlIGlmIChsYnQgPT09IDEpIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICB2YXIgaHUgPSBzdC5oO1xuICAgICAgICBpZiAobGJ0ID09PSAyKSB7XG4gICAgICAgICAgdmFyIGh1ZCA9IHJodShkYXQsIGJ0KTtcbiAgICAgICAgICAvLyBzdWJ0cmFjdCBkZXNjcmlwdGlvbiBsZW5ndGhcbiAgICAgICAgICBsY3MgKz0gYnQgLSAoYnQgPSBodWRbMF0pO1xuICAgICAgICAgIHN0LmggPSBodSA9IGh1ZFsxXTtcbiAgICAgICAgfSBlbHNlIGlmICghaHUpIGVycigwKTtcbiAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gbGNzKSksIGJ1Zi5zdWJhcnJheShzcGwpLCBodSk7XG4gICAgICB9XG4gICAgICAvLyBudW0gc2VxdWVuY2VzXG4gICAgICB2YXIgbnMgPSBkYXRbYnQrK107XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgaWYgKG5zID09PSAyNTUpIG5zID0gKGRhdFtidCsrXSB8IChkYXRbYnQrK10gPDwgOCkpICsgMHg3ZjAwO1xuICAgICAgICBlbHNlIGlmIChucyA+IDEyNykgbnMgPSAoKG5zIC0gMTI4KSA8PCA4KSB8IGRhdFtidCsrXTtcbiAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgIHZhciBzY20gPSBkYXRbYnQrK107XG4gICAgICAgIGlmIChzY20gJiAzKSBlcnIoMCk7XG4gICAgICAgIHZhciBkdHMgPSBbZG1sdCwgZG9jdCwgZGxsdF07XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICBpZiAobWQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHJsZSBidWZcbiAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgIGR0c1tpXSA9IHtcbiAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgbjogcmJ1Zi5zdWJhcnJheSgwLCAxKSxcbiAgICAgICAgICAgICAgdDogbmV3IHUxNihyYnVmLmJ1ZmZlciwgMCwgMSksXG4gICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAobWQgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGFjY3VyYWN5IGxvZyA4IGZvciBvZmZzZXRzLCA5IGZvciBvdGhlcnNcbiAgICAgICAgICAgIChfYSA9IHJmc2UoZGF0LCBidCwgOSAtIChpICYgMSkpKSwgKGJ0ID0gX2FbMF0pLCAoZHRzW2ldID0gX2FbMV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWQgPT09IDMpIHtcbiAgICAgICAgICAgIGlmICghc3QudCkgZXJyKDApO1xuICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gKHN0LnQgPSBkdHMpLFxuICAgICAgICAgIG1sdCA9IF9iWzBdLFxuICAgICAgICAgIG9jdCA9IF9iWzFdLFxuICAgICAgICAgIGxsdCA9IF9iWzJdO1xuICAgICAgICB2YXIgbGIgPSBkYXRbZWJ0IC0gMV07XG4gICAgICAgIGlmICghbGIpIGVycigwKTtcbiAgICAgICAgdmFyIHNwb3MgPSAoZWJ0IDw8IDMpIC0gOCArIG1zYihsYikgLSBsbHQuYixcbiAgICAgICAgICBjYnQgPSBzcG9zID4+IDMsXG4gICAgICAgICAgb3VidCA9IDA7XG4gICAgICAgIHZhciBsc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2N0LmIpID4+IDM7XG4gICAgICAgIHZhciBvc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWx0LmIpID4+IDM7XG4gICAgICAgIHZhciBtc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgZm9yICgrK25zOyAtLW5zOyApIHtcbiAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgIHZhciBvZmYgPVxuICAgICAgICAgICAgb2ZwICtcbiAgICAgICAgICAgICgoKGRhdFtjYnRdIHxcbiAgICAgICAgICAgICAgKGRhdFtjYnQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAgIChkYXRbY2J0ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgKGRhdFtjYnQgKyAzXSA8PCAyNCkpID4+PlxuICAgICAgICAgICAgICAoc3BvcyAmIDcpKSAmXG4gICAgICAgICAgICAgIChvZnAgLSAxKSk7XG4gICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWxiW21sY10pID4+IDM7XG4gICAgICAgICAgdmFyIG1sID1cbiAgICAgICAgICAgIG1sYmxbbWxjXSArXG4gICAgICAgICAgICAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj5cbiAgICAgICAgICAgICAgKHNwb3MgJiA3KSkgJlxuICAgICAgICAgICAgICAoKDEgPDwgbWxiW21sY10pIC0gMSkpO1xuICAgICAgICAgIGNidCA9IChzcG9zIC09IGxsYltsbGNdKSA+PiAzO1xuICAgICAgICAgIHZhciBsbCA9XG4gICAgICAgICAgICBsbGJsW2xsY10gK1xuICAgICAgICAgICAgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+XG4gICAgICAgICAgICAgIChzcG9zICYgNykpICZcbiAgICAgICAgICAgICAgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgIGxzdCA9XG4gICAgICAgICAgICBsbHQudFtsc3RdICtcbiAgICAgICAgICAgICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJlxuICAgICAgICAgICAgICAoKDEgPDwgbGJ0cikgLSAxKSk7XG4gICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWJ0cikgPj4gMztcbiAgICAgICAgICBtc3QgPVxuICAgICAgICAgICAgbWx0LnRbbXN0XSArXG4gICAgICAgICAgICAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICZcbiAgICAgICAgICAgICAgKCgxIDw8IG1idHIpIC0gMSkpO1xuICAgICAgICAgIGNidCA9IChzcG9zIC09IG9idHIpID4+IDM7XG4gICAgICAgICAgb3N0ID1cbiAgICAgICAgICAgIG9jdC50W29zdF0gK1xuICAgICAgICAgICAgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmXG4gICAgICAgICAgICAgICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgc3Qub1syXSA9IHN0Lm9bMV07XG4gICAgICAgICAgICBzdC5vWzFdID0gc3Qub1swXTtcbiAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkeCA9IG9mZiAtIChsbCAhPT0gMCk7XG4gICAgICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICAgIG9mZiA9IGlkeCA9PT0gMyA/IHN0Lm9bMF0gLSAxIDogc3Qub1tpZHhdO1xuICAgICAgICAgICAgICBpZiAoaWR4ID4gMSkgc3Qub1syXSA9IHN0Lm9bMV07XG4gICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICBzdC5vWzBdID0gb2ZmO1xuICAgICAgICAgICAgfSBlbHNlIG9mZiA9IHN0Lm9bMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGw7ICsraSkge1xuICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKG91YnQgKz0gbGwpLCAoc3BsICs9IGxsKTtcbiAgICAgICAgICB2YXIgc3RpbiA9IG91YnQgLSBvZmY7XG4gICAgICAgICAgaWYgKHN0aW4gPCAwKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gLXN0aW47XG4gICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgIGlmIChsZW4gPiBtbCkgbGVuID0gbWw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAob3VidCArPSBsZW4pLCAobWwgLT0gbGVuKSwgKHN0aW4gPSAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbDsgKytpKSB7XG4gICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3VidCAhPT0gc3BsKSB7XG4gICAgICAgICAgd2hpbGUgKHNwbCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBvdWJ0ID0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKG91dCkgc3QueSArPSBvdWJ0O1xuICAgICAgICBlbHNlIGJ1ZiA9IHNsYyhidWYsIDAsIG91YnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgIHN0LnkgKz0gbHNzO1xuICAgICAgICAgIGlmIChzcGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgYnVmW2ldID0gYnVmW3NwbCArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzcGwpIGJ1ZiA9IHNsYyhidWYsIHNwbCk7XG4gICAgICB9XG4gICAgICBzdC5iID0gZWJ0O1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZXJyKDIpO1xuICB9O1xuICAvLyBjb25jYXRcbiAgdmFyIGNjdCA9IGZ1bmN0aW9uIChidWZzLCBvbCkge1xuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoayA9IGJ1ZnNbaV07XG4gICAgICBidWYuc2V0KGNoaywgYik7XG4gICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH07XG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAgICogQHBhcmFtIGRhdCBUaGUgaW5wdXQgZGF0YVxuICAgKiBAcGFyYW0gYnVmIFRoZSBvdXRwdXQgYnVmZmVyLiBJZiB1bnNwZWNpZmllZCwgdGhlIGZ1bmN0aW9uIHdpbGwgYWxsb2NhdGVcbiAgICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICAgKiAgICAgICAgICAgIGRhdGEgaGFzIG11bHRpcGxlIGZyYW1lcyBhbmQgeW91IGtub3cgdGhlIG91dHB1dCBzaXplLCBzcGVjaWZ5aW5nXG4gICAqICAgICAgICAgICAgaXQgd2lsbCB5aWVsZCBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0LCBidWYpIHtcbiAgICB2YXIgYnQgPSAwLFxuICAgICAgYnVmcyA9IFtdLFxuICAgICAgbmIgPSArIWJ1ZixcbiAgICAgIG9sID0gMDtcbiAgICB3aGlsZSAoZGF0Lmxlbmd0aCkge1xuICAgICAgdmFyIHN0ID0gcnpmaChkYXQsIG5iIHx8IGJ1Zik7XG4gICAgICBpZiAodHlwZW9mIHN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChuYikge1xuICAgICAgICAgIGJ1ZiA9IG51bGw7XG4gICAgICAgICAgaWYgKHN0LncubGVuZ3RoID09PSBzdC51KSB7XG4gICAgICAgICAgICBidWZzLnB1c2goKGJ1ZiA9IHN0LncpKTtcbiAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZnMucHVzaChidWYpO1xuICAgICAgICAgIHN0LmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghc3QubCkge1xuICAgICAgICAgIHZhciBibGsgPSByemIoZGF0LCBzdCwgYnVmKTtcbiAgICAgICAgICBpZiAoIWJsaykgZXJyKDUpO1xuICAgICAgICAgIGlmIChidWYpIHN0LmUgPSBzdC55O1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmcy5wdXNoKGJsayk7XG4gICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgY3B3KHN0LncsIDAsIGJsay5sZW5ndGgpO1xuICAgICAgICAgICAgc3Qudy5zZXQoYmxrLCBzdC53Lmxlbmd0aCAtIGJsay5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidCA9IHN0LmIgKyBzdC5jICogNDtcbiAgICAgIH0gZWxzZSBidCA9IHN0O1xuICAgICAgZGF0ID0gZGF0LnN1YmFycmF5KGJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNjdChidWZzLCBvbCk7XG4gIH07XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGw7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjEuMFxuLy9WZXJzaW9uOiA8IDUuMS4xXG4vL1JlcXVpcmVzOiB6c3RkX2RlY29tcHJlc3NcbnZhciBjYW1sX2RlY29tcHJlc3NfaW5wdXQgPSB6c3RkX2RlY29tcHJlc3M7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjEuMVxuLy9WZXJzaW9uOiA8IDUuMi4wXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0gbnVsbDtcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMlxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3pzdGRfaW5pdGlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1JlcXVpcmVzOiB6c3RkX2RlY29tcHJlc3Ncbi8vVmVyc2lvbjogPj0gNS4xLjFcbmZ1bmN0aW9uIGNhbWxfenN0ZF9pbml0aWFsaXplKHVuaXQpIHtcbiAgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gMztcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMjtcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX25vbmVcbnZhciBjYW1sX2VwaGVfbm9uZSA9IHsgY2FtbF9lcGhlX25vbmU6IDAgfTtcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9zZXRfZGF0YV9vcHRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgdmFyIG9sZCA9IGNhbWxfZXBoZV9nZXRfZGF0YSh4KTtcbiAgaWYgKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB2IGluc3RhbmNlb2YgT2JqZWN0KSB2ID0gbmV3IGdsb2JhbFRoaXMuV2Vha1JlZih2KTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgY2FtbF9lcGhlX3NldF9kYXRhX29wdCh4LCBvbGQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9kYXRhX29wdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX25vbmVcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICB2YXIgb2xkID0gY2FtbF9lcGhlX2dldF9kYXRhKHgpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgY2FtbF9lcGhlX3NldF9kYXRhX29wdCh4LCBvbGQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxuZnVuY3Rpb24gY2FtbF9lcGhlX2NyZWF0ZShuKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfY3JlYXRlKG4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX25vbmVcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUobikge1xuICB2YXIgYWxlbiA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgdmFyIHggPSBuZXcgQXJyYXkoYWxlbik7XG4gIHhbMF0gPSAyNTE7XG4gIHhbMV0gPSBcImNhbWxfZXBoZV9saXN0X2hlYWRcIjtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhbGVuOyBpKyspIHtcbiAgICB4W2ldID0gY2FtbF9lcGhlX25vbmU7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9zZXRfa2V5LCBjYW1sX2VwaGVfdW5zZXRfa2V5XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYgKHYgPT09IDApIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSk7XG4gIGVsc2UgY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdlsxXSk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0XG5cbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5KHgsIGkpIHtcbiAgdmFyIHdlYWsgPSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG4gIGlmICh3ZWFrID09PSBjYW1sX2VwaGVfbm9uZSkgcmV0dXJuIDA7XG4gIGlmIChnbG9iYWxUaGlzLldlYWtSZWYgJiYgd2VhayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gICAgaWYgKHdlYWsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gY2FtbF9lcGhlX25vbmU7XG4gICAgICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWzAsIHdlYWtdO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9rZXksY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuLy9BbGlhczogY2FtbF93ZWFrX2dldF9jb3B5XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5KHgsIGkpIHtcbiAgdmFyIHkgPSBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmIChBcnJheS5pc0FycmF5KHopKSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG4vL0FsaWFzOiBjYW1sX3dlYWtfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19rZXkoeCwgaSkge1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbiAgaWYgKHdlYWsgPT09IGNhbWxfZXBoZV9ub25lKSByZXR1cm4gMDtcbiAgaWYgKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB3ZWFrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgd2VhayA9IHdlYWsuZGVyZWYoKTtcbiAgICBpZiAod2VhayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGNhbWxfZXBoZV9ub25lO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9kYXRhX29wdFxuLy9BbGlhczogY2FtbF93ZWFrX2JsaXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2tleShhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIHZhciBvbGQgPSBjYW1sX2VwaGVfZ2V0X2RhdGEoYTEpO1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KFxuICAgIGExLFxuICAgIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgIGEyLFxuICAgIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgIGxlbixcbiAgKTtcbiAgY2FtbF9lcGhlX3NldF9kYXRhX29wdChhMiwgb2xkKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9nZXRfZGF0YSwgY2FtbF9lcGhlX3NldF9kYXRhX29wdFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCkge1xuICB2YXIgb2xkID0gY2FtbF9lcGhlX2dldF9kYXRhKHNyYyk7XG4gIGNhbWxfZXBoZV9zZXRfZGF0YV9vcHQoZHN0LCBvbGQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfbm9uZVxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpIHtcbiAgdmFyIGRhdGEgPSB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIGlmIChkYXRhID09PSBjYW1sX2VwaGVfbm9uZSkgcmV0dXJuIDA7XG4gIGZvciAodmFyIGkgPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgayA9IHhbaV07XG4gICAgaWYgKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiBrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICB2YXIgZCA9IGsuZGVyZWYoKTtcbiAgICAgIGlmIChkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeFtpXSA9IGNhbWxfZXBoZV9ub25lO1xuICAgICAgICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5XZWFrTWFwKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmdldChrKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGNhbWxfZXBoZV9ub25lO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbMCwgZGF0YV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCkge1xuICB2YXIgciA9IGNhbWxfZXBoZV9nZXRfZGF0YSh4KTtcbiAgaWYgKHIgPT09IDApIHJldHVybiAwO1xuICB2YXIgeiA9IHJbMV07XG4gIGlmIChBcnJheS5pc0FycmF5KHopKSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSkge1xuICBmb3IgKHZhciBpID0geC5sZW5ndGggLSAxOyBpID49IGNhbWxfZXBoZV9rZXlfb2Zmc2V0OyBpLS0pIHtcbiAgICB2YXIgayA9IHhbaV07XG4gICAgaWYgKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiBrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICB2YXIgZCA9IGsuZGVyZWYoKTtcbiAgICAgIGlmIChkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeFtpXSA9IGNhbWxfZXBoZV9ub25lO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChnbG9iYWxUaGlzLldlYWtNYXApIHtcbiAgICAgICAgZGF0YSA9IG5ldyBnbG9iYWxUaGlzLldlYWtNYXAoKS5zZXQoaywgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFfb3B0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGFfb3B0KHgsIGRhdGFfb3B0KSB7XG4gIGlmIChkYXRhX29wdCA9PT0gMCkgY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCk7XG4gIGVsc2UgY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGFfb3B0WzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4KSB7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGNhbWxfZXBoZV9ub25lO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZXBoZV9nZXRfZGF0YSh4KTtcbiAgaWYgKGRhdGEgPT09IDApIHJldHVybiAwO1xuICBlbHNlIHJldHVybiAxO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcih1bml0KSB7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PT0gXCJmdW5jdGlvblwiKSBnbG9iYWxUaGlzLmdjKHRydWUpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IodW5pdCkge1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT09IFwiZnVuY3Rpb25cIikgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKHVuaXQpIHtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09PSBcImZ1bmN0aW9uXCIpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkge1xuICByZXR1cm4gWzI1NCwgMCwgMCwgMF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbi8vVmVyc2lvbjogPj0gNC4xMlxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCkge1xuICByZXR1cm4gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbi8vVmVyc2lvbjogPCA0LjEyXG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKSB7XG4gIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbi8vUmVxdWlyZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gY2FtbF9nY19xdWlja19zdGF0KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCkge1xuICByZXR1cm4gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG4vL1ZlcnNpb246ID0gNC4xMFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlcigpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcbnZhciBhbGxfZmluYWxpemVycyA9IG5ldyBnbG9iYWxUaGlzLlNldCgpO1xuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZShjYiwgYSkge1xuICBpZiAoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIHggPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoeCkge1xuICAgICAgYWxsX2ZpbmFsaXplcnMuZGVsZXRlKHgpO1xuICAgICAgY2IoMCk7XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gICAgeC5yZWdpc3RlcihhLCB4KTtcbiAgICBhbGxfZmluYWxpemVycy5hZGQoeCk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSwgc3RhY2tfc2l6ZSwgdHJhY2tlcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9kaXNjYXJkXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX2Rpc2NhcmQodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19yZXN1bWVcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcmVzdW1lKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2Vcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvcl9zbGljZVxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcl9zbGljZSh3b3JrKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21pbm9yX2ZyZWVcbmZ1bmN0aW9uIGNhbWxfZ2V0X21pbm9yX2ZyZWUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfYnVja2V0XG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9idWNrZXQobikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0KGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPSB7XG4gICAganVzdGlmeTogXCIrXCIsXG4gICAgc2lnbnN0eWxlOiBcIi1cIixcbiAgICBmaWxsZXI6IFwiIFwiLFxuICAgIGFsdGVybmF0ZTogZmFsc2UsXG4gICAgYmFzZTogMCxcbiAgICBzaWduZWRjb252OiBmYWxzZSxcbiAgICB3aWR0aDogMCxcbiAgICB1cHBlcmNhc2U6IGZhbHNlLFxuICAgIHNpZ246IDEsXG4gICAgcHJlYzogLTEsXG4gICAgY29udjogXCJmXCIsXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlIFwiLVwiOlxuICAgICAgICBmLmp1c3RpZnkgPSBcIi1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgZi5zaWduc3R5bGUgPSBjO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGYuZmlsbGVyID0gXCIwXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIiNcIjpcbiAgICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIxXCI6XG4gICAgICBjYXNlIFwiMlwiOlxuICAgICAgY2FzZSBcIjNcIjpcbiAgICAgIGNhc2UgXCI0XCI6XG4gICAgICBjYXNlIFwiNVwiOlxuICAgICAgY2FzZSBcIjZcIjpcbiAgICAgIGNhc2UgXCI3XCI6XG4gICAgICBjYXNlIFwiOFwiOlxuICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgZi53aWR0aCA9IDA7XG4gICAgICAgIHdoaWxlICgoKGMgPSBmbXQuY2hhckNvZGVBdChpKSAtIDQ4KSwgYyA+PSAwICYmIGMgPD0gOSkpIHtcbiAgICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgIGYucHJlYyA9IDA7XG4gICAgICAgIGkrKztcbiAgICAgICAgd2hpbGUgKCgoYyA9IGZtdC5jaGFyQ29kZUF0KGkpIC0gNDgpLCBjID49IDAgJiYgYyA8PSA5KSkge1xuICAgICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlO1xuICAgICAgICBmLmJhc2UgPSAxMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgICBmLmJhc2UgPSAxMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwieFwiOlxuICAgICAgICBmLmJhc2UgPSAxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiWFwiOlxuICAgICAgICBmLmJhc2UgPSAxNjtcbiAgICAgICAgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIGYuYmFzZSA9IDg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVcIjpcbiAgICAgIGNhc2UgXCJmXCI6XG4gICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlO1xuICAgICAgICBmLmNvbnYgPSBjO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiRlwiOlxuICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTtcbiAgICAgICAgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT09IFwiLVwiKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PT0gXCIrXCIgJiYgZi5maWxsZXIgPT09IFwiIFwiKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSBcIiBcIjtcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gXCItXCI7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT09IFwiLVwiKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PT0gOCkgYnVmZmVyICs9IFwiMFwiO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09PSAxNikgYnVmZmVyICs9IGYudXBwZXJjYXNlID8gXCIwWFwiIDogXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09PSBcIitcIiAmJiBmLmZpbGxlciA9PT0gXCIwXCIpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9IFwiMFwiO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09PSBcIi1cIikgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9IFwiIFwiO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZiAoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbXG4gICAgMCxcbiAgICBjYW1sX25hbWVkX3ZhbHVlKFwiR3JhcGhpY3MuR3JhcGhpY19mYWlsdXJlXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIiksXG4gIF0pO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZSA9IGN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKSB7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIgKyBuYW1lICsgXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYgKCEoaW5mbyA9PT0gXCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmICghdGFyZ2V0KSB0YXJnZXQgPSBcIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZiAoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpO1xuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3ID8gTnVtYmVyLnBhcnNlSW50KHcpIDogMjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIgKyB3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGggPyBOdW1iZXIucGFyc2VJbnQoaCkgOiAyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIgKyBoKTtcblxuICB2YXIgd2luID0gZ2xvYmFsVGhpcy5vcGVuKFwiYWJvdXQ6YmxhbmtcIiwgdGFyZ2V0LCBzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmICghd2luKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIik7XG4gIH1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcywgdywgaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKSB7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCwgY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsIGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLCB3LCBoKSB7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgbGluZV93aWR0aDogMSxcbiAgICBmb250OiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplOiAyNixcbiAgICBjb2xvcjogMHgwMDAwMDAsXG4gICAgdGl0bGU6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIiksXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYgKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsIGgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gXCJcIiArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSBcIjBcIiArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhciByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gICAgZyA9IChjb2xvciA+PiA4KSAmIDB4ZmYsXG4gICAgYiA9IChjb2xvciA+PiAwKSAmIDB4ZmY7XG4gIHMuY29sb3IgPSBjb2xvcjtcbiAgdmFyIGNfc3RyID0gXCIjXCIgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgsIHkpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsIDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIChkWzFdID1cbiAgICAoY29sb3IgPj4gOCkgJlxuICAgIDB4ZmYpLCAvL2dcbiAgICAoZFsyXSA9IChjb2xvciA+PiAwKSAmIDB4ZmYpOyAvL2JcbiAgZFszXSA9IDB4ZmY7IC8vYVxuICBzLnggPSB4O1xuICBzLnkgPSB5O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLCB4LCBzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCwgeSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbSA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoeCwgcy5oZWlnaHQgLSB5LCAxLCAxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54ID0geDtcbiAgcy55ID0geTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCwgeSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngsIHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LCBzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueCA9IHg7XG4gIHMueSA9IHk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LCB5LCB3LCBoKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCwgcy5oZWlnaHQgLSB5LCB3LCAtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsIGN4LCBjeSwgcnksIHJ4LCBhMSwgYTIpIHtcbiAgd2hpbGUgKGExID4gYTIpIGEyICs9IDM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLFxuICAgIHhQb3MsXG4gICAgeVBvcyxcbiAgICB4UG9zX3ByZXYsXG4gICAgeVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCArIHJ5KSAvIDIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9ICgoYTIgLSBhMSkgKiBNYXRoLlBJKSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IG51bTsgaisrKSB7XG4gICAgeFBvcyA9XG4gICAgICBjeCAtXG4gICAgICByeCAqIE1hdGguc2luKGkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgK1xuICAgICAgcnkgKiBNYXRoLmNvcyhpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9XG4gICAgICBjeSArXG4gICAgICByeSAqIE1hdGguY29zKGkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgK1xuICAgICAgcnggKiBNYXRoLnNpbihpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGogPT09IDApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYgIT09IHhQb3MgfHwgeVBvc19wcmV2ICE9PSB5UG9zKSB7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXYgPSB4UG9zO1xuICAgIHlQb3NfcHJldiA9IHlQb3M7XG4gICAgaSAtPSBkZWx0YTsgLy9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LCB5LCByeCwgcnksIGExLCBhMikge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCwgeCwgcy5oZWlnaHQgLSB5LCByeCwgcnksIGExLCBhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gdztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCwgeSwgdywgaCkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LCBzLmhlaWdodCAtIHksIHcsIC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLCBzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLCBzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSwgcy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgsIHksIHJ4LCByeSwgYTEsIGEyKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LCB4LCBzLmhlaWdodCAtIHksIHJ4LCByeSwgYTEsIGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cikge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIsIHMueCwgcy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpIHtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cikge1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsIHcsIHMudGV4dF9zaXplXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycikge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDE7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodywgaCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB3OyBqKyspIHtcbiAgICAgIHZhciBjID0gYXJyW2kgKyAxXVtqICsgMV07XG4gICAgICB2YXIgbyA9IGkgKiAodyAqIDQpICsgaiAqIDQ7XG4gICAgICBpZiAoYyA9PT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAoYyA+PiAxNikgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IChjID4+IDgpICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAoYyA+PiAwKSAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKSB7XG4gIHZhciBkYXRhID0gWzBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltLmhlaWdodDsgaSsrKSB7XG4gICAgZGF0YVtpICsgMV0gPSBbMF07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbS53aWR0aDsgaisrKSB7XG4gICAgICB2YXIgbyA9IGkgKiAoaW0ud2lkdGggKiA0KSArIGogKiA0LFxuICAgICAgICByID0gaW0uZGF0YVtvICsgMF0sXG4gICAgICAgIGcgPSBpbS5kYXRhW28gKyAxXSxcbiAgICAgICAgYiA9IGltLmRhdGFbbyArIDJdO1xuICAgICAgZGF0YVtpICsgMV1baiArIDFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSwgeCwgeSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmICghaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwgMCwgMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGdsb2JhbFRoaXMuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCBzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICAgICAgaW0uaW1hZ2UgPSBpbWFnZTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSwgeCwgcy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3JlYXRlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jcmVhdGVfaW1hZ2UoeCwgeSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgsIHkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9ibGl0X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9ibGl0X2ltYWdlKGltLCB4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltMiA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgeCxcbiAgICBzLmhlaWdodCAtIGltLmhlaWdodCAtIHksXG4gICAgaW0ud2lkdGgsXG4gICAgaW0uaGVpZ2h0LFxuICApO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSArIDFdID0gaW0yLmRhdGFbaSArIDFdO1xuICAgIGltLmRhdGFbaSArIDJdID0gaW0yLmRhdGFbaSArIDJdO1xuICAgIGltLmRhdGFbaSArIDNdID0gaW0yLmRhdGFbaSArIDNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCkge1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2FpdF9ldmVudFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93YWl0X2V2ZW50KF9ldmwpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9zeW5jaHJvbml6ZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3JlbWVtYmVyX21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVtZW1iZXJfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSwgYiwgYywgZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6IC8mL2csIGx0OiAvPC9nLCBxdW90OiAvXCIvZywgYWxsOiAvWyY8XCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZShzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvO1xuICBpZiAocy5tYXRjaChlbnRpdHkpKSB7XG4gICAgdmFyIHN0cixcbiAgICAgIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICB0ZW1wLmlubmVySFRNTCA9IHM7XG4gICAgc3RyID0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wID0gbnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUoKSB7XG4gIHZhciBjID0gY29uc29sZTtcbiAgdmFyIG0gPSBbXG4gICAgXCJsb2dcIixcbiAgICBcImRlYnVnXCIsXG4gICAgXCJpbmZvXCIsXG4gICAgXCJ3YXJuXCIsXG4gICAgXCJlcnJvclwiLFxuICAgIFwiYXNzZXJ0XCIsXG4gICAgXCJkaXJcIixcbiAgICBcImRpcnhtbFwiLFxuICAgIFwidHJhY2VcIixcbiAgICBcImdyb3VwXCIsXG4gICAgXCJncm91cENvbGxhcHNlZFwiLFxuICAgIFwiZ3JvdXBFbmRcIixcbiAgICBcInRpbWVcIixcbiAgICBcInRpbWVFbmRcIixcbiAgXTtcbiAgZnVuY3Rpb24gZigpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dID0gZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZiAoZXhuLmpzX2Vycm9yKSB7XG4gICAgcmV0dXJuIGV4bi5qc19lcnJvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNikgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYyxcbiAgICBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBsZXhidWZbbGV4X2J1ZmZlcl07XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IgKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlIC0gMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKSB7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT09IDApIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZSBjID0gMjU2O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChidWZmZXIsIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09PSBzdGF0ZSkgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PT0gLTEpIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZSByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaSsrO1xuICAgIGlmIChkc3QgPT09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGkrKztcbiAgICBpZiAoc3JjID09PSAweGZmKSBtZW1bZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlIG1lbVtkc3QgKyAxXSA9IG1lbVtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpKys7XG4gICAgaWYgKGRzdCA9PT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaSsrO1xuICAgIGlmIChzcmMgPT09IDB4ZmYpIG1lbVtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2UgbWVtW2RzdCArIDFdID0gbWVtW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbClcbiAgICB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLFxuICAgIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGxleGJ1ZltsZXhfYnVmZmVyXTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvciAoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZSAtIDE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSkge1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09PSAwKSByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2UgYyA9IDI1NjtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQoYnVmZmVyLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZTtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT09IHN0YXRlKSBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2Ugc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09PSAtMSkgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSxcbiAgICAgICAgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbShcbiAgICAgICAgICB0YmwubGV4X2NvZGUsXG4gICAgICAgICAgcGNfb2ZmLFxuICAgICAgICAgIGxleGJ1ZltsZXhfbWVtXSxcbiAgICAgICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSxcbiAgICAgICAgKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfbHhtX01cbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9WZXJzaW9uOiA+PSA1XG52YXIgY2FtbF9seG1fTSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKFxuICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIjB4ZDEzNDI1NDNkZTgyZWY5NVwiKSxcbik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbHhtX2RhYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9WZXJzaW9uOiA+PSA1XG52YXIgY2FtbF9seG1fZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKFxuICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSxcbik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbHhtX25leHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF94b3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMVxuLy9SZXF1aXJlczogY2FtbF9seG1fTVxuLy9SZXF1aXJlczogY2FtbF9seG1fZGFiYVxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfc2hpZnRfbGVmdCh4LCBrKTtcbiAgfVxuICBmdW5jdGlvbiBzaGlmdF9yKHgsIGspIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCBrKTtcbiAgfVxuICBmdW5jdGlvbiBvcihhLCBiKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfb3IoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF94b3IoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9tdWwoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCwgayksIHNoaWZ0X3IoeCwgNjQgLSBrKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGEsIGkpIHtcbiAgICByZXR1cm4gY2FtbF9iYV9nZXRfMShhLCBpKTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoYSwgaSwgeCkge1xuICAgIHJldHVybiBjYW1sX2JhX3NldF8xKGEsIGksIHgpO1xuICB9XG4gIHZhciBNID0gY2FtbF9seG1fTTtcbiAgdmFyIGRhYmEgPSBjYW1sX2x4bV9kYWJhO1xuICB2YXIgeiwgcTAsIHExO1xuICB2YXIgc3QgPSB2O1xuICB2YXIgYSA9IGdldChzdCwgMCk7XG4gIHZhciBzID0gZ2V0KHN0LCAxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LCAyKTtcbiAgdmFyIHgxID0gZ2V0KHN0LCAzKTtcbiAgLyogQ29tYmluaW5nIG9wZXJhdGlvbiAqL1xuICB6ID0gYWRkKHMsIHgwKTtcbiAgLyogTWl4aW5nIGZ1bmN0aW9uICovXG4gIHogPSBtdWwoeG9yKHosIHNoaWZ0X3IoeiwgMzIpKSwgZGFiYSk7XG4gIHogPSBtdWwoeG9yKHosIHNoaWZ0X3IoeiwgMzIpKSwgZGFiYSk7XG4gIHogPSB4b3Ioeiwgc2hpZnRfcih6LCAzMikpO1xuICAvKiBMQ0cgdXBkYXRlICovXG4gIHNldChzdCwgMSwgYWRkKG11bChzLCBNKSwgYSkpO1xuICAvKiBYQkcgdXBkYXRlICovXG4gIHZhciBxMCA9IHgwO1xuICB2YXIgcTEgPSB4MTtcbiAgcTEgPSB4b3IocTEsIHEwKTtcbiAgcTAgPSByb3RsKHEwLCAyNCk7XG4gIHEwID0geG9yKHhvcihxMCwgcTEpLCBzaGlmdF9sKHExLCAxNikpO1xuICBxMSA9IHJvdGwocTEsIDM3KTtcbiAgc2V0KHN0LCAyLCBxMCk7XG4gIHNldChzdCwgMywgcTEpO1xuICAvKiBSZXR1cm4gcmVzdWx0ICovXG4gIHJldHVybiB6O1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9vanNfd3JhcF9mdW5fYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfb2pzX3dyYXBfZnVuX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpKGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vanNfaXRlcmF0ZV9wcm9wZXJ0aWVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzX3RvX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vanNfaXRlcmF0ZV9wcm9wZXJ0aWVzKG8sIGYpIHtcbiAgdmFyIG5hbWU7XG4gIGZvcihuYW1lIGluIG8pIHtcbiAgICBpZihvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBmKG5hbWUpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZXJfdHJhY2VcbnZhciBjYW1sX3BhcnNlcl90cmFjZSA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheSwgY2FtbF9wYXJzZXJfdHJhY2UsY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0LCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Zkc1xuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKSB7XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCArIFwiXFxuXCIpO1xuICAgIGNhbWxfbWxfb3V0cHV0KGNhbWxfc3lzX2Zkc1syXS5jaGFuaWQsIHMsIDAsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbl9uYW1lKG5hbWVzLCBudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZXMpO1xuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4MDBcIikgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdChcIlxceDAwXCIpW251bWJlcl07XG4gIH1cblxuICBmdW5jdGlvbiBwcmludF90b2tlbihzdGF0ZSwgdG9rKSB7XG4gICAgdmFyIHRva2VuLCBraW5kO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRvaykpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09PSBcIm51bWJlclwiKSBraW5kID0gXCJcIiArIHRva1sxXTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tbMV0gPT09IFwic3RyaW5nXCIpIGtpbmQgPSB0b2tbMV07XG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKSBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pO1xuICAgICAgZWxzZSBraW5kID0gXCJfXCI7XG4gICAgICBsb2coXCJTdGF0ZSBcIiArIHN0YXRlICsgXCI6IHJlYWQgdG9rZW4gXCIgKyB0b2tlbiArIFwiKFwiICsga2luZCArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSB0b2tlbl9uYW1lKHRhYmxlc1t0YmxfbmFtZXNfY29uc3RdLCB0b2spO1xuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGFibGVzLmRnb3RvKSB7XG4gICAgdGFibGVzLmRlZnJlZCA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9saHNdKTtcbiAgICB0YWJsZXMuZ2luZGV4ID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gPSBjYW1sX2xleF9hcnJheSh0YWJsZXNbdGJsX2Rnb3RvXSk7XG4gIH1cblxuICB2YXIgcmVzID0gMCxcbiAgICBuLFxuICAgIG4xLFxuICAgIG4yLFxuICAgIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIHRoZV9sb29wOiBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgMDogLy9TVEFSVDpcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSA2OiAvL2xvb3A6XG4gICAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgICBjbWQgPSByZWR1Y2U7XG4gICAgICAgICAgY29udGludWUgdGhlX2xvb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7XG4gICAgICAgICAgY21kID0gdGVzdHNoaWZ0O1xuICAgICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICAgIGJyZWFrIHRoZV9sb29wO1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgICAgY2FzZSAxOiAvL1RPS0VOX1JFQUQ6XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIHByaW50X3Rva2VuKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSA3OiAvL3Rlc3RzaGlmdDpcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbjEgIT09IDAgJiZcbiAgICAgICAgICBuMiA+PSAwICYmXG4gICAgICAgICAgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PT0gZW52W2Vudl9jdXJyX2NoYXJdXG4gICAgICAgICkge1xuICAgICAgICAgIGNtZCA9IHNoaWZ0O1xuICAgICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuMSAhPT0gMCAmJlxuICAgICAgICAgIG4yID49IDAgJiZcbiAgICAgICAgICBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09PSBlbnZbZW52X2N1cnJfY2hhcl1cbiAgICAgICAgKSB7XG4gICAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgICAgY21kID0gcmVkdWNlO1xuICAgICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICAgIGJyZWFrIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgICBjYXNlIDU6IC8vRVJST1JfREVURUNURUQ6XG4gICAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG4xICE9PSAwICYmXG4gICAgICAgICAgICAgIG4yID49IDAgJiZcbiAgICAgICAgICAgICAgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT09IEVSUkNPREVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIGxvZyhcIlJlY292ZXJpbmcgaW4gc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyO1xuICAgICAgICAgICAgICBjb250aW51ZSB0aGVfbG9vcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgbG9nKFwiRGlzY2FyZGluZyBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIGxvZyhcIk5vIG1vcmUgc3RhdGVzIHRvIGRpc2NhcmRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgICBzcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SOyAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIGxvZyhcIkRpc2NhcmRpbmcgbGFzdCB0b2tlbiByZWFkXCIpO1xuICAgICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICAgIGNtZCA9IGxvb3A7XG4gICAgICAgICAgY29udGludWUgdGhlX2xvb3A7XG4gICAgICAgIH1cbiAgICAgIC8vIFVucmVhY2hhYmxlXG4gICAgICBjYXNlIDg6IC8vc2hpZnQ6XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgOTogLy9zaGlmdF9yZWNvdmVyOlxuICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJTdGF0ZSBcIiArIHN0YXRlICsgXCI6IHNoaWZ0IHRvIHN0YXRlIFwiICsgdGFibGVzLnRhYmxlW24yXSk7XG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgc3ArKztcbiAgICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgICAgYnJlYWsgdGhlX2xvb3A7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICAgIGNhc2UgMjogLy9TVEFDS1NfR1JPV05fMTpcbiAgICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgICAgY21kID0gbG9vcDtcbiAgICAgICAgY29udGludWUgdGhlX2xvb3A7XG5cbiAgICAgIGNhc2UgMTA6IC8vcmVkdWNlOlxuICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG4xICE9PSAwICYmXG4gICAgICAgICAgbjIgPj0gMCAmJlxuICAgICAgICAgIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT09IHN0YXRlMVxuICAgICAgICApXG4gICAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBlbHNlIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgICBicmVhayB0aGVfbG9vcDtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgICAgY2FzZSAzOiAvL1NUQUNLU19HUk9XTl8yOlxuICAgICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgICAgYnJlYWsgdGhlX2xvb3A7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgICBjYXNlIDQ6IC8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgY21kID0gbG9vcDtcbiAgICAgICAgY29udGludWUgdGhlX2xvb3A7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLy8gV2UgcmVwcmVzZW50IGEgW1oudF0gYXMgYSBqYXZhc2NyaXB0IDMyYml0IGludGVnZXJzIG9yIGFzIGEgQmlnSW50LlxuLy8gTGlrZSBpbiBaQXJpdGgsIHdlIGd1YXJhbnRlZSB0aGF0OlxuLy8gIC0gSWYgdGhlIG51bWJlciBmaXRzIGluIGEgMzJiaXQgaW50ZWdlciwgaXQgaXMgc3RvcmVkIGluIGEgMzJiaXQgaW50ZWdlcixcbi8vICAgIG5vdCBhIEJpZ0ludC5cbi8vICAtIENvbnZlcnNlbHksIGlmIHRoZSBudW1iZXIgZG9lcyBub3QgZml0IGluIGEgMzJiaXQgaW50ZWdlciwgaXQgaXMgc3RvcmVkIGluXG4vLyAgICBhIEJpZ0ludC4gV2UgYWxtb3N0IGNvdWxkIGdldCBhd2F5IHdpdGggdXNpbmcgcHJpbWl0aXZlIGludGVnZXJzIHVwIHRvIDUzXG4vLyAgICBiaXRzLCBidXQgdGhpcyB3b3VsZCByZXF1aXJlIGdpdmluZyB1cCBtYXJzaGFsaW5nIChiZWNhdXNlIHRoZSBqc19vZl9vY2FtbFxuLy8gICAgcnVudGltZSBhc3N1bWVzIHRoYXQgbnVtYmVycyBhcmUgZWl0aGVyIDMyYml0IGludGVnZXJzIG9yIGZsb2F0cywgYW5kXG4vLyAgICByZWZ1c2VzIHRvIG1hcnNoYWwgZmxvYXRzIHRoYXQgYXJlIG5vdCBleGFjdGx5IDMyYml0IGludGVnZXJzKSwgYW5kIHNvIHdlXG4vLyAgICBkb24ndC4gSSBhbSBub3Qgc3VyZSB0aGlzIHdvdWxkIGJyaW5nIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdHMgZHVlIHRvIHRoZVxuLy8gICAgYWRkaXRpb25hbCBjaGVja3MgcmVxdWlyZWQgYW55d2F5cyAodGhlIGNoZWNrcyBmb3IgMzJiaXQgaW50ZWdlcnMgaGFwcGVuXG4vLyAgICBpbiBaQXJpdGgncyBPQ2FtbCBjb2RlLCBzbyB3ZSBjYW4ndCByZXBsYWNlIHRoZW0gd2l0aCBjaGVja3MgZm9yIDUzIGJpdFxuLy8gICAgaW50ZWdlcnMpLlxuLy9cbi8vIE5vdGUgdGhhdCBzb21lIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBjYWxsIG90aGVyIGZ1bmN0aW9ucyBhcyB1dGlsaXR5IGluXG4vLyBhIHdheSB0aGF0IGRvZXNuJ3QgcmVzcGVjdCB0aGVzZSBpbnZhcmlhbnRzLCBhbmQgc28gc29tZSBmdW5jdGlvbnMgY2FuIHNlZVxuLy8gbm9uLW5vcm1hbGl6ZWQgbnVtYmVycyBhcyBpbnB1dC5cblxuLy9Qcm92aWRlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbm9ybWFsaXplKHgpIHtcbiAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHggPT09ICh4IHwgMCkpIHJldHVybiB4O1xuXG4gICAgcmV0dXJuIEJpZ0ludCh4KTtcbiAgfVxuXG4gIGlmICgtMjE0NzQ4MzY0OCA8PSB4ICYmIHggPD0gMjE0NzQ4MzY0NykgcmV0dXJuIE51bWJlcih4KSB8IDA7XG4gIHJldHVybiB4O1xufVxuXG4vL2V4dGVybmFsIG11bF9vdmVyZmxvd3M6IGludCAtPiBpbnQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9tdWxfb3ZlcmZsb3dzXG5mdW5jdGlvbiBtbF96X211bF9vdmVyZmxvd3MoeCwgeSkge1xuICBsZXQgeiA9IHggKiB5O1xuICByZXR1cm4gKyh6ICE9PSAoeiB8IDApKTtcbn1cblxuLy9leHRlcm5hbCBpbml0OiB1bml0IC0+IHVuaXRcbi8vUHJvdmlkZXM6IG1sX3pfaW5pdFxuLy9SZXF1aXJlczogY2FtbF96YXJpdGhfbWFyc2hhbCwgY2FtbF96YXJpdGhfdW5tYXJzaGFsLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IG1sX3pfaGFzaCwgbWxfel9jb21wYXJlXG5mdW5jdGlvbiBtbF96X2luaXQodW5pdCkge1xuICBjYW1sX2N1c3RvbV9vcHNbJ196J10gPVxuICB7XG4gICAgc2VyaWFsaXplOiBjYW1sX3phcml0aF9tYXJzaGFsLFxuICAgIGRlc2VyaWFsaXplOiBjYW1sX3phcml0aF91bm1hcnNoYWwsXG4gICAgaGFzaDogbWxfel9oYXNoLFxuICAgIGNvbXBhcmU6IG1sX3pfY29tcGFyZSxcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpZ0ludC5wcm90b3R5cGUsICdjYW1sX2N1c3RvbScsIHsgdmFsdWU6ICdfeicgfSk7XG4gIHJldHVybiAwXG59XG5cbi8vZXh0ZXJuYWwgbmVnOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbmVnIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9uZWcoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKC16MSk7XG59XG5cbi8vZXh0ZXJuYWwgYWRkOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9hZGQgY29uc3Rcbi8vUmVxdWlyZXM6IG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2FkZCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKEJpZ0ludCh6MSkgKyBCaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBzdWI6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3N1YiBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc3ViKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSAtIEJpZ0ludCh6MikpO1xufVxuXG4vL2V4dGVybmFsIG11bDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9tdWwoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShCaWdJbnQoejEpICogQmlnSW50KHoyKSk7XG59XG5cbi8vZXh0ZXJuYWwgZGl2OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Rpdih6MSwgejIpIHtcbiAgaWYgKHoyID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKEJpZ0ludCh6MSkgLyBCaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBjZGl2OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9jZGl2XG4vL1JlcXVpcmVzOiBtbF96X2RpdiwgbWxfel9zaWduLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9jZGl2KHoxLCB6Mikge1xuICBsZXQgejFfcG9zID0gbWxfel9zaWduKHoxKTtcbiAgbGV0IHoyX3BvcyA9IG1sX3pfc2lnbih6Mik7XG4gIGlmICh6MV9wb3MgKiB6Ml9wb3MgPiAwKSAvKiBNdWx0aXBsaWNhdGlvbiBpcyBsaWtlIGEgc2lnbndpc2UgeG9yICovIHtcbiAgICBpZiAoQmlnSW50KHoxKSAlIEJpZ0ludCh6MikgIT09IDBuKSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSAvIEJpZ0ludCh6MikgKyAxbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X2Rpdih6MSwgejIpO1xufVxuXG4vL2V4dGVybmFsIGZkaXY6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2ZkaXZcbi8vUmVxdWlyZXM6IG1sX3pfZGl2LCBtbF96X3NpZ24sIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2ZkaXYoejEsIHoyKSB7XG4gIGxldCB6MV9wb3MgPSBtbF96X3NpZ24oejEpO1xuICBsZXQgejJfcG9zID0gbWxfel9zaWduKHoyKTtcbiAgaWYgKHoxX3BvcyAqIHoyX3BvcyA8IDApIC8qIE11bHRpcGxpY2F0aW9uIGlzIGxpa2UgYSBzaWdud2lzZSB4b3IgKi8ge1xuICAgIGlmIChCaWdJbnQoejEpICUgQmlnSW50KHoyKSAhPT0gMG4pIHtcbiAgICAgIHJldHVybiBtbF96X25vcm1hbGl6ZShCaWdJbnQoejEpIC8gQmlnSW50KHoyKSAtIDFuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1sX3pfZGl2KHoxLCB6Mik7XG59XG5cbi8vZXh0ZXJuYWwgcmVtOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9yZW1cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3JlbSh6MSwgejIpIHtcbiAgaWYgKHoyID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKEJpZ0ludCh6MSkgJSBCaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBkaXZfcmVtOiB0IC0+IHQgLT4gKHQgKiB0KVxuLy9Qcm92aWRlczogbWxfel9kaXZfcmVtXG4vL1JlcXVpcmVzOiBtbF96X2RpdiwgbWxfel9yZW1cbmZ1bmN0aW9uIG1sX3pfZGl2X3JlbSh6MSwgejIpIHtcbiAgcmV0dXJuIFswLCBtbF96X2Rpdih6MSwgejIpLCBtbF96X3JlbSh6MSwgejIpXVxufVxuLy9leHRlcm5hbCBzdWNjOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc3VjYyBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc3VjYyh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSArIDFuKTtcbn1cblxuLy9leHRlcm5hbCBwcmVkOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcHJlZCBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfcHJlZCh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSAtIDFuKTtcbn1cblxuLy9leHRlcm5hbCBhYnM6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9hYnMgY29uc3Rcbi8vUmVxdWlyZXM6IG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Ficyh6MSkge1xuICBpZiAoejEgPCAwKSByZXR1cm4gbWxfel9ub3JtYWxpemUoLXoxKTtcbiAgcmV0dXJuIHoxO1xufVxuXG4vL2V4dGVybmFsIGxvZ2FuZDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbG9nYW5kIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2dhbmQoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShCaWdJbnQoejEpICYgQmlnSW50KHoyKSk7XG59XG5cbi8vZXh0ZXJuYWwgbG9nb3I6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ29yIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2dvcih6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKEJpZ0ludCh6MSkgfCBCaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBsb2d4b3I6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ3hvciBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9neG9yKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSBeIEJpZ0ludCh6MikpO1xufVxuXG4vL2V4dGVybmFsIGxvZ25vdDogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ25vdCBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9nbm90KHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh+ejEpO1xufVxuXG4vL2V4dGVybmFsIHNoaWZ0X2xlZnQ6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc2hpZnRfbGVmdCBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc2hpZnRfbGVmdCh6MSwgYW10KSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShCaWdJbnQoejEpIDw8IEJpZ0ludChhbXQpKTtcbn1cblxuLy9leHRlcm5hbCBzaGlmdF9yaWdodDogdCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zaGlmdF9yaWdodCBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc2hpZnRfcmlnaHQoejEsIGFtdCkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSA+PiBCaWdJbnQoYW10KSk7XG59XG5cbi8vZXh0ZXJuYWwgc2hpZnRfcmlnaHRfdHJ1bmM6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc2hpZnRfcmlnaHRfdHJ1bmMgY29uc3Rcbi8vUmVxdWlyZXM6IG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NoaWZ0X3JpZ2h0X3RydW5jKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHoxKSAvICgxbiA8PCBCaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfaW50MzIgY29uc3RcbmZ1bmN0aW9uIG1sX3pfb2ZfaW50MzIoaSkge1xuICByZXR1cm4gaSB8IDA7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfbmF0aXZlaW50OiBuYXRpdmVpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9uYXRpdmVpbnQgY29uc3RcbmZ1bmN0aW9uIG1sX3pfb2ZfbmF0aXZlaW50KGkpIHtcbiAgcmV0dXJuIGkgfCAwO1xufVxuXG4vL2V4dGVybmFsIG9mX2ludDY0OiBpbnQ2NCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2ludDY0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfbmVnLCBtbF96X25vcm1hbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksY2FtbF9pbnQ2NF9oaTMyLGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gbWxfel9vZl9pbnQ2NChpNjQpIHtcbiAgbGV0IG5lZyA9IGZhbHNlO1xuICBpZiAoY2FtbF9pbnQ2NF9jb21wYXJlKGk2NCwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkoMCwgMCkpIDwgMCkge1xuICAgIG5lZyA9IHRydWU7XG4gICAgaTY0ID0gY2FtbF9pbnQ2NF9uZWcoaTY0KVxuICB9XG4gIGxldCBsbyA9IGNhbWxfaW50NjRfbG8zMihpNjQpID4+PiAwO1xuICBsZXQgaGkgPSBjYW1sX2ludDY0X2hpMzIoaTY0KSA+Pj4gMDtcbiAgbGV0IHggPSBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgMzJuKTtcbiAgaWYgKG5lZykgeyB4ID0gLXggfVxuICByZXR1cm4gbWxfel9ub3JtYWxpemUoeClcbn1cblxuLy9leHRlcm5hbCBvZl9mbG9hdDogZmxvYXQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZSwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfb2ZfZmxvYXQoZjEpIHtcbiAgaWYgKGYxID09IEluZmluaXR5IHx8IGYxID09IC1JbmZpbml0eSB8fCBmMSAhPSBmMSlcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGYxIDwgMCA/IE1hdGguY2VpbChmMSkgOiBNYXRoLmZsb29yKGYxKSk7XG59XG5cbi8vZXh0ZXJuYWwgdG9faW50OiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel90b19pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX3pfdG9faW50KHoxKSB7XG4gIGlmICh0eXBlb2YgejEgPT09IFwibnVtYmVyXCIgJiYgejEgPT09ICh6MSB8IDApKSByZXR1cm4gejE7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xufVxuXG4vL2V4dGVybmFsIHRvX2ludDMyOiB0IC0+IGludDMyXG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBtbF96X3RvX2ludFxuZnVuY3Rpb24gbWxfel90b19pbnQzMih6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCB0b19pbnQzMl91bnNpZ25lZDogdCAtPiBpbnQzMlxuLy9Qcm92aWRlczogbWxfel90b19pbnQzMl91bnNpZ25lZFxuLy9SZXF1aXJlczogbWxfel9maXRzX2ludDMyX3Vuc2lnbmVkLCBtbF96X25vcm1hbGl6ZSwgY2FtbF9yYWlzZV9jb25zdGFudFxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel90b19pbnQzMl91bnNpZ25lZCh6MSkge1xuICBpZiAobWxfel9maXRzX2ludDMyX3Vuc2lnbmVkKHoxKSkge1xuICAgIHJldHVybiBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgQmlnSW50KHoxKSkpIHwgMDtcbiAgfVxuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbn1cblxuLy9leHRlcm5hbCB0b19uYXRpdmVpbnRfdW5zaWduZWQ6IHQgLT4gbmF0aXZlaW50XG4vL1Byb3ZpZGVzOiBtbF96X3RvX25hdGl2ZWludF91bnNpZ25lZFxuLy9SZXF1aXJlczogbWxfel90b19pbnQzMl91bnNpZ25lZFxuZnVuY3Rpb24gbWxfel90b19uYXRpdmVpbnRfdW5zaWduZWQoejEpIHtcbiAgcmV0dXJuIG1sX3pfdG9faW50MzJfdW5zaWduZWQoejEpO1xufVxuXG4vL2V4dGVybmFsIHRvX2ludDY0OiB0IC0+IGludDY0XG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludDY0XG4vL1JlcXVpcmVzOiBtbF96X2ZpdHNfaW50NjQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpXG5mdW5jdGlvbiBtbF96X3RvX2ludDY0KHoxKSB7XG4gIGlmICghbWxfel9maXRzX2ludDY0KHoxKSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIGxldCB6MW4gPSBCaWdJbnQoejEpXG4gIGxldCBtYXNrID0gMHhmZmZmZmZmZm5cbiAgbGV0IGxvID0gTnVtYmVyKHoxbiAmIG1hc2spO1xuICBsZXQgaGkgPSBOdW1iZXIoKHoxbiA+PiAzMm4pICYgbWFzayk7XG4gIGxldCB4ID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vZXh0ZXJuYWwgdG9faW50NjRfdW5zaWduZWQ6IHQgLT4gaW50NjRcbi8vUHJvdmlkZXM6IG1sX3pfdG9faW50NjRfdW5zaWduZWRcbi8vUmVxdWlyZXM6IG1sX3pfZml0c19pbnQ2NF91bnNpZ25lZCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGlcbmZ1bmN0aW9uIG1sX3pfdG9faW50NjRfdW5zaWduZWQoejEpIHtcbiAgaWYgKCFtbF96X2ZpdHNfaW50NjRfdW5zaWduZWQoejEpKSB7XG4gICAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX25hbWVkX3ZhbHVlKFwibWxfel9vdmVyZmxvd1wiKSk7XG4gIH1cbiAgbGV0IHoxbiA9IEJpZ0ludC5hc0ludE4oNjQsIEJpZ0ludCh6MSkpXG4gIGxldCBtYXNrID0gMHhmZmZmZmZmZm5cbiAgbGV0IGxvID0gTnVtYmVyKHoxbiAmIG1hc2spO1xuICBsZXQgaGkgPSBOdW1iZXIoKHoxbiA+PiAzMm4pICYgbWFzayk7XG4gIGxldCB4ID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vZXh0ZXJuYWwgdGVzdGJpdDogdCAtPiBpbnQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel90ZXN0Yml0IGNvbnN0XG5mdW5jdGlvbiBtbF96X3Rlc3RiaXQoeiwgcG9zKSB7XG4gIHJldHVybiBOdW1iZXIoKEJpZ0ludCh6KSA+PiBCaWdJbnQocG9zKSkgJiAxbik7XG59XG5cbi8vZXh0ZXJuYWwgdG9fbmF0aXZlaW50OiB0IC0+IG5hdGl2ZWludFxuLy9Qcm92aWRlczogbWxfel90b19uYXRpdmVpbnRcbi8vUmVxdWlyZXM6IG1sX3pfdG9faW50XG5mdW5jdGlvbiBtbF96X3RvX25hdGl2ZWludCh6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCBmb3JtYXQ6IHN0cmluZyAtPiB0IC0+IHN0cmluZ1xuLy9Qcm92aWRlczogbWxfel9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfZmFpbHdpdGgsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Zvcm1hdChmbXQsIHoxKSB7XG4gIGxldCB6MW4gPSBCaWdJbnQoejEpO1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9aYXJpdGgvYmxvYi9kMDU1NWQ0NTFjZTI5NWM0NDk3ZjI0YThkOTk5M2Y4ZGQyMzA5N2RmL3oubWxpcCNMMjk3XG4gIGxldCBiYXNlID0gMTA7XG4gIGxldCBjYXMgPSAwO1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgYWx0ID0gMDtcbiAgbGV0IGRpciA9IDA7XG4gIGxldCBzaWduID0gJyc7XG4gIGxldCBwYWQgPSAnICc7XG4gIGxldCBpZHggPSAwO1xuICBsZXQgcHJlZml4ID0gXCJcIjtcbiAgd2hpbGUgKGZtdFtpZHhdID09ICclJykgaWR4Kys7XG4gIGZvciAoOyA7IGlkeCsrKSB7XG4gICAgaWYgKGZtdFtpZHhdID09ICcjJykgYWx0ID0gMTtcbiAgICBlbHNlIGlmIChmbXRbaWR4XSA9PSAnMCcpIHBhZCA9ICcwJztcbiAgICBlbHNlIGlmIChmbXRbaWR4XSA9PSAnLScpIGRpciA9IDE7XG4gICAgZWxzZSBpZiAoZm10W2lkeF0gPT0gJyAnIHx8IGZtdFtpZHhdID09ICcrJykgc2lnbiA9IGZtdFtpZHhdO1xuICAgIGVsc2UgYnJlYWs7XG4gIH1cbiAgaWYgKHoxbiA8IDApIHsgc2lnbiA9ICctJzsgejFuID0gLXoxbiB9XG4gIGZvciAoOyBmbXRbaWR4XSA+PSAnMCcgJiYgZm10W2lkeF0gPD0gJzknOyBpZHgrKylcbiAgICB3aWR0aCA9IDEwICogd2lkdGggKyAoK2ZtdFtpZHhdKTtcbiAgc3dpdGNoIChmbXRbaWR4XSkge1xuICAgIGNhc2UgJ2knOiBjYXNlICdkJzogY2FzZSAndSc6IGJyZWFrO1xuICAgIGNhc2UgJ2InOiBiYXNlID0gMjsgaWYgKGFsdCkgcHJlZml4ID0gXCIwYlwiOyBicmVhaztcbiAgICBjYXNlICdvJzogYmFzZSA9IDg7IGlmIChhbHQpIHByZWZpeCA9IFwiMG9cIjsgYnJlYWs7XG4gICAgY2FzZSAneCc6IGJhc2UgPSAxNjsgaWYgKGFsdCkgcHJlZml4ID0gXCIweFwiOyBicmVhaztcbiAgICBjYXNlICdYJzogYmFzZSA9IDE2OyBpZiAoYWx0KSBwcmVmaXggPSBcIjBYXCI7IGNhcyA9IDE7IGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2ZhaWx3aXRoKFwiVW5zdXBwb3J0ZWQgZm9ybWF0ICdcIiArIGZtdCArIFwiJ1wiKTtcbiAgfVxuICBpZiAoZGlyKSBwYWQgPSAnICc7XG4gIGxldCByZXMgPSB6MW4udG9TdHJpbmcoYmFzZSk7XG4gIGlmIChjYXMgPT09IDEpIHtcbiAgICByZXMgPSByZXMudG9VcHBlckNhc2UoKTtcbiAgfVxuICBsZXQgc2l6ZSA9IHJlcy5sZW5ndGg7XG4gIGlmIChwYWQgPT0gJyAnKSB7XG4gICAgaWYgKGRpcikge1xuICAgICAgcmVzID0gc2lnbiArIHByZWZpeCArIHJlcztcbiAgICAgIGZvciAoOyByZXMubGVuZ3RoIDwgd2lkdGg7KSByZXMgPSByZXMgKyBwYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHNpZ24gKyBwcmVmaXggKyByZXM7XG4gICAgICBmb3IgKDsgcmVzLmxlbmd0aCA8IHdpZHRoOykgcmVzID0gcGFkICsgcmVzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJlID0gc2lnbiArIHByZWZpeDtcbiAgICBmb3IgKDsgcmVzLmxlbmd0aCArIHByZS5sZW5ndGggPCB3aWR0aDspIHJlcyA9IHBhZCArIHJlcztcbiAgICByZXMgPSBwcmUgKyByZXM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTtcbn1cblxuLy9Qcm92aWRlczoganNvb196X29mX2pzX3N0cmluZ19iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2UoYmFzZSwgcykge1xuICBpZiAoYmFzZSA9PSAwKSB7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9aYXJpdGgvYmxvYi9iOGRiYWY0OGE3OTI3MDYxZGY2OTlhZDdjZTY0MmJiNGYxZmU1MzA4L2NhbWxfei5jI0w1OThcbiAgICBiYXNlID0gMTA7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBzaWduID0gMTtcbiAgICBpZiAoc1twXSA9PSAnLScpIHsgc2lnbiA9IC0xOyBwKysgfVxuICAgIGVsc2UgaWYgKHNbcF0gPT0gJysnKSB7IHArKyB9XG4gICAgaWYgKHNbcF0gPT0gJzAnKSB7XG4gICAgICBwKys7XG4gICAgICBpZiAocy5sZW5ndGggPT0gcCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBiYyA9IHNbcF07XG4gICAgICAgIGlmIChiYyA9PSAnbycgfHwgYmMgPT0gJ08nKSB7XG4gICAgICAgICAgYmFzZSA9IDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYmMgPT0gJ3gnIHx8IGJjID09ICdYJykge1xuICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiYyA9PSAnYicgfHwgYmMgPT0gJ0InKSB7XG4gICAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UgIT0gMTApIHtcbiAgICAgICAgICBzID0gcy5zdWJzdHJpbmcocCArIDEpO1xuICAgICAgICAgIGlmIChzaWduID09IC0xKSBzID0gXCItXCIgKyBzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlnaXQoY29kZSkge1xuICAgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHJldHVybiBjb2RlIC0gNDg7XG4gICAgaWYgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpIHJldHVybiBjb2RlIC0gOTcgKyAxMDtcbiAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSByZXR1cm4gY29kZSAtIDY1ICsgMTA7XG4gIH1cbiAgbGV0IGkgPSAwO1xuICBpZiAoc1tpXSA9PSAnKycpIHtcbiAgICAvL3JlbW92ZSBsZWFkaW5nICcrJ1xuICAgIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgfVxuICBlbHNlIGlmIChzW2ldID09ICctJykgaSsrO1xuICBpZiAoc1tpXSA9PSAnXycpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloub2Zfc3Vic3RyaW5nX2Jhc2U6IGludmFsaWQgZGlnaXRcIik7XG4gIHMgPSBzLnJlcGxhY2UoL18vZywgJycpO1xuICAvL25vcm1hbGl6ZSBcImVtcHR5XCIgbnVtYmVyc1xuICBpZiAocyA9PSAnLScgfHwgcyA9PSAnJykgcyA9ICcwJztcbiAgZm9yICg7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBkaWdpdChzLmNoYXJDb2RlQXQoaSkpO1xuICAgIGlmIChjID09IHVuZGVmaW5lZCB8fCBjID49IGJhc2UpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLm9mX3N1YnN0cmluZ19iYXNlOiBpbnZhbGlkIGRpZ2l0XCIpO1xuICB9XG5cbiAgaWYgKGJhc2UgPT09IDEwKSByZXR1cm4gbWxfel9ub3JtYWxpemUoQmlnSW50KHMpKTtcblxuICBsZXQgbmVnID0gZmFsc2U7XG4gIGkgPSAwO1xuICBpZiAoc1tpXSA9PSAnLScpIHsgbmVnID0gdHJ1ZTsgaSsrOyB9XG4gIGxldCBuID0gMG47XG4gIGZvciAoOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgIG4gKj0gQmlnSW50KGJhc2UpO1xuICAgIG4gKz0gQmlnSW50KGRpZ2l0KHMuY2hhckNvZGVBdChpKSkpO1xuICB9XG4gIGlmIChuZWcpIG4gPSAtbjtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKG4pO1xufVxuXG4vL2V4dGVybmFsIG9mX3N1YnN0cmluZ19iYXNlOiBpbnQgLT4gc3RyaW5nIC0+IHBvczppbnQgLT4gbGVuOmludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX3N1YnN0cmluZ19iYXNlXG4vL1JlcXVpcmVzOiBqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBtbF96X29mX3N1YnN0cmluZ19iYXNlKGJhc2UsIHMsIHBvcywgbGVuKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICBpZiAocG9zICE9IDAgfHwgbGVuICE9IHMubGVuZ3RoKSB7XG4gICAgaWYgKHMubGVuZ3RoIC0gcG9zIDwgbGVuKSB7XG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLm9mX3N1YnN0cmluZ19iYXNlOiBpbnZhbGlkIG9mZnNldCBvciBsZW5ndGhcIik7XG4gICAgfVxuICAgIHMgPSBzLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxuICByZXR1cm4ganNvb196X29mX2pzX3N0cmluZ19iYXNlKGJhc2UsIHMpO1xufVxuXG4vL2V4dGVybmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gbWxfel9jb21wYXJlKHoxLCB6Mikge1xuICByZXR1cm4gejEgPT0gejIgPyAwIDogejEgPiB6MiA/IDEgOiAtMTtcbn1cblxuLy9leHRlcm5hbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZXF1YWwgY29uc3RcbmZ1bmN0aW9uIG1sX3pfZXF1YWwoejEsIHoyKSB7XG4gIHJldHVybiB6MSA9PSB6MiA/IDEgOiAwO1xufVxuXG4vL2V4dGVybmFsIHNpZ246IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3NpZ24gY29uc3RcbmZ1bmN0aW9uIG1sX3pfc2lnbih6MSkge1xuICByZXR1cm4gejEgPT0gMCA/IDAgOiB6MSA+IDAgPyAxIDogLTE7XG59XG5cbi8vZXh0ZXJuYWwgZ2NkOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9nY2Rcbi8vUmVxdWlyZXM6IG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2djZCh6MSwgejIpIHtcbiAgbGV0IGEgPSBCaWdJbnQoejEpO1xuICBpZiAoYSA8IDApIGEgPSAtYTtcbiAgbGV0IGIgPSBCaWdJbnQoejIpO1xuICBpZiAoYiA8IDApIGIgPSAtYjtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBtbF96X25vcm1hbGl6ZShhKTtcbiAgaWYgKGEgPT09IDBuKSByZXR1cm4gbWxfel9ub3JtYWxpemUoYik7XG4gIGlmIChiID09PSAwbikgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGEpO1xuICBsZXQgYyA9IDFuLCBkLCB0O1xuICBmdW5jdGlvbiBtaW4oYSwgYikgeyByZXR1cm4gYSA8IGIgPyBhIDogYiB9XG4gIHdoaWxlICgoYSAmIDFuKSA9PT0gMG4gJiYgKGIgJiAxbikgPT09IDBuKSB7XG4gICAgZCA9IG1pbihhICYgLWEsIGIgJiAtYik7XG4gICAgYSAvPSBkO1xuICAgIGIgLz0gZDtcbiAgICBjICo9IGQ7XG4gIH1cbiAgd2hpbGUgKChhICYgMW4pID09PSAwbikge1xuICAgIGEgLz0gYSAmIC1hO1xuICB9XG4gIGRvIHtcbiAgICB3aGlsZSAoKGIgJiAxbikgPT09IDBuKSB7XG4gICAgICBiIC89IGIgJiAtYjtcbiAgICB9XG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xuICAgIH1cbiAgICBiIC09IGE7XG4gIH0gd2hpbGUgKGIgIT09IDBuKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGMgPT09IDFuID8gYSA6IGEgKiBjKTtcbn1cblxuLy9leHRlcm5hbCBudW1iaXRzOiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9udW1iaXRzIGNvbnN0XG5mdW5jdGlvbiBtbF96X251bWJpdHMoejEpIHtcbiAgaWYgKHoxIDwgMCkgejEgPSAtejE7XG4gIGxldCBuID0gMDtcbiAgbGV0IHVwcGVyQm91bmQgPSAxbjtcbiAgd2hpbGUgKHVwcGVyQm91bmQgPD0gejEpIHtcbiAgICBuICs9IDE7XG4gICAgdXBwZXJCb3VuZCA9IHVwcGVyQm91bmQgPDwgMW47XG4gIH1cbiAgcmV0dXJuIG47IC8vIDJee24tMX0gPD0gfHh8IDwgMl5uXG59XG5cbi8vZXh0ZXJuYWwgZml0c19pbnQ6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX2ludCBjb25zdFxuZnVuY3Rpb24gbWxfel9maXRzX2ludCh6MSkge1xuICByZXR1cm4gdHlwZW9mIHoxID09PSBcIm51bWJlclwiID8gKyh6MSA9PT0gKHoxIHwgMCkpIDogMDtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDMyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQzMlxuLy9SZXF1aXJlczogbWxfel9maXRzX2ludFxuZnVuY3Rpb24gbWxfel9maXRzX2ludDMyKHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50KHoxKTtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDMyX3Vuc2lnbmVkOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQzMl91bnNpZ25lZFxuZnVuY3Rpb24gbWxfel9maXRzX2ludDMyX3Vuc2lnbmVkKHoxKSB7XG4gIHJldHVybiAwIDw9IHoxICYmIHoxIDw9IDQyOTQ5NjcyOTU7XG59XG5cbi8vZXh0ZXJuYWwgZml0c19pbnQ2NF91bnNpZ25lZDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X2ZpdHNfaW50NjRfdW5zaWduZWRcbmZ1bmN0aW9uIG1sX3pfZml0c19pbnQ2NF91bnNpZ25lZCh6MSkge1xuICByZXR1cm4gMCA8PSB6MSAmJiB6MSA8PSAxODQ0Njc0NDA3MzcwOTU1MTYxNW47XG59XG5cbi8vZXh0ZXJuYWwgZml0c19uYXRpdmVpbnRfdW5zaWduZWQ6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX25hdGl2ZWludF91bnNpZ25lZFxuLy9SZXF1aXJlczogbWxfel9maXRzX2ludDMyX3Vuc2lnbmVkXG5mdW5jdGlvbiBtbF96X2ZpdHNfbmF0aXZlaW50X3Vuc2lnbmVkKHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50MzJfdW5zaWduZWQoejEpO1xufVxuXG5cbi8vZXh0ZXJuYWwgZml0c19pbnQ2NDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X2ZpdHNfaW50NjRcbmZ1bmN0aW9uIG1sX3pfZml0c19pbnQ2NCh6MSkge1xuICBpZiAoejEgPD0gOTIyMzM3MjAzNjg1NDc3NTgwN24gJiYgejEgPj0gLTkyMjMzNzIwMzY4NTQ3NzU4MDhuKVxuICAgIHJldHVybiAxXG4gIGVsc2VcbiAgICByZXR1cm4gMFxufVxuXG4vL2V4dGVybmFsIGZpdHNfbmF0aXZlaW50OiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19uYXRpdmVpbnRcbi8vUmVxdWlyZXM6IG1sX3pfZml0c19pbnRcbmZ1bmN0aW9uIG1sX3pfZml0c19uYXRpdmVpbnQoejEpIHtcbiAgcmV0dXJuIG1sX3pfZml0c19pbnQoejEpO1xufVxuXG4vL2V4dGVybmFsIHBvd206IHQgLT4gdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcG93bVxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemUsIG1sX3pfaW52ZXJ0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBqc29vX2JpZ2ludF9tb2RfcG93XG5mdW5jdGlvbiBtbF96X3Bvd20oejEsIHoyLCB6Mykge1xuICBpZiAoejMgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICBpZiAoejMgPT0gMSB8fCB6MyA9PSAtMSkgcmV0dXJuIDA7XG4gIGlmICh6MiA9PSAwKSByZXR1cm4gMTtcbiAgbGV0IHozbiA9IEJpZ0ludCh6Myk7XG4gIGlmICh6MiA8IDApIHtcbiAgICBsZXQgaW52ID0gQmlnSW50KG1sX3pfaW52ZXJ0KHoxLCB6MykpO1xuICAgIGxldCByID0ganNvb19iaWdpbnRfbW9kX3BvdyhpbnYsIEJpZ0ludCgtejIpLCB6M24pO1xuICAgIGlmIChyIDwgMCkgciA9IHIgKyAoejNuIDwgMCA/IC16M24gOiB6M24pO1xuICAgIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgciA9IGpzb29fYmlnaW50X21vZF9wb3coQmlnSW50KHoxKSwgQmlnSW50KHoyKSwgejNuKTtcbiAgICBpZiAociA8IDApIHIgPSByICsgKHozbiA8IDAgPyAtejNuIDogejNuKTtcbiAgICByZXR1cm4gbWxfel9ub3JtYWxpemUocik7XG4gIH1cbn1cblxuLy9leHRlcm5hbCBwb3duOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9wb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIG1sX3pfbm9ybWFsaXplLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfcG93KHoxLCBpMSkge1xuICBpZiAoaTEgPCAwKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5wb3c6IGV4cG9uZW50IG11c3QgYmUgbm9ubmVnYXRpdmVcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKEJpZ0ludCh6MSkgKiogQmlnSW50KGkxKSk7XG59XG5cbi8vZXh0ZXJuYWwgaGFzaDogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIG1sX3pfaGFzaCh6MSkge1xuICBsZXQgejFuID0gQmlnSW50KHoxKTtcbiAgbGV0IG5lZyA9IHoxbiA8IDA7XG4gIGlmIChuZWcpIHoxbiA9IC16MW47XG5cbiAgbGV0IGFjYyA9IDAsIGxlbiA9IDE7XG4gIGxldCBsZWZ0ID0gejFuO1xuICB3aGlsZSAobGVmdCA+PSAyICoqIDMyKSB7XG4gICAgYWNjID0gY2FtbF9oYXNoX21peF9pbnQoYWNjLCBOdW1iZXIobGVmdCAmIDB4ZmZmZmZmZmZuKSk7XG4gICAgbGVmdCA+Pj0gMzJuO1xuICAgIGxlbiArPSAxO1xuICB9XG4gIGFjYyA9IGNhbWxfaGFzaF9taXhfaW50KGFjYywgTnVtYmVyKGxlZnQpIHwgMCk7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgYWNjID0gY2FtbF9oYXNoX21peF9pbnQoYWNjLCAwKTtcbiAgfVxuICBpZiAobmVnKSB7XG4gICAgYWNjID0gYWNjICsgMVxuICB9XG4gIHJldHVybiBhY2MgfCAwXG59XG5cbi8vZXh0ZXJuYWwgdG9fYml0czogdCAtPiBzdHJpbmdcbi8vUHJvdmlkZXM6IG1sX3pfdG9fYml0cyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBtbF96X3RvX2JpdHMoejEpIHtcbiAgbGV0IHoxbiA9IEJpZ0ludCh6MSk7XG4gIGlmICh6MW4gPCAwKSB6MW4gPSAtejFuO1xuICBsZXQgcmVzID0gXCJcIjtcbiAgd2hpbGUgKHoxbiAhPT0gMG4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoejFuICUgMjU2bikgfCAwKTtcbiAgICB6MW4gLz0gMjU2bjtcbiAgfVxuICB3aGlsZSAocmVzLmxlbmd0aCAlIDQgIT0gMCkge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApO1xuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHJlcyk7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfYml0czogc3RyaW5nIC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfYml0cyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9vZl9iaXRzKHoxKSB7XG4gIGxldCByID0gMG47XG4gIGxldCBiYXNlID0gMW47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHoxKTsgaSsrKSB7XG4gICAgbGV0IGQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHoxLCBpKTtcbiAgICByICs9IGJhc2UgKiBCaWdJbnQoZCk7XG4gICAgYmFzZSAqPSAyNTZuO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbn1cblxuLy9leHRlcm5hbCBwb3dtX3NlYzogdCAtPiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9wb3dtX3NlY1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgbWxfel9wb3dtLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfcG93bV9zZWMoejEsIHoyLCB6Mykge1xuICBpZiAoejEgPCAwKSB6MyA9IC16MztcbiAgLy8gcG93bV9zZWMgcmVxdWlyZXMgdGhhdCB0aGUgZXhwb25lbnQgYmUgcG9zaXRpdmVcbiAgaWYgKHoyIDwgMSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucG93bV9zZWM6IGV4cG9uZW50IG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIH1cbiAgaWYgKChCaWdJbnQoejMpICYgMW4pICE9PSAxbikge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucG93bV9zZWM6IG1vZHVsdXMgbXVzdCBiZSBvZGRcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfcG93bSh6MSwgejIsIHozKVxufVxuXG4vL2V4dGVybmFsIHJvb3Q6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcm9vdFxuLy9SZXF1aXJlczogbWxfel9wb3csIG1sX3pfbm9ybWFsaXplLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfcm9vdCh6LCBpKSB7XG4gIGlmIChpICUgMiA9PT0gMCAmJiB6IDwgMCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucm9vdDogZXZlbiByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyXCIpO1xuICB9XG5cbiAgaWYgKHogPT0gMCB8fCB6ID09IDEpIHtcbiAgICByZXR1cm4gTnVtYmVyKHopIHwgMDtcbiAgfVxuXG4gIGxldCBzdGFydCA9IDBuO1xuICBsZXQgZW5kID0gQmlnSW50KHopO1xuICBsZXQgYW5zID0gMG47XG5cbiAgbGV0IGJpZ2kgPSBCaWdJbnQoaSk7XG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICBsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSAvIDJuO1xuICAgIGxldCBwbyA9IG1pZCAqKiBiaWdpO1xuICAgIGlmIChwbyA9PSB6KSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUobWlkKTtcbiAgICB9IGVsc2UgaWYgKHBvIDwgeikge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxbjtcbiAgICAgIGFucyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbWlkIC0gMW47XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShhbnMpO1xufVxuXG4vL2V4dGVybmFsIHJvb3RyZW06IHQgLT4gaW50IC0+IHQgKiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Jvb3RyZW1cbi8vUmVxdWlyZXM6IG1sX3pfcG93LCBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Jvb3RyZW0oeiwgaSkge1xuICBpZiAoaSAlIDIgPT09IDAgJiYgeiA8IDApIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLnJvb3RyZW06IGV2ZW4gcm9vdCBvZiBhIG5lZ2F0aXZlIG51bWJlclwiKTtcbiAgfVxuXG4gIGlmICh6ID09IDAgfHwgeiA9PT0gMSkge1xuICAgIHJldHVybiBbMCwgTnVtYmVyKHopIHwgMCwgMF07XG4gIH1cblxuICBsZXQgc3RhcnQgPSAwbjtcbiAgbGV0IGVuZCA9IEJpZ0ludCh6KTtcbiAgbGV0IGFucyA9IDBuO1xuXG4gIGxldCBiaWdpID0gQmlnSW50KGkpO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgbGV0IG1pZCA9IChzdGFydCArIGVuZCkgLyAybjtcbiAgICBsZXQgcG8gPSBtaWQgKiogYmlnaTtcbiAgICBpZiAocG8gPT0geikge1xuICAgICAgcmV0dXJuIFswLCBtbF96X25vcm1hbGl6ZShtaWQpLCAwXTtcbiAgICB9IGVsc2UgaWYgKHBvIDwgeikge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxbjtcbiAgICAgIGFucyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbWlkIC0gMW47XG4gICAgfVxuICB9XG4gIHJldHVybiBbMCwgbWxfel9ub3JtYWxpemUoYW5zKSwgbWxfel9ub3JtYWxpemUoQmlnSW50KHopIC0gKGFucyAqKiBiaWdpKSldO1xufVxuXG4vL2V4dGVybmFsIGludmVydDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfaW52ZXJ0XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X2djZGV4dF9pbnRlcm4sIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2ludmVydChhLCBuKSB7XG4gIC8vIEJlY2F1c2UgW2EubW9kSW52KG4pXSBwcm9kdWNlcyBkaWZmZXJlbnQgcmVzdWx0cyBmb3IgZWRnZSBjYXNlcyxcbiAgLy8gd2Ugd3JvdGUgb3VyIG93biBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBnY2RleHRfaW50ZXJuLlxuICBpZiAobiA9PSAxIHx8IG4gPT0gLTEpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChuID09IDAgJiYgKGEgPT0gMSB8fCBhID09IC0xKSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGlmIChuID09IDAgfHwgYSA9PSAwKSB7XG4gICAgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICB9XG4gIGxldCB4ID0gbWxfel9nY2RleHRfaW50ZXJuKGEsIG4pO1xuICBsZXQgciA9IEJpZ0ludCh4WzJdKTtcbiAgYSA9IEJpZ0ludChhKTtcbiAgbiA9IEJpZ0ludChuKTtcbiAgaWYgKG4gPCAwKSBuID0gLW47XG4gIGxldCB0bXAgPSAoYSAqIHIpICUgbjtcbiAgaWYgKHRtcCA8IDApIHRtcCArPSBuO1xuICBpZiAociA8IDApIHIgKz0gbjtcbiAgaWYgKHRtcCA9PSAxKSB7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9XG4gIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbn1cblxuLy9leHRlcm5hbCBwZXJmZWN0X3Bvd2VyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfcGVyZmVjdF9wb3dlclxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgbWxfel9udW1iaXRzLCBtbF96X3Jvb3QsIG1sX3pfcG93XG5mdW5jdGlvbiBtbF96X3BlcmZlY3RfcG93ZXIoeikge1xuICAvLyBSZXR1cm4gdHJ1ZSBpZiBvcCBpcyBhIHBlcmZlY3QgcG93ZXIsIGkuZS4sIGlmIHRoZXJlIGV4aXN0IGludGVnZXJzIGEgYW5kXG4gIC8vIGIsIHdpdGggYiA+IDEsIHN1Y2ggdGhhdCBvcCA9IGFeYi5cbiAgLy8gT3RoZXJ3aXNlIGZhbHNlLlxuICBpZiAoeiA9PSAwIHx8IHogPT0gMSB8fCB6ID09IC0xKSByZXR1cm4gMTtcblxuICBsZXQgenAgPSB6IDwgMCA/IC16IDogejtcbiAgbGV0IGxvZzJ6ID0gbWxfel9udW1iaXRzKHpwKTtcbiAgZm9yIChsZXQgYiA9IDI7IGIgPD0gbG9nMno7IGIrKykge1xuICAgIGlmICh6IDwgMCAmJiBiICUgMiA9PSAwKSBjb250aW51ZTtcbiAgICBsZXQgcCA9IG1sX3pfcm9vdCh6cCwgYik7XG4gICAgaWYgKHogPCAwKSBwID0gLXA7XG4gICAgbGV0IHIgPSBtbF96X3BvdyhwLCBiKTtcbiAgICBpZiAoeiA9PSByKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vZXh0ZXJuYWwgcGVyZmVjdF9zcXVhcmU6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9wZXJmZWN0X3NxdWFyZVxuLy9SZXF1aXJlczogbWxfel9yb290XG5mdW5jdGlvbiBtbF96X3BlcmZlY3Rfc3F1YXJlKHopIHtcbiAgaWYgKHogPCAwKSByZXR1cm4gMDtcbiAgbGV0IHJvb3QgPSBCaWdJbnQobWxfel9yb290KHosIDIpKTtcbiAgaWYgKHJvb3QgKiByb290ID09IHopIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG5cbi8vTXVzdCBoYXZlIDAgPD0gbG93IDw9IGhpZ2hcbi8vUHJvdmlkZXM6IGpzb29fYmlnaW50X3JhbmRfYmV0d2VlblxuZnVuY3Rpb24ganNvb19iaWdpbnRfcmFuZF9iZXR3ZWVuKGxvdywgaGlnaCkge1xuICBsZXQgcmFuZ2UgPSBoaWdoIC0gbG93ICsgMW47XG4gIGxldCBiYXNlID0gMWU3LCBiaWdiYXNlID0gQmlnSW50KGJhc2UpO1xuICBsZXQgcmVzdWx0ID0gMG4sIHJlc3RyaWN0ZWQgPSB0cnVlO1xuXG4gIGxldCBkaWdpdHMgPSBbXTtcbiAgd2hpbGUgKHJhbmdlID49IGJpZ2Jhc2UpIHtcbiAgICBkaWdpdHMucHVzaChOdW1iZXIocmFuZ2UgJSBiaWdiYXNlKSk7XG4gICAgcmFuZ2UgLz0gYmlnYmFzZTtcbiAgfVxuICBkaWdpdHMucHVzaChOdW1iZXIocmFuZ2UpKTtcbiAgZGlnaXRzLnJldmVyc2UoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0b3AgPSByZXN0cmljdGVkID8gZGlnaXRzW2ldIHwgMCA6IGJhc2U7XG4gICAgcmFuZ2UgLz0gYmlnYmFzZTtcbiAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0b3ApO1xuICAgIHJlc3VsdCAqPSBiaWdiYXNlO1xuICAgIHJlc3VsdCArPSBCaWdJbnQoZGlnaXQpO1xuICAgIGlmIChkaWdpdCA8IHRvcCkgcmVzdHJpY3RlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBsb3cgKyByZXN1bHQ7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fYmlnaW50X21vZF9wb3dcbmZ1bmN0aW9uIGpzb29fYmlnaW50X21vZF9wb3coc2VsZiwgZXhwLCBtb2QpIHtcbiAgaWYgKG1vZCA9PT0gMG4pIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsbyAwXCIpO1xuICBpZiAoZXhwIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbmVnYXRpdmUgZXhwb25lbnRcIik7XG4gIGxldCByID0gMW4sIGJhc2UgPSBzZWxmICUgbW9kO1xuICB3aGlsZSAoZXhwID4gMCkge1xuICAgIGlmIChiYXNlID09PSAwbikgcmV0dXJuIDBuO1xuICAgIGlmICgoZXhwICYgMW4pID09PSAxbikgciA9IChyICogYmFzZSkgJSBtb2Q7XG4gICAgZXhwID4+PSAxbjtcbiAgICBiYXNlID0gKGJhc2UgKiBiYXNlKSAlIG1vZDtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy9leHRlcm5hbCBwcm9iYWJfcHJpbWU6IHQgLT4gaW50IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9wcm9iYWJfcHJpbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fYmlnaW50X21vZF9wb3csIGpzb29fYmlnaW50X3JhbmRfYmV0d2VlblxuLy9Ob3RlOiBjYWxsZWQgd2l0aCBbMW5dIGZyb20gW21sX3pfcHJpbW9yaWFsXVxuZnVuY3Rpb24gbWxfel9wcm9iYWJfcHJpbWUoeiwgaSkge1xuICBpZiAoeiA8IDApIHogPSAtejtcblxuICAvLyBUZXN0IGZvciBiYXNpYyBwcmltZXMgKG11bHRpcGxlcyBvZiAyLCAzLCA1KVxuICBpZiAoeiA9PSAxKSByZXR1cm4gMDtcbiAgaWYgKHogPT0gMiB8fCB6ID09IDMgfHwgeiA9PSA1KSByZXR1cm4gMTtcbiAgbGV0IG4gPSBCaWdJbnQoeik7XG4gIGlmIChuICUgMm4gPT09IDBuIHx8IG4gJSAzbiA9PT0gMG4gfHwgbiAlIDVuID09PSAwbikgcmV0dXJuIDA7XG4gIGlmICh6IDwgNDkpIHJldHVybiAxO1xuXG4gIC8vIE1pbGxlci1SYWJpbiB0ZXN0XG4gIGxldCBuUHJldiA9IG4gLSAxbixcbiAgICBiID0gblByZXYsXG4gICAgciA9IDAsXG4gICAgYSwgZCwgaiwgeDtcbiAgd2hpbGUgKGIgJSAybiA9PT0gMG4pIGIgLz0gMm4sIHIrKztcbiAgbmV4dDogZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgIGEgPSBqc29vX2JpZ2ludF9yYW5kX2JldHdlZW4oMm4sIG4gLSAybik7XG4gICAgeCA9IGpzb29fYmlnaW50X21vZF9wb3coYSwgYiwgbik7XG4gICAgaWYgKHggPT09IDFuIHx8IHggPT09IG5QcmV2KSBjb250aW51ZTtcbiAgICBmb3IgKGQgPSByIC0gMTsgZCAhPSAwOyBkLS0pIHtcbiAgICAgIHggPSAoeCAqIHgpICUgbjtcbiAgICAgIGlmICh4ID09PSAxbikgcmV0dXJuIDA7XG4gICAgICBpZiAoeCA9PT0gblByZXYpIGNvbnRpbnVlIG5leHQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAxO1xufVxuXG4vL2V4dGVybmFsIG5leHRwcmltZTogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X25leHRwcmltZSBjb25zdFxuLy9SZXF1aXJlczogbWxfel9ub3JtYWxpemUsIG1sX3pfcHJvYmFiX3ByaW1lXG5mdW5jdGlvbiBtbF96X25leHRwcmltZSh6MSkge1xuICAvLyBJbnRlcmVzdGluZ2x5LCB0aGUgemFyaXRoIG5leHRfcHJpbWUgb25seSByZXR1cm5zXG4gIC8vIHByb2JhYmFsaXN0aWMgcHJpbWVzLiAgV2UgZG8gdGhlIHNhbWUsIHdpdGggdGhlXG4gIC8vIHNhbWUgcHJvYmFibGlzdGljIHBhcmFtZXRlciBvZiAyNS5cbiAgLy8gaHR0cHM6Ly9mb3NzaWVzLm9yZy9kb3gvZ21wLTYuMS4yL21wel8ybmV4dHByaW1lXzhjX3NvdXJjZS5odG1sXG5cbiAgaWYgKHoxIDwgMSB8fCB6MSA9PSAxKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBsZXQgejFuID0gQmlnSW50KHoxKVxuICBpZiAoKHoxbiAmIDFuKSA9PT0gMW4pIHtcbiAgICB6MW4gKz0gMm47XG4gIH0gZWxzZSB7XG4gICAgejFuICs9IDFuO1xuICB9XG5cbiAgZm9yICg7IDspIHtcbiAgICBpZiAobWxfel9wcm9iYWJfcHJpbWUoejFuLCAyNSkpIHtcbiAgICAgIHJldHVybiBtbF96X25vcm1hbGl6ZSh6MW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB6MW4gKz0gMm47XG4gICAgfVxuICB9XG59XG5cbi8vZXh0ZXJuYWwgY19leHRyYWN0OiB0IC0+IGludCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9leHRyYWN0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9leHRyYWN0KHoxLCBwb3MsIGxlbikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoKEJpZ0ludCh6MSkgPj4gQmlnSW50KHBvcykpICYgKCgxbiA8PCBCaWdJbnQobGVuKSkgLSAxbikpO1xufVxuXG4vL2V4dGVybmFsIGNfZXh0cmFjdF9zbWFsbDogdCAtPiBpbnQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZXh0cmFjdF9zbWFsbFxuZnVuY3Rpb24gbWxfel9leHRyYWN0X3NtYWxsKHoxLCBwb3MsIGxlbikge1xuICByZXR1cm4gTnVtYmVyKEJpZ0ludC5hc0ludE4oMzIsIHoxID4+IEJpZ0ludChwb3MpKSkgJiAoKDEgPDwgbGVuKSAtIDEpO1xufVxuXG4vL2V4dGVybmFsIGdjZGV4dF9pbnRlcm46IHQgLT4gdCAtPiAodCAqIHQgKiBib29sKVxuLy9Qcm92aWRlczogbWxfel9nY2RleHRfaW50ZXJuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9nY2RleHRfaW50ZXJuKHoxLCB6Mikge1xuICBpZiAoejEgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICBsZXQgYSA9IEJpZ0ludCh6MSk7XG4gIGxldCBiID0gQmlnSW50KHoyKTtcbiAgbGV0IHggPSAwbjtcbiAgbGV0IGxhc3R4ID0gMW47XG4gIGxldCB5ID0gMW47XG4gIGxldCBsYXN0eSA9IDFuO1xuICBsZXQgcSwgdCwgcjtcbiAgd2hpbGUgKGIgIT09IDBuKSB7XG4gICAgcSA9IGEgLyBiO1xuICAgIHIgPSBhIC0gcSAqIGI7XG4gICAgdCA9IHg7XG4gICAgeCA9IGxhc3R4IC0gcSAqIHg7XG4gICAgbGFzdHggPSB0O1xuICAgIHQgPSB5O1xuICAgIHkgPSBsYXN0eSAtIHEgKiB5O1xuICAgIGxhc3R5ID0gdDtcbiAgICBhID0gYjtcbiAgICBiID0gcjtcbiAgfVxuICBpZiAoYSA8IDApXG4gICAgcmV0dXJuIFswLCBtbF96X25vcm1hbGl6ZSgtYSksIG1sX3pfbm9ybWFsaXplKC1sYXN0eCksIDFdXG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIG1sX3pfbm9ybWFsaXplKGEpLCBtbF96X25vcm1hbGl6ZShsYXN0eCksIDFdXG59XG5cbi8vZXh0ZXJuYWwgc3FydDogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3NxcnRcbi8vUmVxdWlyZXM6IG1sX3pfcm9vdCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3NxcnQoejEpIHtcbiAgaWYgKHoxIDwgMCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouc3FydDogc3F1YXJlIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfcm9vdCh6MSwgMik7XG59XG5cbi8vZXh0ZXJuYWwgc3FydF9yZW06IHQgLT4gKHQgKiB0KVxuLy9Qcm92aWRlczogbWxfel9zcXJ0X3JlbVxuLy9SZXF1aXJlczogbWxfel9yb290LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NxcnRfcmVtKHopIHtcbiAgaWYgKHogPCAwKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5zcXJ0X3JlbTogc3F1YXJlIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgbGV0IHJvb3QgPSBtbF96X3Jvb3QoeiwgMik7XG4gIGxldCByb290biA9IEJpZ0ludChyb290KTtcbiAgbGV0IGRpZmYgPSBCaWdJbnQoeikgLSByb290biAqIHJvb3RuO1xuICByZXR1cm4gWzAsIHJvb3QsIG1sX3pfbm9ybWFsaXplKGRpZmYpXVxufVxuXG4vL2V4dGVybmFsIHRyYWlsaW5nX3plcm9zOiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel90cmFpbGluZ196ZXJvcyBjb25zdFxuZnVuY3Rpb24gbWxfel90cmFpbGluZ196ZXJvcyh6KSB7XG4gIGlmICh6ID09IDApIHtcbiAgICAvLyBtYXhfaW50IGluIDMyYml0XG4gICAgcmV0dXJuIDB4N2ZmZmZmZmY7XG4gIH1cbiAgaWYgKHogPCAwKSB6ID0gLXo7XG4gIGxldCB6biA9IEJpZ0ludCh6KTtcbiAgbGV0IGkgPSAwO1xuICB6biA9ICh6biBeICh6biAtIDFuKSkgPj4gMW47XG4gIGZvciAoaSA9IDA7IHpuICE9PSAwbjsgaSsrKSB6biA+Pj0gMW47XG4gIHJldHVybiBpO1xufVxuXG4vL2V4dGVybmFsIHBvcGNvdW50OiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9wb3Bjb3VudFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel9wb3Bjb3VudCh6KSB7XG4gIGlmICh6IDwgMCkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIHogPSBCaWdJbnQoeik7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAwOyB6ICE9PSAwbjsgaSsrKSB7XG4gICAgeiAmPSB6IC0gMW47XG4gIH1cbiAgaWYgKGkgIT09IChpIHwgMCkpIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICByZXR1cm4gaSB8IDA7XG59XG5cbi8vZXh0ZXJuYWwgaGFtZGlzdDogdCAtPiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9oYW1kaXN0XG4vL1JlcXVpcmVzOiBtbF96X3BvcGNvdW50LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfcmFpc2VfY29uc3RhbnRcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2hhbWRpc3QoejEsIHoyKSB7XG4gIGlmICgoejEgPCAwKSAhPT0gKHoyIDwgMCkpIHtcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgfVxuICBpZiAoKHR5cGVvZiB6MSA9PSAnYmlnbnVtJyB8fCB0eXBlb2YgejIgPT0gJ2JpZ251bScpICYmICh6MSA8IDAgfHwgejIgPCAwKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouaGFtZGlzdDogbmVnYXRpdmUgYXJndW1lbnRzXCIpO1xuICB9XG4gIHJldHVybiBtbF96X3BvcGNvdW50KEJpZ0ludCh6MSkgXiBCaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBzaXplOiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9zaXplIGNvbnN0XG5mdW5jdGlvbiBtbF96X3NpemUoejEpIHtcbiAgLy8gQ2xhaW0gdG8gYmUgYSAzMi1iaXQgYXJjaGl0ZWN0dXJlLlxuICBpZiAoejEgPCAwKSB6MSA9IC16MTtcbiAgbGV0IHoxbiA9IEJpZ0ludCh6MSk7XG4gIGxldCBsZW4gPSAxO1xuICB3aGlsZSAoejFuID49IDIgKiogMzIpIHsgbGVuICs9IDE7IHoxbiA+Pj0gMzJuOyB9XG4gIHJldHVybiBsZW4gfCAwO1xufVxuXG4vL2V4dGVybmFsIGRpdmV4YWN0OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9kaXZleGFjdFxuLy9SZXF1aXJlczogbWxfel9kaXZcbmZ1bmN0aW9uIG1sX3pfZGl2ZXhhY3QoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X2Rpdih6MSwgejIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfemFyaXRoX21hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfemFyaXRoX21hcnNoYWwod3JpdGVyLCB2LCBzeikge1xuICBsZXQgdm4gPSBCaWdJbnQodik7XG4gIGxldCBuZWcgPSB2biA8IDA7XG4gIGlmIChuZWcpIHZuID0gLXZuO1xuICBsZXQgYml0cyA9IFtdO1xuICB3aGlsZSAodm4gPj0gMiAqKiAzMikge1xuICAgIGJpdHMucHVzaChOdW1iZXIodm4gJiAweGZmZmZmZmZmbikpO1xuICAgIHZuID4+PSAzMm47XG4gIH1cbiAgYml0cy5wdXNoKE51bWJlcih2bikgfCAwKTtcbiAgd3JpdGVyLndyaXRlKDgsIG5lZyA/IDEgOiAwKTtcbiAgbGV0IGJsb2NrID0gYml0cy5sZW5ndGg7XG4gIGxldCBsZW4gPSBibG9jayAqIDQ7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jazsgaSsrKSB7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzW2ldID4+PiAwKSAmIDB4ZmYpO1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0c1tpXSA+Pj4gOCkgJiAweGZmKTtcbiAgICB3cml0ZXIud3JpdGUoOCwgKGJpdHNbaV0gPj4+IDE2KSAmIDB4ZmYpO1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0c1tpXSA+Pj4gMjQpICYgMHhmZik7XG4gIH1cbiAgc3pbMF0gPSA0ICogKDEgKyAoKChsZW4gKyAzKSAvIDQpIHwgMCkpO1xuICBzelsxXSA9IDggKiAoMSArICgoKGxlbiArIDcpIC8gOCkgfCAwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfemFyaXRoX3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIGNhbWxfemFyaXRoX3VubWFyc2hhbChyZWFkZXIsIHN6KSB7XG4gIGxldCBuZWdhdGU7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSgpKSB7XG4gICAgY2FzZSAxOiBuZWdhdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlIDA6IG5lZ2F0ZSA9IGZhbHNlOyBicmVhaztcbiAgICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHogKG1hbGZvcm1lZCBpbnB1dClcIik7XG4gIH1cbiAgbGV0IGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gIGxldCB4ID0gMG47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC8gNDsgaSsrKSB7XG4gICAgbGV0IHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgeSB8PSByZWFkZXIucmVhZDh1KCkgPDwgOFxuICAgIHkgfD0gcmVhZGVyLnJlYWQ4dSgpIDw8IDE2XG4gICAgeSB8PSByZWFkZXIucmVhZDh1KCkgPDwgMjRcbiAgICB4IHw9IEJpZ0ludC5hc1VpbnROKDMyLCBCaWdJbnQoeSkpIDw8IChCaWdJbnQoaSkgKiAzMm4pO1xuICB9XG4gIGlmIChuZWdhdGUpIHggPSAteDtcbiAgc3pbMF0gPSBsZW4gKyA0O1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoeClcbn1cblxuLy9Qcm92aWRlczogbWxfel9kaXZpc2libGVcbmZ1bmN0aW9uIG1sX3pfZGl2aXNpYmxlKGEsIGIpIHtcbiAgaWYgKGEgPT0gMCAmJiBiID09IDApIHJldHVybiAxO1xuICBpZiAoYiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKGIgPT0gMSkgcmV0dXJuIDE7XG4gIGlmIChiID09IDIgfHwgYiA9PSAtMikgcmV0dXJuICsoKEJpZ0ludChhKSAmIDFuKSA9PT0gMG4pO1xuICByZXR1cm4gKygoQmlnSW50KGEpICUgQmlnSW50KGIpKSA9PT0gMG4pO1xufVxuXG4vL1Byb3ZpZGVzOiBtbF96X2NvbmdydWVudFxuLy9SZXF1aXJlczogbWxfel9kaXZpc2libGVcbmZ1bmN0aW9uIG1sX3pfY29uZ3J1ZW50KGEsIGIsIGMpIHtcbiAgcmV0dXJuIG1sX3pfZGl2aXNpYmxlKEJpZ0ludChhKSAtIEJpZ0ludChiKSwgYyk7XG59XG5cbi8vZXh0ZXJuYWwgcmVtb3ZlIDogdCAtPiB0IC0+IHQgKiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfcmVtb3ZlXG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZSwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gbWxfel9yZW1vdmUoYSwgYikge1xuICBpZiAoYiA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIGlmIChhID09IDAgfHwgYiA9PSAxIHx8IGIgPT0gLTEpIHJldHVybiBbMCwgYSwgMF07XG4gIGxldCBpID0gMDtcbiAgYSA9IEJpZ0ludChhKTtcbiAgYiA9IEJpZ0ludChiKTtcbiAgd2hpbGUgKChhICUgYikgPT09IDBuKSB7XG4gICAgYSAvPSBiO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gWzAsIG1sX3pfbm9ybWFsaXplKGEpLCBpXTtcbn1cblxuLy9leHRlcm5hbCBmYWMgOiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9mYWNcbi8vUmVxdWlyZXM6IG1sX3pfZmFjTSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X2ZhYyhpKSB7XG4gIGlmIChpIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5mYWM6IG5vbi1wb3NpdGl2ZSBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIG1sX3pfZmFjTShpLCAxKTtcbn1cblxuLy9leHRlcm5hbCBmYWMyIDogaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZmFjMlxuLy9SZXF1aXJlczogbWxfel9mYWNNLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfZmFjMihpKSB7XG4gIGlmIChpIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5mYWMyOiBub24tcG9zaXRpdmUgYXJndW1lbnRcIik7XG4gIHJldHVybiBtbF96X2ZhY00oaSwgMik7XG59XG5cbi8vZXh0ZXJuYWwgZmFjTSA6IGludCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9mYWNNXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2ZhY00oaSwgbSkge1xuICBpZiAoaSA8IDAgfHwgbSA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouZmFjTTogbm9uLXBvc2l0aXZlIGFyZ3VtZW50XCIpO1xuICBpZiAobSA9PSAwKSByZXR1cm4gaTtcbiAgbGV0IG1uID0gQmlnSW50KG0pO1xuICBsZXQgY3VycmVudCA9IEJpZ0ludChpKTtcbiAgbGV0IHJlcyA9IDFuO1xuICB3aGlsZSAoY3VycmVudCA+IDApIHtcbiAgICByZXMgKj0gY3VycmVudDtcbiAgICBjdXJyZW50IC09IG1uO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShyZXMpO1xufVxuXG4vL2V4dGVybmFsIGZpYiA6IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2ZpYlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9maWIoaSkge1xuICBpZiAoaSA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouZmliOiBuZWdhdGl2ZSBhcmd1bWVudHNcIik7XG4gIGlmIChpID09IDAgfHwgaSA9PSAxKSByZXR1cm4gaTtcbiAgbGV0IGEgPSAwbiwgYiA9IDFuO1xuICBmb3IgKGxldCBrID0gMTsgayA8IGk7IGsrKykge1xuICAgIGxldCBiMiA9IGI7XG4gICAgYiArPSBhO1xuICAgIGEgPSBiMjtcbiAgfVxuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYik7XG59XG5cbi8vZXh0ZXJuYWwgbHVjbnVtIDogaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbHVjbnVtXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2x1Y251bShpKSB7XG4gIGlmIChpIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5sdWNudW06IG5lZ2F0aXZlIGFyZ3VtZW50c1wiKTtcbiAgaWYgKGkgPT0gMCkgcmV0dXJuIDI7XG4gIGlmIChpID09IDEpIHJldHVybiAxO1xuICBsZXQgYSA9IDJuLCBiID0gMW47XG4gIGZvciAobGV0IGsgPSAxOyBrIDwgaTsgaysrKSB7XG4gICAgbGV0IGIyID0gYjtcbiAgICBiICs9IGE7XG4gICAgYSA9IGIyO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiKTtcbn1cblxuLy9Qcm92aWRlczogbWxfel9qYWNvYmlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9qYWNvYmkobiwgaykge1xuICBsZXQgbm4gPSBCaWdJbnQobik7XG4gIGxldCBrbiA9IEJpZ0ludChrKTtcbiAgLy9hc3NlcnQoayA+IDAgYW5kIGsgJSAyID09IDEpXG4gIGlmIChrbiA8PSAwIHx8IGtuICUgMm4gIT09IDFuKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouamFjb2JpOiBzZWNvbmQgYXJndW1lbnQgaXMgbmVnYXRpdmUgb3IgZXZlblwiKTtcbiAgbm4gPSBubiAlIGtuO1xuICBpZiAobm4gPCAwKSBubiArPSBrbjtcbiAgbGV0IHQgPSAxO1xuICB3aGlsZSAobm4gIT09IDBuKSB7XG4gICAgd2hpbGUgKG5uICUgMm4gPT09IDBuKSB7XG4gICAgICBubiAvPSAybjtcbiAgICAgIGxldCByID0ga24gJSA4blxuICAgICAgaWYgKHIgPT09IDNuIHx8IHIgPT09IDVuKSB7XG4gICAgICAgIHQgPSAtdFxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbjEgPSBubiwgazEgPSBrbjtcbiAgICBubiA9IGsxO1xuICAgIGtuID0gbjE7XG4gICAgaWYgKG5uICUgNG4gPT09IDNuICYmIGtuICUgNG4gPT09IDNuKSB7XG4gICAgICB0ID0gLXRcbiAgICB9XG4gICAgbm4gPSBubiAlIGtuXG4gIH1cbiAgaWYgKGtuID09PSAxbilcbiAgICByZXR1cm4gdFxuICBlbHNlXG4gICAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogbWxfel9sZWdlbmRyZVxuLy9SZXF1aXJlczogbWxfel9qYWNvYmlcbmZ1bmN0aW9uIG1sX3pfbGVnZW5kcmUoYSwgYikge1xuICByZXR1cm4gbWxfel9qYWNvYmkoYSwgYik7XG59XG5cbi8vUHJvdmlkZXM6IG1sX3pfa3JvbmVja2VyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBtbF96X2tyb25lY2tlcihuLCBrKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJtbF96X2tyb25lY2tlciBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IG1sX3pfcHJpbW9yaWFsXG4vL1JlcXVpcmVzOiBtbF96X3Byb2JhYl9wcmltZSwgbWxfel9ub3JtYWxpemUsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9wcmltb3JpYWwoYSkge1xuICBpZiAoYSA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucHJpbW9yaWFsOiBub24tcG9zaXRpdmUgYXJndW1lbnRcIik7XG4gIGxldCB6MSA9IDFuO1xuICBsZXQgcmVzID0gMW47XG4gIHdoaWxlICh6MSA8PSBhKSB7XG4gICAgaWYgKG1sX3pfcHJvYmFiX3ByaW1lKHoxLCAyNSkpIHtcbiAgICAgIHJlcyAqPSB6MTtcbiAgICB9XG4gICAgaWYgKHoxID09PSAxbiB8fCB6MSA9PT0gMm4pIHoxICs9IDFuO1xuICAgIGVsc2UgejEgKz0gMm47XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHJlcyk7XG59XG5cbi8vUHJvdmlkZXM6IG1sX3pfYmluXG4vL1JlcXVpcmVzOiBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X2JpbihuLCBrKSB7XG4gIGlmIChrIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5iaW46IG5vbi1wb3NpdGl2ZSBhcmd1bWVudFwiKTtcbiAgbiA9IEJpZ0ludChuKTtcbiAgayA9IEJpZ0ludChrKTtcbiAgbGV0IGNvZWZmID0gMW47XG4gIGZvciAobGV0IHggPSBuIC0gayArIDFuOyB4IDw9IG47IHgrKykgY29lZmYgKj0geDtcbiAgZm9yIChsZXQgeCA9IDFuOyB4IDw9IGs7IHgrKykgY29lZmYgLz0geDtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGNvZWZmKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8qIDB4MDAtMHgxRjogbm9uZSAqLywgMHgwMCwgMHgwMCwgMHhmZixcbiAgICAweDAzIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqLywgMHhmZSwgMHhmZiwgMHhmZixcbiAgICAweDg3IC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovLCAweGZlLCAweGZmLCAweGZmLFxuICAgIDB4MDcgLyogMHg2MC0weDdGOiBhIHRvIHogKi8sIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLyogMHg4MC0weDlGOiBub25lICovLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLyogMHhBMC0weEJGOiBub25lICovLCAweGZmLCAweGZmLCAweDdmLFxuICAgIDB4ZmYgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqLywgMHhmZiwgMHhmZiwgMHg3ZixcbiAgICAweGZmIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi8sXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCxcbiAgICBDSEFSTk9STTogMSxcbiAgICBTVFJJTkc6IDIsXG4gICAgU1RSSU5HTk9STTogMyxcbiAgICBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LFxuICAgIEVPTDogNixcbiAgICBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsXG4gICAgRU5ER1JPVVA6IDksXG4gICAgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMixcbiAgICBTSU1QTEVTVEFSOiAxMyxcbiAgICBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSxcbiAgICBQVVNIQkFDSzogMTYsXG4gICAgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMTgsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzW2MgPj4gM10gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsIGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLCBpID4+IDMpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuICAgIHZhciBwcm9nID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgIGNwb29sID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgIG5vcm10YWJsZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgbnVtZ3JvdXBzID0gcmVbNF0gfCAwLFxuICAgICAgbnVtcmVnaXN0ZXJzID0gcmVbNV0gfCAwLFxuICAgICAgc3RhcnRjaGFycyA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgc3RhY2sgPSBbXSxcbiAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBncm91cHNbaV0gPSB7IHN0YXJ0OiAtMSwgZW5kOiAtMSB9O1xuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzdGFjay5wdXNoKGl0ZW0pO1xuICAgIH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGggKiAyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmIChnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMiAqIGkgKyAxXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyICogaSArIDEgKyAxXSA9IGcuZW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJ0aWFsKSByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgIH07XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmVmaXhfbWF0Y2goKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmVmaXhfbWF0Y2goKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7XG4gICAgICAgICAgICBpIDwgYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKSBjID0gc1srK3Bvc107XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7XG4gICAgICAgICAgICBpIDwgYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSkgYyA9IHNbKytwb3NdO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgICAgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICAgIGlmIChwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT09IDEwIC8qIFxcbiAqLykge1xuICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICAgIGlmIChwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT09IDEwIC8qIFxcbiAqLykge1xuICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuV09SREJPVU5EQVJZOlxuICAgICAgICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc193b3JkX2xldHRlcihzWzBdKSkgYnJlYWs7XG4gICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9PSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkJFR0dST1VQOlxuICAgICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICAgIHB1c2goeyB1bmRvOiB7IG9iajogZ3JvdXAsIHByb3A6IFwic3RhcnRcIiwgdmFsdWU6IGdyb3VwLnN0YXJ0IH0gfSk7XG4gICAgICAgICAgZ3JvdXAuc3RhcnQgPSBwb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgICBwdXNoKHsgdW5kbzogeyBvYmo6IGdyb3VwLCBwcm9wOiBcImVuZFwiLCB2YWx1ZTogZ3JvdXAuZW5kIH0gfSk7XG4gICAgICAgICAgZ3JvdXAuZW5kID0gcG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgICAgaWYgKGdyb3VwLnN0YXJ0IDwgMCB8fCBncm91cC5lbmQgPCAwKSB7XG4gICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNbaV0gIT09IHNbcG9zXSkge1xuICAgICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuU0lNUExFUExVUzpcbiAgICAgICAgICBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgICAgfSBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICAgIHJldHVybiBhY2NlcHQoKTtcbiAgICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgICBwdXNoKHsgcG9zOiB7IHBjOiBwYyArIHNhcmcsIHR4dDogcG9zIH0gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5TRVRNQVJLOlxuICAgICAgICAgIHB1c2goe1xuICAgICAgICAgICAgdW5kbzogeyBvYmo6IHJlX3JlZ2lzdGVyLCBwcm9wOiB1YXJnLCB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ10gfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkNIRUNLUFJPR1JFU1M6XG4gICAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmIChwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIik7XG4gIHdoaWxlIChwb3MgPD0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gWzBdOyAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZiAocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnNlYXJjaF9iYWNrd2FyZFwiKTtcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUsIHMsIHBvcykge1xuICBpZiAocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKTtcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3BhcnRpYWxfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfcGFydGlhbF9tYXRjaChyZSwgcywgcG9zKSB7XG4gIGlmIChwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKTtcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCwgZ3JvdXBzLCBvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlIChuIDwgbGVuKSB7XG4gICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICBpZiAoY3VyICE9PSBcIlxcXFxcIikge1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gPT09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2ggKGN1cikge1xuICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgICAgaWYgKGMgKiAyID49IGdyb3Vwcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjICogMik7XG4gICAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjICogMiArIDEpO1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IHJlZmVyZW5jZSB0byB1bm1hdGNoZWQgZ3JvdXBcIik7XG4gICAgICAgICAgcmVzICs9IG9yaWcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzICs9IFwiXFxcXFwiICsgY3VyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpO1xufVxuIl0sImlnbm9yZUxpc3QiOlswLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzOCw0MF19fSx7Im9mZnNldCI6eyJsaW5lIjo5Njg4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZXJhc2VfcmVsIiwicGFyYW0iLCJyZXN0IiwidHkiLCJ0eTEiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwcmVjIiwiaWNvbnYiLCJmY29udiIsInN0ciIsImNociIsImZtdHR5IiwiZm10aW5nX2xpdCIsImZtdGluZ19nZW4iLCJjaGFyX3NldCIsIndpZHRoX29wdCIsImNvdW50ZXIiLCJpZ24iLCJmIiwiYXJpdHkiLCJDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQSxJQytnQlEsOEJBa0NZO0FBQUEsSUFsQ1o7QUFBQTtBQUFBLFdBQUFDLE9BQUEsVUFLSSwyQkFBZ0I7QUFBQTtBQUFBLFdBQUFBLFNBTHBCLFVBT00sNkJBQWdCO0FBQUE7QUFBQSxXQUFBQSxTQVB0QixVQVNHLDZCQUFnQjtBQUFBO0FBQUEsV0FBQUEsU0FUbkIsVUFXSyw2QkFBZ0I7QUFBQTtBQUFBLFdBQUFBLFNBWHJCLFVBZVMsNkJBQWdCO0FBQUE7QUFBQSxXQUFBQSxTQWZ6QixVQWFLLDZCQUFnQjtBQUFBO0FBQUEsV0FBQUEsU0FickIsVUFpQkssNkJBQWdCO0FBQUE7QUFBQSxXQUFBQSxTQWpCckIsVUFtQkksNkJBQWdCO0FBQUE7QUFBQSxXQUFBQSxTQW5CcEIsVUFBQUMsS0FBQTtBQUFBLE9BcUJlLGlDQUFjO0FBQUE7QUFBQSxXQUFBRCxTQXJCN0IsVUFBQUUsTUFBQTtBQUFBLE9BdUJ1Qix1Q0FBYztBQUFBO0FBQUEsV0FBQUYsU0F2QnJDLFVBeUJLLDhCQUFnQjtBQUFBO0FBQUEsV0FBQUEsVUF6QnJCLFVBMkJLLCtCQUFnQjtBQUFBO0FBQUEsV0FBQUEsVUEzQnJCLFVBNkJHLCtCQUFnQjtBQUFBO0FBQUEsV0FBQUEsVUE3Qm5CLFVBK0JNLCtCQUFnQjtBQUFBLG1CQUFBQSxVQS9CdEIsVUFpQ2MsK0JBQWdCO0FBQUE7QUFBQSxHQUNOO0FBQUEsWUFBQUcsYUFB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RG5DLFNBOEJOLHNDQUFzQjtBQUFBO0FBQUEsV0FBQUEsVUE5QmhCLFNBQUFtQixXQUFBLFNBQUFDLFlBQUE7QUFBQSxPQTZDdUIsMkRBQW9CO0FBQUE7QUFBQSxXQUFBcEIsVUE3QzNDLFNBQUFxQixVQUFBO0FBQUEsT0ErQ2MsK0NBQW9CO0FBQUE7QUFBQSxXQUFBckIsVUEvQ2xDLFNBaURFLHNDQUFzQjtBQUFBO0FBQUEsV0FBQUEsVUFqRHhCLFNBQUFzQixNQUFBO0FBQUEsT0FtRE8sMkNBQW9CO0FBQUE7QUFBQSxXQUFBdEIsVUFuRDNCLFNBQUF1QixJQUFBLFNBQUFDLFFBQUE7QUFBQSxPQTRCSyxnREFBb0I7QUFBQTtBQUFBLEdBK0JsQztBQUFBLE9BQUFDLDJCRGpyQlIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjk4NjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfZmFsc2UiLCJjc3RfdHJ1ZSIsImNhbWxfYXRvbWljX2NhcyIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9tbF9mbHVzaCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19jb25jYXQiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfc3lzX29wZW4iLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzIiwiSW52YWxpZF9hcmd1bWVudCIsIkZhaWx1cmUiLCJNYXRjaF9mYWlsdXJlIiwiQXNzZXJ0X2ZhaWx1cmUiLCJOb3RfZm91bmQiLCJPdXRfb2ZfbWVtb3J5IiwiU3RhY2tfb3ZlcmZsb3ciLCJTeXNfZXJyb3IiLCJFbmRfb2ZfZmlsZSIsIkRpdmlzaW9uX2J5X3plcm8iLCJTeXNfYmxvY2tlZF9pbyIsIlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJFeGl0IiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0Iiwic3ltYm9sX2NvbmNhdCIsImNzdF9jaGFyX29mX2ludCIsImNzdF9ib29sX29mX3N0cmluZyIsImNoYXJfb2ZfaW50IiwibiIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwicGFyYW0iLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsInMxIiwibCIsImkiLCJtYXRjaCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzeW1ib2wiLCJsMSIsImwyIiwiaDEiLCJoMiIsInRsIiwiaDMiLCJibG9jayIsImRzdCIsIm9mZnNldCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwiY3N0X291dHB1dCIsImNzdF9vdXRwdXRfc3Vic3RyaW5nIiwiY3N0X2lucHV0IiwiY3N0X3JlYWxseV9pbnB1dCIsIm9wZW5fb3V0X2dlbiIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsImZsdXNoX2FsbCIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsInYiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0IiwiciIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9saW5lIiwiYnVpbGRfcmVzdWx0IiwiYnVmIiwicG9zIiwiaGQiLCJhY2N1IiwiYmVnIiwicmVzIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsInN0ciIsInN0cjIiLCJmbXQyIiwic3RyMSIsImZtdDEiLCJzMiIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCIsInN1Y2Nlc3MiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsIlN0ZGxpYiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvc3RkbGliLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEcmtCL0QiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjhfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyAoIEAgKSBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IGgxIDo6IFtdIC0+IGgxIDo6IGwyXG4gIHwgaDEgOjogaDIgOjogW10gLT4gaDEgOjogaDIgOjogbDJcbiAgfCBoMSA6OiBoMiA6OiBoMyA6OiB0bCAtPiBoMSA6OiBoMiA6OiBoMyA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbigqIGZvciBhdF9leGl0ICopXG50eXBlICdhIGF0b21pY190XG5leHRlcm5hbCBhdG9taWNfbWFrZSA6ICdhIC0+ICdhIGF0b21pY190ID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgYXRvbWljX2dldCA6ICdhIGF0b21pY190IC0+ICdhID0gXCIlYXRvbWljX2xvYWRcIlxuZXh0ZXJuYWwgYXRvbWljX2NvbXBhcmVfYW5kX3NldCA6ICdhIGF0b21pY190IC0+ICdhIC0+ICdhIC0+IGJvb2xcbiAgPSBcIiVhdG9taWNfY2FzXCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSBhdG9taWNfbWFrZSBmbHVzaF9hbGxcblxubGV0IHJlYyBhdF9leGl0IGYgPVxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfeWV0X3RvX3J1biA9IGF0b21pY19tYWtlIHRydWUgaW5cbiAgbGV0IG9sZF9leGl0ID0gYXRvbWljX2dldCBleGl0X2Z1bmN0aW9uIGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgaWYgYXRvbWljX2NvbXBhcmVfYW5kX3NldCBmX3lldF90b19ydW4gdHJ1ZSBmYWxzZSB0aGVuIGYgKCkgO1xuICAgIG9sZF9leGl0ICgpXG4gIGluXG4gIGxldCBzdWNjZXNzID0gYXRvbWljX2NvbXBhcmVfYW5kX3NldCBleGl0X2Z1bmN0aW9uIG9sZF9leGl0IG5ld19leGl0IGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gYXRfZXhpdCBmXG5cbmxldCBkb19kb21haW5fbG9jYWxfYXRfZXhpdCA9IHJlZiAoZnVuICgpIC0+ICgpKVxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9XG4gICghZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQpICgpO1xuICAoYXRvbWljX2dldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICAgID0gQXJyYXlcbm1vZHVsZSBBcnJheUxhYmVscyAgICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQXRvbWljICAgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgICA9IEJpZ2FycmF5XG5tb2R1bGUgQm9vbCAgICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgICA9IEJ5dGVzXG5tb2R1bGUgQnl0ZXNMYWJlbHMgICAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgICA9IENoYXJcbm1vZHVsZSBDb21wbGV4ICAgICAgICA9IENvbXBsZXhcbm1vZHVsZSBDb25kaXRpb24gICAgICA9IENvbmRpdGlvblxubW9kdWxlIERpZ2VzdCAgICAgICAgID0gRGlnZXN0XG5tb2R1bGUgRG9tYWluICAgICAgICAgPSBEb21haW5cbm1vZHVsZSBFZmZlY3QgICAgICAgICA9IEVmZmVjdFxubW9kdWxlIEVpdGhlciAgICAgICAgID0gRWl0aGVyXG5tb2R1bGUgRXBoZW1lcm9uICAgICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgICAgPSBGbG9hdFxubW9kdWxlIEZvcm1hdCAgICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgICA9IEdjXG5tb2R1bGUgSGFzaHRibCAgICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW5fY2hhbm5lbCAgICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBNdXRleCAgICAgICAgICA9IE11dGV4XG5tb2R1bGUgTmF0aXZlaW50ICAgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgICA9IE9wdGlvblxubW9kdWxlIE91dF9jaGFubmVsICAgID0gT3V0X2NoYW5uZWxcbm1vZHVsZSBQYXJzaW5nICAgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQcmludGV4YyAgICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZW1hcGhvcmUgICAgICA9IFNlbWFwaG9yZVxubW9kdWxlIFNlcSAgICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTdGFjayAgICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJpbmcgICAgICAgICA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ0xhYmVscyAgID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgICAgPSBTeXNcbm1vZHVsZSBUeXBlICAgICAgICAgICA9IFR5cGVcbm1vZHVsZSBVY2hhciAgICAgICAgICA9IFVjaGFyXG5tb2R1bGUgVW5pdCAgICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgICAgPSBXZWFrXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTAzNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiZ2xvYmFsX2RhdGEiLCJvY2FtbF92ZXJzaW9uIiwib2NhbWxfcmVsZWFzZSIsIlN0ZGxpYiIsImV4ZWN1dGFibGVfbmFtZSIsIm9zX3R5cGUiLCJiYWNrZW5kX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJtYXhfYXJyYXlfbGVuZ3RoIiwibWF4X2Zsb2F0YXJyYXlfbGVuZ3RoIiwibWF4X3N0cmluZ19sZW5ndGgiLCJnZXRlbnZfb3B0IiwicyIsImludGVyYWN0aXZlIiwic2V0X3NpZ25hbCIsInNpZ19udW0iLCJzaWdfYmVoIiwiQnJlYWsiLCJjYXRjaF9icmVhayIsIm9uIiwiTWFrZSIsIkltbWVkaWF0ZTY0IiwiU3RkbGliX1N5cyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvc3lzLm1sLmluIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxrQkNtQ3NCO0FBQUEsSUFBQUMsVUFDQTtBQUFBLElBQUFDLGVBQVk7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxZQUFBQyxXQUFBQztBQUFBQSxJQXVCaEMsY0FBUztBQUFBO0FBQUEsZUQzRFg7QUFBQSwyQkM0RG9CO0FBQUEsS0Q1RHBCO0FBQUE7QUFBQSxHQzREd0I7QUFBQSxPQUFBQyxjQXhCVTtBQUFBLFlBQUFDLFdBQUFDLFNBQUFDLFNBNkM2QjtBQUFBLE9BQUFDLFFBN0M3QjtBQUFBLFlBQUFDLFlBQUFDLElBK0VoQyxpQkFHa0M7QUFBQSxZQUFBQyxLQUFBLFVBc0Q1QjtBQUFBO0FBQUEsSUFBQUMsY0F4STBCO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHBDbEMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIEBjb25maWd1cmVfaW5wdXRAICopXG4jMyBcInN5cy5tbC5pblwiXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgYmFja2VuZF90eXBlID1cbiAgfCBOYXRpdmVcbiAgfCBCeXRlY29kZVxuICB8IE90aGVyIG9mIHN0cmluZ1xuKCogU3lzdGVtIGludGVyZmFjZSAqKVxuXG5leHRlcm5hbCBnZXRfY29uZmlnOiB1bml0IC0+IHN0cmluZyAqIGludCAqIGJvb2wgPSBcImNhbWxfc3lzX2dldF9jb25maWdcIlxuZXh0ZXJuYWwgZ2V0X2V4ZWN1dGFibGVfbmFtZSA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWVcIlxuZXh0ZXJuYWwgYXJndiA6IHN0cmluZyBhcnJheSA9IFwiJXN5c19hcmd2XCJcbmV4dGVybmFsIGJpZ19lbmRpYW4gOiB1bml0IC0+IGJvb2wgPSBcIiViaWdfZW5kaWFuXCJcbmV4dGVybmFsIHdvcmRfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIld29yZF9zaXplXCJcbmV4dGVybmFsIGludF9zaXplIDogdW5pdCAtPiBpbnQgPSBcIiVpbnRfc2l6ZVwiXG5leHRlcm5hbCBtYXhfd29zaXplIDogdW5pdCAtPiBpbnQgPSBcIiVtYXhfd29zaXplXCJcbmV4dGVybmFsIHVuaXggOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfdW5peFwiXG5leHRlcm5hbCB3aW4zMiA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV93aW4zMlwiXG5leHRlcm5hbCBjeWd3aW4gOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfY3lnd2luXCJcbmV4dGVybmFsIGdldF9iYWNrZW5kX3R5cGUgOiB1bml0IC0+IGJhY2tlbmRfdHlwZSA9IFwiJWJhY2tlbmRfdHlwZVwiXG5cbmxldCBleGVjdXRhYmxlX25hbWUgPSBnZXRfZXhlY3V0YWJsZV9uYW1lKClcbmxldCAob3NfdHlwZSwgXywgXykgPSBnZXRfY29uZmlnKClcbmxldCBiYWNrZW5kX3R5cGUgPSBnZXRfYmFja2VuZF90eXBlICgpXG5sZXQgYmlnX2VuZGlhbiA9IGJpZ19lbmRpYW4gKClcbmxldCB3b3JkX3NpemUgPSB3b3JkX3NpemUgKClcbmxldCBpbnRfc2l6ZSA9IGludF9zaXplICgpXG5sZXQgdW5peCA9IHVuaXggKClcbmxldCB3aW4zMiA9IHdpbjMyICgpXG5sZXQgY3lnd2luID0gY3lnd2luICgpXG5sZXQgbWF4X2FycmF5X2xlbmd0aCA9IG1heF93b3NpemUgKClcbmxldCBtYXhfZmxvYXRhcnJheV9sZW5ndGggPSBtYXhfYXJyYXlfbGVuZ3RoIC8gKDY0IC8gd29yZF9zaXplKVxubGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxXG5leHRlcm5hbCBydW50aW1lX3ZhcmlhbnQgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9ydW50aW1lX3ZhcmlhbnRcIlxuZXh0ZXJuYWwgcnVudGltZV9wYXJhbWV0ZXJzIDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXCJcblxuZXh0ZXJuYWwgZmlsZV9leGlzdHM6IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N5c19maWxlX2V4aXN0c1wiXG5leHRlcm5hbCBpc19kaXJlY3RvcnkgOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5XCJcbmV4dGVybmFsIGlzX3JlZ3VsYXJfZmlsZSA6IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGVcIlxuZXh0ZXJuYWwgcmVtb3ZlOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcmVtb3ZlXCJcbmV4dGVybmFsIHJlbmFtZSA6IHN0cmluZyAtPiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcmVuYW1lXCJcbmV4dGVybmFsIGdldGVudjogc3RyaW5nIC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZ2V0ZW52XCJcblxubGV0IGdldGVudl9vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKGdldGVudiBzKVxuICB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG5cbmV4dGVybmFsIGNvbW1hbmQ6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXCJcbmV4dGVybmFsIHRpbWU6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX3N5c190aW1lXCIgXCJjYW1sX3N5c190aW1lX3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2hkaXI6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19jaGRpclwiXG5leHRlcm5hbCBta2Rpcjogc3RyaW5nIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19ta2RpclwiXG5leHRlcm5hbCBybWRpcjogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX3JtZGlyXCJcbmV4dGVybmFsIGdldGN3ZDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfc3lzX2dldGN3ZFwiXG5leHRlcm5hbCByZWFkZGlyIDogc3RyaW5nIC0+IHN0cmluZyBhcnJheSA9IFwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnlcIlxuXG5sZXQgaW50ZXJhY3RpdmUgPSByZWYgZmFsc2VcblxudHlwZSBzaWduYWxfYmVoYXZpb3IgPVxuICAgIFNpZ25hbF9kZWZhdWx0XG4gIHwgU2lnbmFsX2lnbm9yZVxuICB8IFNpZ25hbF9oYW5kbGUgb2YgKGludCAtPiB1bml0KVxuXG5leHRlcm5hbCBzaWduYWwgOiBpbnQgLT4gc2lnbmFsX2JlaGF2aW9yIC0+IHNpZ25hbF9iZWhhdmlvclxuICAgICAgICAgICAgICAgID0gXCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXJcIlxuXG5sZXQgc2V0X3NpZ25hbCBzaWdfbnVtIHNpZ19iZWggPSBpZ25vcmUoc2lnbmFsIHNpZ19udW0gc2lnX2JlaClcblxubGV0IHNpZ2FicnQgPSAtMVxubGV0IHNpZ2Fscm0gPSAtMlxubGV0IHNpZ2ZwZSA9IC0zXG5sZXQgc2lnaHVwID0gLTRcbmxldCBzaWdpbGwgPSAtNVxubGV0IHNpZ2ludCA9IC02XG5sZXQgc2lna2lsbCA9IC03XG5sZXQgc2lncGlwZSA9IC04XG5sZXQgc2lncXVpdCA9IC05XG5sZXQgc2lnc2VndiA9IC0xMFxubGV0IHNpZ3Rlcm0gPSAtMTFcbmxldCBzaWd1c3IxID0gLTEyXG5sZXQgc2lndXNyMiA9IC0xM1xubGV0IHNpZ2NobGQgPSAtMTRcbmxldCBzaWdjb250ID0gLTE1XG5sZXQgc2lnc3RvcCA9IC0xNlxubGV0IHNpZ3RzdHAgPSAtMTdcbmxldCBzaWd0dGluID0gLTE4XG5sZXQgc2lndHRvdSA9IC0xOVxubGV0IHNpZ3Z0YWxybSA9IC0yMFxubGV0IHNpZ3Byb2YgPSAtMjFcbmxldCBzaWdidXMgPSAtMjJcbmxldCBzaWdwb2xsID0gLTIzXG5sZXQgc2lnc3lzID0gLTI0XG5sZXQgc2lndHJhcCA9IC0yNVxubGV0IHNpZ3VyZyA9IC0yNlxubGV0IHNpZ3hjcHUgPSAtMjdcbmxldCBzaWd4ZnN6ID0gLTI4XG5cbmV4Y2VwdGlvbiBCcmVha1xuXG5sZXQgY2F0Y2hfYnJlYWsgb24gPVxuICBpZiBvbiB0aGVuXG4gICAgc2V0X3NpZ25hbCBzaWdpbnQgKFNpZ25hbF9oYW5kbGUoZnVuIF8gLT4gcmFpc2UgQnJlYWspKVxuICBlbHNlXG4gICAgc2V0X3NpZ25hbCBzaWdpbnQgU2lnbmFsX2RlZmF1bHRcblxuXG5leHRlcm5hbCBlbmFibGVfcnVudGltZV93YXJuaW5nczogYm9vbCAtPiB1bml0ID1cbiAgXCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXCJcbmV4dGVybmFsIHJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZDogdW5pdCAtPiBib29sID1cbiAgXCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFwiXG5cbigqIFRoZSB2ZXJzaW9uIHN0cmluZyBpcyBmb3VuZCBpbiBmaWxlIC4uL1ZFUlNJT04gKilcblxubGV0IG9jYW1sX3ZlcnNpb24gPSBcIkBWRVJTSU9OQFwiXG5cbmxldCBkZXZlbG9wbWVudF92ZXJzaW9uID0gQE9DQU1MX0RFVkVMT1BNRU5UX1ZFUlNJT05AXG5cbnR5cGUgZXh0cmFfcHJlZml4ID0gUGx1cyB8IFRpbGRlXG5cbnR5cGUgZXh0cmFfaW5mbyA9IGV4dHJhX3ByZWZpeCAqIHN0cmluZ1xuXG50eXBlIG9jYW1sX3JlbGVhc2VfaW5mbyA9IHtcbiAgbWFqb3IgOiBpbnQ7XG4gIG1pbm9yIDogaW50O1xuICBwYXRjaGxldmVsIDogaW50O1xuICBleHRyYSA6IGV4dHJhX2luZm8gb3B0aW9uXG59XG5cbmxldCBvY2FtbF9yZWxlYXNlID0ge1xuICBtYWpvciA9IEBPQ0FNTF9WRVJTSU9OX01BSk9SQDtcbiAgbWlub3IgPSBAT0NBTUxfVkVSU0lPTl9NSU5PUkA7XG4gIHBhdGNobGV2ZWwgPSBAT0NBTUxfVkVSU0lPTl9QQVRDSExFVkVMQDtcbiAgZXh0cmEgPSBAT0NBTUxfUkVMRUFTRV9FWFRSQUBcbn1cblxuKCogT3B0aW1pemF0aW9uICopXG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcblxubW9kdWxlIEltbWVkaWF0ZTY0ID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkoTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUpID0gc3RydWN0XG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZTY0XVxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG4gICAgZXh0ZXJuYWwgbWFnaWMgOiBfIHJlcHIgLT4gdCByZXByID0gXCIlaWRlbnRpdHlcIlxuICAgIGxldCByZXByID1cbiAgICAgIGlmIHdvcmRfc2l6ZSA9IDY0IHRoZW5cbiAgICAgICAgbWFnaWMgSW1tZWRpYXRlXG4gICAgICBlbHNlXG4gICAgICAgIG1hZ2ljIE5vbl9pbW1lZGlhdGVcbiAgZW5kXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDQ1OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9PYmpfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfb2JqX3RhZyIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1N5cyIsImlzX2Jsb2NrIiwiYSIsImRvdWJsZV9maWVsZCIsIngiLCJpIiwic2V0X2RvdWJsZV9maWVsZCIsInYiLCJpbmZvIiwib2JqIiwiYXJpdHkiLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwibmFtZSIsImlkIiwiRXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3N0X09ial9FcGhlbWVyb25fY3JlYXRlIiwiY3N0X09ial9FcGhlbWVyb25fZ2V0X2tleSIsImNzdF9PYmpfRXBoZW1lcm9uX2dldF9rZXlfY29weSIsImNzdF9PYmpfRXBoZW1lcm9uX3NldF9rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl91bnNldF9rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl9jaGVja19rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl9ibGl0X2tleSIsImNyZWF0ZSIsImwiLCJsZW5ndGgiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsImUiLCJvIiwibXNnIiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsImUxIiwibzEiLCJlMiIsIm8yIiwiU3RkbGliX09iaiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvb2JqLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGtDQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLFNBQUFDLEdDeUJrQywyQ0FBYztBQUFBLFlBQUFDLGFBQUFDLEdBQUFDLEdBU1Isb0NBQXFDO0FBQUEsWUFBQUMsaUJBQUFGLEdBQUFDLEdBQUFFO0FBQUFBLElBRTNFO0FBQUEsSUFBdUM7QUFBQTtBQUFBO0FBQUEsVURwQ3pDO0FBQUEsSUFBQWpCLGdDQUFBO0FBQUEsSUFBQUEsa0NBQUE7QUFBQSxZQUFBa0IsS0FBQUM7QUFBQUEsSUM2Rlk7QUFBQSxLQUFPO0FBQUE7QUFBQSxLQUFBRCxPQUNIO0FBQUEsS0FBQUUsUUFqQlo7QUFBQSxLQUFBQyxZQVdTO0FBQUEsSUFDVDtBQUFBLEdBSzZCO0FBQUEsWUFBQUMsT0FBQVI7QUFBQUE7QUFBQUE7QUFBQUEsS0FTeEIsa0JBQWdCLGtEQUFBUyxPQUFxRDtBQUFBLFNBQUFBLE9BQ25FO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FHRixxQkFBbUIsZ0NBQUFDLE9BQXlDO0FBQUEsU0FBQUEsT0FDMUQ7QUFBQTtBQUFBLElBRUY7QUFBQTtBQUFBLGNBQ0Usb0RBQXVDO0FBQUE7QUFBQSxZQUFBQSxLQUFBRCxNQUdwQjtBQUFBLFlBQUFFLEdBQUFGLE1BR0E7QUFBQTtBQUFBLElBQUFHLHdCRHJIOUI7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsWUFBQUMsT0FBQUM7QUFBQUEsUUFBQSxNQ21JSTtBQUFBLGdCQUNFO0FBQUEsSUFDRixrQ0FBUTtBQUFBO0FBQUEsWUFBQUMsT0FBQXZCLEdBRUssd0JBQWdDO0FBQUEsWUFBQXdCLHdCQUFBQyxHQUFBQyxHQUFBQztBQUFBQTtBQUFBQSxLQUFBLE1BRzdDO0FBQUEscUJBQXNCO0FBQUEsV0FBdEI7QUFBQSxpQkFDRSxnQ0FBZTtBQUFBO0FBQUEsWUFBQUMsUUFBQUgsR0FBQUM7QUFBQUEsSUFJakI7QUFBQSxJQUNBLHNDQUFXO0FBQUE7QUFBQSxZQUFBRyxhQUFBSixHQUFBQztBQUFBQSxJQUlYO0FBQUEsSUFDQSwyQ0FBZ0I7QUFBQTtBQUFBLFlBQUFJLFFBQUFMLEdBQUFDLEdBQUExQjtBQUFBQSxJQUloQjtBQUFBLElBQ0EseUNBQWE7QUFBQTtBQUFBLFlBQUErQixVQUFBTixHQUFBQztBQUFBQSxJQUliO0FBQUEsSUFDQSx3Q0FBYTtBQUFBO0FBQUEsWUFBQU0sVUFBQVAsR0FBQUM7QUFBQUEsSUFJYjtBQUFBLElBQ0Esd0NBQWE7QUFBQTtBQUFBLFlBQUFPLFNBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFmO0FBQUFBLElBTWI7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUEyQix5Q0FDTjtBQUFBO0FBQUEsWUFFaEI7QUFBQSxrQkFBZTtBQUFBLEtBQWY7QUFBQTtBQUFBLElBREEsd0RBQ3FDO0FBQUE7QUFBQTtBQUFBLElBQUFnQjtBQUFBQSxNRDdLOUMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG50eXBlIHJhd19kYXRhID0gbmF0aXZlaW50XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIHJhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0M1xuXG5sZXQgZm9yY2luZ190YWcgPSAyNDRcbmxldCBjb250X3RhZyA9IDI0NVxubGV0IGxhenlfdGFnID0gMjQ2XG5sZXQgY2xvc3VyZV90YWcgPSAyNDdcbmxldCBvYmplY3RfdGFnID0gMjQ4XG5sZXQgaW5maXhfdGFnID0gMjQ5XG5sZXQgZm9yd2FyZF90YWcgPSAyNTBcblxubGV0IG5vX3NjYW5fdGFnID0gMjUxXG5cbmxldCBhYnN0cmFjdF90YWcgPSAyNTFcbmxldCBzdHJpbmdfdGFnID0gMjUyXG5sZXQgZG91YmxlX3RhZyA9IDI1M1xubGV0IGRvdWJsZV9hcnJheV90YWcgPSAyNTRcbmxldCBjdXN0b21fdGFnID0gMjU1XG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbm1vZHVsZSBFcGhlbWVyb24gPSBzdHJ1Y3RcbiAgdHlwZSBvYmpfdCA9IHRcblxuICB0eXBlIHQgKCoqIGVwaGVtZXJvbiAqKVxuXG4gICAoKiogVG8gY2hhbmdlIGluIHN5bmMgd2l0aCB3ZWFrLmggKilcbiAgbGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuICBsZXQgbWF4X2VwaGVfbGVuZ3RoID0gU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2VwaGVfY3JlYXRlXCJcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTA2MTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfYXRvbWljX2ZldGNoX2FkZCIsInNldCIsInIiLCJ4IiwiaW5jciIsImRlY3IiLCJTdGRsaWJfQXRvbWljIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9hdG9taWMubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLElBQUFDLEdBQUFDLEdDdUJjLHFDQUFxQjtBQUFBLFlBQUFDLEtBQUFGLEdBQ3RCLHNDQUEwQjtBQUFBLFlBQUFHLEtBQUFILEdBQzFCLHVDQUE2QjtBQUFBO0FBQUEsSUFBQUk7QUFBQUEsTUR6QjFDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU3RlcGhlbiBEb2xhbiwgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3LTIwMTggVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UuICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgbWFrZSA6ICdhIC0+ICdhIHQgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+ICdhID0gXCIlYXRvbWljX2xvYWRcIlxuZXh0ZXJuYWwgZXhjaGFuZ2UgOiAnYSB0IC0+ICdhIC0+ICdhID0gXCIlYXRvbWljX2V4Y2hhbmdlXCJcbmV4dGVybmFsIGNvbXBhcmVfYW5kX3NldCA6ICdhIHQgLT4gJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWF0b21pY19jYXNcIlxuZXh0ZXJuYWwgZmV0Y2hfYW5kX2FkZCA6IGludCB0IC0+IGludCAtPiBpbnQgPSBcIiVhdG9taWNfZmV0Y2hfYWRkXCJcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgc2V0IHIgeCA9IGlnbm9yZSAoZXhjaGFuZ2UgciB4KVxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDY0MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfT2JqIiwiVW5kZWZpbmVkIiwiZm9yY2VfZ2VuX2xhenlfYmxvY2siLCJvbmx5X3ZhbCIsImJsayIsImNsb3N1cmUiLCJyZXN1bHQiLCJlIiwicGFyYW0iLCJmb3JjZV9sYXp5X2Jsb2NrIiwiZm9yY2VfZ2VuIiwibHp2IiwidCIsIkNhbWxpbnRlcm5hbExhenkiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMscUJBQUFDLFVBQUFDO0FBQUFBLElDdUVRO0FBQUEsS0FHQztBQUFBLElBRkU7QUFBQSxTQUFBQyxZQVpjO0FBQUEsS0FDdkI7QUFBQSxTQUFBQyxXQUNhO0FBQUEsS0FDYjtBQUFBLEtBQ0E7QUFBQSxLQUFtQjtBQUFBO0FBQUEsUUFBQUQsVUFuQkk7QUFBQSxJQUN2QjtBQUFBLElBQStCO0FBQUEsU0FBQUMsU0FFaEI7QUFBQSxLQUNiO0FBQUEsS0FDQTtBQUFBO0FBQUE7QUFBQSxVQUFBQztBQUFBQSxTQUFBQSxJRGxESjtBQUFBLEtDcURJLGtCQUFBQyxPQUF1Qyx3Q0FBTztBQUFBLEtBQzlDO0FBQUEsS0FBZTtBQUFBO0FBQUEsR0FvQks7QUFBQSxZQUFBQyxpQkFBQUwsS0FHRyxtQ0FBd0M7QUFBQSxZQUFBTSxVQUFBUCxVQUFBUTtBQUFBQSxRQUFBQyxJQXFCekQ7QUFBQSxJQUNSLHlCQUMwQjtBQUFBLElBRXJCLHdCQUE0QjtBQUFBLElBQzVCLG1DQUNBLG1DQUFrQztBQUFBO0FBQUEsT0FBQUMsbUJEeEd6QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBJbnRlcm5hbHMgb2YgZm9yY2luZyBsYXp5IHZhbHVlcy4gKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxuKCogW3VwZGF0ZV90b19mb3JjaW5nIGJsa10gdHJpZXMgdG8gdXBkYXRlIGEgW2Jsa10gd2l0aCBbbGF6eV90YWddIHRvXG4gICBbZm9yY2luZ190YWddIHVzaW5nIGNvbXBhcmUtYW5kLXN3YXAgKENBUyksIHRha2luZyBjYXJlIHRvIGhhbmRsZSBjb25jdXJyZW50XG4gICBtYXJraW5nIG9mIHRoZSBoZWFkZXIgd29yZCBieSBhIGNvbmN1cnJlbnQgR0MgdGhyZWFkLiBSZXR1cm5zIFswXSBpZiB0aGVcbiAgIENBUyBpcyBzdWNjZXNzZnVsLiBJZiB0aGUgQ0FTIGZhaWxzLCB0aGVuIHRoZSB0YWcgd2FzIG9ic2VydmVkIHRvIGJlXG4gICBzb21ldGhpbmcgb3RoZXIgdGhhbiBbbGF6eV90YWddIGR1ZSB0byBhIGNvbmN1cnJlbnQgbXV0YXRvci4gSW4gdGhpcyBjYXNlLFxuICAgdGhlIGZ1bmN0aW9uIHJldHVybnMgWzFdLiAqKVxuZXh0ZXJuYWwgdXBkYXRlX3RvX2ZvcmNpbmcgOiBPYmoudCAtPiBpbnQgPVxuICBcImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZ1wiIFtAQG5vYWxsb2NdXG5cbigqIFtyZXNldF90b19sYXp5IGJsa10gZXhwZWN0cyBbYmxrXSB0byBiZSBhIGxhenkgb2JqZWN0IHdpdGggW09iai5mb3JjaW5nX3RhZ11cbiAgIGFuZCB1cGRhdGVzIHRoZSB0YWcgdG8gW09iai5sYXp5X3RhZ10sIHRha2luZyBjYXJlIHRvIGhhbmRsZSBjb25jdXJyZW50XG4gICBtYXJraW5nIG9mIHRoaXMgb2JqZWN0J3MgaGVhZGVyIGJ5IGEgY29uY3VycmVudCBHQyB0aHJlYWQuICopXG5leHRlcm5hbCByZXNldF90b19sYXp5IDogT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenlcIiBbQEBub2FsbG9jXVxuXG4oKiBbdXBkYXRlX3RvX2ZvcndhcmQgYmxrXSBleHBlY3RzIFtibGtdIHRvIGJlIGEgbGF6eSBvYmplY3Qgd2l0aFxuICAgW09iai5mb3JjaW5nX3RhZ10gYW5kIHVwZGF0ZXMgdGhlIHRhZyB0byBbT2JqLmZvcndhcmRfdGFnXSwgdGFraW5nIGNhcmUgdG9cbiAgIGhhbmRsZSBjb25jdXJyZW50IG1hcmtpbmcgb2YgdGhpcyBvYmplY3QncyBoZWFkZXIgYnkgYSBjb25jdXJyZW50IEdDIHRocmVhZC5cbiAqKVxuZXh0ZXJuYWwgdXBkYXRlX3RvX2ZvcndhcmQgOiBPYmoudCAtPiB1bml0ID1cbiAgXCJjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcIiBbQEBub2FsbG9jXVxuXG4oKiBBc3N1bWVzIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgZm9yY2luZyAqKVxubGV0IGRvX2ZvcmNlX2Jsb2NrIGJsayA9XG4gIGxldCBiID0gT2JqLnJlcHIgYmxrIGluXG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCBiIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgKCkpOyAoKiBSZWxlYXNlIHRoZSBjbG9zdXJlICopXG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgdXBkYXRlX3RvX2ZvcndhcmQgYjtcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJlc2V0X3RvX2xhenkgYjtcbiAgICByYWlzZSBlXG5cbigqIEFzc3VtZXMgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBmb3JjaW5nICopXG5sZXQgZG9fZm9yY2VfdmFsX2Jsb2NrIGJsayA9XG4gIGxldCBiID0gT2JqLnJlcHIgYmxrIGluXG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCBiIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgKCkpOyAoKiBSZWxlYXNlIHRoZSBjbG9zdXJlICopXG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciByZXN1bHQpO1xuICB1cGRhdGVfdG9fZm9yd2FyZCBiO1xuICByZXN1bHRcblxuKCogQ2FsbGVkIGJ5IFtmb3JjZV9nZW5dICopXG5sZXQgZm9yY2VfZ2VuX2xhenlfYmxvY2sgfm9ubHlfdmFsIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICAoKiBXZSBleHBlY3QgdGhlIHRhZyB0byBiZSBbbGF6eV90YWddLCBidXQgbWF5IGJlIG90aGVyIHRhZ3MgZHVlIHRvXG4gICAgIGNvbmN1cnJlbnQgZm9yY2luZyBvZiBsYXp5IHZhbHVlcy4gKilcbiAgbWF0Y2ggdXBkYXRlX3RvX2ZvcmNpbmcgKE9iai5yZXByIGJsaykgd2l0aFxuICB8IDAgd2hlbiBvbmx5X3ZhbCAtPiBkb19mb3JjZV92YWxfYmxvY2sgYmxrXG4gIHwgMCAtPiBkb19mb3JjZV9ibG9jayBibGtcbiAgfCBfIC0+IHJhaXNlIFVuZGVmaW5lZFxuXG4oKiB1c2VkIGluIHRoZSAlbGF6eV9mb3JjZSBwcmltaXRpdmUgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIGJsayA9IGZvcmNlX2dlbl9sYXp5X2Jsb2NrIH5vbmx5X3ZhbDpmYWxzZSBibGtcblxuKCogW2ZvcmNlX2dlbiB+b25seV92YWw6ZmFsc2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXNcbiAgIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0c1xuICAgYXJndW1lbnQsIGV4Y2VwdCB3aGVuIGFmbCBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxubGV0IGZvcmNlX2dlbiB+b25seV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0IGNvdWxkIGhhdmUgYmVlblxuICAgICAgIHNob3J0Y3V0IGR1cmluZyBHQywgc28gdGhhdCBpbmZvcm1hdGlvbiBtdXN0IGJlIGZvcmdvdHRlbiAoc2VlIEdQUiM3MTNcbiAgICAgICBhbmQgaXNzdWUgIzczMDEpLiBUaGlzIGlzIG5vdCBhbiBpc3N1ZSBoZXJlIGF0IHRoZSBtb21lbnQgc2luY2VcbiAgICAgICBbT2JqLnRhZ10gaXMgbm90IHNpbXBsaWZpZWQgYnkgdGhlIGNvbXBpbGVyLCBhbmQgR1BSIzcxMyBhbHNvXG4gICAgICAgZW5zdXJlcyB0aGF0IG5vIHZhbHVlIHdpbGwgYmUga25vd24gdG8gaGF2ZSBGb3J3YXJkX3RhZy5cbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gICgqIFNUQVJUIG5vIHNhZmUgcG9pbnRzLiBJZiBhIEdDIG9jY3VycyBoZXJlLCB0aGVuIHRoZSBvYmplY3QgW3hdIG1heSBiZVxuICAgICBzaG9ydC1jaXJjdWl0ZWQsIGFuZCBnZXR0aW5nIHRoZSBmaXJzdCBmaWVsZCBvZiBbeF0gd291bGQgZ2V0IHVzIHRoZSB3cm9uZ1xuICAgICB2YWx1ZS4gTHVja2lseSwgdGhlIGNvbXBpbGVyIGRvZXMgbm90IGluc2VydCBHQyBzYWZlIHBvaW50cyBhdCB0aGlzIHBsYWNlLFxuICAgICBzbyBpdCBpcyBvay4gKilcbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuXG4gICAgKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZylcbiAgKCogRU5EIG5vIHNhZmUgcG9pbnRzICopXG4gIGVsc2UgaWYgdCA9IE9iai5mb3JjaW5nX3RhZyB0aGVuIHJhaXNlIFVuZGVmaW5lZFxuICBlbHNlIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfZ2VuX2xhenlfYmxvY2sgfm9ubHlfdmFsIGx6dlxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwNzAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9PYmoiLCJVbmRlZmluZWQiLCJmb3JjZV92YWwiLCJsIiwiZnJvbV9mdW4iLCJ4IiwiZnJvbV92YWwiLCJ2IiwidCIsImlzX3ZhbCIsIm1hcCIsIm1hcF92YWwiLCJTdGRsaWJfTGF6eSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvbGF6eS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxZQUFBQyxVQUFBQyxHQ3VEa0IsNENBQTJDO0FBQUEsWUFBQUMsU0FBQVY7QUFBQUEsUUFBQVcsSUFHbkQ7QUFBQSxJQUNSO0FBQUEsSUFBOEI7QUFBQSxHQUNWO0FBQUEsWUFBQUMsU0FBQUM7QUFBQUEsUUFBQUMsSUFHWjtBQUFBLElBQ1I7QUFBQTtBQUFBO0FBQUEsS0FJRztBQUFBLElBSCtDLHdDQUkvQztBQUFBO0FBQUEsWUFBQUMsT0FBQU47QUFBQUEsUUFBQSxNQUVxQjtBQUFBLDBDQUFvQjtBQUFBLEdBQWdCO0FBQUEsWUFBQU8sSUFBQWhCLEdBQUFXO0FBQUFBLElBRzVEO0FBQUE7QUFBQSx1QkQxRUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0MwRUU7QUFBQSxHQUFrQjtBQUFBLFlBQUFNLFFBQUFqQixHQUFBVztBQUFBQSxJQUdmO0FBQUEsS0FFRTtBQUFBO0FBQUEsd0JEL0VQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVDK0VPO0FBQUEsY0FEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBUyxPQUFhLFNBQWIsbUJBQ1M7QUFBQTtBQUFBO0FBQUEsSUFBQU87QUFBQUEsTUQvRXpCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbGludGVybmFsTGF6eS50XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG5sZXQgZm9yY2VfdmFsIGwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX2dlbiB+b25seV92YWw6dHJ1ZSBsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8XG4gICAgIHQgPSBPYmouZm9yY2luZ190YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBtYXAgZiB4ID1cbiAgbGF6eSAoZiAoZm9yY2UgeCkpXG5cbmxldCBtYXBfdmFsIGYgeCA9XG4gIGlmIGlzX3ZhbCB4XG4gIHRoZW4gZnJvbV92YWwgKGYgKGZvcmNlIHgpKVxuICBlbHNlIGxhenkgKGYgKGZvcmNlIHgpKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwNzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfQXRvbWljIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYiIsIlN0ZGxpYl9MYXp5IiwiY3N0X1NlcV9pbml0IiwiY3N0X1NlcV90YWtlIiwiY3N0X1NlcV9kcm9wIiwiZW1wdHkiLCJwYXJhbSIsInJldHVybiIsIngiLCJjb25zIiwibmV4dCIsImFwcGVuZCIsInNlcTEiLCJzZXEyIiwibWF0Y2giLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwieSIsImZpbHRlciIsImNvbmNhdCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiaXRlciIsInVuZm9sZCIsInUiLCJpc19lbXB0eSIsInhzIiwidW5jb25zIiwibGVuZ3RoIiwiYWNjdSIsIml0ZXJpIiwiaSIsImZvbGRfbGVmdGkiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZpbmQiLCJmaW5kX2luZGV4IiwiZmluZF9tYXAiLCJyZXN1bHQiLCJmaW5kX21hcGkiLCJpdGVyMiIsInlzIiwiZm9sZF9sZWZ0MiIsImZvcl9hbGwyIiwiZXhpc3RzMiIsImVxdWFsIiwiZXEiLCJjb21wYXJlIiwiY21wIiwiYyIsImluaXRfYXV4IiwiaiIsImluaXQiLCJuIiwicmVwZWF0IiwiZm9yZXZlciIsImN5Y2xlX25vbmVtcHR5IiwiY3ljbGUiLCJpdGVyYXRlMSIsIml0ZXJhdGUiLCJtYXBpX2F1eCIsIm1hcGkiLCJ0YWlsX3NjYW4iLCJzIiwic2NhbiIsInRha2VfYXV4IiwidGFrZSIsImRyb3AiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsIm5vZGUiLCJncm91cCIsIkZvcmNlZF90d2ljZSIsInRvX2xhenkiLCJmYWlsdXJlIiwibWVtb2l6ZSIsIm9uY2UiLCJhY3Rpb24iLCJ6aXAiLCJtYXAyIiwiaW50ZXJsZWF2ZSIsInNvcnRlZF9tZXJnZTEiLCJzb3J0ZWRfbWVyZ2UiLCJtYXBfZnN0IiwieHlzIiwibWFwX3NuZCIsInVuemlwIiwiZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIiwiZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCIsInoiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uIiwicGVlbCIsInhzcyIsInRyYW5zcG9zZSIsInRhaWxzIiwiaGVhZHMiLCJyZW1haW5kZXJzIiwibWFwX3Byb2R1Y3QiLCJwcm9kdWN0Iiwib2ZfZGlzcGVuc2VyIiwiaXQiLCJ0b19kaXNwZW5zZXIiLCJpbnRzIiwiU3RkbGliX1NlcSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvc2VxLm1sIl0sIm1hcHBp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QXBDO0FBQUFBLGNBQUEsSUFBQVUsR0FzQnJCLDBCQUFLO0FBQUEsS0FEUCxxQkQ3cEJOLDBCQzZwQk07QUFBQSxJQUVJO0FBQUEsYUFBQThFLElBQUEsS0FKVTtBQUFBLHNCQUhsQjtBQUFBLElBU0U7QUFBQTtBQUFBLFlBQUFNLFFBQUExRSxJQUFBZ0I7QUFBQUEsSUFHRiw0QkFBQXBDLEdBQUFVLEdBQXdCLGlCQUFNLFVBQU87QUFBQTtBQUFBLFlBQUFxRixhQUFBQztBQUFBQSxhQUFBcEQsRUFBQTlDO0FBQUFBLFNBQUFRLFFBSTdCO0FBQUEsS0FBSSxZQUVOO0FBQUEsU0FBQU4sSUFGTTtBQUFBLEtBSU47QUFBQSxJQUFXO0FBQUEsSUFFakI7QUFBQSxHQUFDO0FBQUEsWUFBQWlHLGFBQUE3RTtBQUFBQSxRQUFBc0MsSUFHRDtBQUFBLElBQ0EsZ0JBQUE1RDtBQUFBQSxTQUFBUSxRQUNRO0FBQUEsS0FBTSxZQUVSO0FBQUEsU0FBQWMsS0FGUSxVQUFBcEIsSUFBQTtBQUFBLEtBSVI7QUFBQSxLQUNBLGNBQU0sQ0FOWjtBQUFBLEdBTVk7QUFBQSxZQUFBa0csS0FBQXpFLEdBQUEzQjtBQUFBQSxRQUFBLE1BS0g7QUFBQSxJQUFZLDRCQUFaLHdCQUFZO0FBQUEsR0FBQztBQUFBO0FBQUEsSUFBQXFHO0FBQUFBLE1EN3JCeEIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggbmV4dCAoKSA9IENvbnMgKHgsIG5leHQpXG5cbmxldCByZWMgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIG1hdGNoIHNlcTEoKSB3aXRoXG4gIHwgTmlsIC0+IHNlcTIoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKHgsIGFwcGVuZCBuZXh0IHNlcTIpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGNvbmNhdCBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICBhcHBlbmQgeCAoY29uY2F0IG5leHQpICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGFwcGVuZCAoZiB4KSAoZmxhdF9tYXAgZiBuZXh0KSAoKVxuXG5sZXQgY29uY2F0X21hcCA9IGZsYXRfbWFwXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBmb2xkX2xlZnQgZiBhY2MgbmV4dFxuXG5sZXQgcmVjIGl0ZXIgZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBmIHg7XG4gICAgICAgIGl0ZXIgZiBuZXh0XG5cbmxldCByZWMgdW5mb2xkIGYgdSAoKSA9XG4gIG1hdGNoIGYgdSB3aXRoXG4gIHwgTm9uZSAtPiBOaWxcbiAgfCBTb21lICh4LCB1JykgLT4gQ29ucyAoeCwgdW5mb2xkIGYgdScpXG5cbmxldCBpc19lbXB0eSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKF8sIF8pIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgdW5jb25zIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBTb21lICh4LCB4cylcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcblxuXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBhY2N1IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoXywgeHMpIC0+XG4gICAgICBsZW5ndGhfYXV4IChhY2N1ICsgMSkgeHNcblxubGV0W0BpbmxpbmVdIGxlbmd0aCB4cyA9XG4gIGxlbmd0aF9hdXggMCB4c1xuXG5sZXQgcmVjIGl0ZXJpX2F1eCBmIGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgICgpXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBmIGkgeDtcbiAgICAgIGl0ZXJpX2F1eCBmIChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBpdGVyaSBmIHhzID1cbiAgaXRlcmlfYXV4IGYgMCB4c1xuXG5sZXQgcmVjIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSBpIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBpIHggaW5cbiAgICAgIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAoaSsxKSB4c1xuXG5sZXRbQGlubGluZV0gZm9sZF9sZWZ0aSBmIGFjY3UgeHMgPVxuICBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgMCB4c1xuXG5sZXQgcmVjIGZvcl9hbGwgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgcCB4ICYmIGZvcl9hbGwgcCB4c1xuXG5sZXQgcmVjIGV4aXN0cyBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgcCB4IHx8IGV4aXN0cyBwIHhzXG5cbmxldCByZWMgZmluZCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kIHAgeHNcblxubGV0IGZpbmRfaW5kZXggcCB4cyA9XG4gIGxldCByZWMgYXV4IGkgeHMgPSBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgaWYgcCB4IHRoZW4gU29tZSBpIGVsc2UgYXV4IChpKzEpIHhzIGluXG4gIGF1eCAwIHhzXG5cbmxldCByZWMgZmluZF9tYXAgZiB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGZpbmRfbWFwIGYgeHNcbiAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc3VsdFxuXG5sZXQgZmluZF9tYXBpIGYgeHMgPVxuICBsZXQgcmVjIGF1eCBpIHhzID0gbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBhdXggKGkrMSkgeHNcbiAgICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgICByZXN1bHQgaW5cbiAgYXV4IDAgeHNcblxuKCogW2l0ZXIyXSwgW2ZvbGRfbGVmdDJdLCBbZm9yX2FsbDJdLCBbZXhpc3RzMl0sIFttYXAyXSwgW3ppcF0gd29yayBhbHNvIGluXG4gICB0aGUgY2FzZSB3aGVyZSB0aGUgdHdvIHNlcXVlbmNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzLiBUaGV5IHN0b3AgYXMgc29vblxuICAgYXMgb25lIHNlcXVlbmNlIGlzIGV4aGF1c3RlZC4gVGhlaXIgYmVoYXZpb3IgaXMgc2xpZ2h0bHkgYXN5bW1ldHJpYzogd2hlblxuICAgW3hzXSBpcyBlbXB0eSwgdGhleSBkbyBub3QgZm9yY2UgW3lzXTsgaG93ZXZlciwgd2hlbiBbeXNdIGlzIGVtcHR5LCBbeHNdIGlzXG4gICBmb3JjZWQsIGV2ZW4gdGhvdWdoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIFt4cygpXSB0dXJucyBvdXRcbiAgIHRvIGJlIHVzZWxlc3MuICopXG5cbmxldCByZWMgaXRlcjIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeTtcbiAgICAgICAgICBpdGVyMiBmIHhzIHlzXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBhY2N1XG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGxldCBhY2N1ID0gZiBhY2N1IHggeSBpblxuICAgICAgICAgIGZvbGRfbGVmdDIgZiBhY2N1IHhzIHlzXG5cbmxldCByZWMgZm9yX2FsbDIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgZiB4IHkgJiYgZm9yX2FsbDIgZiB4cyB5c1xuXG5sZXQgcmVjIGV4aXN0czIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSB8fCBleGlzdHMyIGYgeHMgeXNcblxubGV0IHJlYyBlcXVhbCBlcSB4cyB5cyA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICB8IE5pbCwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpLCBDb25zICh5LCB5cykgLT5cbiAgICAgIGVxIHggeSAmJiBlcXVhbCBlcSB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXylcbiAgfCBDb25zIChfLCBfKSwgTmlsIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIDBcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgbGV0IGMgPSBjbXAgeCB5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSBjbXAgeHMgeXNcbiAgfCBOaWwsIENvbnMgKF8sIF8pIC0+XG4gICAgICAtMVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgICsxXG5cblxuXG4oKiBbaW5pdF9hdXggZiBpIGpdIGlzIHRoZSBzZXF1ZW5jZSBbZiBpLCAuLi4sIGYgKGotMSldLiAqKVxuXG5sZXQgcmVjIGluaXRfYXV4IGYgaSBqICgpID1cbiAgaWYgaSA8IGogdGhlbiBiZWdpblxuICAgIENvbnMgKGYgaSwgaW5pdF9hdXggZiAoaSArIDEpIGopXG4gIGVuZFxuICBlbHNlXG4gICAgTmlsXG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlNlcS5pbml0XCJcbiAgZWxzZVxuICAgIGluaXRfYXV4IGYgMCBuXG5cbmxldCByZWMgcmVwZWF0IHggKCkgPVxuICBDb25zICh4LCByZXBlYXQgeClcblxubGV0IHJlYyBmb3JldmVyIGYgKCkgPVxuICBDb25zIChmKCksIGZvcmV2ZXIgZilcblxuKCogVGhpcyBwcmVsaW1pbmFyeSBkZWZpbml0aW9uIG9mIFtjeWNsZV0gcmVxdWlyZXMgdGhlIHNlcXVlbmNlIFt4c11cbiAgIHRvIGJlIG5vbmVtcHR5LiBBcHBseWluZyBpdCB0byBhbiBlbXB0eSBzZXF1ZW5jZSB3b3VsZCBwcm9kdWNlIGFcbiAgIHNlcXVlbmNlIHRoYXQgZGl2ZXJnZXMgd2hlbiBpdCBpcyBmb3JjZWQuICopXG5cbmxldCByZWMgY3ljbGVfbm9uZW1wdHkgeHMgKCkgPVxuICBhcHBlbmQgeHMgKGN5Y2xlX25vbmVtcHR5IHhzKSAoKVxuXG4oKiBbY3ljbGUgeHNdIGNoZWNrcyB3aGV0aGVyIFt4c10gaXMgZW1wdHkgYW5kLCBpZiBzbywgcmV0dXJucyBhbiBlbXB0eVxuICAgc2VxdWVuY2UuIE90aGVyd2lzZSwgW2N5Y2xlIHhzXSBwcm9kdWNlcyBvbmUgY29weSBvZiBbeHNdIGZvbGxvd2VkXG4gICB3aXRoIHRoZSBpbmZpbml0ZSBzZXF1ZW5jZSBbY3ljbGVfbm9uZW1wdHkgeHNdLiBUaHVzLCB0aGUgbm9uZW1wdGluZXNzXG4gICBjaGVjayBpcyBwZXJmb3JtZWQganVzdCBvbmNlLiAqKVxuXG5sZXQgY3ljbGUgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgIENvbnMgKHgsIGFwcGVuZCB4cycgKGN5Y2xlX25vbmVtcHR5IHhzKSlcblxuKCogW2l0ZXJhdGUxIGYgeF0gaXMgdGhlIHNlcXVlbmNlIFtmIHgsIGYgKGYgeCksIC4uLl0uXG4gICBJdCBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChpdGVyYXRlIGYgeCldLlxuICAgW2l0ZXJhdGUxXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIGl0ZXJhdGUxIGYgeCAoKSA9XG4gIGxldCB5ID0gZiB4IGluXG4gIENvbnMgKHksIGl0ZXJhdGUxIGYgeSlcblxuKCogW2l0ZXJhdGUgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW3gsIGYgeCwgLi4uXS4gKilcblxuKCogVGhlIHJlYXNvbiB3aHkgd2UgZ2l2ZSB0aGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLFxuICAgYXMgb3Bwb3NlZCB0byB0aGUgbW9yZSBuYWl2ZSBkZWZpbml0aW9uIHRoYXQgbWF5IGNvbWUgdG8gbWluZCwgaXMgdGhhdFxuICAgd2UgYXJlIGNhcmVmdWwgdG8gYXZvaWQgZXZhbHVhdGluZyBbZiB4XSB1bnRpbCB0aGlzIGZ1bmN0aW9uIGNhbGwgaXNcbiAgIGFjdHVhbGx5IG5lY2Vzc2FyeS4gVGhlIG5haXZlIGRlZmluaXRpb24gKG5vdCBzaG93biBoZXJlKSBjb21wdXRlcyB0aGVcbiAgIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgc2VxdWVuY2UsIFtmIHhdLCB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuICAgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLiAqKVxuXG5sZXQgaXRlcmF0ZSBmIHggPVxuICBjb25zIHggKGl0ZXJhdGUxIGYgeClcblxuXG5cbmxldCByZWMgbWFwaV9hdXggZiBpIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKGYgaSB4LCBtYXBpX2F1eCBmIChpKzEpIHhzKVxuXG5sZXRbQGlubGluZV0gbWFwaSBmIHhzID1cbiAgbWFwaV9hdXggZiAwIHhzXG5cbigqIFt0YWlsX3NjYW4gZiBzIHhzXSBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChzY2FuIGYgcyB4cyldLlxuICAgW3RhaWxfc2Nhbl0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtzY2FuXS4gKilcblxuKCogVGhpcyBzbGlnaHRseSBpbmRpcmVjdCBkZWZpbml0aW9uIG9mIFtzY2FuXSBpcyBtZWFudCB0byBhdm9pZCBjb21wdXRpbmdcbiAgIGVsZW1lbnRzIHRvbyBlYXJseTsgc2VlIHRoZSBhYm92ZSBjb21tZW50IGFib3V0IFtpdGVyYXRlMV0gYW5kIFtpdGVyYXRlXS4gKilcblxubGV0IHJlYyB0YWlsX3NjYW4gZiBzIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBzID0gZiBzIHggaW5cbiAgICAgIENvbnMgKHMsIHRhaWxfc2NhbiBmIHMgeHMpXG5cbmxldCBzY2FuIGYgcyB4cyA9XG4gIGNvbnMgcyAodGFpbF9zY2FuIGYgcyB4cylcblxuKCogW3Rha2VdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFt0YWtlIDAgeHNdIHJldHVybnMgW2VtcHR5XVxuICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgcmVjIHRha2VfYXV4IG4geHMgPVxuICBpZiBuID0gMCB0aGVuXG4gICAgZW1wdHlcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgICBDb25zICh4LCB0YWtlX2F1eCAobi0xKSB4cylcblxubGV0IHRha2UgbiB4cyA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZXEudGFrZVwiO1xuICB0YWtlX2F1eCBuIHhzXG5cbigqIFtmb3JjZV9kcm9wIG4geHNdIGlzIGVxdWl2YWxlbnQgdG8gW2Ryb3AgbiB4cyAoKV0uXG4gICBbZm9yY2VfZHJvcCBuIHhzXSByZXF1aXJlcyBbbiA+IDBdLlxuICAgW2ZvcmNlX2Ryb3BdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZHJvcF0uICopXG5cbmxldCByZWMgZm9yY2VfZHJvcCBuIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxldCBuID0gbiAtIDEgaW5cbiAgICAgIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgeHMoKVxuICAgICAgZWxzZVxuICAgICAgICBmb3JjZV9kcm9wIG4geHNcblxuKCogW2Ryb3BdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFtkcm9wIDAgeHNdIHJldHVybnMgW3hzXSBpbW1lZGlhdGVseSxcbiAgIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgZHJvcCBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS5kcm9wXCJcbiAgZWxzZSBpZiBuID0gMCB0aGVuXG4gICAgeHNcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgZm9yY2VfZHJvcCBuIHhzXG5cbmxldCByZWMgdGFrZV93aGlsZSBwIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIENvbnMgKHgsIHRha2Vfd2hpbGUgcCB4cykgZWxzZSBOaWxcblxubGV0IHJlYyBkcm9wX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSBhcyBub2RlIC0+XG4gICAgICBpZiBwIHggdGhlbiBkcm9wX3doaWxlIHAgeHMgKCkgZWxzZSBub2RlXG5cbmxldCByZWMgZ3JvdXAgZXEgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoY29ucyB4ICh0YWtlX3doaWxlIChlcSB4KSB4cyksIGdyb3VwIGVxIChkcm9wX3doaWxlIChlcSB4KSB4cykpXG5cbmV4Y2VwdGlvbiBGb3JjZWRfdHdpY2VcblxubW9kdWxlIFN1c3BlbnNpb24gPSBzdHJ1Y3RcblxuICB0eXBlICdhIHN1c3BlbnNpb24gPVxuICAgIHVuaXQgLT4gJ2FcblxuICAoKiBDb252ZXJzaW9ucy4gKilcblxuICBsZXQgdG9fbGF6eSA6ICdhIHN1c3BlbnNpb24gLT4gJ2EgTGF6eS50ID1cbiAgICBMYXp5LmZyb21fZnVuXG4gICAgKCogZnVuIHMgLT4gbGF6eSAocygpKSAqKVxuXG4gIGxldCBmcm9tX2xhenkgKHMgOiAnYSBMYXp5LnQpIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+IExhenkuZm9yY2Ugc1xuXG4gICgqIFttZW1vaXplXSB0dXJucyBhbiBhcmJpdHJhcnkgc3VzcGVuc2lvbiBpbnRvIGEgcGVyc2lzdGVudCBzdXNwZW5zaW9uLiAqKVxuXG4gIGxldCBtZW1vaXplIChzIDogJ2Egc3VzcGVuc2lvbikgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmcm9tX2xhenkgKHRvX2xhenkgcylcblxuICAoKiBbZmFpbHVyZV0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgZmFpbHMgd2hlbiBmb3JjZWQuICopXG5cbiAgbGV0IGZhaWx1cmUgOiBfIHN1c3BlbnNpb24gPVxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogQSBzdXNwZW5zaW9uIGNyZWF0ZWQgYnkgW29uY2VdIGhhcyBiZWVuIGZvcmNlZCB0d2ljZS4gKilcbiAgICAgIHJhaXNlIEZvcmNlZF90d2ljZVxuXG4gICgqIElmIFtmXSBpcyBhIHN1c3BlbnNpb24sIHRoZW4gW29uY2UgZl0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgY2FuIGJlIGZvcmNlZFxuICAgICBhdCBtb3N0IG9uY2UuIElmIGl0IGlzIGZvcmNlZCBtb3JlIHRoYW4gb25jZSwgdGhlbiBbRm9yY2VkX3R3aWNlXSBpc1xuICAgICByYWlzZWQuICopXG5cbiAgbGV0IG9uY2UgKGYgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGxldCBhY3Rpb24gPSBBdG9taWMubWFrZSBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBHZXQgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBzdG9yZWQgaW4gW2FjdGlvbl0sIGFuZCB3cml0ZSB0aGVcbiAgICAgICAgIGZ1bmN0aW9uIFtmYWlsdXJlXSBpbiBpdHMgcGxhY2UsIHNvIHRoZSBuZXh0IGFjY2VzcyB3aWxsIHJlc3VsdFxuICAgICAgICAgaW4gYSBjYWxsIHRvIFtmYWlsdXJlKCldLiAqKVxuICAgICAgbGV0IGYgPSBBdG9taWMuZXhjaGFuZ2UgYWN0aW9uIGZhaWx1cmUgaW5cbiAgICAgIGYoKVxuXG5lbmQgKCogU3VzcGVuc2lvbiAqKVxuXG5sZXQgcmVjIG1lbW9pemUgeHMgPVxuICBTdXNwZW5zaW9uLm1lbW9pemUgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG1lbW9pemUgeHMpXG4gIClcblxubGV0IHJlYyBvbmNlIHhzID1cbiAgU3VzcGVuc2lvbi5vbmNlIChmdW4gKCkgLT5cbiAgICBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBDb25zICh4LCBvbmNlIHhzKVxuICApXG5cblxubGV0IHJlYyB6aXAgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zICgoeCwgeSksIHppcCB4cyB5cylcblxubGV0IHJlYyBtYXAyIGYgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zIChmIHggeSwgbWFwMiBmIHhzIHlzKVxuXG5sZXQgcmVjIGludGVybGVhdmUgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHlzKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKHgsIGludGVybGVhdmUgeXMgeHMpXG5cbigqIFtzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSB5c10uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCB4cyAoY29ucyB5IHlzKV0uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgW3NvcnRlZF9tZXJnZSBjbXAgKGNvbnMgeCB4cykgKGNvbnMgeSB5cyldLlxuXG4gICBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgYnVpbGRpbmcgYmxvY2tzIGluIHRoZSBkZWZpbml0aW9uXG4gICBvZiBbc29ydGVkX21lcmdlXS4gKilcblxubGV0IHJlYyBzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5cyAoKSA9XG4gIG1hdGNoIHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgQ29ucyAoeCwgeHMpXG4gIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuYW5kIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh5LCB5cylcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzID1cbiAgaWYgY21wIHggeSA8PSAwIHRoZW5cbiAgICBDb25zICh4LCBzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5cylcbiAgZWxzZVxuICAgIENvbnMgKHksIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzKVxuXG5sZXQgc29ydGVkX21lcmdlIGNtcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICAgIHwgTmlsLCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBOaWwsIGNcbiAgICB8IGMsIE5pbCAtPlxuICAgICAgICBjXG4gICAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuXG5sZXQgcmVjIG1hcF9mc3QgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKHgsIF8pLCB4eXMpIC0+XG4gICAgICBDb25zICh4LCBtYXBfZnN0IHh5cylcblxubGV0IHJlYyBtYXBfc25kIHh5cyAoKSA9XG4gIG1hdGNoIHh5cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKChfLCB5KSwgeHlzKSAtPlxuICAgICAgQ29ucyAoeSwgbWFwX3NuZCB4eXMpXG5cbmxldCB1bnppcCB4eXMgPVxuICBtYXBfZnN0IHh5cywgbWFwX3NuZCB4eXNcblxubGV0IHNwbGl0ID1cbiAgdW56aXBcblxuKCogW2ZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzXSBpcyBlcXVpdmFsZW50IHRvXG4gICBbZmlsdGVyX21hcCBFaXRoZXIuZmluZF9sZWZ0IChtYXAgZiB4cyldLiAqKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IHkgLT5cbiAgICAgICAgICBDb25zICh5LCBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cylcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyAoKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBFaXRoZXIuTGVmdCBfIC0+XG4gICAgICAgICAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpXG4gICAgICB8IEVpdGhlci5SaWdodCB6IC0+XG4gICAgICAgICAgQ29ucyAoeiwgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzKVxuXG5sZXQgcGFydGl0aW9uX21hcCBmIHhzID1cbiAgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMsXG4gIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4c1xuXG5sZXQgcGFydGl0aW9uIHAgeHMgPVxuICBmaWx0ZXIgcCB4cywgZmlsdGVyIChmdW4geCAtPiBub3QgKHAgeCkpIHhzXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtwZWVsIHhzc10gaXMgYSBwYWlyIG9mXG4gICB0aGUgZmlyc3QgY29sdW1uIChhIHNlcXVlbmNlIG9mIGVsZW1lbnRzKSBhbmQgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIG1hdHJpeCAoYSBzZXF1ZW5jZSBvZiBzaG9ydGVyIHJvd3MpLiBUaGVzZSB0d28gc2VxdWVuY2VzIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gQW4gZW1wdHkgcm93IGlzIGlnbm9yZWQuICopXG5cbigqIEJlY2F1c2UgW3BlZWxdIHVzZXMgW3VuemlwXSwgaXRzIGFyZ3VtZW50IG11c3QgYmUgcGVyc2lzdGVudC4gVGhlIHNhbWVcbiAgIHJlbWFyayBhcHBsaWVzIHRvIFt0cmFuc3Bvc2VdLCBbZGlhZ29uYWxzXSwgW3Byb2R1Y3RdLCBldGMuICopXG5cbmxldCBwZWVsIHhzcyA9XG4gIHVuemlwIChmaWx0ZXJfbWFwIHVuY29ucyB4c3MpXG5cbmxldCByZWMgdHJhbnNwb3NlIHhzcyAoKSA9XG4gIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHhzcyBpblxuICBpZiBpc19lbXB0eSBoZWFkcyB0aGVuIGJlZ2luXG4gICAgYXNzZXJ0IChpc19lbXB0eSB0YWlscyk7XG4gICAgTmlsXG4gIGVuZFxuICBlbHNlXG4gICAgQ29ucyAoaGVhZHMsIHRyYW5zcG9zZSB0YWlscylcblxuKCogVGhlIGludGVybmFsIGZ1bmN0aW9uIFtkaWFnb25hbHNdIHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50LCBbcmVtYWluZGVyc10sXG4gICB3aGljaCBjb250YWlucyB0aGUgcmVtYWluZGVycyBvZiB0aGUgcm93cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuXG4gICBkaXNjb3ZlcmVkLiAqKVxuXG5sZXQgcmVjIGRpYWdvbmFscyByZW1haW5kZXJzIHhzcyAoKSA9XG4gIG1hdGNoIHhzcygpIHdpdGhcbiAgfCBDb25zICh4cywgeHNzKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IG5vbmVtcHR5IHJvdyBbeCA6OiB4c10uIFRodXMsIHRoZSBuZXh0IGRpYWdvbmFsXG4gICAgICAgICAgICAgaXMgW3ggOjogaGVhZHNdOiB0aGlzIGRpYWdvbmFsIGJlZ2lucyB3aXRoIFt4XSBhbmQgY29udGludWVzIHdpdGhcbiAgICAgICAgICAgICB0aGUgZmlyc3QgZWxlbWVudCBvZiBldmVyeSByb3cgaW4gW3JlbWFpbmRlcnNdLiBJbiB0aGUgcmVjdXJzaXZlXG4gICAgICAgICAgICAgY2FsbCwgdGhlIGFyZ3VtZW50IFtyZW1haW5kZXJzXSBpcyBpbnN0YW50aWF0ZWQgd2l0aCBbeHMgOjpcbiAgICAgICAgICAgICB0YWlsc10sIHdoaWNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LCBbeHNdLFxuICAgICAgICAgICAgIGFuZCB0aGF0IHdlIGtlZXAgdGhlIHRhaWxzIG9mIHRoZSBwcmUtZXhpc3RpbmcgcmVtYWluaW5nIHJvd3MuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGNvbnMgeCBoZWFkcywgZGlhZ29uYWxzIChjb25zIHhzIHRhaWxzKSB4c3MpXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IGVtcHR5IHJvdy4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGRpYWdvbmFsIGlzXG4gICAgICAgICAgICAganVzdCBbaGVhZHNdLCBhbmQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIGp1c3QgW3RhaWxzXSxcbiAgICAgICAgICAgICBhcyB3ZSBkbyBub3QgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LiAqKVxuICAgICAgICAgIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHJlbWFpbmRlcnMgaW5cbiAgICAgICAgICBDb25zIChoZWFkcywgZGlhZ29uYWxzIHRhaWxzIHhzcylcbiAgICAgIGVuZFxuICB8IE5pbCAtPlxuICAgICAgKCogVGhlcmUgYXJlIG5vIG1vcmUgcm93cyB0byBiZSBkaXNjb3ZlcmVkLiBUaGVyZSByZW1haW5zIHRvIGV4aGF1c3RcbiAgICAgICAgIHRoZSByZW1haW5pbmcgcm93cy4gKilcbiAgICAgIHRyYW5zcG9zZSByZW1haW5kZXJzICgpXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtkaWFnb25hbHMgeHNzXSBpc1xuICAgdGhlIHNlcXVlbmNlIG9mIGl0cyBkaWFnb25hbHMuXG5cbiAgIFRoZSBmaXJzdCBkaWFnb25hbCBjb250YWlucyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgZmlyc3Qgcm93LiBUaGUgc2Vjb25kIGRpYWdvbmFsIGNvbnRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgc2Vjb25kIHJvdyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBmaXJzdCByb3c7IGFuZCBzbyBvbi5cbiAgIFRoaXMga2luZCBvZiBkaWFnb25hbCBpcyBpbiBmYWN0IHNvbWV0aW1lcyBrbm93biBhcyBhbiBhbnRpZGlhZ29uYWwuXG5cbiAgIC0gRXZlcnkgZGlhZ29uYWwgaXMgYSBmaW5pdGUgc2VxdWVuY2UuXG4gICAtIFRoZSByb3dzIG9mIHRoZSBtYXRyaXggW3hzc10gYXJlIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBpcyBub3QgcmVxdWlyZWQgdG8gYmUgZmluaXRlIChpbiBlaXRoZXIgZGlyZWN0aW9uKS5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBtdXN0IGJlIHBlcnNpc3RlbnQuICopXG5cbmxldCBkaWFnb25hbHMgeHNzID1cbiAgZGlhZ29uYWxzIGVtcHR5IHhzc1xuXG5sZXQgbWFwX3Byb2R1Y3QgZiB4cyB5cyA9XG4gIGNvbmNhdCAoZGlhZ29uYWxzIChcbiAgICBtYXAgKGZ1biB4IC0+XG4gICAgICBtYXAgKGZ1biB5IC0+XG4gICAgICAgIGYgeCB5XG4gICAgICApIHlzXG4gICAgKSB4c1xuICApKVxuXG5sZXQgcHJvZHVjdCB4cyB5cyA9XG4gIG1hcF9wcm9kdWN0IChmdW4geCB5IC0+ICh4LCB5KSkgeHMgeXNcblxubGV0IG9mX2Rpc3BlbnNlciBpdCA9XG4gIGxldCByZWMgYyAoKSA9XG4gICAgbWF0Y2ggaXQoKSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5pbFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIENvbnMgKHgsIGMpXG4gIGluXG4gIGNcblxubGV0IHRvX2Rpc3BlbnNlciB4cyA9XG4gIGxldCBzID0gcmVmIHhzIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICghcykoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIHMgOj0geHM7XG4gICAgICAgIFNvbWUgeFxuXG5cblxubGV0IHJlYyBpbnRzIGkgKCkgPVxuICBDb25zIChpLCBpbnRzIChpICsgMSkpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE0OTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfaGFzaCIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiY3N0IiwiU3RkbGliIiwiY3N0X0NoYXJfY2hyIiwiY3N0X2IiLCJjc3RfdCIsImNzdF9uIiwiY3N0X3IiLCJjaHIiLCJuIiwiZXNjYXBlZCIsImMiLCJzIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSIsImMxIiwiYzIiLCJlcXVhbCIsInNlZWRlZF9oYXNoIiwic2VlZCIsIngiLCJoYXNoIiwiU3RkbGliX0NoYXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2NoYXIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLElBQUFDO0FBQUFBLElDcUJFLHVCQUFxRDtBQUFBLElBQTVCLDBDQUF3QztBQUFBO0FBQUEsWUFBQUMsUUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FPckQ7QUFBQSxtQkFFRjtBQUFBLE1BRkU7QUFBQTtBQUFBO0FBQUEsOEJBQ0Y7QUFBQSxNQURFO0FBQUE7QUFBQTtBQUFBLFVBTUY7QUFBQTtBQUFBLFVBRkE7QUFBQTtBQUFBLFVBREE7QUFBQTtBQUFBLFVBRUE7QUFBQTtBQUFBO0FBQUEsU0FBQUMsSUFRRTtBQUFBLEtBQ1I7QUFBQSxLQUNBO0FBQUEsS0FDQTtBQUFBLEtBQ0E7QUFBQSxLQUNBLDhCQUFrQjtBQUFBO0FBQUEsUUFBQUEsTUFWVjtBQUFBLElBQ1I7QUFBQSxJQUNBLGdDQVFrQjtBQUFBO0FBQUEsWUFBQUMsZ0JBQUFGLEdBRUYseUNBRVo7QUFBQSxZQUFBRyxnQkFBQUgsR0FFWSx5Q0FFWjtBQUFBLFlBQUFJLFFBQUFDLElBQUFDLElBSVUsbUJBQWlCO0FBQUEsWUFBQUMsTUFBQUYsSUFBQUMsSUFDSSxtQ0FBSTtBQUFBLFlBQUFFLFlBQUFDLE1BQUFDLEdBSXBCLGtDQUErQjtBQUFBLFlBQUFDLEtBQUFELEdBQzNDLCtCQUE0QjtBQUFBO0FBQUEsSUFBQUU7QUFBQUEsTURoRXpDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE1NzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfdWNoYXJfbWwiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWIiLCJjc3RfaXNfbm90X2FuX1VuaWNvZGVfc2NhbGFyX3YiLCJjc3RfaXNfbm90X2FfbGF0aW4xX2NoYXJhY3RlciIsImNzdF9VIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsInN1Y2MiLCJ1IiwicHJlZCIsImlzX3ZhbGlkIiwiaSIsIm9mX2ludCIsImlzX2NoYXIiLCJvZl9jaGFyIiwiYyIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsIiwiY29tcGFyZSIsImhhc2giLCJ1dGZfZGVjb2RlX2lzX3ZhbGlkIiwiZCIsInV0Zl9kZWNvZGVfbGVuZ3RoIiwidXRmX2RlY29kZV91Y2hhciIsInV0Zl9kZWNvZGUiLCJuIiwidXRmX2RlY29kZV9pbnZhbGlkIiwidXRmXzhfYnl0ZV9sZW5ndGgiLCJ1dGZfMTZfYnl0ZV9sZW5ndGgiLCJTdGRsaWJfVWNoYXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL3VjaGFyLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsZ0NBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxJQ2lDRTtBQUFBO0FBQUEsOEJBQ2dCLDhDQUNYO0FBQUE7QUFBQSxZQUFBQyxLQUFBRDtBQUFBQSxJQUdMO0FBQUE7QUFBQSx3QkFDZ0IsOENBQ1g7QUFBQTtBQUFBLFlBQUFFLFNBQUFDO0FBQUFBLFFBQUEsTUFFVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUEwRDtBQUFBLFlBQUFDLE9BQUFEO0FBQUFBLElBQ3pELGdCQUFnQjtBQUFBO0FBQUE7QUFBQSxPQXhCRTtBQUFBLHFCQUFqQjtBQUFBLElBd0JnRDtBQUFBO0FBQUEsWUFBQUUsUUFBQUwsR0FJbkQsdUJBQU87QUFBQSxZQUFBTSxRQUFBQyxHQUNQLFNBQVc7QUFBQSxZQUFBQyxRQUFBUjtBQUFBQSxJQUV6QixhQUNBO0FBQUE7QUFBQTtBQUFBLE9BL0I0QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQWtEO0FBQUEsSUE4QmhDLGlDQUM3QjtBQUFBO0FBQUEsWUFBQVMsZUFBQSxLRG5EbkI7QUFBQSxZQUFBQyxNQUFBO0FBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUEsWUFBQUMsb0JBQUFDLEdDd0VxQyxvQ0FBcUI7QUFBQSxZQUFBQyxrQkFBQUQsR0FDdkIsMEJBQThCO0FBQUEsWUFBQUUsaUJBQUFGLEdBQy9CLG9CQUErQjtBQUFBLFlBQUFHLFdBQUFDLEdBQUFsQixHQUNuQyx5QkFBMEM7QUFBQSxZQUFBbUIsbUJBQUFELEdBQ3BDLHVCQUEyQjtBQUFBLFlBQUFFLGtCQUFBcEI7QUFBQUEsSUFHdEQsVUFBUztBQUFBLElBQ1QsYUFBZTtBQUFBLElBQ2YsY0FBZTtBQUFBLElBQ2YsZUFBZTtBQUFBLElBQ2Y7QUFBQSxLQUNGO0FBQUEsSUFEbUI7QUFBQSxHQUNQO0FBQUEsWUFBQXFCLG1CQUFBckI7QUFBQUEsSUFHVixVQUFTO0FBQUEsSUFDVCxlQUFlO0FBQUEsSUFDZjtBQUFBLEtBQ0Y7QUFBQSxJQURtQjtBQUFBLEdBQ1A7QUFBQTtBQUFBLElBQUFzQjtBQUFBQSxNRDFGbkIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFuaWVsIEMuIEJ1ZW56bGkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuXG5sZXQgZXJyX25vX3ByZWQgPSBcIlUrMDAwMCBoYXMgbm8gcHJlZGVjZXNzb3JcIlxubGV0IGVycl9ub19zdWNjID0gXCJVKzEwRkZGRiBoYXMgbm8gc3VjY2Vzc29yXCJcbmxldCBlcnJfbm90X3N2IGkgPSBmb3JtYXRfaW50IFwiJVhcIiBpIF4gXCIgaXMgbm90IGFuIFVuaWNvZGUgc2NhbGFyIHZhbHVlXCJcbmxldCBlcnJfbm90X2xhdGluMSB1ID0gXCJVK1wiIF4gZm9ybWF0X2ludCBcIiUwNFhcIiB1IF4gXCIgaXMgbm90IGEgbGF0aW4xIGNoYXJhY3RlclwiXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgbWluID0gMHgwMDAwXG5sZXQgbWF4ID0gMHgxMEZGRkZcbmxldCBsb19ib3VuZCA9IDB4RDdGRlxubGV0IGhpX2JvdW5kID0gMHhFMDAwXG5cbmxldCBib20gPSAweEZFRkZcbmxldCByZXAgPSAweEZGRkRcblxubGV0IHN1Y2MgdSA9XG4gIGlmIHUgPSBsb19ib3VuZCB0aGVuIGhpX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1heCB0aGVuIGludmFsaWRfYXJnIGVycl9ub19zdWNjIGVsc2VcbiAgdSArIDFcblxubGV0IHByZWQgdSA9XG4gIGlmIHUgPSBoaV9ib3VuZCB0aGVuIGxvX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1pbiB0aGVuIGludmFsaWRfYXJnIGVycl9ub19wcmVkIGVsc2VcbiAgdSAtIDFcblxubGV0IGlzX3ZhbGlkIGkgPSAobWluIDw9IGkgJiYgaSA8PSBsb19ib3VuZCkgfHwgKGhpX2JvdW5kIDw9IGkgJiYgaSA8PSBtYXgpXG5sZXQgb2ZfaW50IGkgPSBpZiBpc192YWxpZCBpIHRoZW4gaSBlbHNlIGludmFsaWRfYXJnIChlcnJfbm90X3N2IGkpXG5leHRlcm5hbCB1bnNhZmVfb2ZfaW50IDogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB0b19pbnQgOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX2NoYXIgdSA9IHUgPCAyNTZcbmxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xubGV0IHRvX2NoYXIgdSA9XG4gIGlmIHUgPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyAoZXJyX25vdF9sYXRpbjEgdSkgZWxzZVxuICBDaGFyLnVuc2FmZV9jaHIgdVxuXG5sZXQgdW5zYWZlX3RvX2NoYXIgPSBDaGFyLnVuc2FmZV9jaHJcblxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IGhhc2ggPSB0b19pbnRcblxuKCogVVRGIGNvZGVjcyB0b29scyAqKVxuXG50eXBlIHV0Zl9kZWNvZGUgPSBpbnRcbigqIFRoaXMgaXMgYW4gaW50IFsweERVVVVVVVVdIGRlY29tcG9zZWQgYXMgZm9sbG93czpcbiAgIC0gW0RdIGlzIGZvdXIgYml0cyBmb3IgZGVjb2RlIGluZm9ybWF0aW9uLCB0aGUgaGlnaGVzdCBiaXQgaXMgc2V0IGlmIHRoZVxuICAgICBkZWNvZGUgaXMgdmFsaWQuIFRoZSB0aHJlZSBsb3dlciBiaXRzIGluZGljYXRlIHRoZSBudW1iZXIgb2YgZWxlbWVudHNcbiAgICAgZnJvbSB0aGUgc291cmNlIHRoYXQgd2VyZSBjb25zdW1lZCBieSB0aGUgZGVjb2RlLlxuICAgLSBbVVVVVVVVXSBpcyB0aGUgZGVjb2RlZCBVbmljb2RlIGNoYXJhY3RlciBvciB0aGUgVW5pY29kZSByZXBsYWNlbWVudFxuICAgICBjaGFyYWN0ZXIgVStGRkZEIGlmIGZvciBpbnZhbGlkIGRlY29kZXMuICopXG5cbmxldCB2YWxpZF9iaXQgPSAyN1xubGV0IGRlY29kZV9iaXRzID0gMjRcblxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfaXNfdmFsaWQgZCA9IChkIGxzciB2YWxpZF9iaXQpID0gMVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfbGVuZ3RoIGQgPSAoZCBsc3IgZGVjb2RlX2JpdHMpIGxhbmQgMGIxMTFcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX3VjaGFyIGQgPSB1bnNhZmVfb2ZfaW50IChkIGxhbmQgMHhGRkZGRkYpXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZSBuIHUgPSAoKDggbG9yIG4pIGxzbCBkZWNvZGVfYml0cykgbG9yICh0b19pbnQgdSlcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2ludmFsaWQgbiA9IChuIGxzbCBkZWNvZGVfYml0cykgbG9yIHJlcFxuXG5sZXQgdXRmXzhfYnl0ZV9sZW5ndGggdSA9IG1hdGNoIHRvX2ludCB1IHdpdGhcbnwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxufCB1IHdoZW4gdSA8PSAweDAwN0YgLT4gMVxufCB1IHdoZW4gdSA8PSAweDA3RkYgLT4gMlxufCB1IHdoZW4gdSA8PSAweEZGRkYgLT4gM1xufCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPiA0XG58IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCB1dGZfMTZfYnl0ZV9sZW5ndGggdSA9IG1hdGNoIHRvX2ludCB1IHdpdGhcbnwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxufCB1IHdoZW4gdSA8PSAweEZGRkYgLT4gMlxufCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPiA0XG58IF8gLT4gYXNzZXJ0IGZhbHNlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE3MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfTGlzdF9tYXAyIiwiY3N0X0xpc3RfbnRoIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiY3N0X2hkIiwiY3N0X3RsIiwiY3N0X250aCIsImxlbmd0aCIsImwiLCJsZW4iLCJwYXJhbSIsImNvbnMiLCJhIiwiaGQiLCJ0bCIsIm50aCIsIm4iLCJudGhfb3B0IiwiYXBwZW5kIiwiY3N0X0xpc3RfaW5pdCIsImNzdF9MaXN0X3Jldl9tYXAyIiwiY3N0X0xpc3RfaXRlcjIiLCJjc3RfTGlzdF9mb2xkX2xlZnQyIiwiY3N0X0xpc3RfZm9sZF9yaWdodDIiLCJjc3RfTGlzdF9mb3JfYWxsMiIsImNzdF9MaXN0X2V4aXN0czIiLCJjc3RfTGlzdF9jb21iaW5lIiwicmV2X2FwcGVuZCIsImwxIiwibDIiLCJyZXYiLCJpbml0IiwibGFzdCIsImkiLCJyMSIsInIyIiwiYmxvY2siLCJkc3QiLCJvZmZzZXQiLCJmbGF0dGVuIiwiciIsIm1hcCIsIm1hdGNoIiwibWFwaSIsInJldl9tYXAiLCJhY2N1IiwiaXRlciIsIml0ZXJpIiwiZm9sZF9sZWZ0IiwiZm9sZF9yaWdodCIsIm1hcDIiLCJiMiIsImIxIiwicmV2X21hcDIiLCJpdGVyMiIsImZvbGRfbGVmdDIiLCJmb2xkX3JpZ2h0MiIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwibWVtIiwieCIsIm1lbXEiLCJhc3NvYyIsImIiLCJhc3NvY19vcHQiLCJhc3NxIiwiYXNzcV9vcHQiLCJtZW1fYXNzb2MiLCJtZW1fYXNzcSIsInJlbW92ZV9hc3NvYyIsInBhaXIiLCJyZW1vdmVfYXNzcSIsImZpbmQiLCJmaW5kX29wdCIsImZpbmRfaW5kZXgiLCJmaW5kX21hcCIsInJlc3VsdCIsImZpbmRfbWFwaSIsImZpbmRfYWxsIiwiZmlsdGVyaSIsImZpbHRlcl9tYXAiLCJ2IiwiY29uY2F0X21hcCIsInhzIiwieXMiLCJ5IiwiZm9sZF9sZWZ0X21hcCIsImxfYWNjdSIsInBhcnRpdGlvbiIsInllcyIsIm5vIiwicGFydGl0aW9uX21hcCIsImxlZnQiLCJyaWdodCIsInNwbGl0IiwicnkiLCJyeCIsImNvbWJpbmUiLCJtZXJnZSIsImNtcCIsInQyIiwiaDIiLCJ0MSIsImgxIiwic3RhYmxlX3NvcnQiLCJzb3J0IiwieDIiLCJ4MSIsInMiLCJ4MyIsIm4xIiwibjIiLCJzMSIsInMyIiwicmV2X3NvcnQiLCJzb3J0X3VuaXEiLCJjIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImlzX2VtcHR5IiwiZXF1YWwiLCJlcSIsImNvbXBhcmUiLCJ0b19zZXEiLCJhdXgiLCJ0YWlsIiwib2Zfc2VxIiwic2VxIiwiU3RkbGliX0xpc3QiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2xpc3QubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEs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KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBsaXN0cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGxpc3QgPSBbXSB8ICg6Oikgb2YgJ2EgKiAnYSBsaXN0XG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBpbml0IGkgbGFzdCBmID1cbiAgaWYgaSA+IGxhc3QgdGhlbiBbXVxuICBlbHNlIGlmIGkgPSBsYXN0IHRoZW4gW2YgaV1cbiAgZWxzZVxuICAgIGxldCByMSA9IGYgaSBpblxuICAgIGxldCByMiA9IGYgKGkrMSkgaW5cbiAgICByMSA6OiByMiA6OiBpbml0IChpKzIpIGxhc3QgZlxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaW5pdCAwIChsZW4gLSAxKSBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgW2ExXSAtPlxuICAgICAgbGV0IHIxID0gZiBhMSBpblxuICAgICAgW3IxXVxuICB8IGExOjphMjo6bCAtPlxuICAgICAgbGV0IHIxID0gZiBhMSBpblxuICAgICAgbGV0IHIyID0gZiBhMiBpblxuICAgICAgcjE6OnIyOjptYXAgZiBsXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IFthMV0gLT5cbiAgICAgIGxldCByMSA9IGYgaSBhMSBpblxuICAgICAgW3IxXVxuICB8IGExOjphMjo6bCAtPlxuICAgICAgbGV0IHIxID0gZiBpIGExIGluXG4gICAgICBsZXQgcjIgPSBmIChpKzEpIGEyIGluXG4gICAgICByMTo6cjI6Om1hcGkgKGkrMikgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKFthMV0sIFtiMV0pIC0+XG4gICAgICBsZXQgcjEgPSBmIGExIGIxIGluXG4gICAgICBbcjFdXG4gIHwgKGExOjphMjo6bDEsIGIxOjpiMjo6bDIpIC0+XG4gICAgICBsZXQgcjEgPSBmIGExIGIxIGluXG4gICAgICBsZXQgcjIgPSBmIGEyIGIyIGluXG4gICAgICByMTo6cjI6Om1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgZmluZF9pbmRleCBwID1cbiAgbGV0IHJlYyBhdXggaSA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBwIGEgdGhlbiBTb21lIGkgZWxzZSBhdXggKGkrMSkgbCBpblxuICBhdXggMFxuXG5sZXQgcmVjIGZpbmRfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIGYgbFxuICAgICBlbmRcblxubGV0IGZpbmRfbWFwaSBmID1cbiAgbGV0IHJlYyBhdXggaSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBhdXggKGkrMSkgbFxuICAgICBlbmQgaW5cbiAgYXV4IDBcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgZmluZF9hbGwgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCA6OiBmaW5kX2FsbCBwIGwgZWxzZSBmaW5kX2FsbCBwIGxcblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbHRlcmkgcCBpID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHg6OmwgLT5cbiAgICAgIGxldCBpJyA9IGkgKyAxIGluXG4gICAgICBpZiBwIGkgeCB0aGVuIHggOjogZmlsdGVyaSBwIGknIGwgZWxzZSBmaWx0ZXJpIHAgaScgbFxuXG5sZXQgZmlsdGVyaSBwIGwgPSBmaWx0ZXJpIHAgMCBsXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IGwgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIGxcbiAgICAgIHwgU29tZSB2IC0+IHYgOjogZmlsdGVyX21hcCBmIGxcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgY29uY2F0X21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHg6OnhzIC0+IHByZXBlbmRfY29uY2F0X21hcCAoZiB4KSBmIHhzXG5hbmRbQHRhaWxfbW9kX2NvbnNdIHByZXBlbmRfY29uY2F0X21hcCB5cyBmIHhzID1cbiAgbWF0Y2ggeXMgd2l0aFxuICB8IFtdIC0+IGNvbmNhdF9tYXAgZiB4c1xuICB8IHkgOjogeXMgLT4geSA6OiBwcmVwZW5kX2NvbmNhdF9tYXAgeXMgZiB4c1xuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIHZlcnkgbG9uZyBsaXN0IChsZW5ndGggb3ZlciBhYm91dCAxMDAwMDApLCBpdCB1c2VkIHRvIGJlXG4gICBmYXN0ZXIgdG8gY29udmVydCB0aGUgbGlzdCB0byBhbiBhcnJheSwgc29ydCB0aGUgYXJyYXksIGFuZCBjb252ZXJ0XG4gICBiYWNrLCB0cnVuY2F0aW5nIHRoZSBhcnJheSBvYmplY3QgYWZ0ZXIgcHJlcGVuZGluZyBlYWNoIHRob3VzYW5kXG4gICBlbnRyaWVzIHRvIHRoZSByZXN1bHRpbmcgbGlzdC4gSW1wb3NzaWJsZSBub3cgdGhhdCBPYmoudHJ1bmNhdGUgaGFzXG4gICBiZWVuIHJlbW92ZWQuICopXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCBuID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBpZiBuID0gMCB0aGVuIDAgZWxzZVxuICAgICAgaWYgbiA+IDAgdGhlbiAtMSBlbHNlIDFcbiAgfCBfIDo6IGwgLT5cbiAgICBpZiBuIDw9IDAgdGhlbiAxIGVsc2VcbiAgICAgIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCAobi0xKVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIDo6IF8gLT4gZmFsc2VcblxuKCoqIHsxIENvbXBhcmlzb259ICopXG5cbigqIE5vdGU6IHdlIGFyZSAqbm90KiBzaG9ydGN1dHRpbmcgdGhlIGxpc3QgYnkgdXNpbmdcbiAgIFtMaXN0LmNvbXBhcmVfbGVuZ3Roc10gZmlyc3Q7IHRoaXMgbWF5IGJlIHNsb3dlciBvbiBsb25nIGxpc3RzXG4gICBpbW1lZGlhdGVseSBzdGFydCB3aXRoIGRpc3RpbmN0IGVsZW1lbnRzLiBJdCBpcyBhbHNvIGluY29ycmVjdCBmb3JcbiAgIFtjb21wYXJlXSBiZWxvdywgYW5kIGl0IGlzIGJldHRlciAocHJpbmNpcGxlIG9mIGxlYXN0IHN1cnByaXNlKSB0b1xuICAgdXNlIHRoZSBzYW1lIGFwcHJvYWNoIGZvciBib3RoIGZ1bmN0aW9ucy4gKilcbmxldCByZWMgZXF1YWwgZXEgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiB0cnVlXG4gIHwgW10sIF86Ol8gfCBfOjpfLCBbXSAtPiBmYWxzZVxuICB8IGExOjpsMSwgYTI6OmwyIC0+IGVxIGExIGEyICYmIGVxdWFsIGVxIGwxIGwyXG5cbmxldCByZWMgY29tcGFyZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF86Ol8gLT4gLTFcbiAgfCBfOjpfLCBbXSAtPiAxXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT5cbiAgICBsZXQgYyA9IGNtcCBhMSBhMiBpblxuICAgIGlmIGMgPD4gMCB0aGVuIGNcbiAgICBlbHNlIGNvbXBhcmUgY21wIGwxIGwyXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgbCA9XG4gIGxldCByZWMgYXV4IGwgKCkgPSBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFNlcS5OaWxcbiAgICB8IHggOjogdGFpbCAtPiBTZXEuQ29ucyAoeCwgYXV4IHRhaWwpXG4gIGluXG4gIGF1eCBsXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG9mX3NlcSBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gW11cbiAgfCBTZXEuQ29ucyAoeDEsIHNlcSkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW3gxXVxuICAgICAgfCBTZXEuQ29ucyAoeDIsIHNlcSkgLT4geDEgOjogeDIgOjogb2Zfc2VxIHNlcVxuICAgICAgZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTMwODgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2hhc2giLCJhYnMiLCJ4IiwibG9nbm90IiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwieSIsIm1heCIsInRvX3N0cmluZyIsInNlZWRlZF9oYXNoIiwic2VlZCIsImhhc2giLCJTdGRsaWJfSW50Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9pbnQubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxZQUFBO0FBQUEsWUFBQUMsSUFBQUMsR0M0QlksMkJBQXdCO0FBQUEsWUFBQUMsT0FBQUQsR0FNckIsY0FBYTtBQUFBLFlBQUFFLE1BQUEsVURsQzVCO0FBQUEsT0FBQUMsVUFBQTtBQUFBLFlBQUFDLElBQUFKLEdBQUFLLEdDd0NrQixxQkFBdUI7QUFBQSxZQUFBQyxJQUFBTixHQUFBSyxHQUN2QixxQkFBdUI7QUFBQSxZQUFBRSxVQUFBUCxHQVVOO0FBQUEsWUFBQVEsWUFBQUMsTUFBQVQsR0FJVixrQ0FBK0I7QUFBQSxZQUFBVSxLQUFBVixHQUMzQywrQkFBNEI7QUFBQTtBQUFBLElBQUFXO0FBQUFBLE1EeER6QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2J5dGVzX21sIiwiY3N0X2luZGV4X291dF9vZl9ib3VuZHMiLCJjYW1sX2JsaXRfYnl0ZXMiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19zZXQiLCJjYW1sX2J5dGVzX3NldDE2IiwiY2FtbF9ieXRlc19zZXQzMiIsImNhbWxfYnl0ZXNfc2V0NjQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9VY2hhciIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9JbnQiLCJTdGRsaWJfU2VxIiwiU3RkbGliX0NoYXIiLCJtYWtlIiwibiIsImMiLCJzIiwiaW5pdCIsImkiLCJlbXB0eSIsImNzdF9TdHJpbmdfc3ViX0J5dGVzX3N1YiIsImNzdF9CeXRlc19leHRlbmQiLCJjc3RfU3RyaW5nX2ZpbGxfQnl0ZXNfZmlsbCIsImNzdF9CeXRlc19ibGl0IiwiY3N0X1N0cmluZ19ibGl0X0J5dGVzX2JsaXRfc3RyIiwiY3N0X0J5dGVzX2NvbmNhdCIsImNzdF9TdHJpbmdfaW5kZXhfZnJvbV9CeXRlc19pbiIsImNzdF9TdHJpbmdfaW5kZXhfZnJvbV9vcHRfQnl0ZSIsImNzdF9TdHJpbmdfcmluZGV4X2Zyb21fQnl0ZXNfciIsImNzdF9TdHJpbmdfcmluZGV4X2Zyb21fb3B0X0J5dCIsImNzdF9TdHJpbmdfY29udGFpbnNfZnJvbV9CeXRlcyIsImNzdF9TdHJpbmdfcmNvbnRhaW5zX2Zyb21fQnl0ZSIsImNvcHkiLCJsZW4iLCJyIiwidG9fc3RyaW5nIiwiYiIsIm9mX3N0cmluZyIsInN1YiIsIm9mcyIsInN1Yl9zdHJpbmciLCJzeW1ib2wiLCJhIiwibWF0Y2giLCJleHRlbmQiLCJsZWZ0IiwicmlnaHQiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJmaWxsIiwiYmxpdCIsInMxIiwib2ZzMSIsInMyIiwib2ZzMiIsImJsaXRfc3RyaW5nIiwiaXRlciIsIml0ZXJpIiwiY29uY2F0Iiwic2VwIiwibCIsInNlcGxlbiIsImFjYyIsInBhcmFtIiwicG9zIiwiaGQiLCJ0bCIsIngiLCJkc3QiLCJjYXQiLCJsMSIsImwyIiwiaXNfc3BhY2UiLCJ0cmltIiwiaiIsInVuc2FmZV9lc2NhcGUiLCJlc2NhcGVkIiwibWFwIiwibWFwaSIsImZvbGRfbGVmdCIsImZvbGRfcmlnaHQiLCJleGlzdHMiLCJwIiwiZm9yX2FsbCIsInVwcGVyY2FzZV9hc2NpaSIsImxvd2VyY2FzZV9hc2NpaSIsImFwcGx5MSIsImNhcGl0YWxpemVfYXNjaWkiLCJ1bmNhcGl0YWxpemVfYXNjaWkiLCJzdGFydHNfd2l0aCIsInByZWZpeCIsImxlbl9zIiwibGVuX3ByZSIsImVuZHNfd2l0aCIsInN1ZmZpeCIsImxlbl9zdWYiLCJkaWZmIiwiaW5kZXhfcmVjIiwibGltIiwiaW5kZXgiLCJpbmRleF9yZWNfb3B0IiwiaW5kZXhfb3B0IiwiaW5kZXhfZnJvbSIsImluZGV4X2Zyb21fb3B0IiwicmluZGV4X3JlYyIsInJpbmRleCIsInJpbmRleF9mcm9tIiwicmluZGV4X3JlY19vcHQiLCJyaW5kZXhfb3B0IiwicmluZGV4X2Zyb21fb3B0IiwiY29udGFpbnNfZnJvbSIsImNvbnRhaW5zIiwicmNvbnRhaW5zX2Zyb20iLCJjb21wYXJlIiwiY3N0X0J5dGVzX29mX3NlcV9jYW5ub3RfZ3Jvd19iIiwic3BsaXRfb25fY2hhciIsInRvX3NlcSIsImF1eCIsInRvX3NlcWkiLCJvZl9zZXEiLCJidWYiLCJuZXdfbGVuIiwibmV3X2J1ZiIsInVuc2FmZV9nZXRfdWludDE2X2xlIiwidW5zYWZlX2dldF91aW50MTZfYmUiLCJnZXRfaW50OCIsImdldF91aW50MTZfbGUiLCJnZXRfdWludDE2X2JlIiwiZ2V0X2ludDE2X25lIiwiZ2V0X2ludDE2X2xlIiwiZ2V0X2ludDE2X2JlIiwiZ2V0X2ludDMyX2xlIiwiZ2V0X2ludDMyX2JlIiwiZ2V0X2ludDY0X2xlIiwiZ2V0X2ludDY0X2JlIiwidW5zYWZlX3NldF91aW50MTZfbGUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9iZSIsInNldF9pbnQxNl9sZSIsInNldF9pbnQxNl9iZSIsInNldF9pbnQzMl9sZSIsInNldF9pbnQzMl9iZSIsInNldF9pbnQ2NF9sZSIsInNldF9pbnQ2NF9iZSIsInNldF91aW50OCIsInNldF91aW50MTZfbmUiLCJkZWNfaW52YWxpZCIsImRlY19yZXQiLCJ1Iiwibm90X2luX3g4MF90b194QkYiLCJub3RfaW5feEEwX3RvX3hCRiIsIm5vdF9pbl94ODBfdG9feDlGIiwibm90X2luX3g5MF90b194QkYiLCJub3RfaW5feDgwX3RvX3g4RiIsInV0Zl84X3VjaGFyXzMiLCJiMCIsImIxIiwiYjIiLCJ1dGZfOF91Y2hhcl80IiwiYjMiLCJnZXRfdXRmXzhfdWNoYXIiLCJtYXgiLCJzZXRfdXRmXzhfdWNoYXIiLCJzZXQiLCJsYXN0IiwiaXNfdmFsaWRfdXRmXzgiLCJnZXRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwic2V0X3V0Zl8xNmJlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2YmUiLCJnZXRfdXRmXzE2bGVfdWNoYXIiLCJzZXRfdXRmXzE2bGVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZsZSIsIlN0ZGxpYl9CeXRlcyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvYnl0ZXMubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FB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LE1BaUJuQixpQ0FBQS9JLElBQUE7QUFBQTtBQUFBLEtBWkUsWUFBZ0I7QUFBQSxLQUNoQixjQUFnQjtBQUFBLFNBQUFrSSxJQUNWO0FBQUEsS0FDRztBQUFBLE1BQ0EsY0FBYztBQUFBLFVBQUFnQixPQUVuQjtBQUFBLE1BQ0EsZUFBbUI7QUFBQSxVQUFBaEIsTUFDYjtBQUFBLE1BQ0c7QUFBQSxXQUFBbEksTUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BRDRCO0FBQUE7QUFBQSxTQUFBQSxNQU5KO0FBQUE7QUFBQTtBQUFBLEdBU2hCO0FBQUE7QUFBQSxJQUFBNEo7QUFBQUEsTUEzeEJMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEcERwQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gSW50Lm1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCB1bnNhZmVfZXNjYXBlIHMgPVxuICAoKiBXZSBwZXJmb3JtIHR3byBwYXNzZXMgb24gdGhlIGlucHV0IHNlcXVlbmNlLCBvbmUgdG8gY29tcHV0ZSB0aGVcbiAgICAgcmVzdWx0IHNpemUgYW5kIG9uZSB0byB3cml0ZSB0aGUgcmVzdWx0LlxuXG4gICAgICMxMTUwOCwgIzExNTA5OiBUaGlzIGxvZ2ljIHdvdWxkIGJlIGluY29ycmVjdCBpbiBwcmVzZW5jZSBvZlxuICAgICBjb25jdXJyZW50IG1vZGlmaWNhdGlvbiB0byB0aGUgaW5wdXQsIG1ha2luZyB0aGUgdXNlIG9mXG4gICAgIFt1bnNhZmVfc2V0XSBiZWxvdyBtZW1vcnktdW5zYWZlLlxuXG4gICAgIFByZWNvbmRpdGlvbjogVGhpcyBmdW5jdGlvbiBtYXkgYmUgc2FmZWx5IGNhbGxlZCBvbjpcbiAgICAgLSBhbiBpbW11dGFibGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAtIGEgdW5pcXVlbHktb3duZWQgYnl0ZSBzZXF1ZW5jZSAodGhlIGZ1bmN0aW9uIHRha2VzIG93bmVyc2hpcClcblxuICAgICBJbiBlaXRoZXIgY2FzZSB3ZSByZXR1cm4gYSB1bmlxdWVseS1vd25lZCBieXRlIHNlcXVlbmNlLlxuICAqKVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIHNcbiAgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBlc2NhcGVkIGIgPVxuICBsZXQgYiA9IGNvcHkgYiBpblxuICAoKiBXZSBjb3B5IG91ciBpbnB1dCB0byBvYnRhaW4gYSB1bmlxdWVseS1vd25lZCBieXRlIHNlcXVlbmNlIFtiXVxuICAgICB0byBzYXRpc2Z5IFt1bnNhZmVfZXNjYXBlXSdzIHByZWNvbmRpdGlvbiAqKVxuICB1bnNhZmVfZXNjYXBlIGJcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiBUaGUgZ2V0XyBmdW5jdGlvbnMgYXJlIGFsbCBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNnVcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG4gIGVsc2Ugc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4XG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9iZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHggZWxzZVxuICB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcblxuKCogVVRGIGNvZGVjcyBhbmQgdmFsaWRhdGlvbnMgKilcblxubGV0IGRlY19pbnZhbGlkID0gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkXG5sZXRbQGlubGluZV0gZGVjX3JldCBuIHUgPSBVY2hhci51dGZfZGVjb2RlIG4gKFVjaGFyLnVuc2FmZV9vZl9pbnQgdSlcblxuKCogSW4gY2FzZSBvZiBkZWNvZGluZyBlcnJvciwgaWYgd2UgZXJyb3Igb24gdGhlIGZpcnN0IGJ5dGUsIHdlXG4gICBjb25zdW1lIHRoZSBieXRlLCBvdGhlcndpc2Ugd2UgY29uc3VtZSB0aGUgW25dIGJ5dGVzIHByZWNlZGluZ1xuICAgdGhlIGVycm9yaW5nIGJ5dGUuXG5cbiAgIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGNsaWVudCB1c2VzIGRlY29kZXMgd2l0aG91dCBjYXJpbmcgYWJvdXRcbiAgIHZhbGlkaXR5IGl0IG5hdHVyYWxseSByZXBsYWNlIGJvZ3VzIGRhdGEgd2l0aCBVY2hhci5yZXAgYWNjb3JkaW5nXG4gICB0byB0aGUgV0hBVFdHIEVuY29kaW5nIHN0YW5kYXJkLiBPdGhlciBzY2hlbWVzIGFyZSBwb3NzaWJsZSBieVxuICAgY29uc3VsdGluZyB0aGUgbnVtYmVyIG9mIHVzZWQgYnl0ZXMgb24gaW52YWxpZCBkZWNvZGVzLiBGb3IgbW9yZVxuICAgZGV0YWlscyBzZWUgaHR0cHM6Ly9oc2l2b25lbi5maS9icm9rZW4tdXRmLTgvXG5cbiAgIEZvciB0aGlzIHJlYXNvbiBpbiBbZ2V0X3V0Zl84X3VjaGFyXSB3ZSBncmFkdWFsbHkgY2hlY2sgdGhlIG5leHRcbiAgIGJ5dGUgaXMgYXZhaWxhYmxlIHJhdGhlciB0aGFuIGRvaW5nIGl0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgZmlyc3QgYnl0ZS4gQ29udHJhc3Qgd2l0aCBbaXNfdmFsaWRfdXRmXzhdLiAqKVxuXG4oKiBVVEYtOCAqKVxuXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194QkYgYiA9IGIgbHNyIDYgPD4gMGIxMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94QTBfdG9feEJGIGIgPSBiIGxzciA1IDw+IDBiMTAxXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OUYgYiA9IGIgbHNyIDUgPD4gMGIxMDBcbmxldFtAaW5saW5lXSBub3RfaW5feDkwX3RvX3hCRiBiID0gYiA8IDB4OTAgfHwgMHhCRiA8IGJcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g4RiBiID0gYiBsc3IgNCA8PiAweDhcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzIgYjAgYjEgPVxuICAoKGIwIGxhbmQgMHgxRikgbHNsIDYpIGxvclxuICAoKGIxIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8zIGIwIGIxIGIyID1cbiAgKChiMCBsYW5kIDB4MEYpIGxzbCAxMikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMgPVxuICAoKGIwIGxhbmQgMHgwNykgbHNsIDE4KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCAxMikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjMgbGFuZCAweDNGKSlcblxubGV0IGdldF91dGZfOF91Y2hhciBiIGkgPVxuICBsZXQgYjAgPSBnZXRfdWludDggYiBpIGluICgqIHJhaXNlcyBpZiBbaV0gaXMgbm90IGEgdmFsaWQgaW5kZXguICopXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIGIwIHdpdGggKCogU2VlIFRoZSBVbmljb2RlIFN0YW5kYXJkLCBUYWJsZSAzLjcgKilcbiAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gZGVjX3JldCAxIGIwXG4gIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGRlY19yZXQgMiAodXRmXzhfdWNoYXJfMiBiMCBiMSlcbiAgfCAnXFx4RTAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3hBMF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RUQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OUYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhGMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDkwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OEYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgXyAtPiBkZWNfaW52YWxpZCAxXG5cbmxldCBzZXRfdXRmXzhfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgICBzZXRfdWludDggYiBpIHU7XG4gICAgICAxXG4gIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhDMCBsb3IgKHUgbHNyIDYpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAyKVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RTAgbG9yICh1IGxzciAxMikpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMylcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RjAgbG9yICh1IGxzciAxOCkpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIChpICsgMikgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgNClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzggYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgKGdldCBiIGkpIHdpdGhcbiAgICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBsb29wIG1heCBiIChpICsgMSlcbiAgICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94QTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFRCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDlGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g5MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g4RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkJFICopXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2YmVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkxFICopXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2bGVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTQzNDQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX2JsaXRfc3RyaW5nIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX3N0cmluZ19oYXNoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJlbXB0eSIsIlN0ZGxpYiIsIlN0ZGxpYl9CeXRlcyIsImJ0cyIsImJvcyIsIm1ha2UiLCJuIiwiYyIsImluaXQiLCJvZl9ieXRlcyIsInRvX2J5dGVzIiwic3ViIiwicyIsIm9mcyIsImxlbiIsImJsaXQiLCJjc3RfU3RyaW5nX2NvbmNhdCIsImNvbmNhdCIsInNlcCIsImwiLCJzZXBsZW4iLCJhY2MiLCJwYXJhbSIsInBvcyIsImhkIiwidGwiLCJ4IiwiZHN0IiwiY2F0IiwiY3N0X1N0cmluZ19pbmRleF9mcm9tX0J5dGVzX2luIiwiY3N0X1N0cmluZ19pbmRleF9mcm9tX29wdF9CeXRlIiwiY3N0X1N0cmluZ19yaW5kZXhfZnJvbV9CeXRlc19yIiwiY3N0X1N0cmluZ19yaW5kZXhfZnJvbV9vcHRfQnl0IiwiY3N0X1N0cmluZ19jb250YWluc19mcm9tX0J5dGVzIiwiY3N0X1N0cmluZ19yY29udGFpbnNfZnJvbV9CeXRlIiwiaXRlciIsImkiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJmb2xkX3JpZ2h0IiwiYSIsImZvbGRfbGVmdCIsImV4aXN0cyIsImZvcl9hbGwiLCJpc19zcGFjZSIsInRyaW0iLCJlc2NhcGVkIiwiYiIsImluZGV4X3JlYyIsImxpbSIsImluZGV4IiwiaW5kZXhfcmVjX29wdCIsImluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXgiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9yZWNfb3B0IiwicmluZGV4X29wdCIsInJpbmRleF9mcm9tX29wdCIsImNvbnRhaW5zX2Zyb20iLCJjb250YWlucyIsInJjb250YWluc19mcm9tIiwidXBwZXJjYXNlX2FzY2lpIiwibG93ZXJjYXNlX2FzY2lpIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsInN0YXJ0c193aXRoIiwicHJlZml4IiwibGVuX3MiLCJsZW5fcHJlIiwiZW5kc193aXRoIiwic3VmZml4IiwibGVuX3N1ZiIsImRpZmYiLCJoYXNoIiwic3BsaXRfb25fY2hhciIsInIiLCJqIiwiY29tcGFyZSIsInRvX3NlcSIsInRvX3NlcWkiLCJvZl9zZXEiLCJnIiwiZ2V0X3V0Zl84X3VjaGFyIiwiaXNfdmFsaWRfdXRmXzgiLCJnZXRfdXRmXzE2YmVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiZ2V0X2ludDgiLCJnZXRfdWludDE2X2xlIiwiZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQzMl9iZSIsImdldF9pbnQ2NF9sZSIsImdldF9pbnQ2NF9iZSIsIlN0ZGxpYl9TdHJpbmciXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL3N0cmluZy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBZixNQUFBO0FBQUEsSUFBQWdCLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0FBQUM7QUFBQUEsSUNtQ0UsT0FBVSxn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QSxZQUFBOEUsbUJBQUE5RSxHQUFBd0I7QUFBQUEsUUFBQSxNQUVIO0FBQUEsSUFBTywyQ0FBRTtBQUFBO0FBQUEsWUFBQXVELGtCQUFBL0U7QUFBQUEsUUFBQSxNQUNiO0FBQUEsSUFBTztBQUFBO0FBQUEsWUFBQWdGLFNBQUFoRixHQUFBd0I7QUFBQUEsUUFBQSxNQVN2QjtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUF5RCxjQUFBakYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDQztBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUEwRCxjQUFBbEYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUEyRCxhQUFBbkYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDWDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUE0RCxhQUFBcEYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUE2RCxhQUFBckYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUE4RCxhQUFBdEYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUErRCxhQUFBdkYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUFnRSxhQUFBeEYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBLFlBQUFpRSxhQUFBekYsR0FBQXdCO0FBQUFBLFFBQUEsTUFDVDtBQUFBLElBQU8sMkNBQUU7QUFBQTtBQUFBO0FBQUEsSUFBQWtFO0FBQUFBLE1EblIvQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgZW1wdHkgPSBcIlwiXG5sZXQgb2ZfYnl0ZXMgPSBCLnRvX3N0cmluZ1xubGV0IHRvX2J5dGVzID0gQi5vZl9zdHJpbmdcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCA9ICggXiApXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5sZXQgZm9sZF9yaWdodCBmIHggYSA9XG4gIEIuZm9sZF9yaWdodCBmIChib3MgeCkgYVxubGV0IGZvbGRfbGVmdCBmIGEgeCA9XG4gIEIuZm9sZF9sZWZ0IGYgYSAoYm9zIHgpXG5sZXQgZXhpc3RzIGYgcyA9XG4gIEIuZXhpc3RzIGYgKGJvcyBzKVxubGV0IGZvcl9hbGwgZiBzID1cbiAgQi5mb3JfYWxsIGYgKGJvcyBzKVxuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBiID0gYm9zIHMgaW5cbiAgKCogV2Ugc2F0aXNmeSBbdW5zYWZlX2VzY2FwZV0ncyBwcmVjb25kaXRpb24gYnkgcGFzc2luZyBhblxuICAgICBpbW11dGFibGUgYnl0ZSBzZXF1ZW5jZSBbYl0uICopXG4gIGJ0cyAoQi51bnNhZmVfZXNjYXBlIGIpXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2ggOiBpbnQgLT4gc3RyaW5nIC0+IGludCA9IFwiY2FtbF9zdHJpbmdfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2ggMCB4XG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuXG4oKiBVVEYgZGVjb2RlcnMgYW5kIHZhbGlkYXRvcnMgKilcblxubGV0IGdldF91dGZfOF91Y2hhciBzIGkgPSBCLmdldF91dGZfOF91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfOCBzID0gQi5pc192YWxpZF91dGZfOCAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2YmVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2YmUgKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmxlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmxlIChib3MgcylcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfc3RyaW5nX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX3N0cmluZ19nZXQ2NFwiXG5cbmxldCBnZXRfaW50OCBzIGkgPSBCLmdldF9pbnQ4IChib3MgcykgaVxubGV0IGdldF91aW50MTZfbGUgcyBpID0gQi5nZXRfdWludDE2X2xlIChib3MgcykgaVxubGV0IGdldF91aW50MTZfYmUgcyBpID0gQi5nZXRfdWludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9uZSBzIGkgPSBCLmdldF9pbnQxNl9uZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbGUgcyBpID0gQi5nZXRfaW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2JlIHMgaSA9IEIuZ2V0X2ludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9sZSBzIGkgPSBCLmdldF9pbnQzMl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfYmUgcyBpID0gQi5nZXRfaW50MzJfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2xlIHMgaSA9IEIuZ2V0X2ludDY0X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9iZSBzIGkgPSBCLmdldF9pbnQ2NF9iZSAoYm9zIHMpIGlcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNDgyOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TZXEiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYiIsIkZsb2F0YXJyYXkiLCJjc3RfQXJyYXlfaW5pdCIsImNzdF9BcnJheV9zdWIiLCJjc3RfQXJyYXlfZmlsbCIsImNzdF9BcnJheV9ibGl0IiwiY3N0X0FycmF5X2l0ZXIyX2FycmF5c19tdXN0X2hhIiwiY3N0X0FycmF5X21hcDJfYXJyYXlzX211c3RfaGF2IiwiY3N0X0FycmF5X2Zvcl9hbGwyIiwiY3N0X0FycmF5X2V4aXN0czIiLCJjc3RfQXJyYXlfY29tYmluZSIsImluaXQiLCJsIiwicmVzIiwiaSIsIm1ha2VfbWF0cml4Iiwic3giLCJzeSIsIngiLCJjb3B5IiwiYSIsImFwcGVuZCIsImwxIiwic3ViIiwib2ZzIiwibGVuIiwiZmlsbCIsInYiLCJibGl0Iiwib2ZzMSIsIm9mczIiLCJpdGVyIiwiaXRlcjIiLCJiIiwibWFwIiwiciIsIm1hcF9pbnBsYWNlIiwibWFwaV9pbnBsYWNlIiwibWFwMiIsImxhIiwibGIiLCJpdGVyaSIsIm1hcGkiLCJ0b19saXN0IiwibGlzdF9sZW5ndGgiLCJhY2N1IiwicGFyYW0iLCJ0Iiwib2ZfbGlzdCIsInRsIiwiaGQiLCJmb2xkX2xlZnQiLCJmb2xkX2xlZnRfbWFwIiwiYWNjIiwiaW5wdXRfYXJyYXkiLCJtYXRjaCIsImVsdCIsIm91dHB1dF9hcnJheSIsImZvbGRfcmlnaHQiLCJleGlzdHMiLCJwIiwibiIsImZvcl9hbGwiLCJmb3JfYWxsMiIsImwyIiwibjEiLCJuMiIsImV4aXN0czIiLCJtZW0iLCJtZW1xIiwiZmluZF9vcHQiLCJmaW5kX2luZGV4IiwiZmluZF9tYXAiLCJmaW5kX21hcGkiLCJzcGxpdCIsImIwIiwiYmkiLCJhaSIsImNvbWJpbmUiLCJuYSIsIm5iIiwiQm90dG9tIiwic29ydCIsImNtcCIsIm1heHNvbiIsImkzMSIsImUiLCJqIiwiZXhuIiwiZmF0aGVyIiwic3RhYmxlX3NvcnQiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0IiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyIiwiczEiLCJpMSIsImkyIiwiZCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0b19zZXEiLCJhdXgiLCJ0b19zZXFpIiwib2Zfc2VxIiwiU3RkbGliX0FycmF5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9hcnJheS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFD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KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcblxubW9kdWxlIEZsb2F0YXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGZsb2F0YXJyYXkgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiBmbG9hdGFycmF5IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmxldCBpbml0IGwgZiA9XG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlXG4gIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgKCogU2VlICM2NTc1LiBXZSBjb3VsZCBhbHNvIGNoZWNrIGZvciBtYXhpbXVtIGFycmF5IHNpemUsIGJ1dCB0aGlzIGRlcGVuZHNcbiAgICAgb24gd2hldGhlciB3ZSBjcmVhdGUgYSBmbG9hdCBhcnJheSBvciBhIHJlZ3VsYXIgb25lLi4uICopXG4gIGVsc2VcbiAgIGxldCByZXMgPSBjcmVhdGUgbCAoZiAwKSBpblxuICAgZm9yIGkgPSAxIHRvIHByZWQgbCBkb1xuICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICBkb25lO1xuICAgcmVzXG5cbmxldCBtYWtlX21hdHJpeCBzeCBzeSBpbml0ID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzeCBbfHxdIGluXG4gIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgdW5zYWZlX3NldCByZXMgeCAoY3JlYXRlIHN5IGluaXQpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwX2lucGxhY2UgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgYSBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gIGRvbmVcblxubGV0IG1hcGlfaW5wbGFjZSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgdW5zYWZlX3NldCBhIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICBkb25lXG5cbmxldCBtYXAyIGYgYSBiID1cbiAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgaWYgbGEgPD4gbGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlIGJlZ2luXG4gICAgaWYgbGEgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSAoZiAodW5zYWZlX2dldCBhIDApICh1bnNhZmVfZ2V0IGIgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBtYXBpIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmIDAgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQgcmVjIHRvbGlzdCBpIHJlcyA9XG4gICAgaWYgaSA8IDAgdGhlbiByZXMgZWxzZSB0b2xpc3QgKGkgLSAxKSAodW5zYWZlX2dldCBhIGkgOjogcmVzKSBpblxuICB0b2xpc3QgKGxlbmd0aCBhIC0gMSkgW11cblxuKCogQ2Fubm90IHVzZSBMaXN0Lmxlbmd0aCBoZXJlIGJlY2F1c2UgdGhlIExpc3QgbW9kdWxlIGRlcGVuZHMgb24gQXJyYXkuICopXG5sZXQgcmVjIGxpc3RfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY3VcbiAgfCBfOjp0IC0+IGxpc3RfbGVuZ3RoIChzdWNjIGFjY3UpIHRcblxubGV0IG9mX2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGEgPSBjcmVhdGUgKGxpc3RfbGVuZ3RoIDAgbCkgaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpKzEpIHRsIGluXG4gICAgICBmaWxsIDEgdGxcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX2xlZnRfbWFwIGYgYWNjIGlucHV0X2FycmF5ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dF9hcnJheSBpblxuICBpZiBsZW4gPSAwIHRoZW4gKGFjYywgW3x8XSkgZWxzZSBiZWdpblxuICAgIGxldCBhY2MsIGVsdCA9IGYgYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IDApIGluXG4gICAgbGV0IG91dHB1dF9hcnJheSA9IGNyZWF0ZSBsZW4gZWx0IGluXG4gICAgbGV0IGFjYyA9IHJlZiBhY2MgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGFjYycsIGVsdCA9IGYgIWFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSBpKSBpblxuICAgICAgYWNjIDo9IGFjYyc7XG4gICAgICB1bnNhZmVfc2V0IG91dHB1dF9hcnJheSBpIGVsdDtcbiAgICBkb25lO1xuICAgICFhY2MsIG91dHB1dF9hcnJheVxuICBlbmRcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZvcl9hbGwyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZXhpc3RzMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZXhpc3RzMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtcSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiB4ID09ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9vcHQgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgaWYgcCB4IHRoZW4gU29tZSB4XG4gICAgICBlbHNlIGxvb3AgKHN1Y2MgaSlcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX2luZGV4IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gU29tZSBpXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXAgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX21hcGkgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IGEgaSkgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKHN1Y2MgaSlcbiAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICBpblxuICBsb29wIDBcblxubGV0IHNwbGl0IHggPVxuICBpZiB4ID0gW3x8XSB0aGVuIFt8fF0sIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCBhMCwgYjAgPSB1bnNhZmVfZ2V0IHggMCBpblxuICAgIGxldCBuID0gbGVuZ3RoIHggaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBuIGEwIGluXG4gICAgbGV0IGIgPSBjcmVhdGUgbiBiMCBpblxuICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgbGV0IGFpLCBiaSA9IHVuc2FmZV9nZXQgeCBpIGluXG4gICAgICB1bnNhZmVfc2V0IGEgaSBhaTtcbiAgICAgIHVuc2FmZV9zZXQgYiBpIGJpXG4gICAgZG9uZTtcbiAgICBhLCBiXG4gIGVuZFxuXG5sZXQgY29tYmluZSBhIGIgPVxuICBsZXQgbmEgPSBsZW5ndGggYSBpblxuICBsZXQgbmIgPSBsZW5ndGggYiBpblxuICBpZiBuYSA8PiBuYiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuY29tYmluZVwiO1xuICBpZiBuYSA9IDAgdGhlbiBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgeCA9IGNyZWF0ZSBuYSAodW5zYWZlX2dldCBhIDAsIHVuc2FmZV9nZXQgYiAwKSBpblxuICAgIGZvciBpID0gMSB0byBuYSAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgeCBpICh1bnNhZmVfZ2V0IGEgaSwgdW5zYWZlX2dldCBiIGkpXG4gICAgZG9uZTtcbiAgICB4XG4gIGVuZFxuXG5leGNlcHRpb24gQm90dG9tIG9mIGludFxubGV0IHNvcnQgY21wIGEgPVxuICBsZXQgbWF4c29uIGwgaSA9XG4gICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAheFxuICAgIGVuZCBlbHNlXG4gICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgIHRoZW4gaTMxKzFcbiAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgaW5cbiAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICBidWJibGVkb3duIGwgalxuICBpblxuICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gIGRvbmU7XG4gIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cblxubGV0IGN1dG9mZiA9IDVcbmxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgZW5kXG4gICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gIGluXG4gIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgIGRlY3IgajtcbiAgICAgIGRvbmU7XG4gICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgZG9uZTtcbiAgaW5cbiAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgIGxldCB0ID0gbWFrZSBsMiAoZ2V0IGEgMCkgaW5cbiAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgZW5kXG5cblxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3Jldl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBsZW4gPSBsaXN0X2xlbmd0aCAwIGwgaW5cbiAgICAgIGxldCBhID0gY3JlYXRlIGxlbiBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICAgIGluXG4gICAgICBmaWxsIChsZW4tMikgdGxcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gIG9mX3Jldl9saXN0IGxcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNTU2MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9oYXNoIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbXVsIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiU3RkbGliX1N5cyIsIkFzc2VydF9mYWlsdXJlIiwiemVybyIsIm9uZSIsInN1Y2MiLCJuIiwicHJlZCIsImFicyIsImxvZ25vdCIsIm1pbnVzX29uZSIsIm1pbl9pbnQiLCJtYXhfaW50IiwidW5zaWduZWRfdG9faW50IiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsInMiLCJjb21wYXJlIiwiZXF1YWwiLCJ4IiwieSIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwibWluIiwibWF4IiwidW5zaWduZWRfZGl2IiwiZCIsInEiLCJyIiwidW5zaWduZWRfcmVtIiwic2VlZGVkX2hhc2giLCJzZWVkIiwiaGFzaCIsIlN0ZGxpYl9JbnQzMiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvaW50MzIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxLQUFBQyxHQytDcUI7QUFBQSxZQUFBQyxLQUFBRCxHQUNBO0FBQUEsWUFBQUUsSUFBQUYsR0FDTiw0Q0FBeUI7QUFBQSxZQUFBRyxPQUFBSCxHQUdYO0FBQUE7QUFBQSxVRHBEN0I7QUFBQTtBQUFBLElBQUFJLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBQSxZQ3lETTtBQUFBLEtBQUFDO0FBQUFBLE9BQ0EsU0FBQVA7QUFBQUEsUUFDSyx1Q0FBdUI7QUFBQSxTQUN4QjtBQUFBLFFBRUE7QUFBQSxPQUFJO0FBQUE7QUFBQSxJRDlEZDtBQUFBLEtDb0VNO0FBQUEsUUFBQU8sa0JBRkEsU0FBQVAsR0FBUyxtQkFBeUI7QUFBQTtBQUFBLFlBQUFRLFVBQUFSLEdBS3RCLHVDQUFhO0FBQUEsWUFBQVMsY0FBQUM7QUFBQUEsSUFNN0IsY0FBUztBQUFBO0FBQUEsZUQ3RVg7QUFBQSw4QkM4RW9CO0FBQUEsS0Q5RXBCO0FBQUE7QUFBQSxHQzhFd0I7QUFBQSxPQUFBQyxVRDlFeEI7QUFBQSxZQUFBQyxNQUFBQyxHQUFBQyxHQ2tGNEIsMkNBQ1MsQ0FBSTtBQUFBLFlBQUFDLGlCQUFBZixHQUFBZ0I7QUFBQUEsUUFBQUYsSUFHZixvQkFBQUQsSUFBaEI7QUFBQSxJQUprQiw2QkFJYTtBQUFBO0FBQUEsWUFBQUksSUFBQUosR0FBQUMsR0FFcEIsMkNBQW9CO0FBQUEsWUFBQUksSUFBQUwsR0FBQUMsR0FDcEIsc0NBQW9CO0FBQUEsWUFBQUssYUFBQW5CLEdBQUFvQjtBQUFBQSxJQU1wQztBQUFBLEtBQ0UsK0NBSTRDO0FBQUEsUUFBQUMsSUFGNUIsdUNBQUFDLElBQ0w7QUFBQSxJQUNYLGtEQUE0QztBQUFBO0FBQUEsWUFBQUMsYUFBQXZCLEdBQUFvQjtBQUFBQSxJQUd0QyxXQUFMLFNBQUssMEJBQXFCO0FBQUE7QUFBQSxZQUFBSSxZQUFBQyxNQUFBWixHQUlULGtDQUErQjtBQUFBLFlBQUFhLEtBQUFiLEdBQzNDLCtCQUE0QjtBQUFBO0FBQUEsSUFBQWM7QUFBQUEsTUQ1R3pDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTU2NjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfaGFzaCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJnbG9iYWxfZGF0YSIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJtaW5faW50IiwibWF4X2ludCIsIlN0ZGxpYiIsInN1Y2MiLCJuIiwicHJlZCIsImFicyIsImxvZ25vdCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJzIiwiY29tcGFyZSIsIngiLCJ5IiwiZXF1YWwiLCJ1bnNpZ25lZF9jb21wYXJlIiwibSIsIm1pbiIsIm1heCIsInVuc2lnbmVkX2RpdiIsImQiLCJxIiwiciIsInVuc2lnbmVkX3JlbSIsInNlZWRlZF9oYXNoIiwic2VlZCIsImhhc2giLCJTdGRsaWJfSW50NjQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2ludDY0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLEtBQUFDLEdDNkNhLDZCQUFRO0FBQUEsWUFBQUMsS0FBQUQsR0FDUiw2QkFBUTtBQUFBLFlBQUFFLElBQUFGO0FBQUFBLElBQ04sdUNBQW9CLHlCQUFLO0FBQUE7QUFBQSxZQUFBRyxPQUFBSCxHQUd6QixxQ0FBYztBQUFBLE9BQUFILFlBR2I7QUFBQSxZQUFBTyxnQkFBQUo7QUFBQUEsSUFFVDtBQUFBO0FBQUEsY0FBdUI7QUFBQSxLQUN4QjtBQUFBLElBRUE7QUFBQSxHQUFJO0FBQUEsWUFBQUssVUFBQUwsR0FHUSx5Q0FBYTtBQUFBLFlBQUFNLGNBQUFDO0FBQUFBLElBTTdCLGNBQVM7QUFBQTtBQUFBLGVEbkVYO0FBQUEsOEJDb0VvQjtBQUFBLEtEcEVwQjtBQUFBO0FBQUEsR0NvRXdCO0FBQUEsWUFBQUMsUUFBQUMsR0FBQUMsR0FhSSwrQkFBa0I7QUFBQSxZQUFBQyxNQUFBRixHQUFBQyxHQUFsQiw2Q0FDUyxDQUFJO0FBQUEsWUFBQUUsaUJBQUFaLEdBQUFhO0FBQUFBLFFBQUFILElBR2YsNEJBQUFELElBQWhCO0FBQUEsSUFKa0IsK0JBSWE7QUFBQTtBQUFBLFlBQUFLLElBQUFMLEdBQUFDLEdBRXBCLDJDQUFvQjtBQUFBLFlBQUFLLElBQUFOLEdBQUFDLEdBQ3BCLHNDQUFvQjtBQUFBLFlBQUFNLGFBQUFoQixHQUFBaUI7QUFBQUEsSUFNcEM7QUFBQSxLQUNFLCtDQUk0QztBQUFBO0FBQUEsS0FBQUM7QUFBQUEsT0FGdkM7QUFBQSxTQUFXO0FBQUEsV0FBSztBQUFBO0FBQUEsS0FBQUMsSUFDaEIsa0JBQU07QUFBQSxJQUNYLHFDQXRETSwwQkFzRHNDO0FBQUE7QUFBQSxZQUFBQyxhQUFBcEIsR0FBQWlCO0FBQUFBLElBR3RDLE9BQVgsa0JBQU0sZUFBSyx1QkFBcUI7QUFBQTtBQUFBLFlBQUFJLFlBQUFDLE1BQUFiLEdBSVQsa0NBQStCO0FBQUEsWUFBQWMsS0FBQWQsR0FDM0MsK0JBQTRCO0FBQUE7QUFBQSxJQUFBZTtBQUFBQSxNQXJEdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR0REYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQ2NF06IDY0LWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQ2NCAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG5leHRlcm5hbCB0b19uYXRpdmVpbnQgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuXG5sZXQgemVybyA9IDBMXG5sZXQgb25lID0gMUxcbmxldCBtaW51c19vbmUgPSAtMUxcbmxldCBzdWNjIG4gPSBhZGQgbiAxTFxubGV0IHByZWQgbiA9IHN1YiBuIDFMXG5sZXQgYWJzIG4gPSBpZiBuID49IDBMIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDAwMDAwMDAwMExcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRkZGRkZGRkZGTFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xTClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gIGZ1biBuIC0+XG4gICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZyA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG50eXBlIHQgPSBpbnQ2NFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTU3NjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfaGFzaCIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX211bCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9TeXMiLCJ6ZXJvIiwib25lIiwic3VjYyIsIm4iLCJwcmVkIiwiYWJzIiwic2l6ZSIsIm1pbl9pbnQiLCJtYXhfaW50IiwibG9nbm90IiwidW5zaWduZWRfdG9faW50IiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsInMiLCJjb21wYXJlIiwiZXF1YWwiLCJ4IiwieSIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwibWluIiwibWF4IiwidW5zaWduZWRfZGl2IiwiZCIsInEiLCJyIiwidW5zaWduZWRfcmVtIiwic2VlZGVkX2hhc2giLCJzZWVkIiwiaGFzaCIsIlN0ZGxpYl9OYXRpdmVpbnQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL25hdGl2ZWludC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxLQUFBQyxHQzJDcUI7QUFBQSxZQUFBQyxLQUFBRCxHQUNBO0FBQUEsWUFBQUUsSUFBQUYsR0FDTiw0Q0FBeUI7QUFBQTtBQUFBLElBQUFHLE9EN0N4QztBQUFBLElBQUFDLFVDK0NjO0FBQUEsSUFBQUMsVUFDQTtBQUFBLFlBQUFDLE9BQUFOLEdBQ2U7QUFBQSxPQUFBSyxZQUREO0FBQUEsWUFBQUUsZ0JBQUFQO0FBQUFBLElBTXJCLHVDQUF1QjtBQUFBLEtBQ3hCO0FBQUEsSUFFQTtBQUFBLEdBQUk7QUFBQSxZQUFBUSxVQUFBUixHQUdRLHVDQUFhO0FBQUEsWUFBQVMsY0FBQUM7QUFBQUEsSUFNN0IsY0FBUztBQUFBO0FBQUEsZURsRVg7QUFBQSw4QkNtRW9CO0FBQUEsS0RuRXBCO0FBQUE7QUFBQSxHQ21Fd0I7QUFBQSxPQUFBQyxVQWR0QjtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDLEdBa0IwQiwyQ0FDUyxDQUFJO0FBQUEsWUFBQUMsaUJBQUFmLEdBQUFnQjtBQUFBQSxRQUFBRixJQUdmLGlCQUFBRCxJQUFoQjtBQUFBLElBSmtCLDZCQUlhO0FBQUE7QUFBQSxZQUFBSSxJQUFBSixHQUFBQyxHQUVwQiwyQ0FBb0I7QUFBQSxZQUFBSSxJQUFBTCxHQUFBQyxHQUNwQixzQ0FBb0I7QUFBQSxZQUFBSyxhQUFBbkIsR0FBQW9CO0FBQUFBLElBTXBDO0FBQUEsS0FDRSwrQ0FJNEM7QUFBQSxRQUFBQyxJQUY1Qix1Q0FBQUMsSUFDTDtBQUFBLElBQ1gsa0RBQTRDO0FBQUE7QUFBQSxZQUFBQyxhQUFBdkIsR0FBQW9CO0FBQUFBLElBR3RDLFdBQUwsU0FBSywwQkFBcUI7QUFBQTtBQUFBLFlBQUFJLFlBQUFDLE1BQUFaLEdBSVQsa0NBQStCO0FBQUEsWUFBQWEsS0FBQWIsR0FDM0MsK0JBQTRCO0FBQUE7QUFBQSxJQUFBYztBQUFBQSxNQTVDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHJERiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTU4NTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfTWFwX2JhbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9MaXN0IiwiY3N0X01hcF9yZW1vdmVfbWluX2VsdCIsIlN0ZGxpYl9NYXAiLCJPcmQiLCJoZWlnaHQiLCJwYXJhbSIsImgiLCJjcmVhdGUiLCJsIiwieCIsImQiLCJyIiwiaGwiLCJociIsInNpbmdsZXRvbiIsImJhbCIsImxyIiwibGQiLCJsdiIsImxsIiwibHJyIiwibHJkIiwibHJ2IiwibHJsIiwicnIiLCJyZCIsInJ2IiwicmwiLCJybHIiLCJybGQiLCJybHYiLCJybGwiLCJlbXB0eSIsImlzX2VtcHR5IiwiYWRkIiwiZGF0YSIsIm0iLCJ2IiwiYyIsImZpbmQiLCJmaW5kX2ZpcnN0IiwiZDAiLCJ2MCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwibWVtIiwibWluX2JpbmRpbmciLCJtaW5fYmluZGluZ19vcHQiLCJtYXhfYmluZGluZyIsIm1heF9iaW5kaW5nX29wdCIsInJlbW92ZV9taW5fYmluZGluZyIsInQxIiwidDIiLCJtYXRjaCIsInJlbW92ZSIsInVwZGF0ZSIsImFkZF90b19saXN0IiwiaXRlciIsIm1hcCIsIm1hcGkiLCJmb2xkIiwiYWNjdSIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImpvaW4iLCJyaCIsImxoIiwiY29uY2F0IiwiY29uY2F0X29yX2pvaW4iLCJzcGxpdCIsInByZXMiLCJtZXJnZSIsInMxIiwiczIiLCJoMSIsInIxIiwiZDEiLCJ2MSIsImwxIiwicjIiLCJkMiIsImwyIiwidjIiLCJ1bmlvbiIsImgyIiwicyIsImZpbHRlciIsInB2ZCIsImZpbHRlcl9tYXAiLCJmdmQiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNvbnNfZW51bSIsImUiLCJjb21wYXJlIiwiY21wIiwibTEiLCJtMiIsImUyIiwiZTEiLCJlcXVhbCIsImNhcmRpbmFsIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJvZl9saXN0IiwiYnMiLCJhZGRfc2VxIiwiaSIsIm9mX3NlcSIsInNlcV9vZl9lbnVtIiwicmVzdCIsInQiLCJ0b19zZXEiLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJuIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9tYXAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWIsY0FBQTtBQUFBLElBQUFBLGdCQUFBO0FBQUEsSUFBQUEsZ0JBQUE7QUFBQSxJQUFBQSxnQkFBQTtBQUFBLElBQUFjLHlCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLGdCQUFBQztBQUFBQSxpQkFBQUMsT0FBQUM7QUFBQUEsU0NnRmlCLFlBQ0E7QUFBQSxhQUFBQyxJQURBO0FBQUEsU0FFRztBQUFBLFFBQUM7QUFBQSxpQkFBQUMsT0FBQUMsR0FBQUMsR0FBQUMsR0FBQUM7QUFBQUE7QUFBQUEsVUFBQUMsS0FHTjtBQUFBLFVBQUFDLEtBQWtCO0FBQUEsZ0JBQzNCO0FBQUE7QUFBQSxRQUEyRDtBQUFBLGlCQUFBQyxVQUFBTCxHQUFBQyxHQUV6QywwQkFBbUM7QUFBQSxpQkFBQUssSUFBQVAsR0FBQUMsR0FBQUMsR0FBQUM7QUFBQUEsU0FHckQsVUFBQUwsSUFBQSxNQUFBTSxLQUErQyxZQUFBQSxLQUFoQjtBQUFBLFNBQy9CLFVBQUFOLE1BQUEsTUFBQU8sS0FBK0MsY0FBQUEsS0FBaEI7QUFBQSxTQUMvQjtBQUFBLFVBQW9CLFFBRVAsMkNBdUJnRDtBQUFBLGNBQUFHLEtBekJ6QyxNQUFBQyxLQUFBLE1BQUFDLEtBQUEsTUFBQUMsS0FBQSxZQUlFO0FBQUEsVUFBYjtBQUFBLFdBQ2UsT0FBaUIsbUJBQWpCLG9CQW9CcUM7QUFBQSxVQW5CbEQsU0FFUSx5Q0FpQjBDO0FBQUE7QUFBQSxXQUFBQyxNQW5CbEQ7QUFBQSxXQUFBQyxNQUFBO0FBQUEsV0FBQUMsTUFBQTtBQUFBLFdBQUFDLE1BQUE7QUFBQSxpQkFJc0M7QUFBQSxVQUE5QixPQUFxQixPQUFyQix1Q0FlMEM7QUFBQTtBQUFBLFNBYnBEO0FBQUEsb0JBYVA7QUFBQTtBQUFBO0FBQUEsU0FiMkIsUUFFaEIsMkNBV2dEO0FBQUEsYUFBQUMsS0FiaEMsTUFBQUMsS0FBQSxNQUFBQyxLQUFBLE1BQUFDLEtBQUEsWUFJUDtBQUFBLFNBQWIsc0JBQ00sT0FBaUIsT0FBakIsZ0NBUThDO0FBQUEsU0FQbEQsU0FFUSwyQ0FLMEM7QUFBQTtBQUFBLFVBQUFDLE1BUGxEO0FBQUEsVUFBQUMsTUFBQTtBQUFBLFVBQUFDLE1BQUE7QUFBQSxVQUFBQyxNQUFBO0FBQUEsZ0JBSW1DO0FBQUEsU0FBM0IsT0FBa0IsT0FBbEIsb0NBRzBDO0FBQUE7QUFBQSxZQUFBQyxRRHRIbkU7QUFBQSxpQkFBQUMsU0FBQTVCLE9DMEhtQixvQkFBbUM7QUFBQSxpQkFBQTZCLElBQUF6QixHQUFBMEIsTUFBQUM7QUFBQUEsU0FFdEMsUUFFTjtBQUFBO0FBQUEsVUFBQTlCLElBRk07QUFBQSxVQUFBSyxJQUFBO0FBQUEsVUFBQUQsSUFBQTtBQUFBLFVBQUEyQixJQUFBO0FBQUEsVUFBQTdCLElBQUE7QUFBQSxVQUFBOEIsSUFJRTtBQUFBLFNBQ1IsWUFDRSw2Q0FNbUM7QUFBQSxTQUxoQztBQUFBLGNBQUFkLEtBSU07QUFBQSxVQUNULHNCQUF1QixnQkFBWTtBQUFBO0FBQUEsYUFBQUwsS0FKMUI7QUFBQSxTQUNULHNCQUF1QixnQkFHWTtBQUFBO0FBQUEsaUJBQUFvQixLQUFBOUIsR0FBQUo7QUFBQUEsYUFBQUEsVUFFOUI7QUFBQTtBQUFBLHdCQUVQO0FBQUE7QUFBQSxXQUFBTSxJQUZPO0FBQUEsV0FBQUQsSUFBQTtBQUFBLFdBQUEyQixJQUFBO0FBQUEsV0FBQTdCLElBQUE7QUFBQSxXQUFBOEIsSUFJQztBQUFBLFVBQ1IsWUFBYztBQUFBLGNBQUEzQixNQUNUO0FBQUE7QUFBQTtBQUFBLFFBQStCO0FBQUEsaUJBQUE2QixXQUFBbEQsR0FBQWU7QUFBQUEsYUFBQUEsVUFXdkI7QUFBQTtBQUFBLHdCQUViO0FBQUE7QUFBQSxXQUFBTSxNQUZhO0FBQUEsV0FBQThCLE9BQUE7QUFBQSxXQUFBQyxPQUFBO0FBQUEsV0FBQWxDLE1BQUE7QUFBQSxVQUlWO0FBQUEsZUFBQWtDLEtBQ0QsTUFBQUQsS0FBQSxNQUFBcEMsUUFBQTtBQUFBO0FBQUEsWUFkZSxZQUVqQjtBQUFBLGdCQUFBTSxJQUZpQixVQUFBOEIsT0FBQSxVQUFBQyxPQUFBLFVBQUFsQyxJQUFBO0FBQUEsWUFJZDtBQUFBLGFBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVNBO0FBQUE7QUFBQSxRQUFjO0FBQUEsaUJBQUFtQyxlQUFBckQsR0FBQWU7QUFBQUEsYUFBQUEsVUFXQztBQUFBO0FBQUEsd0JBRWpCO0FBQUE7QUFBQSxXQUFBTSxNQUZpQjtBQUFBLFdBQUE4QixPQUFBO0FBQUEsV0FBQUMsT0FBQTtBQUFBLFdBQUFsQyxNQUFBO0FBQUEsVUFJZDtBQUFBLGVBQUFrQyxLQUNELE1BQUFELEtBQUEsTUFBQXBDLFFBQUE7QUFBQTtBQUFBLFlBZG1CLFlBRXJCO0FBQUEsZ0JBQUFNLElBRnFCLFVBQUE4QixPQUFBLFVBQUFDLE9BQUEsVUFBQWxDLElBQUE7QUFBQSxZQUlsQjtBQUFBLGFBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVNBO0FBQUE7QUFBQSxRQUFrQjtBQUFBLGlCQUFBb0MsVUFBQXRELEdBQUFlO0FBQUFBLGFBQUFBLFVBV1I7QUFBQTtBQUFBLHdCQUVaO0FBQUE7QUFBQSxXQUFBTSxNQUZZO0FBQUEsV0FBQThCLE9BQUE7QUFBQSxXQUFBQyxPQUFBO0FBQUEsV0FBQWxDLE1BQUE7QUFBQSxVQUlUO0FBQUEsZUFBQWtDLEtBQ0QsTUFBQUQsS0FBQSxNQUFBcEMsUUFBQTtBQUFBO0FBQUEsWUFkYyxZQUVoQjtBQUFBLGdCQUFBTSxJQUZnQixVQUFBOEIsT0FBQSxVQUFBQyxPQUFBLFVBQUFsQyxJQUFBO0FBQUEsWUFJYjtBQUFBLGFBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVNBO0FBQUE7QUFBQSxRQUFhO0FBQUEsaUJBQUFxQyxjQUFBdkQsR0FBQWU7QUFBQUEsYUFBQUEsVUFXQztBQUFBO0FBQUEsd0JBRWhCO0FBQUE7QUFBQSxXQUFBTSxNQUZnQjtBQUFBLFdBQUE4QixPQUFBO0FBQUEsV0FBQUMsT0FBQTtBQUFBLFdBQUFsQyxNQUFBO0FBQUEsVUFJYjtBQUFBLGVBQUFrQyxLQUNELE1BQUFELEtBQUEsTUFBQXBDLFFBQUE7QUFBQTtBQUFBLFlBZGtCLFlBRXBCO0FBQUEsZ0JBQUFNLElBRm9CLFVBQUE4QixPQUFBLFVBQUFDLE9BQUEsVUFBQWxDLElBQUE7QUFBQSxZQUlqQjtBQUFBLGFBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVNBO0FBQUE7QUFBQSxRQUFpQjtBQUFBLGlCQUFBc0MsU0FBQXJDLEdBQUFKO0FBQUFBLGFBQUFBLFVBRVI7QUFBQTtBQUFBLHdCQUVYO0FBQUE7QUFBQSxXQUFBTSxJQUZXO0FBQUEsV0FBQUQsSUFBQTtBQUFBLFdBQUEyQixJQUFBO0FBQUEsV0FBQTdCLElBQUE7QUFBQSxXQUFBOEIsSUFJSDtBQUFBLFVBQ1IsWUFBYztBQUFBLGNBQUEzQixNQUNUO0FBQUE7QUFBQTtBQUFBLFFBQW1DO0FBQUEsaUJBQUFvQyxJQUFBdEMsR0FBQUo7QUFBQUEsYUFBQUEsVUFFbEM7QUFBQTtBQUFBLHdCQUVOO0FBQUE7QUFBQSxXQUFBTSxJQUZNO0FBQUEsV0FBQTBCLElBQUE7QUFBQSxXQUFBN0IsSUFBQTtBQUFBLFdBQUE4QixJQUlFO0FBQUEsaUJBQ1I7QUFBQTtBQUFBLGNBQUEzQixNQUFBO0FBQUE7QUFBQTtBQUFBLFFBQXVDO0FBQUEsaUJBQUFxQyxZQUFBM0M7QUFBQUEsYUFBQUEsVUFFdkI7QUFBQTtBQUFBLHdCQUNUO0FBQUEsY0FBQUcsSUFEUztBQUFBLHNCQUFBRSxJQUFBLFlBQUEyQixJQUFBLFlBRU07QUFBQSxVQUNaO0FBQUE7QUFBQSxRQUFhO0FBQUEsaUJBQUFZLGdCQUFBNUM7QUFBQUEsYUFBQUEsVUFFSDtBQUFBO0FBQUEsd0JBQ2I7QUFBQSxjQUFBRyxJQURhO0FBQUEsc0JBQUFFLElBQUEsWUFBQTJCLElBQUEsWUFFRTtBQUFBLFVBQ2I7QUFBQTtBQUFBLFFBQWlCO0FBQUEsaUJBQUFhLFlBQUE3QztBQUFBQSxhQUFBQSxVQUVWO0FBQUE7QUFBQSx3QkFDVDtBQUFBLFVBRFM7QUFBQSxlQUFBSyxJQUFBLFlBQUEyQixJQUFBO0FBQUEsV0FFTTtBQUFBO0FBQUEsY0FBQTFCLElBRk47QUFBQSxVQUdOO0FBQUE7QUFBQSxRQUFhO0FBQUEsaUJBQUF3QyxnQkFBQTlDO0FBQUFBLGFBQUFBLFVBRUg7QUFBQTtBQUFBLHdCQUNiO0FBQUEsVUFEYTtBQUFBLGVBQUFLLElBQUEsWUFBQTJCLElBQUE7QUFBQSxXQUVFO0FBQUE7QUFBQSxjQUFBMUIsSUFGRjtBQUFBLFVBR1Y7QUFBQTtBQUFBLFFBQWlCO0FBQUEsaUJBQUF5QyxtQkFBQS9DO0FBQUFBLFNBRUosWUFDaEIsb0RBRTRDO0FBQUEsYUFBQUcsSUFINUI7QUFBQTtBQUFBLGNBQUFHLElBQUEsVUFBQUQsSUFBQSxVQUFBMkIsSUFBQTtBQUFBLFVBR0EsT0FBc0IsSUFBdEIsK0JBQTRCO0FBQUE7QUFBQSxhQUFBMUIsTUFINUI7QUFBQSxTQUVKO0FBQUEsUUFDZ0M7QUFBQSxxQkFBQTBDLElBQUFDO0FBQUFBLFNBR3ZELFNBQ2dCO0FBQUEsU0FEaEIsU0FFZ0I7QUFBQSxhQUFBQyxRQUVDLGlCQUFBN0MsSUFBYyxVQUFBRCxJQUFBO0FBQUEsU0FDaEIsT0FBdUIsY0FBdkIsdUJBQXVCO0FBQUE7QUFBQSxpQkFBQStDLE9BQUEvQyxHQUFBMkI7QUFBQUEsU0FFekIsUUFFVDtBQUFBO0FBQUEsVUFBQXpCLElBRlM7QUFBQSxVQUFBRCxJQUFBO0FBQUEsVUFBQTJCLElBQUE7QUFBQSxVQUFBN0IsSUFBQTtBQUFBLFVBQUE4QixJQUlEO0FBQUEsU0FDUixZQUFjLGdCQUk4QztBQUFBLFNBSHZEO0FBQUEsY0FBQWQsS0FHTTtBQUFBLFVBQWMsc0JBQXVCLGdCQUFZO0FBQUE7QUFBQSxhQUFBTCxLQUZqRDtBQUFBLFNBQWMsc0JBQXVCLGdCQUVZO0FBQUE7QUFBQSxpQkFBQXNDLE9BQUFoRCxHQUFBbkIsR0FBQThDO0FBQUFBLFNBRW5EO0FBQUEsY0FBQW1CLFVBRUc7QUFBQSxVQUFNLGNBQ1I7QUFBQSxjQUFBcEIsU0FEUTtBQUFBLFVBRUg7QUFBQTtBQUFBO0FBQUEsVUFBQTdCLElBSk47QUFBQSxVQUFBSyxJQUFBO0FBQUEsVUFBQUQsSUFBQTtBQUFBLFVBQUEyQixJQUFBO0FBQUEsVUFBQTdCLElBQUE7QUFBQSxVQUFBOEIsSUFPRDtBQUFBLFNBQ1I7QUFBQSxjQUFBaUIsUUFDUTtBQUFBLFVBQVUsWUFDTixnQkFReUI7QUFBQSxjQUFBcEIsT0FUbkI7QUFBQSxVQUdaLDZDQU0rQjtBQUFBO0FBQUEsU0FMNUI7QUFBQSxjQUFBWCxLQUlFO0FBQUEsVUFDVCxzQkFBdUIsZ0JBQVk7QUFBQTtBQUFBLGFBQUFMLEtBSjFCO0FBQUEsU0FDVCxzQkFBdUIsZ0JBR1k7QUFBQTtBQUFBLGlCQUFBdUMsWUFBQWpELEdBQUEwQixNQUFBQztBQUFBQSxrQkFBQUYsSUFBQTdCO0FBQUFBLFVBRy9CLFlBQWlCO0FBQUEsY0FBQUcsSUFBakI7QUFBQSxVQUF5QztBQUFBLFNBQWdCO0FBQUEsU0FDbkUsd0JBQWM7QUFBQTtBQUFBLGlCQUFBbUQsS0FBQXJFLEdBQUFlO0FBQUFBLGFBQUFBLFVBRUg7QUFBQTtBQUFBLHdCQUNBO0FBQUEsY0FBQU0sSUFEQSxZQUFBRCxJQUFBLFlBQUEyQixJQUFBLFlBQUE3QixJQUFBO0FBQUEsVUFHUDtBQUFBLFVBQVU7QUFBQSxVQUFLO0FBQUE7QUFBQSxRQUFVO0FBQUEsaUJBQUFvRCxJQUFBdEUsR0FBQWU7QUFBQUEsU0FFbkIsWUFFTjtBQUFBO0FBQUEsVUFBQUMsSUFGTTtBQUFBLFVBQUFLLElBQUE7QUFBQSxVQUFBRCxJQUFBO0FBQUEsVUFBQTJCLElBQUE7QUFBQSxVQUFBN0IsSUFBQTtBQUFBLFVBQUFBLE1BSUc7QUFBQSxVQUFBRSxNQUNBO0FBQUEsVUFBQUMsTUFDQTtBQUFBLFNBQ1Q7QUFBQSxRQUE0QjtBQUFBLGlCQUFBa0QsS0FBQXZFLEdBQUFlO0FBQUFBLFNBRXJCLFlBRVA7QUFBQTtBQUFBLFVBQUFDLElBRk87QUFBQSxVQUFBSyxJQUFBO0FBQUEsVUFBQUQsSUFBQTtBQUFBLFVBQUEyQixJQUFBO0FBQUEsVUFBQTdCLElBQUE7QUFBQSxVQUFBQSxNQUlFO0FBQUEsVUFBQUUsTUFDQTtBQUFBLFVBQUFDLE1BQ0E7QUFBQSxTQUNUO0FBQUEsUUFBNEI7QUFBQSxpQkFBQW1ELEtBQUF4RSxHQUFBOEMsR0FBQTJCO0FBQUFBLGFBQUEzQixNQUdoQyxHQUFBMkIsU0FBQTtBQUFBO0FBQUEsb0JBQ1c7QUFBQTtBQUFBLFdBQUFwRCxJQURYO0FBQUEsV0FBQUQsSUFBQTtBQUFBLFdBQUEyQixJQUFBO0FBQUEsV0FBQTdCLElBQUE7QUFBQSxXQUFBdUQsU0FHYSxvQkFBTztBQUFBLFVBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUFDLFFBQUFDLEdBQUE1RDtBQUFBQSxhQUFBQSxVQUV0QjtBQUFBO0FBQUEsd0JBQ0g7QUFBQTtBQUFBLFdBQUFNLElBREc7QUFBQSxXQUFBRCxJQUFBO0FBQUEsV0FBQTJCLElBQUE7QUFBQSxXQUFBN0IsSUFBQTtBQUFBLGlCQUVTO0FBQUEsVUFBSztBQUFBLHFCQUFJO0FBQUEsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFmO0FBQUE7QUFBQTtBQUFBLFFBQThCO0FBQUEsaUJBQUEwRCxPQUFBRCxHQUFBNUQ7QUFBQUEsYUFBQUEsVUFFN0M7QUFBQTtBQUFBLHdCQUNGO0FBQUE7QUFBQSxXQUFBTSxJQURFO0FBQUEsV0FBQUQsSUFBQTtBQUFBLFdBQUEyQixJQUFBO0FBQUEsV0FBQTdCLElBQUE7QUFBQSxpQkFFVTtBQUFBLFVBQUs7QUFBQTtBQUFBO0FBQUEscUJBQUk7QUFBQSxXQUFVO0FBQUE7QUFBQTtBQUFBLFVBQWQ7QUFBQTtBQUFBLFFBQTRCO0FBQUEsaUJBQUEyRCxnQkFBQUMsR0FBQTNELEdBQUFKO0FBQUFBLFNBVWxDLFlBQ1gsc0JBRXdCO0FBQUEsYUFBQU0sSUFIYixVQUFBRCxJQUFBLFVBQUEyQixJQUFBLFVBQUE3QixJQUFBO0FBQUEsU0FHaEIsT0FBdUIsSUFBdkIsa0NBQTZCO0FBQUE7QUFBQSxpQkFBQTZELGdCQUFBRCxHQUFBM0QsR0FBQUo7QUFBQUEsU0FFYixZQUNYLHNCQUV3QjtBQUFBLGFBQUFNLElBSGIsVUFBQUQsSUFBQSxVQUFBMkIsSUFBQSxVQUFBN0IsSUFBQTtBQUFBLFNBR1YsT0FBdUIsYUFBdkIseUJBQXVCO0FBQUE7QUFBQSxpQkFBQThELEtBQUE5RCxHQUFBNkIsR0FBQTNCLEdBQUFDO0FBQUFBLFNBTW5DLFFBQ2dCLCtCQU1FO0FBQUEsU0FQbEIsUUFFZ0IsK0JBS0U7QUFBQTtBQUFBLFVBQUE0RCxLQVBsQjtBQUFBLFVBQUEvQyxLQUFBO0FBQUEsVUFBQUMsS0FBQTtBQUFBLFVBQUFDLEtBQUE7QUFBQSxVQUFBQyxLQUFBO0FBQUEsVUFBQTZDLEtBQUE7QUFBQSxVQUFBeEQsS0FBQTtBQUFBLFVBQUFDLEtBQUE7QUFBQSxVQUFBQyxLQUFBO0FBQUEsVUFBQUMsS0FBQTtBQUFBLFNBS0k7QUFBQSxtQkFBZ0QsZ0JBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUNNLElBQWY7QUFBQSxxQkFDeEIsa0JBQWM7QUFBQTtBQUFBLGlCQUFBc0QsT0FBQXBCLElBQUFDO0FBQUFBLFNBT2xCLFNBQ2dCO0FBQUEsU0FEaEIsU0FFZ0I7QUFBQSxhQUFBQyxRQUVDLGlCQUFBN0MsSUFBYyxVQUFBRCxJQUFBO0FBQUEsU0FDZixPQUF1QixlQUF2Qix1QkFBdUI7QUFBQTtBQUFBLGlCQUFBaUUsZUFBQXJCLElBQUFoQixHQUFBM0IsR0FBQTRDO0FBQUFBLFNBR3ZDLFFBRVUscUJBQVk7QUFBQSxhQUFBNUMsTUFGdEI7QUFBQSxTQUNZLDJCQUNVO0FBQUE7QUFBQSxpQkFBQWlFLE1BQUFsRSxHQUFBSjtBQUFBQSxTQUVWLFlBRVI7QUFBQTtBQUFBLFVBQUFNLElBRlE7QUFBQSxVQUFBRCxJQUFBO0FBQUEsVUFBQTJCLElBQUE7QUFBQSxVQUFBN0IsSUFBQTtBQUFBLFVBQUE4QixJQUlBO0FBQUEsU0FDUixZQUFjO0FBQUEsU0FDVDtBQUFBO0FBQUEsV0FBQWlCLFFBR2tCO0FBQUEsV0FBQS9CLEtBQVM7QUFBQSxXQUFBb0QsT0FBQTtBQUFBLFdBQUE1RCxLQUFBO0FBQUEsVUFBSyx1Q0FBYTtBQUFBO0FBQUE7QUFBQSxVQUFBdUMsVUFGM0I7QUFBQSxVQUFBNUIsS0FBUztBQUFBLFVBQUFpRCxTQUFBO0FBQUEsVUFBQXpELEtBQUE7QUFBQSxTQUFlLHlDQUFhO0FBQUEsUUFFQztBQUFBLGlCQUFBMEQsTUFBQXZGLEdBQUF3RixJQUFBQztBQUFBQSxTQUdqRTtBQUFBLGNBQUFDLEtBQUEsT0FBQUMsS0FBQSxPQUFBQyxLQUFBLE9BQUFDLEtBQUEsT0FBQUMsS0FBQTtBQUFBLFVBRXNEO0FBQUE7QUFBQSxZQUFBN0IsUUFDL0I7QUFBQSxZQUFBOEIsS0FBVztBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUEsa0JBQ3dCO0FBQUEsa0JBQXBCO0FBQUEsV0FBbkIsT0FBZSxlQUFmLCtCQUtIO0FBQUE7QUFBQTtBQUFBLHVCQVJJO0FBQUEsU0FEcEI7QUFBQSxVQVNJO0FBQUE7QUFBQSxVQUFBRixPQVRKO0FBQUEsVUFBQUMsT0FBQTtBQUFBLFVBQUFFLEtBQUE7QUFBQSxVQUFBRCxPQUFBO0FBQUEsVUFBQWhDLFVBTXVCO0FBQUEsVUFBQTBCLE9BQVc7QUFBQSxVQUFBQyxPQUFBO0FBQUEsVUFBQUUsT0FBQTtBQUFBLGdCQUN3QjtBQUFBLGdCQUFwQjtBQUFBLFNBQW5CLE9BQWUsZUFBZixtQ0FFSDtBQUFBO0FBQUEsaUJBQUFLLE1BQUFuRyxHQUFBd0YsSUFBQUM7QUFBQUEsU0FHaEI7QUFBQTtBQUFBO0FBQUEsWUFBQVcsS0FBQTtBQUFBLFlBQUFMLEtBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUEsWUFBQUUsS0FBQTtBQUFBLFlBQUFELEtBQUE7QUFBQSxZQUFBUCxLQUFBO0FBQUEsWUFBQUMsS0FBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUEsWUFBQUMsS0FBQTtBQUFBLFdBSUk7QUFBQTtBQUFBLGFBQUE3QixRQUNxQjtBQUFBLGFBQUE4QixPQUFXO0FBQUEsYUFBQUMsT0FBQTtBQUFBLGFBQUFDLE9BQUE7QUFBQSxhQUFBL0UsSUFDdEI7QUFBQSxhQUFBRyxJQUFzQjtBQUFBLFlBQzlCLFdBQ1UseUJBT3FDO0FBQUEsZ0JBQUEyRSxPQVIvQztBQUFBLFlBRWlDLE9BQVksc0JBQVosK0JBTWM7QUFBQTtBQUFBO0FBQUEsWUFBQS9CLFVBSjVCO0FBQUEsWUFBQTBCLE9BQVc7QUFBQSxZQUFBQyxPQUFBO0FBQUEsWUFBQUUsT0FBQTtBQUFBLFlBQUE1RSxNQUN0QjtBQUFBLFlBQUFHLE1BQXNCO0FBQUEsV0FDOUIsV0FDVSw2QkFDcUM7QUFBQSxlQUFBdUUsT0FGL0M7QUFBQSxXQUVpQyxPQUFZLHdCQUFaLGlDQUFjO0FBQUE7QUFBQSxjQUFBUyxJQWZyRDtBQUFBO0FBQUE7QUFBQSxjQUFBQSxJQUFBO0FBQUEsU0FDNkI7QUFBQSxRQWN3QjtBQUFBLGlCQUFBQyxPQUFBM0IsR0FBQTdCO0FBQUFBLFNBRXhDLFFBQ0Y7QUFBQTtBQUFBLFVBQUF6QixJQURFO0FBQUEsVUFBQUQsSUFBQTtBQUFBLFVBQUEyQixJQUFBO0FBQUEsVUFBQTdCLElBQUE7QUFBQSxVQUFBQSxNQUlBO0FBQUEsVUFBQXFGLE1BQ0M7QUFBQSxVQUFBbEYsTUFDRDtBQUFBLFNBQ1QsVUFDSyx1QkFBWTtBQUFBLFNBREwsMkJBQXVCO0FBQUEsU0FBTywyQkFDekI7QUFBQTtBQUFBLGlCQUFBbUYsV0FBQXhHLEdBQUFlO0FBQUFBLFNBRUosWUFDTjtBQUFBO0FBQUEsVUFBQU0sSUFETTtBQUFBLFVBQUFELElBQUE7QUFBQSxVQUFBMkIsSUFBQTtBQUFBLFVBQUE3QixJQUFBO0FBQUEsVUFBQUEsTUFJSjtBQUFBLFVBQUF1RixNQUNDO0FBQUEsVUFBQXBGLE1BQ0Q7QUFBQSxTQUNULFVBRVksdUJBQ1Q7QUFBQSxhQUFBRCxNQUhIO0FBQUEsU0FDZSw2QkFFWjtBQUFBO0FBQUEsaUJBQUFzRixVQUFBL0IsR0FBQTVEO0FBQUFBLFNBRVMsWUFDTDtBQUFBO0FBQUEsVUFBQU0sSUFESztBQUFBLFVBQUFELElBQUE7QUFBQSxVQUFBMkIsSUFBQTtBQUFBLFVBQUE3QixJQUFBO0FBQUEsVUFBQStDLFFBSUc7QUFBQSxVQUFBMEMsS0FBYTtBQUFBLFVBQUFDLEtBQUE7QUFBQSxVQUFBTCxNQUNsQjtBQUFBLFVBQUF0QyxVQUNLO0FBQUEsVUFBQTRDLEtBQWE7QUFBQSxVQUFBQyxLQUFBO0FBQUEsU0FDNUI7QUFBQSxvQkFDc0I7QUFBQSxVQUFoQixtQ0FBYztBQUFBO0FBQUEsbUJBQ0E7QUFBQSxTQUFkLCtCQUFZO0FBQUEsUUFBaUI7QUFBQSxpQkFBQUMsVUFBQWpFLEdBQUFrRTtBQUFBQSxhQUFBbEUsTUFLdkMsR0FBQWtFLE1BQUE7QUFBQTtBQUFBLG9CQUNXO0FBQUE7QUFBQSxXQUFBM0YsSUFEWDtBQUFBLFdBQUFELElBQUE7QUFBQSxXQUFBMkIsSUFBQTtBQUFBLFdBQUE3QixJQUFBO0FBQUEsV0FBQThGLE1BRXVCO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBOEI7QUFBQSxpQkFBQUMsUUFBQUMsS0FBQUMsSUFBQUM7QUFBQUE7QUFBQUEsVUFBQUMsT0FjbkI7QUFBQSxVQUFBQyxPQUFuQjtBQUFBLFVBQUFBLEtBQWtCO0FBQUEsVUFBQUQsS0FBQTtBQUFBO0FBQUEsVUFWN0IsMkJBVWdEO0FBQUEsVUFWaEQsU0FHWTtBQUFBO0FBQUEsV0FBQUEsT0FIWjtBQUFBLFdBQUF0QixLQUFBO0FBQUEsV0FBQUMsS0FBQTtBQUFBLFdBQUFFLEtBQUE7QUFBQSxXQUFBb0IsT0FBQTtBQUFBLFdBQUEzQixLQUFBO0FBQUEsV0FBQUMsS0FBQTtBQUFBLFdBQUFDLEtBQUE7QUFBQSxXQUFBN0MsSUFLVTtBQUFBLFVBQ1IsWUFBZTtBQUFBLGNBQUFBLE1BQ1A7QUFBQSxVQUNSLGNBQWU7QUFBQSxjQUFBcUUsT0FDZSxxQkFBQUMsT0FBbEI7QUFBQSxVQUFpQjtBQUFBO0FBQUE7QUFBQSxRQUNpQjtBQUFBLGlCQUFBQyxNQUFBTCxLQUFBQyxJQUFBQztBQUFBQTtBQUFBQSxVQUFBQyxPQVdwQjtBQUFBLFVBQUFDLE9BQW5CO0FBQUEsVUFBQUEsS0FBa0I7QUFBQSxVQUFBRCxLQUFBO0FBQUE7QUFBQSxVQVAzQiwwQkFPOEM7QUFBQSxVQVA5QyxTQUdZO0FBQUE7QUFBQSxXQUFBQSxPQUhaO0FBQUEsV0FBQXRCLEtBQUE7QUFBQSxXQUFBQyxLQUFBO0FBQUEsV0FBQUUsS0FBQTtBQUFBLFdBQUFvQixPQUFBO0FBQUEsV0FBQTNCLEtBQUE7QUFBQSxXQUFBQyxLQUFBO0FBQUEsV0FBQUMsS0FBQTtBQUFBLGlCQUtFO0FBQUEsVUFBaUI7QUFBQSxxQkFBUTtBQUFBLFdBQVM7QUFBQSxnQkFBQXdCLE9BQ04scUJBQUFDLE9BQWxCO0FBQUEsWUFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFETztBQUFBO0FBQUE7QUFBQSxxQkFBakI7QUFBQTtBQUFBO0FBQUEsUUFFMkI7QUFBQSxpQkFBQUUsU0FBQXpHO0FBQUFBLFNBRWpDLFlBQ047QUFBQSxhQUFBTSxJQURNLFVBQUFILElBQUEsZ0JBRWlCO0FBQUEsU0FBakIsc0NBQVU7QUFBQSxRQUFpQjtBQUFBLGlCQUFBdUcsYUFBQWhELE1BQUExRDtBQUFBQSxhQUFBMEQsU0FFekIsTUFBQTFELFVBQUE7QUFBQTtBQUFBLHdCQUNSO0FBQUE7QUFBQSxXQUFBTSxJQURRO0FBQUEsV0FBQUQsSUFBQTtBQUFBLFdBQUEyQixJQUFBO0FBQUEsV0FBQTdCLElBQUE7QUFBQSxXQUFBdUQsU0FFNEI7QUFBQSxVQUFtQjtBQUFBO0FBQUE7QUFBQSxRQUFHO0FBQUEsaUJBQUFpRCxTQUFBckIsR0FHckUseUJBQWlCO0FBQUEsaUJBQUFzQixRQUFBQztBQUFBQSxTQU9GO0FBQUE7QUFBQSwyQkFBQTlFLEdBQUEvQjtBQUFBQSx1QkFBQWdDLElBQWUsVUFBQStCLElBQUE7QUFBQSxtQkFBaUIsbUJBQVU7QUFBQTtBQUFBO0FBQUEscUJBQVM7QUFBQTtBQUFBLGlCQUFBK0MsUUFBQUMsR0FBQWhGO0FBQUFBLFNBR2xFO0FBQUE7QUFBQSwyQkFBQUEsR0FBQS9CO0FBQUFBLHVCQUFBZ0MsSUFBYyxVQUFBK0IsSUFBQTtBQUFBLG1CQUFnQixtQkFBVTtBQUFBO0FBQUE7QUFBQSxvQkFBSTtBQUFBO0FBQUEsaUJBQUFpRCxPQUFBRCxHQUUvQix3QkFBZTtBQUFBLGlCQUFBRSxZQUFBaEYsR0FBQWpDO0FBQUFBLFNBRUYsUUFDakI7QUFBQTtBQUFBLFVBQUFrSCxPQURpQjtBQUFBLFVBQUFDLElBQUE7QUFBQSxVQUFBbkYsSUFBQTtBQUFBLFVBQUErQixJQUFBO0FBQUEsZ0JBRTJCO0FBQUEsU0FBa0Isb0NBQS9CLCtCQUErQjtBQUFBLFFBQUM7QUFBQSxpQkFBQXFELE9BQUFyRjtBQUFBQSxhQUFBLE1BRzNEO0FBQUEsU0FBaUI7QUFBQTtBQUFBLGlCQUFBc0YsVUFBQS9CLEdBQUFXO0FBQUFBLGFBQUFYLE1BRzlCLEdBQUFXLE1BQUE7QUFBQTtBQUFBLG9CQUNXO0FBQUE7QUFBQSxXQUFBM0YsSUFEWDtBQUFBLFdBQUFELElBQUE7QUFBQSxXQUFBMkIsSUFBQTtBQUFBLFdBQUE3QixJQUFBO0FBQUEsV0FBQThGLE1BRXNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBOEI7QUFBQSxpQkFBQXFCLGdCQUFBckYsR0FBQWpDO0FBQUFBLFNBRXRCLFFBQ3JCO0FBQUE7QUFBQSxVQUFBa0gsT0FEcUI7QUFBQSxVQUFBQyxJQUFBO0FBQUEsVUFBQW5GLElBQUE7QUFBQSxVQUFBK0IsSUFBQTtBQUFBLGdCQUdRO0FBQUEsU0FBa0I7QUFBQTtBQUFBLCtCQUFuQyxtQ0FBbUM7QUFBQSxRQUFDO0FBQUEsaUJBQUF3RCxXQUFBdEY7QUFBQUEsYUFBQSxNQUd4QztBQUFBLFNBQWlCO0FBQUE7QUFBQSxpQkFBQXVGLFlBQUFDLEtBQUExRjtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxlQUFBQSxNQVlyQixHQUFBRSxJQUFBO0FBQUE7QUFBQSxZQVRTO0FBQUE7QUFBQSxhQUFBM0IsSUFBQTtBQUFBLGFBQUFELElBQUE7QUFBQSxhQUFBMkIsSUFBQTtBQUFBLGFBQUE3QixJQUFBO0FBQUEsYUFBQXVILElBR0o7QUFBQSxZQUFpQjtBQUFBLFlBRWxCO0FBQUEsaUJBQUF6RixNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQURTO0FBQUE7QUFBQSxxQkFKWDtBQUFBO0FBQUE7QUFBQSxvQkFHRTtBQUFBO0FBQUEsU0FLYTtBQUFBO0FBQUEsUURqaUJsQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkX3RvX2xpc3Q6IGtleSAtPiAnYSAtPiAnYSBsaXN0IHQgLT4gJ2EgbGlzdCB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPlxuICAgICAgJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChrZXkgLT4gJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBvZl9saXN0IDogKGtleSAqICdhKSBsaXN0IC0+ICdhIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgYWRkX3RvX2xpc3QgeCBkYXRhIG0gPVxuICAgICAgbGV0IGFkZCA9IGZ1bmN0aW9uIE5vbmUgLT4gU29tZSBbZGF0YV0gfCBTb21lIGwgLT4gU29tZSAoZGF0YSA6OiBsKSBpblxuICAgICAgdXBkYXRlIHggYWRkIG1cblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sXG4gICAgICAgICBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSxcbiAgICAgICAgIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW2ZdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZnZkID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGZ2ZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZCcgLT4gam9pbiBsJyB2IGQnIHInXG4gICAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0IGwnIHInXG4gICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IHRvX2xpc3QgPSBiaW5kaW5nc1xuICAgIGxldCBvZl9saXN0IGJzID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBtIChrLCB2KSAtPiBhZGQgayB2IG0pIGVtcHR5IGJzXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2NzM5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9MaXN0IiwiRW1wdHkiLCJjcmVhdGUiLCJwYXJhbSIsImNsZWFyIiwicyIsImNvcHkiLCJwdXNoIiwieCIsInBvcCIsIm1hdGNoIiwidGwiLCJoZCIsInBvcF9vcHQiLCJkcm9wIiwidG9wIiwidG9wX29wdCIsImlzX2VtcHR5IiwibGVuZ3RoIiwiaXRlciIsImZvbGQiLCJhY2MiLCJ0b19zZXEiLCJhZGRfc2VxIiwicSIsImkiLCJvZl9zZXEiLCJnIiwiU3RkbGliX1N0YWNrIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9zdGFjay5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLE9BQUFDLE9DbUJnQixpQkFBb0I7QUFBQSxZQUFBQyxNQUFBQyxHQUV0QixVQUFXLG1CQUFVO0FBQUEsWUFBQUMsS0FBQUQsR0FFdEIsdUJBQXlCO0FBQUEsWUFBQUUsS0FBQUMsR0FBQUgsR0FFdkIscUJBQWlCLDhCQUFrQjtBQUFBLFlBQUFJLElBQUFKO0FBQUFBLFFBQUFLLFFBR2hEO0FBQUEsZ0JBRVk7QUFBQSxRQUFBQyxLQUZaLFVBQUFDLEtBQUE7QUFBQSxJQUNZO0FBQUEsSUFBVztBQUFBLElBQW9CO0FBQUEsR0FDcEI7QUFBQSxZQUFBQyxRQUFBUjtBQUFBQSxRQUFBSyxRQUd2QjtBQUFBLGdCQUVZO0FBQUEsUUFBQUMsS0FGWixVQUFBQyxLQUFBO0FBQUEsSUFDWTtBQUFBLElBQVc7QUFBQSxJQUFvQjtBQUFBLEdBQzNCO0FBQUEsWUFBQUUsS0FBQVQ7QUFBQUEsUUFBQUssUUFHaEI7QUFBQSxnQkFFUTtBQUFBLFFBQUFDLEtBRlI7QUFBQSxJQUNhO0FBQUEsSUFBVztBQUFBO0FBQUEsR0FDTDtBQUFBLFlBQUFJLElBQUFWO0FBQUFBLFFBQUFLLFFBR25CO0FBQUEsZ0JBRVc7QUFBQSxRQUFBRSxLQUZYO0FBQUEsSUFDVztBQUFBLEdBQ1c7QUFBQSxZQUFBSSxRQUFBWDtBQUFBQSxRQUFBSyxRQUd0QjtBQUFBLGdCQUVXO0FBQUEsUUFBQUUsS0FGWDtBQUFBLElBQ1c7QUFBQSxHQUNJO0FBQUEsWUFBQUssU0FBQVosR0FFQSwwQkFBVTtBQUFBLFlBQUFhLE9BQUFiLEdBRVosWUFBSztBQUFBLFlBQUFjLEtBQUEzQixHQUFBYSxHQUVMLDJDQUFlO0FBQUEsWUFBQWUsS0FBQTVCLEdBQUE2QixLQUFBaEIsR0FFWCxnREFBd0I7QUFBQSxZQUFBaUIsT0FBQWpCLEdBSTVCLHdDQUFlO0FBQUEsWUFBQWtCLFFBQUFDLEdBQUFDO0FBQUFBLElBRVosMENBQUFqQixHQUFtQixpQkFBUSxNQUFHO0FBQUE7QUFBQSxZQUFBa0IsT0FBQUMsT0FBQXRCLElBR3RDLFdBQ1IsZUFBVyxTQUNWO0FBQUE7QUFBQSxJQUFBdUI7QUFBQUEsTURyRUgiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0geyBtdXRhYmxlIGMgOiAnYSBsaXN0OyBtdXRhYmxlIGxlbiA6IGludDsgfVxuXG5leGNlcHRpb24gRW1wdHlcblxubGV0IGNyZWF0ZSAoKSA9IHsgYyA9IFtdOyBsZW4gPSAwOyB9XG5cbmxldCBjbGVhciBzID0gcy5jIDwtIFtdOyBzLmxlbiA8LSAwXG5cbmxldCBjb3B5IHMgPSB7IGMgPSBzLmM7IGxlbiA9IHMubGVuOyB9XG5cbmxldCBwdXNoIHggcyA9IHMuYyA8LSB4IDo6IHMuYzsgcy5sZW4gPC0gcy5sZW4gKyAxXG5cbmxldCBwb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgcG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IFNvbWUgaGRcbiAgfCBbXSAgICAgLT4gTm9uZVxuXG5sZXQgZHJvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBfaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxXG4gIHwgW10gLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBoZFxuICB8IFtdICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IFNvbWUgaGRcbiAgfCBbXSAgICAtPiBOb25lXG5cbmxldCBpc19lbXB0eSBzID0gKHMuYyA9IFtdKVxuXG5sZXQgbGVuZ3RoIHMgPSBzLmxlblxuXG5sZXQgaXRlciBmIHMgPSBMaXN0Lml0ZXIgZiBzLmNcblxubGV0IGZvbGQgZiBhY2MgcyA9IExpc3QuZm9sZF9sZWZ0IGYgYWNjIHMuY1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBMaXN0LnRvX3NlcSBzLmNcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBzID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBzIGc7XG4gIHNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNjg0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TZXEiLCJFbXB0eSIsImNyZWF0ZSIsInBhcmFtIiwiY2xlYXIiLCJxIiwiYWRkIiwieCIsImNlbGwiLCJtYXRjaCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwibmV4dCIsInRha2Vfb3B0IiwiY29weSIsInFfcmVzIiwicHJldiIsImlzX2VtcHR5IiwibGVuZ3RoIiwiaXRlciIsImZvbGQiLCJhY2N1IiwidHJhbnNmZXIiLCJxMSIsInEyIiwidG9fc2VxIiwiYXV4IiwiYyIsImFkZF9zZXEiLCJpIiwib2Zfc2VxIiwiZyIsIlN0ZGxpYl9RdWV1ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvcXVldWUubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0M0QmdCLG9CQUlmO0FBQUEsWUFBQUMsTUFBQUMsR0FHQyxVQUNBLFVBQ0EsbUJBQWE7QUFBQSxZQUFBQyxJQUFBQyxHQUFBRjtBQUFBQSxRQUFBRyxPQUdiLFdBQUFDLFFBSUE7QUFBQTtBQUFBO0FBQUEscURBUWdCO0FBQUE7QUFBQSxZQUFBQyxLQUFBTDtBQUFBQSxRQUFBSSxRQU1oQjtBQUFBLGdCQUNTO0FBQUEsUUFBQUUsVUFEVDtBQUFBLElBRXNCO0FBQUEsR0FBTztBQUFBLFlBQUFDLFNBQUFQO0FBQUFBLFFBQUFJLFFBRzdCO0FBQUEsZ0JBQ1M7QUFBQSxRQUFBRSxVQURUO0FBQUEsSUFFc0I7QUFBQSxHQUFZO0FBQUEsWUFBQUUsS0FBQVI7QUFBQUEsUUFBQSxNQU1sQztBQUFBLGNBQ1M7QUFBQSxRQUFBTSxVQURUO0FBQUE7QUFBQSxTQUFBRyxPQUFBO0FBQUEsS0FNRTtBQUFBLEtBQ0E7QUFBQSxLQUNBO0FBQUE7QUFBQSxJQUxBO0FBQUEsSUFBTztBQUFBLEdBS0E7QUFBQSxZQUFBQyxTQUFBVjtBQUFBQSxRQUFBLE1BR1Q7QUFBQSxjQUNTO0FBQUEsUUFBQU0sVUFEVDtBQUFBO0FBQUEsU0FBQUcsT0FBQTtBQUFBLEtBTUU7QUFBQSxLQUNBO0FBQUEsS0FDQTtBQUFBO0FBQUEsSUFMQTtBQUFBLElBQU87QUFBQSxHQUtLO0FBQUEsWUFBQUUsS0FBQVg7QUFBQUEsUUFBQUcsU0FpQkwsTUFBQVMsUUFBQSxpQkFBQUMsT0FBQSxHQUFBVixPQUFBO0FBQUE7QUFBQSxLQVZQLFdBQ1MsaUJBQW9CO0FBQUEsU0FBQUcsVUFEN0IsU0FBQUcsT0FBQSxTQUFBSSxTQUdFO0FBQUEsS0FDQSxTQUVZLHVCQURIO0FBQUEsS0FHVDtBQUFBO0FBQUE7QUFBQSxHQUVvRTtBQUFBLFlBQUFDLFNBQUFkLEdBR3hFLDBCQUFZO0FBQUEsWUFBQWUsT0FBQWYsR0FHWixZQUFRO0FBQUEsWUFBQWdCLEtBQUExQixHQUFBVTtBQUFBQSxRQUFBRyxTQVVHLE1BQUFBLE9BQUE7QUFBQTtBQUFBLEtBTlQsV0FDUztBQUFBLFNBQUFHLFVBRFQsU0FBQUcsT0FBQTtBQUFBLEtBR0U7QUFBQSxLQUFTO0FBQUE7QUFBQSxHQUdZO0FBQUEsWUFBQVEsS0FBQTNCLEdBQUE0QixRQUFBbEI7QUFBQUEsUUFBQUcsU0FVVCxNQUFBZSxPQUFBLFFBQUFmLE9BQUE7QUFBQTtBQUFBLEtBTmQsV0FDUztBQUFBO0FBQUEsTUFBQUcsVUFEVDtBQUFBLE1BQUFHLE9BQUE7QUFBQSxNQUFBUyxTQUdhO0FBQUEsS0FDWDtBQUFBO0FBQUE7QUFBQSxHQUUrQjtBQUFBLFlBQUFDLFNBQUFDLElBQUFDO0FBQUFBLFFBQUEsTUFHbkM7QUFBQTtBQUFBLFFBQUFqQixRQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FVRTtBQUFBLDREQUxBLFVBS1E7QUFBQTtBQUFBLFlBQUFrQixPQUFBdEI7QUFBQUEsYUFBQXVCLElBQUFDLEdBQUExQjtBQUFBQSxLQUtPLFFBQ1I7QUFBQSxTQUFBSSxJQURRLE1BQUFPLE9BQUE7QUFBQSxLQUVtQyw0QkFBUix3QkFBUTtBQUFBLElBQUM7QUFBQSxjQUV2RDtBQUFBLHlCRDVKRixzQkM0SkU7QUFBQSxHQUFXO0FBQUEsWUFBQWdCLFFBQUF6QixHQUFBMEI7QUFBQUEsSUFFSywwQ0FBQXhCLEdBQW1CLGdCQUFRLE1BQUc7QUFBQTtBQUFBLFlBQUF5QixPQUFBQyxPQUFBNUIsSUFHdEMsV0FDUixlQUFXLFNBQ1Y7QUFBQTtBQUFBLElBQUE2QjtBQUFBQSxNQTlCRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURySUYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRnJhbmNvaXMgUG90dGllciwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXhjZXB0aW9uIEVtcHR5XG5cbnR5cGUgJ2EgY2VsbCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7IGNvbnRlbnQ6ICdhOyBtdXRhYmxlIG5leHQ6ICdhIGNlbGwgfVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbGVuZ3RoOiBpbnQ7XG4gIG11dGFibGUgZmlyc3Q6ICdhIGNlbGw7XG4gIG11dGFibGUgbGFzdDogJ2EgY2VsbFxufVxuXG5sZXQgY3JlYXRlICgpID0ge1xuICBsZW5ndGggPSAwO1xuICBmaXJzdCA9IE5pbDtcbiAgbGFzdCA9IE5pbFxufVxuXG5sZXQgY2xlYXIgcSA9XG4gIHEubGVuZ3RoIDwtIDA7XG4gIHEuZmlyc3QgPC0gTmlsO1xuICBxLmxhc3QgPC0gTmlsXG5cbmxldCBhZGQgeCBxID1cbiAgbGV0IGNlbGwgPSBDb25zIHtcbiAgICBjb250ZW50ID0geDtcbiAgICBuZXh0ID0gTmlsXG4gIH0gaW5cbiAgbWF0Y2ggcS5sYXN0IHdpdGhcbiAgfCBOaWwgLT5cbiAgICBxLmxlbmd0aCA8LSAxO1xuICAgIHEuZmlyc3QgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuICB8IENvbnMgbGFzdCAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoICsgMTtcbiAgICBsYXN0Lm5leHQgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuXG5sZXQgcHVzaCA9XG4gIGFkZFxuXG5sZXQgcGVlayBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBjb250ZW50XG5cbmxldCBwZWVrX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IFNvbWUgY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHRha2Vfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIFNvbWUgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIFNvbWUgY29udGVudFxuXG5sZXQgcG9wID1cbiAgdGFrZVxuXG5sZXQgY29weSA9XG4gIGxldCByZWMgY29weSBxX3JlcyBwcmV2IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IHFfcmVzLmxhc3QgPC0gcHJldjsgcV9yZXNcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCByZXMgPSBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IGluXG4gICAgICBiZWdpbiBtYXRjaCBwcmV2IHdpdGhcbiAgICAgIHwgTmlsIC0+IHFfcmVzLmZpcnN0IDwtIHJlc1xuICAgICAgfCBDb25zIHAgLT4gcC5uZXh0IDwtIHJlc1xuICAgICAgZW5kO1xuICAgICAgY29weSBxX3JlcyByZXMgbmV4dFxuICBpblxuICBmdW4gcSAtPiBjb3B5IHsgbGVuZ3RoID0gcS5sZW5ndGg7IGZpcnN0ID0gTmlsOyBsYXN0ID0gTmlsIH0gTmlsIHEuZmlyc3RcblxubGV0IGlzX2VtcHR5IHEgPVxuICBxLmxlbmd0aCA9IDBcblxubGV0IGxlbmd0aCBxID1cbiAgcS5sZW5ndGhcblxubGV0IGl0ZXIgPVxuICBsZXQgcmVjIGl0ZXIgZiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgZiBjb250ZW50O1xuICAgICAgaXRlciBmIG5leHRcbiAgaW5cbiAgZnVuIGYgcSAtPiBpdGVyIGYgcS5maXJzdFxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgZm9sZCBmIGFjY3UgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gYWNjdVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgY29udGVudCBpblxuICAgICAgZm9sZCBmIGFjY3UgbmV4dFxuICBpblxuICBmdW4gZiBhY2N1IHEgLT4gZm9sZCBmIGFjY3UgcS5maXJzdFxuXG5sZXQgdHJhbnNmZXIgcTEgcTIgPVxuICBpZiBxMS5sZW5ndGggPiAwIHRoZW5cbiAgICBtYXRjaCBxMi5sYXN0IHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHExLmxlbmd0aDtcbiAgICAgIHEyLmZpcnN0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiAgICB8IENvbnMgbGFzdCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHEyLmxlbmd0aCArIHExLmxlbmd0aDtcbiAgICAgIGxhc3QubmV4dCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcSA9XG4gIGxldCByZWMgYXV4IGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICB8IE5pbCAtPiBTZXEuTmlsXG4gICAgfCBDb25zIHsgY29udGVudD14OyBuZXh0OyB9IC0+IFNlcS5Db25zICh4LCBhdXggbmV4dClcbiAgaW5cbiAgYXV4IHEuZmlyc3RcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBxID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBxIGc7XG4gIHFcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNjk5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYmxpdF9zdHJpbmciLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9ieXRlc19zZXQxNiIsImNhbWxfYnl0ZXNfc2V0MzIiLCJjYW1sX2J5dGVzX3NldDY0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ludDMyX2Jzd2FwIiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9TZXEiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiQXNzZXJ0X2ZhaWx1cmUiLCJjc3RfQnVmZmVyX3N1YiIsImNzdF9CdWZmZXJfYmxpdCIsImNzdF9CdWZmZXJfbnRoIiwiY3N0X0J1ZmZlcl9hZGRfY2Fubm90X2dyb3dfYnVmIiwiZHVtbXkiLCJjcmVhdGUiLCJuIiwicyIsImNvbnRlbnRzIiwiYiIsInRvX2J5dGVzIiwic3ViIiwib2ZzIiwibGVuIiwiYmxpdCIsInNyYyIsInNyY29mZiIsImRzdCIsImRzdG9mZiIsIm50aCIsInBvc2l0aW9uIiwibWF0Y2giLCJsZW5ndGgiLCJidWZmZXIiLCJjbGVhciIsInJlc2V0IiwiaW5uZXIiLCJyZXNpemUiLCJtb3JlIiwib2xkX3BvcyIsIm9sZF9sZW4iLCJuZXdfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwiYyIsInBvcyIsInVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heCIsInVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXgiLCJjc3RfQnVmZmVyX2FkZF9zdWJzdHJpbmdfYWRkX3MiLCJjc3RfQnVmZmVyX2FkZF9jaGFubmVsIiwiY3N0X0J1ZmZlcl90cnVuY2F0ZSIsImFkZF91dGZfOF91Y2hhciIsInUiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwiaWMiLCJ0b19yZWFkIiwiYnVmIiwiYWxyZWFkeV9yZWFkIiwiciIsIm91dHB1dF9idWZmZXIiLCJvYyIsImFkZF9zdWJzdGl0dXRlIiwibGltIiwicHJldmlvdXMiLCJpIiwic3RhcnQiLCJvcGVuaW5nIiwic3RvcCIsIm5ld19zdGFydCIsImsiLCJjbG9zaW5nIiwibmV4dF9pIiwiaWRlbnQiLCJ0cnVuY2F0ZSIsInRvX3NlcSIsImF1eCIsInBhcmFtIiwieCIsInRvX3NlcWkiLCJhZGRfc2VxIiwic2VxIiwib2Zfc2VxIiwiYWRkX2ludDgiLCJhZGRfaW50MTZfbmUiLCJhZGRfaW50MzJfbmUiLCJhZGRfaW50NjRfbmUiLCJhZGRfaW50MTZfbGUiLCJhZGRfaW50MTZfYmUiLCJhZGRfaW50MzJfbGUiLCJhZGRfaW50MzJfYmUiLCJhZGRfaW50NjRfbGUiLCJhZGRfaW50NjRfYmUiLCJTdGRsaWJfQnVmZmVyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9G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RCxXQUcxQjtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUF3QixlQUNBO0FBQUEsSUFDQTtBQUFBLEtBQ0U7QUFBQSxLQUNBO0FBQUE7QUFBQTtBQUFBLEtBRUE7QUFBQSxJQUNGO0FBQUE7QUFBQSxHQUEwQjtBQUFBLFlBQUFzQyxhQUFBNUUsR0FBQW9FO0FBQUFBO0FBQUFBLEtBQUF6RCxXQUcxQjtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUF3QixlQUNBO0FBQUEsSUFDQTtBQUFBLEtBQ0U7QUFBQSxLQUNBO0FBQUE7QUFBQTtBQUFBLEtBRUE7QUFBQSxJQUNGO0FBQUE7QUFBQSxHQUEwQjtBQUFBLFlBQUF1QyxhQUFBN0UsR0FBQW9FO0FBQUFBLFFBQUEsTUFHMUIsaUJBQXVDO0FBQUEsSUFBdkMsMkJBQXVEO0FBQUE7QUFBQSxZQUFBVSxhQUFBOUUsR0FBQW9FO0FBQUFBLFFBQUFBLE1BR3ZELHFCQUE4QztBQUFBLElBQTlDLDJCQUF1RDtBQUFBO0FBQUEsWUFBQVcsYUFBQS9FLEdBQUFvRTtBQUFBQSxRQUFBLE1BR3ZELGlCQUF1QztBQUFBLElBQXZDLDJCQUF1RDtBQUFBO0FBQUEsWUFBQVksYUFBQWhGLEdBQUFvRTtBQUFBQSxRQUFBQSxNQUd2RCxxQkFBOEM7QUFBQSxJQUE5QywyQkFBdUQ7QUFBQTtBQUFBLFlBQUFhLGFBQUFqRixHQUFBb0U7QUFBQUEsUUFBQSxNQUd2RCxpQkFBdUM7QUFBQSxJQUF2QywyQkFBdUQ7QUFBQTtBQUFBLFlBQUFjLGFBQUFsRixHQUFBb0U7QUFBQUEsUUFBQUEsTUFHdkQscUJBQThDO0FBQUEsSUFBOUMsMkJBQXVEO0FBQUE7QUFBQTtBQUFBLElBQUFlO0FBQUFBLE1EM1l6RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxuKCogVGhlIFtpbm5lcl9idWZmZXJdIHR5cGUgZW5zdXJlcyB0aGF0IHRoZSBbbGVuZ3RoXSBhbmQgW2J1ZmZlcl0gZmllbGRzIGFyZVxuICAgYWx3YXlzIHN5bmNocm9uaXplZCwgW2xlbmd0aCA9IEJ5dGVzLmxlbmd0aCBidWZmZXJdLCBldmVuIGluIHByZXNlbmNlXG4gICBvZiBkYXRhIHJhY2VzLlxuKilcbnR5cGUgaW5uZXJfYnVmZmVyID0ge1xuICBidWZmZXI6IGJ5dGVzO1xuICBsZW5ndGg6IGludDtcbn1cblxudHlwZSB0ID1cbiB7bXV0YWJsZSBpbm5lciA6IGlubmVyX2J1ZmZlcjtcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbaW5uZXIubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGlubmVyLmJ1ZmZlcl1cbiAgIEluIGFic2VuY2Ugb2YgZGF0YSByYWNlcywgd2UgYWxzbyBoYXZlXG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5pbm5lci5sZW5ndGhdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5pbm5lci5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4geyBpbm5lciA9IHsgYnVmZmVyID0gczsgbGVuZ3RoID0gbn07IHBvc2l0aW9uID0gMDsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5pbm5lci5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmlubmVyLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMuYmxpdCBzcmMuaW5uZXIuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyO2xlbmd0aH0gPSBiLmlubmVyIGluXG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gbGVuZ3RoIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBidWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgbGV0IGlubmVyID1cbiAgICB7IGJ1ZmZlciA9IGIuaW5pdGlhbF9idWZmZXI7IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmluaXRpYWxfYnVmZmVyIH1cbiAgaW5cbiAgYi5pbm5lciA8LSBpbm5lclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmlubmVyLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5pbm5lcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmlubmVyLmxlbmd0aF0uXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmlubmVyLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5pbm5lci5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5pbm5lciA8LSB7IGJ1ZmZlciA9IG5ld19idWZmZXI7IGxlbmd0aCA9ICFuZXdfbGVuIH1cblxuKCogTm90ZTpcbiAgICBTb21lIG9mIHRoZSBmdW5jdGlvbnMgYmVsb3cgaGF2ZSBhIGZhc3QgcGF0aCB3aGVuIHRoZSBpbm5lclxuICBidWZmZXIgZG9lc24ndCBuZWVkIHRvIGJlIGV4dGVuZGVkLlxuICAgIEluIHRoaXMgY2FzZSwgaXQgaXMgcG9zc2libGUgdG8gdXNlIHVuc2FmZSBhY2Nlc3NlcyBvbiB0aGVcbiAgY29udGVudHMgb2YgdGhlIFtpbm5lcl0gZmllbGQgc2luY2UgaXRzIGZpZWxkcyBhcmUgaW1tdXRhYmxlLlxuICBJbiBwcmVzZW5jZSBvZiBkYXRhIHJhY2VzLCB3ZSBtYXkgYWNjZXNzIHRoZSB3cm9uZyBpbm5lciBidWZmZXIsIGJ1dCB3ZVxuICB3aWxsIHVzZSB0aGlzIGJ1ZmZlciBzYWZlbHkuXG4gIEFzIHNvb24gYXMgd2UgbmVlZCB0byByZXNpemUgdGhlIGJ1ZmZlciwgd2UgZmFsbCBiYWNrIHRvIHNhZmUgYWNjZXNzZXMuXG4qKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgaWYgcG9zID49IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiAxO1xuICAgIEJ5dGVzLnNldCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIGNcbiAgKSBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX3NldCBidWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG5sZXQgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4ID0gNFxubGV0IHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXggPSA0XG5cbmxldCByZWMgYWRkX3V0Zl84X3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmlubmVyLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzhfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzhfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCByZWMgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmlubmVyLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl8xNmJlX3VjaGFyIGIuaW5uZXIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfMTZiZV91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2bGVfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyO2xlbmd0aH0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgbGVuO1xuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gbGVuXG4gICkgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBidWZmZXIgcG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyOyBsZW5ndGh9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIGxlbjtcbiAgICBCeXRlcy5ibGl0X3N0cmluZyBzIDAgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gICkgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYnVmZmVyIHBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmlubmVyLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5pbm5lci5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy5nZXQgYi5pbm5lci5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy5nZXQgYi5pbm5lci5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5cbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtsZW5ndGg7IGJ1ZmZlcn0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDE7XG4gICAgc2V0X2ludDggYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiB4XG4gICkgZWxzZVxuICAgIHVuc2FmZV9zZXRfaW50OCBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiAyO1xuICAgIHNldF9pbnQxNiBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQxNiBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiA0O1xuICAgIHNldF9pbnQzMiBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQzMiBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiA4O1xuICAgIHNldF9pbnQ2NCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQ2NCBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTc1MTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX211dGV4X2xvY2siLCJjYW1sX21sX211dGV4X3VubG9jayIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwicHJvdGVjdCIsIm0iLCJ4IiwiZSIsIlN0ZGxpYl9NdXRleCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvbXV0ZXgubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsUUFBQUMsR0FBQUg7QUFBQUEsSUMwQkU7QUFBQSxJQUFNLFFBQUFJLElBQ0E7QUFBQSxVQUFBQztBQUFBQSxTQUFBQSxJRDNCUjtBQUFBLEtDZ0NJO0FBQUEsS0FBUTtBQUFBO0FBQUEsSUFIUjtBQUFBLElBQVE7QUFBQSxHQUlDO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRGpDYiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgUGFzY2FsIEN1b3EsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRcbmV4dGVybmFsIGNyZWF0ZTogdW5pdCAtPiB0ID0gXCJjYW1sX21sX211dGV4X25ld1wiXG5leHRlcm5hbCBsb2NrOiB0IC0+IHVuaXQgPSBcImNhbWxfbWxfbXV0ZXhfbG9ja1wiXG5leHRlcm5hbCB0cnlfbG9jazogdCAtPiBib29sID0gXCJjYW1sX21sX211dGV4X3RyeV9sb2NrXCJcbmV4dGVybmFsIHVubG9jazogdCAtPiB1bml0ID0gXCJjYW1sX21sX211dGV4X3VubG9ja1wiXG5cbigqIHByaXZhdGUgcmUtZXhwb3J0ICopXG5leHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbigqIGNhbm5vdCBpbmxpbmUsIG90aGVyd2lzZSBmbGFtYmRhIG1pZ2h0IG1vdmUgY29kZSBhcm91bmQuICopXG5sZXRbQGlubGluZSBuZXZlcl0gcHJvdGVjdCBtIGYgPVxuICBsb2NrIG07XG4gIG1hdGNoIGYoKSB3aXRoXG4gIHwgeCAtPlxuICAgIHVubG9jayBtOyB4XG4gIHwgZXhjZXB0aW9uIGUgLT5cbiAgICAoKiBOT1RFOiBbdW5sb2NrXSBkb2VzIG5vdCBwb2xsIGZvciBhc3luY2hyb25vdXMgZXhjZXB0aW9ucyAqKVxuICAgIHVubG9jayBtO1xuICAgIHJlcmFpc2UgZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3NTUxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiU3RkbGliX0NvbmRpdGlvbiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzU2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2RvbWFpbl9kbHNfc2V0IiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2RvbWFpbl9pZCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX011dGV4IiwiU3RkbGliX0NvbmRpdGlvbiIsIlN0ZGxpYiIsIlN0ZGxpYl9BdG9taWMiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9BcnJheSIsImNwdV9yZWxheCIsInBhcmFtIiwidW5pcXVlX3ZhbHVlIiwiY3JlYXRlX2RscyIsInN0Iiwia2V5X2NvdW50ZXIiLCJwYXJlbnRfa2V5cyIsIm5ld19rZXkiLCJzcGxpdF9mcm9tX3BhcmVudCIsImluaXRfb3JwaGFuIiwiaWR4IiwiayIsInNwbGl0Iiwia2kiLCJsIiwibWF5YmVfZ3JvdyIsInN6IiwibmV3X3N6IiwibmV3X3N0IiwicyIsInNldCIsIngiLCJnZXQiLCJpbml0IiwidiIsImdldF9pZCIsImRvbWFpbiIsInNlbGYiLCJpc19tYWluX2RvbWFpbiIsImZpcnN0X2RvbWFpbl9zcGF3bmVkIiwiZmlyc3Rfc3Bhd25fZnVuY3Rpb24iLCJjc3RfZmlyc3RfZG9tYWluX2FscmVhZHlfc3Bhd24iLCJiZWZvcmVfZmlyc3Rfc3Bhd24iLCJvbGRfZiIsIm5ld19mIiwiYXRfZXhpdF9rZXkiLCJhdF9leGl0Iiwib2xkX2V4aXQiLCJuZXdfZXhpdCIsImRvX2F0X2V4aXQiLCJjc3RfaW50ZXJuYWxfZXJyb3JfQW1fSV9hbHJlYWQiLCJzcGF3biIsInBrIiwidGVybV9tdXRleCIsInRlcm1fY29uZGl0aW9uIiwidGVybV9zdGF0ZSIsImJvZHkiLCJyZXMiLCJleCIsInJlc3VsdCIsImpvaW4iLCJtYXRjaCIsInJlY29tbWVuZGVkX2RvbWFpbl9jb3VudCIsIlN0ZGxpYl9Eb21haW4iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2RvbWFpbi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsVUFBQUMsT0MrQm1CLDBDQUFnQjtBQUFBLE9BQUFDLGVEL0JuQztBQUFBLFlBQUFDLFdBQUFGO0FBQUFBLFFBQUFHLEtDMERhO0FBQUEsSUFDVDtBQUFBLEdBQWdCO0FBQUEsR0FFVjtBQUFBO0FBQUEsSUFBQUMsY0FJVTtBQUFBLElBQUFDLGNBS0E7QUFBQSxZQUFBQyxRQUFBQyxtQkFBQUM7QUFBQUE7QUFB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QUFBQSxJQUk1QztBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUF5QjtBQUFBLEdBR3RCO0FBQUEsWUFBQUMsS0FBQWpEO0FBQUFBO0FBQUFBLEtBQUE0QyxhQUVQO0FBQUEsS0FBQUQsaUJBQUE7QUFBQSxLQUFBRCxhQUFBO0FBQUEsSUFDUDtBQUFBLElBVU07QUFBQSxTQUFBUSxRQVJKO0FBQUE7QUFBQSxVQUFBSixNQUFBO0FBQUEsTUFLSTtBQUFBLE1BR08scUJBQUExQixJQUFBLFFBQ0g7QUFBQSxVQUFBMkIsS0FERztBQUFBO0FBQUE7QUFBQSxLQU5QO0FBQUE7QUFBQSxHQVFnQjtBQUFBO0FBQUEsSUFBQUksMkJBNUZnQztBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHJLeEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgS0MgU2l2YXJhbWFrcmlzaG5hbiwgSW5kaWFuIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5LCBNYWRyYXMgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTdGVwaGVuIERvbGFuLCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgIFRvbSBLZWxseSwgT0NhbWwgTGFicyBDb25zdWx0YW5jeSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5kaWFuIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5LCBNYWRyYXMgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgT0NhbWwgTGFicyBDb25zdWx0YW5jeSBMdGQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFJhdyA9IHN0cnVjdFxuICAoKiBMb3ctbGV2ZWwgcHJpbWl0aXZlcyBwcm92aWRlZCBieSB0aGUgcnVudGltZSAqKVxuICB0eXBlIHQgPSBwcml2YXRlIGludFxuICBleHRlcm5hbCBzcGF3biA6ICh1bml0IC0+IHVuaXQpIC0+IE11dGV4LnQgLT4gdFxuICAgID0gXCJjYW1sX2RvbWFpbl9zcGF3blwiXG4gIGV4dGVybmFsIHNlbGYgOiB1bml0IC0+IHRcbiAgICA9IFwiY2FtbF9tbF9kb21haW5faWRcIlxuICBleHRlcm5hbCBjcHVfcmVsYXggOiB1bml0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4XCJcbiAgZXh0ZXJuYWwgZ2V0X3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudDogdW5pdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcIiBbQEBub2FsbG9jXVxuZW5kXG5cbmxldCBjcHVfcmVsYXggKCkgPSBSYXcuY3B1X3JlbGF4ICgpXG5cbnR5cGUgaWQgPSBSYXcudFxuXG50eXBlICdhIHN0YXRlID1cbnwgUnVubmluZ1xufCBGaW5pc2hlZCBvZiAoJ2EsIGV4bikgcmVzdWx0XG5cbnR5cGUgJ2EgdCA9IHtcbiAgZG9tYWluIDogUmF3LnQ7XG4gIHRlcm1fbXV0ZXg6IE11dGV4LnQ7XG4gIHRlcm1fY29uZGl0aW9uOiBDb25kaXRpb24udDtcbiAgdGVybV9zdGF0ZTogJ2Egc3RhdGUgcmVmICgqIHByb3RlY3RlZCBieSBbdGVybV9tdXRleF0gKilcbn1cblxubW9kdWxlIERMUyA9IHN0cnVjdFxuXG4gIHR5cGUgZGxzX3N0YXRlID0gT2JqLnQgYXJyYXlcblxuICBsZXQgdW5pcXVlX3ZhbHVlID0gT2JqLnJlcHIgKHJlZiAwKVxuXG4gIGV4dGVybmFsIGdldF9kbHNfc3RhdGUgOiB1bml0IC0+IGRsc19zdGF0ZSA9IFwiJWRsc19nZXRcIlxuXG4gIGV4dGVybmFsIHNldF9kbHNfc3RhdGUgOiBkbHNfc3RhdGUgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2RvbWFpbl9kbHNfc2V0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3JlYXRlX2RscyAoKSA9XG4gICAgbGV0IHN0ID0gQXJyYXkubWFrZSA4IHVuaXF1ZV92YWx1ZSBpblxuICAgIHNldF9kbHNfc3RhdGUgc3RcblxuICBsZXQgXyA9IGNyZWF0ZV9kbHMgKClcblxuICB0eXBlICdhIGtleSA9IGludCAqICh1bml0IC0+ICdhKVxuXG4gIGxldCBrZXlfY291bnRlciA9IEF0b21pYy5tYWtlIDBcblxuICB0eXBlIGtleV9pbml0aWFsaXplciA9XG4gICAgS0k6ICdhIGtleSAqICgnYSAtPiAnYSkgLT4ga2V5X2luaXRpYWxpemVyXG5cbiAgbGV0IHBhcmVudF9rZXlzID0gQXRvbWljLm1ha2UgKFtdIDoga2V5X2luaXRpYWxpemVyIGxpc3QpXG5cbiAgbGV0IHJlYyBhZGRfcGFyZW50X2tleSBraSA9XG4gICAgbGV0IGwgPSBBdG9taWMuZ2V0IHBhcmVudF9rZXlzIGluXG4gICAgaWYgbm90IChBdG9taWMuY29tcGFyZV9hbmRfc2V0IHBhcmVudF9rZXlzIGwgKGtpIDo6IGwpKVxuICAgIHRoZW4gYWRkX3BhcmVudF9rZXkga2lcblxuICBsZXQgbmV3X2tleSA/c3BsaXRfZnJvbV9wYXJlbnQgaW5pdF9vcnBoYW4gPVxuICAgIGxldCBpZHggPSBBdG9taWMuZmV0Y2hfYW5kX2FkZCBrZXlfY291bnRlciAxIGluXG4gICAgbGV0IGsgPSAoaWR4LCBpbml0X29ycGhhbikgaW5cbiAgICBiZWdpbiBtYXRjaCBzcGxpdF9mcm9tX3BhcmVudCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHNwbGl0IC0+IGFkZF9wYXJlbnRfa2V5IChLSShrLCBzcGxpdCkpXG4gICAgZW5kO1xuICAgIGtcblxuICAoKiBJZiBuZWNlc3NhcnksIGdyb3cgdGhlIGN1cnJlbnQgZG9tYWluJ3MgbG9jYWwgc3RhdGUgYXJyYXkgc3VjaCB0aGF0IFtpZHhdXG4gICAqIGlzIGEgdmFsaWQgaW5kZXggaW4gdGhlIGFycmF5LiAqKVxuICBsZXQgbWF5YmVfZ3JvdyBpZHggPVxuICAgIGxldCBzdCA9IGdldF9kbHNfc3RhdGUgKCkgaW5cbiAgICBsZXQgc3ogPSBBcnJheS5sZW5ndGggc3QgaW5cbiAgICBpZiBpZHggPCBzeiB0aGVuIHN0XG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHJlYyBjb21wdXRlX25ld19zaXplIHMgPVxuICAgICAgICBpZiBpZHggPCBzIHRoZW4gcyBlbHNlIGNvbXB1dGVfbmV3X3NpemUgKDIgKiBzKVxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfc3ogPSBjb21wdXRlX25ld19zaXplIHN6IGluXG4gICAgICBsZXQgbmV3X3N0ID0gQXJyYXkubWFrZSBuZXdfc3ogdW5pcXVlX3ZhbHVlIGluXG4gICAgICBBcnJheS5ibGl0IHN0IDAgbmV3X3N0IDAgc3o7XG4gICAgICBzZXRfZGxzX3N0YXRlIG5ld19zdDtcbiAgICAgIG5ld19zdFxuICAgIGVuZFxuXG4gIGxldCBzZXQgKGlkeCwgX2luaXQpIHggPVxuICAgIGxldCBzdCA9IG1heWJlX2dyb3cgaWR4IGluXG4gICAgKCogW1N5cy5vcGFxdWVfaWRlbnRpdHldIGVuc3VyZXMgdGhhdCBmbGFtYmRhIGRvZXMgbm90IGxvb2sgYXQgdGhlIHR5cGUgb2ZcbiAgICAgKiBbeF0sIHdoaWNoIG1heSBiZSBhIFtmbG9hdF0gYW5kIGNvbmNsdWRlIHRoYXQgdGhlIFtzdF0gaXMgYSBmbG9hdCBhcnJheS5cbiAgICAgKiBXZSBkbyBub3Qgd2FudCBPQ2FtbCdzIGZsb2F0IGFycmF5IG9wdGltaXNhdGlvbiBraWNraW5nIGluIGhlcmUuICopXG4gICAgc3QuKGlkeCkgPC0gT2JqLnJlcHIgKFN5cy5vcGFxdWVfaWRlbnRpdHkgeClcblxuICBsZXQgZ2V0IChpZHgsIGluaXQpID1cbiAgICBsZXQgc3QgPSBtYXliZV9ncm93IGlkeCBpblxuICAgIGxldCB2ID0gc3QuKGlkeCkgaW5cbiAgICBpZiB2ID09IHVuaXF1ZV92YWx1ZSB0aGVuXG4gICAgICBsZXQgdicgPSBPYmoucmVwciAoaW5pdCAoKSkgaW5cbiAgICAgIHN0LihpZHgpIDwtIChTeXMub3BhcXVlX2lkZW50aXR5IHYnKTtcbiAgICAgIE9iai5tYWdpYyB2J1xuICAgIGVsc2UgT2JqLm1hZ2ljIHZcblxuICBsZXQgZ2V0X2luaXRpYWxfa2V5cyAoKSA6IChpbnQgKiBPYmoudCkgbGlzdCA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW4gKEtJICgoaWR4LCBfKSBhcyBrLCBzcGxpdCkpIC0+XG4gICAgICAgICAgIChpZHgsIE9iai5yZXByIChzcGxpdCAoZ2V0IGspKSkpXG4gICAgICAoQXRvbWljLmdldCBwYXJlbnRfa2V5cylcblxuICBsZXQgc2V0X2luaXRpYWxfa2V5cyAobDogKGludCAqIE9iai50KSBsaXN0KSA9XG4gICAgTGlzdC5pdGVyXG4gICAgICAoZnVuIChpZHgsIHYpIC0+XG4gICAgICAgIGxldCBzdCA9IG1heWJlX2dyb3cgaWR4IGluIHN0LihpZHgpIDwtIHYpXG4gICAgICBsXG5cbmVuZFxuXG4oKioqKioqKiogSWRlbnRpdHkgKioqKioqKioqKilcblxubGV0IGdldF9pZCB7IGRvbWFpbjsgXyB9ID0gZG9tYWluXG5cbmxldCBzZWxmICgpID0gUmF3LnNlbGYgKClcblxubGV0IGlzX21haW5fZG9tYWluICgpID0gKHNlbGYgKCkgOj4gaW50KSA9IDBcblxuKCoqKioqKioqIENhbGxiYWNrcyAqKioqKioqKioqKVxuXG4oKiBmaXJzdCBzcGF3biwgZG9tYWluIHN0YXJ0dXAgYW5kIGF0IGV4aXQgZnVuY3Rpb25hbGl0eSAqKVxubGV0IGZpcnN0X2RvbWFpbl9zcGF3bmVkID0gQXRvbWljLm1ha2UgZmFsc2VcblxubGV0IGZpcnN0X3NwYXduX2Z1bmN0aW9uID0gcmVmIChmdW4gKCkgLT4gKCkpXG5cbmxldCBiZWZvcmVfZmlyc3Rfc3Bhd24gZiA9XG4gIGlmIEF0b21pYy5nZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdGhlblxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiZmlyc3QgZG9tYWluIGFscmVhZHkgc3Bhd25lZFwiKVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG9sZF9mID0gIWZpcnN0X3NwYXduX2Z1bmN0aW9uIGluXG4gICAgbGV0IG5ld19mICgpID0gb2xkX2YgKCk7IGYgKCkgaW5cbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSBuZXdfZlxuICBlbmRcblxubGV0IGRvX2JlZm9yZV9maXJzdF9zcGF3biAoKSA9XG4gIGlmIG5vdCAoQXRvbWljLmdldCBmaXJzdF9kb21haW5fc3Bhd25lZCkgdGhlbiBiZWdpblxuICAgIEF0b21pYy5zZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdHJ1ZTtcbiAgICAhZmlyc3Rfc3Bhd25fZnVuY3Rpb24oKTtcbiAgICAoKiBSZWxlYXNlIHRoZSBvbGQgZnVuY3Rpb24gKilcbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSAoZnVuICgpIC0+ICgpKVxuICBlbmRcblxubGV0IGF0X2V4aXRfa2V5ID0gRExTLm5ld19rZXkgKGZ1biAoKSAtPiAoZnVuICgpIC0+ICgpKSlcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBvbGRfZXhpdCA6IHVuaXQgLT4gdW5pdCA9IERMUy5nZXQgYXRfZXhpdF9rZXkgaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICAoKiBUaGUgZG9tYWluIHRlcm1pbmF0aW9uIGNhbGxiYWNrcyAoW2F0X2V4aXRdKSBhcmUgcnVuIGluXG4gICAgICAgbGFzdC1pbi1maXJzdC1vdXQgKExJRk8pIG9yZGVyIGluIG9yZGVyIHRvIGJlIHN5bW1ldHJpYyB3aXRoIHRoZSBkb21haW5cbiAgICAgICBjcmVhdGlvbiBjYWxsYmFja3MgKFthdF9lYWNoX3NwYXduXSkgd2hpY2ggcnVuIGluIGZpcnN0LWluLWZpc3J0LW91dFxuICAgICAgIChGSUZPKSBvcmRlci4gKilcbiAgICBmICgpOyBvbGRfZXhpdCAoKVxuICBpblxuICBETFMuc2V0IGF0X2V4aXRfa2V5IG5ld19leGl0XG5cbmxldCBkb19hdF9leGl0ICgpID1cbiAgbGV0IGYgOiB1bml0IC0+IHVuaXQgPSBETFMuZ2V0IGF0X2V4aXRfa2V5IGluXG4gIGYgKClcblxubGV0IF8gPSBTdGRsaWIuZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQgOj0gZG9fYXRfZXhpdFxuXG4oKioqKioqKiBDcmVhdGlvbiBhbmQgVGVybWluYXRpb24gKioqKioqKiopXG5cbmxldCBzcGF3biBmID1cbiAgZG9fYmVmb3JlX2ZpcnN0X3NwYXduICgpO1xuICBsZXQgcGsgPSBETFMuZ2V0X2luaXRpYWxfa2V5cyAoKSBpblxuXG4gICgqIFRoZSBbdGVybV9tdXRleF0gYW5kIFt0ZXJtX2NvbmRpdGlvbl0gYXJlIHVzZWQgdG9cbiAgICAgc3luY2hyb25pemUgd2l0aCB0aGUgam9pbmluZyBkb21haW5zICopXG4gIGxldCB0ZXJtX211dGV4ID0gTXV0ZXguY3JlYXRlICgpIGluXG4gIGxldCB0ZXJtX2NvbmRpdGlvbiA9IENvbmRpdGlvbi5jcmVhdGUgKCkgaW5cbiAgbGV0IHRlcm1fc3RhdGUgPSByZWYgUnVubmluZyBpblxuXG4gIGxldCBib2R5ICgpID1cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIG1hdGNoXG4gICAgICAgIERMUy5jcmVhdGVfZGxzICgpO1xuICAgICAgICBETFMuc2V0X2luaXRpYWxfa2V5cyBwaztcbiAgICAgICAgbGV0IHJlcyA9IGYgKCkgaW5cbiAgICAgICAgcmVzXG4gICAgICB3aXRoXG4gICAgICB8IHggLT4gT2sgeFxuICAgICAgfCBleGNlcHRpb24gZXggLT4gRXJyb3IgZXhcbiAgICBpblxuXG4gICAgbGV0IHJlc3VsdCcgPVxuICAgICAgKCogUnVuIHRoZSBbYXRfZXhpdF0gY2FsbGJhY2tzIHdoZW4gdGhlIGRvbWFpbiBjb21wdXRhdGlvbiBlaXRoZXJcbiAgICAgICAgIHRlcm1pbmF0ZXMgbm9ybWFsbHkgb3IgZXhjZXB0aW9uYWxseS4gKilcbiAgICAgIG1hdGNoIGRvX2F0X2V4aXQgKCkgd2l0aFxuICAgICAgfCAoKSAtPiByZXN1bHRcbiAgICAgIHwgZXhjZXB0aW9uIGV4IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIF8gLT5cbiAgICAgICAgICAgICAgKCogSWYgdGhlIGRvbWFpbiBjb21wdXRhdGlvbiB0ZXJtaW5hdGVkIG5vcm1hbGx5LCBidXQgdGhlXG4gICAgICAgICAgICAgICAgIFthdF9leGl0XSBjYWxsYmFja3MgcmFpc2VkIGFuIGV4Y2VwdGlvbiwgdGhlbiByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgIGV4Y2VwdGlvbi4gKilcbiAgICAgICAgICAgICAgRXJyb3IgZXhcbiAgICAgICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgICAgICAgKCogSWYgYm90aCB0aGUgZG9tYWluIGNvbXB1dGF0aW9uIGFuZCB0aGUgW2F0X2V4aXRdIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICByYWlzZWQgZXhjZXB0aW9ucywgdGhlbiBpZ25vcmUgdGhlIGV4Y2VwdGlvbiBmcm9tIHRoZVxuICAgICAgICAgICAgICAgICBbYXRfZXhpdF0gY2FsbGJhY2tzIGFuZCByZXR1cm4gdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi4gKilcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgZW5kXG4gICAgaW5cblxuICAgICgqIFN5bmNocm9uaXplIHdpdGggam9pbmluZyBkb21haW5zICopXG4gICAgTXV0ZXgubG9jayB0ZXJtX211dGV4O1xuICAgIG1hdGNoICF0ZXJtX3N0YXRlIHdpdGhcbiAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICAgdGVybV9zdGF0ZSA6PSBGaW5pc2hlZCByZXN1bHQnO1xuICAgICAgICBDb25kaXRpb24uYnJvYWRjYXN0IHRlcm1fY29uZGl0aW9uO1xuICAgIHwgRmluaXNoZWQgXyAtPlxuICAgICAgICBmYWlsd2l0aCBcImludGVybmFsIGVycm9yOiBBbSBJIGFscmVhZHkgZmluaXNoZWQ/XCJcbiAgICAoKiBbdGVybV9tdXRleF0gaXMgdW5sb2NrZWQgaW4gdGhlIHJ1bnRpbWUgYWZ0ZXIgdGhlIGNsZWFudXAgZnVuY3Rpb25zIG9uXG4gICAgICAgdGhlIEMgc2lkZSBhcmUgZmluaXNoZWQuICopXG4gIGluXG4gIHsgZG9tYWluID0gUmF3LnNwYXduIGJvZHkgdGVybV9tdXRleDtcbiAgICB0ZXJtX211dGV4O1xuICAgIHRlcm1fY29uZGl0aW9uO1xuICAgIHRlcm1fc3RhdGUgfVxuXG5sZXQgam9pbiB7IHRlcm1fbXV0ZXg7IHRlcm1fY29uZGl0aW9uOyB0ZXJtX3N0YXRlOyBfIH0gPVxuICBNdXRleC5sb2NrIHRlcm1fbXV0ZXg7XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbWF0Y2ggIXRlcm1fc3RhdGUgd2l0aFxuICAgIHwgUnVubmluZyAtPlxuICAgICAgICBDb25kaXRpb24ud2FpdCB0ZXJtX2NvbmRpdGlvbiB0ZXJtX211dGV4O1xuICAgICAgICBsb29wICgpXG4gICAgfCBGaW5pc2hlZCByZXMgLT5cbiAgICAgICAgTXV0ZXgudW5sb2NrIHRlcm1fbXV0ZXg7XG4gICAgICAgIHJlc1xuICBpblxuICBtYXRjaCBsb29wICgpIHdpdGhcbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBleCAtPiByYWlzZSBleFxuXG5sZXQgcmVjb21tZW5kZWRfZG9tYWluX2NvdW50ID0gUmF3LmdldF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzc5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9hbmQiLCJjc3RfTGkiLCJjc3RfaSIsImNzdF9saSIsImNzdF9uaSIsImNzdF91IiwiY3N0XzAiLCJjc3RfYXRfY2hhcmFjdGVyX251bWJlciIsImNzdF9iYWRfaW5wdXRfZm9ybWF0X3R5cGVfbWlzbSIsImNzdF9jYW1saW50ZXJuYWxGb3JtYXRfbWwiLCJjc3RfaW52YWxpZF9mb3JtYXQiLCJjc3RfcHJlY2lzaW9uIiwiY2FtbF9ibGl0X3N0cmluZyIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImNzdF91bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJBc3NlcnRfZmFpbHVyZSIsIkNhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcyIsIlN0ZGxpYiIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX0ludCIsImNzdF9jIiwiY3N0X3MiLCJjc3RfZiIsImNzdF9CIiwiY3N0X2EiLCJjc3RfdCIsImNzdF9yIiwiY3N0XzBjIiwiY3JlYXRlX2NoYXJfc2V0IiwicGFyYW0iLCJhZGRfaW5fY2hhcl9zZXQiLCJjaGFyX3NldCIsImMiLCJzdHJfaW5kIiwibWFzayIsImZyZWV6ZV9jaGFyX3NldCIsInJldl9jaGFyX3NldCIsImkiLCJpc19pbl9jaGFyX3NldCIsInBhZF9vZl9wYWRfb3B0IiwicGFkX29wdCIsIndpZHRoIiwicGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IiwiaWduIiwiZm10IiwiaWNvbnYiLCJwcmVjX29wdCIsIm5kZWMiLCJmbXR0eSIsIndpZHRoX29wdCIsImNvdW50ZXIiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImZjb252IiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwiYnVmIiwib3ZlcmhlYWQiLCJsZW4iLCJtaW5fbGVuIiwibmV3X2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInMiLCJzdHJfbGVuIiwiYnVmZmVyX2NvbnRlbnRzIiwiY2hhcl9vZl9pY29udiIsImNoYXJfb2ZfZmNvbnYiLCJvcHQiLCJzdGgiLCJjRiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZCIsIm4iLCJicHJpbnRfcHJlY2lzaW9uIiwicHJlYyIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJjaHIiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJpbnRfb2ZfY3VzdG9tX2FyaXR5IiwieCIsInN0cmluZ19vZl9mbXQiLCJmbXRpdGVyIiwicmVzdCIsImZtdGluZ19saXQiLCJmbXRpbmdfZ2VuIiwicHJpbnRfY2hhciIsInNldCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJzd2l0Y2hlciIsImoiLCJhcml0eSIsInN5bW0iLCJ0eSIsInR5MiIsInR5MSIsImZtdHR5X3JlbF9kZXQiLCJtYXRjaCIsImRlIiwiYWYiLCJqZCIsImdhIiwidHJhbnMiLCJyZXN0MSIsInJlc3QyIiwidHkxMiIsInR5MTEiLCJ0eTIyIiwidHkyMSIsImY0IiwiZjIiLCJmbXR0eV9vZl9mbXQiLCJ0eV9yZXN0IiwicHJlY190eSIsImZvcm1hdHRpbmdfZ2VuIiwiZm10dHlfb2ZfY3VzdG9tIiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsImZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSIsIlR5cGVfbWlzbWF0Y2giLCJjc3RfZCIsImNzdF94IiwiY3N0X1giLCJjc3RfbyIsImNzdF9MZCIsImNzdF9MeCIsImNzdF9MWCIsImNzdF9MbyIsImNzdF9MdSIsImNzdF9sZCIsImNzdF9seCIsImNzdF9sWCIsImNzdF9sbyIsImNzdF9sdSIsImNzdF9uZCIsImNzdF9ueCIsImNzdF9uWCIsImNzdF9ubyIsImNzdF9udSIsImNzdF9uZWdfaW5maW5pdHkiLCJjc3RfaW5maW5pdHkiLCJjc3RfbmFuIiwiY3N0X1ByaW50Zl9iYWRfY29udmVyc2lvbiIsImNzdF9ub25femVyb193aWR0aHNfYXJlX3Vuc3VwcCIsImNzdF9wYWRkaW5nIiwiY3N0X2RpZ2l0IiwiY3N0X2NoYXJhY3RlciIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJwIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eTAiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJzdWJfZm10dHkxIiwiZm10MSIsImZtdHR5MiIsImZtdDIiLCJmbXR0eTMiLCJmbXQzIiwidHlwZV9pZ25vcmVkX3BhcmFtX29uZSIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViMl9mbXR0eSIsInN1YjFfZm10dHkiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsInJlcyIsImZpeF9pbnRfcHJlY2lzaW9uIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwibCIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInBvcyIsInB1dCIsImxlZnQiLCJjb252ZXJ0X2ludCIsImNvbnZlcnRfaW50MzIiLCJjb252ZXJ0X25hdGl2ZWludCIsImNvbnZlcnRfaW50NjQiLCJjb252ZXJ0X2Zsb2F0IiwiaGV4Iiwic2lnbiIsImNhbWxfc3BlY2lhbF92YWwiLCJzdHJpbmdfb2ZfZm10dHkiLCJtYWtlX3ByaW50ZiIsImsiLCJhY2MiLCJuZXdfYWNjIiwibyIsImthY2MiLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9wYWRkaW5nIiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX2N1c3RvbSIsIm1ha2VfaXByaW50ZiIsImtvYyIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsIm1zZyIsImJ1ZnB1dF9hY2MiLCJiIiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsInJlYWQiLCJwYXJzZSIsImxpdF9zdGFydCIsImVuZF9pbmQiLCJzdHJfaW5kXzEiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJuZXh0X2luZCIsIm9mZnNldCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInNpemUiLCJwYXJzZV9mbGFncyIsInBjdF9pbmQiLCJ6ZXJvIiwibWludXMiLCJwbHVzIiwic3BhY2UiLCJoYXNoIiwic2V0X2ZsYWciLCJuZXdfaW5kIiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJwYXJzZV9jb252IiwicGFkcHJlYyIsInBhcnNlX2NvbnZlcnNpb24iLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0Iiwic3ViX2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkIiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsImNoYXJfZm9ybWF0Iiwia2luZCIsInBhcnNlX3RhZyIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsImZvcm1hdHRpbmciLCJwYXJzZV9wb3NpdGl2ZSIsInBhcnNlX2ludGVnZXIiLCJhZGRfbGl0ZXJhbCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwiY29tcHV0ZV9pbnRfY29udiIsImluY29tcGF0aWJsZV9mbGFnIiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IiwiQ2FtbGludGVybmFsRm9ybWF0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFOLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQU8sVUFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQVIsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBUztBQUFBQSxNQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQXRDLFFBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBdUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQXhDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQXlDLCtCQUFBO0FBQUEsSUFBQXpDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxNQUFBO0FBQUEsSUFBQTBDLGlCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQWpELFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFILFNBQUE7QUFBQSxJQUFBbUQsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFB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SUFBQUEsV0FBQTtBQUFBLElBQUF3SyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQTFLLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUEySyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQTlLLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUErSyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLDhCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJ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QWhCLG1CQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVEMzZGOUI7QUFBQTtBQUFBLE1DNjZGSSxvREFDOEQ7QUFBQSxLRDk2RmxFO0FBQUE7QUFBQSxHQzg2RmtFO0FBQUE7QUFBQSxJQUFBZ1I7QUFBQUEsTUQ5NkZsRSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IXG4gIHwgRmxvYXRfQ0YgLT4gLTZcbiAgKCogRm9yICVoICVIIGFuZCAlI0YgZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IEludC5tYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCB8IEludF9DZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaVxuICB8IEludF9DaSAtPiAnaScgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfb1xuICB8IEludF9DbyAtPiAnbycgfCBJbnRfdSB8IEludF9DdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbigqIGBjRicgd2lsbCBiZSAnRicgZm9yIGRpc3BsYXlpbmcgZm9ybWF0IGFuZCAnZycgdG8gY2FsbCBsaWJjIHByaW50ZiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgPyhjRj0nRicpIGZjb252ID0gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIC0+ICdmJyB8IEZsb2F0X2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSAtPiAnRScgfCBGbG9hdF9nIC0+ICdnJ1xuICB8IEZsb2F0X0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiBjRlxuICB8IEZsb2F0X2ggLT4gJ2gnIHwgRmxvYXRfSCAtPiAnSCdcbiAgfCBGbG9hdF9DRiAtPiAnRidcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBhbmQvb3IgJyMnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9XG4gIGJlZ2luIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZmxhZ19wIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfZmxhZ19zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZmxhZ18gLT4gKCkgZW5kO1xuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X0NGIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0dcbiAgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT4gKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEZvcm1hdHRpbmdfbGl0LiAqKVxuKCogVXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZm10aW5nX2dlbiB3aXRoXG4gICAgICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkB7XCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQFtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgZW5kO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIGxldCBoZXggKCkgPVxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X2ZsYWdfcCAtPiAnKydcbiAgICAgIHwgRmxvYXRfZmxhZ19zIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICBsZXQgYWRkX2RvdF9pZl9uZWVkZWQgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSkgaW5cbiAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCIgaW5cbiAgbGV0IGNhbWxfc3BlY2lhbF92YWwgc3RyID0gbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+IHN0clxuICAgIHwgRlBfaW5maW5pdGUgLT4gaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICB8IEZQX25hbiAtPiBcIm5hblwiIGluXG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCAtPiBoZXggKClcbiAgfCBGbG9hdF9IIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKGhleCAoKSlcbiAgfCBGbG9hdF9DRiAtPiBjYW1sX3NwZWNpYWxfdmFsIChoZXggKCkpXG4gIHwgRmxvYXRfRiAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgY2FtbF9zcGVjaWFsX3ZhbCAoYWRkX2RvdF9pZl9uZWVkZWQgc3RyKVxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIC0+XG4gICAgZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeFxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA6ICh4LHkpIHBhZGRpbmcgPVxuICAgICAgKCogJTUuM2QgaXMgYWNjZXB0ZWQgYW5kIG1lYW5pbmdmdWw6IHBhZCB0byBsZW5ndGggNSB3aXRoXG4gICAgICAgICBzcGFjZXMsIGJ1dCBmaXJzdCBwYWQgd2l0aCB6ZXJvcyB1cHRvIGxlbmd0aCAzICgwLXBhZGRpbmdcbiAgICAgICAgIGlzIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBcInByZWNpc2lvblwiIGZvciBpbnRlZ2VyIGZvcm1hdHMpLlxuXG4gICAgICAgICAlMDUuM2QgaXMgcmVkdW5kYW50OiBwYWQgdG8gbGVuZ3RoIDUgKndpdGggemVyb3MqLCBidXRcbiAgICAgICAgIGZpcnN0IHBhZCB3aXRoIHplcm9zLi4uIFRvIGFkZCBpbnN1bHQgdG8gdGhlIGluanVyeSwgdGhlXG4gICAgICAgICBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWdub3JlcyB0aGUgMC1wYWRkaW5nIGluZGljYXRpb24gYW5kXG4gICAgICAgICBkb2VzIHRoZSA1IHBhZGRpbmcgd2l0aCBzcGFjZXMgaW5zdGVhZC4gV2UgcmV1c2UgdGhpc1xuICAgICAgICAgaW50ZXJwcmV0YXRpb24gZm9yIGNvbXBhdGliaWxpdHksIGJ1dCBzdGF0aWNhbGx5IHJlamVjdCB0aGlzXG4gICAgICAgICBmb3JtYXQgd2hlbiB0aGUgbGVnYWN5IG1vZGUgaXMgZGlzYWJsZWQsIHRvIHByb3RlY3Qgc3RyaWN0XG4gICAgICAgICB1c2VycyBmcm9tIHRoaXMgY29ybmVyIGNhc2UuICopXG4gICAgICAgbWF0Y2ggZ2V0X3BhZCAoKSwgZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgICAgfCBwYWQsIE5vX3ByZWNpc2lvbiAtPiBwYWRcbiAgICAgICAgIHwgTm9fcGFkZGluZywgXyAgICAgLT4gTm9fcGFkZGluZ1xuICAgICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIG4pLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgbilcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MsIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZCBpblxuXG4gICAgKCogQ2hlY2sgdGhhdCBwYWR0eSA8PiBaZXJvcy4gKilcbiAgICBsZXQgY2hlY2tfbm9fMCBzeW1iICh0eXBlIGEgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA6IChhLGIpIHBhZGRpbmcgPVxuICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKChMZWZ0IHwgUmlnaHQpLCBfKSAtPiBwYWRcbiAgICAgIHwgQXJnX3BhZGRpbmcgKExlZnQgfCBSaWdodCkgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgIGluXG5cbiAgICAoKiBHZXQgcGFkZGluZyBhcyBhIHBhZF9vcHRpb24gKHNlZSBcIiVfXCIsIFwiJXtcIiwgXCIlKFwiIGFuZCBcIiVbXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IG9wdF9vZl9wYWQgYyAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID0gbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBOb25lXG4gICAgICB8IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpIC0+IFNvbWUgd2lkdGhcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJzAnXCJcbiAgICAgIHwgTGl0X3BhZGRpbmcgKExlZnQsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInLSdcIlxuICAgICAgfCBBcmdfcGFkZGluZyBfIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJyonXCJcbiAgICBpblxuICAgIGxldCBnZXRfcGFkX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkICgpKSBpblxuICAgIGxldCBnZXRfcGFkcHJlY19vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZHByZWMgKCkpIGluXG5cbiAgICAoKiBHZXQgcHJlY2lzaW9uIGFzIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfZlwiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBnZXRfcHJlY19vcHQgKCkgPSBtYXRjaCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICB8IE5vX3ByZWNpc2lvbiAgICAgICAtPiBOb25lXG4gICAgICB8IExpdF9wcmVjaXNpb24gbmRlYyAtPiBTb21lIG5kZWNcbiAgICAgIHwgQXJnX3ByZWNpc2lvbiAgICAgIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKidcIlxuICAgIGluXG5cbiAgICBsZXQgZm10X3Jlc3VsdCA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJywnIC0+XG4gICAgICBwYXJzZSBzdHJfaW5kIGVuZF9pbmRcbiAgICB8ICdjJyAtPlxuICAgICAgbGV0IGNoYXJfZm9ybWF0IGZtdF9yZXN0ID0gKCogJWMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKENoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IHNjYW5fZm9ybWF0IGZtdF9yZXN0ID0gKCogJTBjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3NjYW5fbmV4dF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGJlZ2luIG1hdGNoIGdldF9wYWRfb3B0ICdjJyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgMCAtPiBzY2FuX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgX24gLT5cbiAgICAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvclxuICAgICAgICAgICB0aGVuIGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmRcbiAgICAgICAgICAgZWxzZSAoKiBsZWdhY3kgaWdub3JlcyAlYyB3aWR0aHMgKikgY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgIGVuZFxuICAgIHwgJ0MnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2FtbF9jaGFyLGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoQ2FtbF9jaGFyIGZtdF9yZXN0KVxuICAgIHwgJ3MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoU3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ1MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2NhbWxfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChDYW1sX3N0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPlxuICAgICAgbGV0IGljb252ID0gY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ04nIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBUb2tlbl9jb3VudGVyIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyB8ICduJyB8ICdMJyB3aGVuIHN0cl9pbmQ9ZW5kX2luZCB8fCBub3QgKGlzX2ludF9iYXNlIHN0ci5bc3RyX2luZF0pIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyX29mX2NoYXIgc3ltYiBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDMyIChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50MzIgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICduJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKVxuICAgICAgICAgIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDY0IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50NjQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdmJyB8ICdlJyB8ICdFJyB8ICdnJyB8ICdHJyB8ICdGJyB8ICdoJyB8ICdIJyAtPlxuICAgICAgbGV0IGZjb252ID1cbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZFxuICAgICAgICAgIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gKGFmdGVyICdAJykuICopXG4gIGFuZCBwYXJzZV9hZnRlcl9hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBFbmRfb2ZfZm9ybWF0KSlcbiAgICBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ1snIC0+XG4gICAgICAgIHBhcnNlX3RhZyBmYWxzZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV9ib3gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ3snIC0+XG4gICAgICAgIHBhcnNlX3RhZyB0cnVlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnfScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX3RhZywgZm10X3Jlc3QpKVxuICAgICAgfCAnLCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAsXCIsIDAsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCBcIiwgMSwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJzsnIC0+XG4gICAgICAgIHBhcnNlX2dvb2RfYnJlYWsgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICc/JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRkZsdXNoLCBmbXRfcmVzdCkpXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGb3JjZV9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICcuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRmx1c2hfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgcGFyc2VfbWFnaWNfc2l6ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX2F0LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyB3aGVuIHN0cl9pbmQgKyAxIDwgZW5kX2luZCAmJiBzdHIuW3N0cl9pbmQgKyAxXSA9ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMikgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9wZXJjZW50LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgZm10X3Jlc3QpKVxuICAgICAgfCBjIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljIGMsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPG5hbWU+IGFmdGVyIFwiQHtcIiBvciBcIkBbXCIuICopXG4gIGFuZCBwYXJzZV90YWcgOiB0eXBlIGUgZiAuIGJvb2wgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBpc19vcGVuX3RhZyBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICB0cnlcbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBsZXQgaW5kID0gU3RyaW5nLmluZGV4X2Zyb20gc3RyIChzdHJfaW5kICsgMSkgJz4nIGluXG4gICAgICAgIGlmIGluZCA+PSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIHN0cl9pbmQgKGluZCAtIHN0cl9pbmQgKyAxKSBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChpbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIChpbmQgKyAxKSBpblxuICAgICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoc3ViX2ZtdCwgc3ViX3N0cikgaW5cbiAgICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcbiAgICAgIHwgXyAtPlxuICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChFbmRfb2ZfZm9ybWF0LCBcIlwiKSBpblxuICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8d2lkdGggb2Zmc2V0PiBhZnRlciBcIkA7XCIuICopXG4gIGFuZCBwYXJzZV9nb29kX2JyZWFrIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGxldCBuZXh0X2luZCwgZm9ybWF0dGluZ19saXQgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHx8IHN0ci5bc3RyX2luZF0gPD4gJzwnIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gKFxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHdpZHRoID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzNdIHdpdGhcbiAgICAgICAgICAgICAgfCAnPicgLT5cbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzMtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfMyArIDEsIEJyZWFrIChzLCB3aWR0aCwgMClcbiAgICAgICAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNCwgb2Zmc2V0ID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzMgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzUgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF80IGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfNV0gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfNS1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF81ICsgMSwgQnJlYWsgKHMsIHdpZHRoLCBvZmZzZXQpXG4gICAgICAgICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgKVxuICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBzdHJfaW5kLCBCcmVhayAoXCJAO1wiLCAxLCAwKVxuICAgIGluXG4gICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgdGhlIHNpemUgaW4gYSA8bj4uICopXG4gIGFuZCBwYXJzZV9tYWdpY19zaXplIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIG1hdGNoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgc2l6ZSA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzNdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kIC0gMikgKHN0cl9pbmRfMyAtIHN0cl9pbmQgKyAzKSBpblxuICAgICAgICAgIFNvbWUgKHN0cl9pbmRfMyArIDEsIE1hZ2ljX3NpemUgKHMsIHNpemUpKVxuICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgTm9uZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgJzwnLCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgYW5kIGNvbnN0cnVjdCBhIGNoYXIgc2V0LiAqKVxuICBhbmQgcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuXG4gICAgbGV0IGNoYXJfc2V0ID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gICAgbGV0IGFkZF9jaGFyIGMgPVxuICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGM7XG4gICAgaW5cbiAgICBsZXQgYWRkX3JhbmdlIGMgYycgPVxuICAgICAgZm9yIGkgPSBpbnRfb2ZfY2hhciBjIHRvIGludF9vZl9jaGFyIGMnIGRvXG4gICAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCAoY2hhcl9vZl9pbnQgaSk7XG4gICAgICBkb25lO1xuICAgIGluXG5cbiAgICBsZXQgZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kID1cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogJyUlJyBhbG9uZSBpcyBub3QgYWNjZXB0ZWQgaW4gY2hhcmFjdGVyIHNldHMsIFxcXG4gICAgICAgICB1c2UgJSUlJSBpbnN0ZWFkIGF0IHBvc2l0aW9uICVkLlwiIHN0ciBzdHJfaW5kXG4gICAgaW5cblxuICAgICgqIFBhcnNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBjaGFyIHNldC4gKilcbiAgICBsZXQgcmVjIHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbGV0IGMgPSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBQYXJzZSB0aGUgY29udGVudCBvZiBhIGNoYXIgc2V0IHVudGlsIHRoZSBmaXJzdCAnXScuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogVGVzdCBmb3IgcmFuZ2UgaW4gY2hhciBzZXQuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG4gICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIHdoZW4gYyA9ICclJyAtPlxuICAgICAgICBhZGRfY2hhciBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgaWYgYyA9ICclJyB0aGVuIGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZDtcbiAgICAgICAgKCogbm90ZSB0aGF0ICdAJyBhbG9uZSBpcyBhY2NlcHRlZCwgYXMgZG9uZSBieSB0aGUgbGVnYWN5XG4gICAgICAgICAgIGltcGxlbWVudGF0aW9uOyB0aGUgZG9jdW1lbnRhdGlvbiBzcGVjaWZpY2FsbHkgcmVxdWlyZXMgJUBcbiAgICAgICAgICAgc28gd2UgY291bGQgd2FybiBvbiB0aGF0ICopXG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGMnXG5cbiAgICAoKiBNYW5hZ2UgcmFuZ2UgaW4gY2hhciBzZXQgKGV4Y2VwdCBpZiB0aGUgJy0nIHRoZSBsYXN0IGNoYXIgYmVmb3JlICddJykgKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIC0+XG4gICAgICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kXG4gICAgICAgICAgfCBfIC0+IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZFxuICAgICAgICBlbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgaW5cbiAgICBsZXQgc3RyX2luZCwgcmV2ZXJzZSA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICAgIHwgJ14nIC0+IHN0cl9pbmQgKyAxLCB0cnVlXG4gICAgICAgIHwgXyAtPiBzdHJfaW5kLCBmYWxzZSBpblxuICAgIGxldCBuZXh0X2luZCA9IHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgIGxldCBjaGFyX3NldCA9IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCBpblxuICAgIG5leHRfaW5kLCAoaWYgcmV2ZXJzZSB0aGVuIHJldl9jaGFyX3NldCBjaGFyX3NldCBlbHNlIGNoYXJfc2V0KVxuXG4gICgqIENvbnN1bWUgYWxsIG5leHQgc3BhY2VzLCByYWlzZSBhbiBGYWlsdXJlIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgaWYgc3RyLltzdHJfaW5kXSA9ICcgJyB0aGVuIHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgZWxzZSBzdHJfaW5kXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmUgaWYgZW5kX2luZCBpc1xuICAgICByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIGFjYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBhY2MgKiAxMCArIChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnKSBpblxuICAgICAgaWYgbmV3X2FjYyA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBpbnRlZ2VyICVkIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGltaXQgJWRcIlxuICAgICAgICAgIHN0ciBuZXdfYWNjIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgbmV3X2FjY1xuICAgIHwgXyAtPiBzdHJfaW5kLCBhY2NcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZVxuICAgICBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9pbnRlZ2VyIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDBcbiAgICB8ICctJyAtPiAoXG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgICBsZXQgbmV4dF9pbmQsIG4gPSBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgMCBpblxuICAgICAgICBuZXh0X2luZCwgLW5cbiAgICAgIHwgYyAtPlxuICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImRpZ2l0XCIgY1xuICAgIClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQWRkIGEgbGl0ZXJhbCB0byBhIGZvcm1hdCBmcm9tIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgc3ViLXNlcXVlbmNlLiAqKVxuICBhbmQgYWRkX2xpdGVyYWwgOiB0eXBlIGEgZCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiAoYSwgXywgXywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBmbXQgLT4gbWF0Y2ggc3RyX2luZCAtIGxpdF9zdGFydCB3aXRoXG4gICAgfCAwICAgIC0+IEZtdF9FQkIgZm10XG4gICAgfCAxICAgIC0+IEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoc3RyLltsaXRfc3RhcnRdLCBmbXQpKVxuICAgIHwgc2l6ZSAtPiBGbXRfRUJCIChTdHJpbmdfbGl0ZXJhbCAoU3RyaW5nLnN1YiBzdHIgbGl0X3N0YXJ0IHNpemUsIGZtdCkpXG5cbiAgKCogU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdFxuICAgICAoaS5lLiB0aGUgY29ycmVzcG9uZGluZyBcIiV9XCIgb3IgXCIlKVwiKSAqKVxuICBhbmQgc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogdW5jbG9zZWQgc3ViLWZvcm1hdCwgXFxcbiAgICAgICAgIGV4cGVjdGVkIFxcXCIlJSVjXFxcIiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkXCIgc3RyIGMgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICclJyAtPlxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBpZiBzdHIuW3N0cl9pbmQgKyAxXSA9IGMgdGhlbiAoKiBFbmQgb2YgZm9ybWF0IGZvdW5kICopIHN0cl9pbmQgZWxzZVxuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgIHwgJ18nIC0+XG4gICAgICAgICAgKCogU2VhcmNoIGZvciBcIiVfKFwiIG9yIFwiJV97XCIuICopXG4gICAgICAgICAgaWYgc3RyX2luZCArIDIgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMl0gd2l0aFxuICAgICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kIGNcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAoKiAley4uLiV9IHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAoKiAlKC4uLiUpIHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnfScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJSguLi4lfS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnKSdcIiAnfSdcbiAgICAgICAgfCAnKScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJXsuLi4lKS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnfSdcIiAnKSdcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgZW5kXG4gICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgKCogQ2hlY2sgaWYgc3ltYiBpcyBhIHZhbGlkIGludCBjb252ZXJzaW9uIGFmdGVyIFwiJWxcIiwgXCIlblwiIG9yIFwiJUxcIiAqKVxuICBhbmQgaXNfaW50X2Jhc2Ugc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcblxuICAoKiBDb252ZXJ0IGEgY2hhciAobCwgbiBvciBMKSB0byBpdHMgYXNzb2NpYXRlZCBjb3VudGVyLiAqKVxuICBhbmQgY291bnRlcl9vZl9jaGFyIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdsJyAtPiBMaW5lX2NvdW50ZXIgIHwgJ24nIC0+IENoYXJfY291bnRlclxuICAgIHwgJ0wnIC0+IFRva2VuX2NvdW50ZXIgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGludF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIG1hdGNoIHBsdXMsIGhhc2gsIHNwYWNlLCBzeW1iIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfZCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X2lcbiAgICB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdkJyAtPiBJbnRfc2QgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnaScgLT4gSW50X3NpXG4gICAgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X3BkIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9waVxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3gnIC0+IEludF94ICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdYJyAtPiBJbnRfWFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3gnIC0+IEludF9DeCB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdYJyAtPiBJbnRfQ1hcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdvJyAtPiBJbnRfb1xuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ28nIC0+IEludF9Db1xuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3UnIC0+IEludF91XG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnZCcgLT4gSW50X0NkXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnaScgLT4gSW50X0NpXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAndScgLT4gSW50X0N1XG4gICAgfCBfLCB0cnVlLCBfLCAneCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0N4XG4gICAgfCBfLCB0cnVlLCBfLCAnWCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NYXG4gICAgfCBfLCB0cnVlLCBfLCAnbycgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NvXG4gICAgfCBfLCB0cnVlLCBfLCAoJ2QnIHwgJ2knIHwgJ3UnKSAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiXG4gICAgfCB0cnVlLCBfLCB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCB0cnVlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIlxuICAgIHwgdHJ1ZSwgXywgZmFsc2UsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBmYWxzZSBoYXNoIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIGZhbHNlLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHNwYWNlLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbGV0IGZsYWcgPSBtYXRjaCBwbHVzLCBzcGFjZSB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19cbiAgICB8IGZhbHNlLCAgdHJ1ZSAtPiBGbG9hdF9mbGFnX3NcbiAgICB8ICB0cnVlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX3BcbiAgICB8ICB0cnVlLCAgdHJ1ZSAtPlxuICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEZsb2F0X2ZsYWdfcFxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCIgaW5cbiAgICBsZXQga2luZCA9IG1hdGNoIGhhc2gsIHN5bWIgd2l0aFxuICAgIHwgXywgJ2YnIC0+IEZsb2F0X2ZcbiAgICB8IF8sICdlJyAtPiBGbG9hdF9lXG4gICAgfCBfLCAnRScgLT4gRmxvYXRfRVxuICAgIHwgXywgJ2cnIC0+IEZsb2F0X2dcbiAgICB8IF8sICdHJyAtPiBGbG9hdF9HXG4gICAgfCBfLCAnaCcgLT4gRmxvYXRfaFxuICAgIHwgXywgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgdHJ1ZSwgJ0YnIC0+IEZsb2F0X0NGXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSBpblxuICAgIGZsYWcsIGtpbmRcblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgaW5jb21wYXRpYmxlIG9wdGlvbnMuKilcbiAgYW5kIGluY29tcGF0aWJsZV9mbGFnIDogdHlwZSBhIC4gaW50IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZyAtPiBhID1cbiAgICBmdW4gcGN0X2luZCBzdHJfaW5kIHN5bWIgb3B0aW9uIC0+XG4gICAgICBsZXQgc3ViZm10ID0gU3RyaW5nLnN1YiBzdHIgcGN0X2luZCAoc3RyX2luZCAtIHBjdF9pbmQpIGluXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICAlcyBpcyBpbmNvbXBhdGlibGUgd2l0aCAnJWMnIGluIHN1Yi1mb3JtYXQgJVNcIlxuICAgICAgICBzdHIgcGN0X2luZCBvcHRpb24gc3ltYiBzdWJmbXRcblxuICBpbiBwYXJzZSAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICgqIEd1YXJkZWQgc3RyaW5nIHRvIGZvcm1hdCBjb252ZXJzaW9ucyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgc3RyIGZtdHR5ID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCBmbXR0eSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIlxuICAgICAgc3RyIChzdHJpbmdfb2ZfZm10dHkgZm10dHkpXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgY29tcGF0aWJsZSB3aXRoIGFuIG90aGVyIGZvcm1hdC4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciAoRm9ybWF0IChmbXQnLCBzdHInKSkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IChmbXR0eV9vZl9mbXQgZm10JyksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCIgc3RyIHN0cidcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjk5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9CdWZmZXIiLCJDYW1saW50ZXJuYWxGb3JtYXQiLCJTdGRsaWIiLCJrZnByaW50ZiIsImsiLCJvIiwicGFyYW0iLCJmbXQiLCJhY2MiLCJrYnByaW50ZiIsImIiLCJpa2ZwcmludGYiLCJvYyIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJpYnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsImJ1ZiIsInNwcmludGYiLCJzIiwiU3RkbGliX1ByaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvcHJpbnRmLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsWUFBQUMsU0FBQUMsR0FBQUMsR0FBQUM7QUFBQUEsUUFBQUMsTUNrQmE7QUFBQSxJQUNYO0FBQUE7QUFBQSxzQkFBQUM7QUFBQUEsY0FBd0I7QUFBQSxjQUFnQix1QkFBSztBQUFBO0FBQUE7QUFBQSxpQkFBZ0I7QUFBQTtBQUFBLFlBQUFDLFNBQUFMLEdBQUFNLEdBQUFKO0FBQUFBLFFBQUFDLE1BQ2xEO0FBQUEsSUFDWDtBQUFBO0FBQUEsc0JBQUFDO0FBQUFBLGNBQXdCO0FBQUEsY0FBZ0IsdUJBQUs7QUFBQTtBQUFBO0FBQUEsaUJBQWdCO0FBQUE7QUFBQSxZQUFBRyxVQUFBUCxHQUFBUSxJQUFBTjtBQUFBQSxRQUFBQyxNQUNqRDtBQUFBLElBQ1osb0RBQXFCO0FBQUE7QUFBQSxZQUFBTSxRQUFBRCxJQUFBTDtBQUFBQSxJQUdGLDhCRDFCckIsb0JDMEIyQztBQUFBO0FBQUEsWUFBQU8sUUFBQUosR0FBQUg7QUFBQUEsSUFDdkIsOEJEM0JwQixtQkMyQnlDO0FBQUE7QUFBQSxZQUFBUSxTQUFBSCxJQUFBTDtBQUFBQSxJQUNuQiwrQkQ1QnRCLG9CQzRCNkM7QUFBQTtBQUFBLFlBQUFTLFNBQUFOLEdBQUFIO0FBQUFBLElBQ3hCLCtCRDdCckIsbUJDNkIyQztBQUFBO0FBQUEsWUFBQVUsT0FBQVYsS0FDMUIsK0JBQWtCO0FBQUEsWUFBQVcsUUFBQVgsS0FDakIsK0JBQWtCO0FBQUEsWUFBQVksU0FBQWYsR0FBQUU7QUFBQUEsUUFBQUMsTUFFdkI7QUFBQSxhQUFBSCxJQUFBSTtBQUFBQSxTQUFBWSxNQUVDO0FBQUEsS0FDVjtBQUFBLEtBQ0UsT0FBcUIsY0FBckIsa0NBQXFCO0FBQUE7QUFBQSxJQUN6QixxREFBNkI7QUFBQTtBQUFBLFlBQUFDLFFBQUFkLEtBRWIseUJBQUFlLEdBQW1CLFNBQUMsT0FBSztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR4QzNDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjMwOTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfcyIsImNzdF9Qcm9ncmFtX25vdF9saW5rZWRfd2l0aF9nXyIsImNzdF9jaGFyYWN0ZXJzIiwiY3N0X0ZhdGFsX2Vycm9yX2V4Y2VwdGlvbiIsImNzdF9GYXRhbF9lcnJvcl9leGNlcHRpb25fcyIsImNzdF9VbmNhdWdodF9leGNlcHRpb24iLCJjc3RfVW5jYXVnaHRfZXhjZXB0aW9uX3MiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw2IiwiYTMiLCJhNCIsImE1IiwiY2FtbF9jYWxsOCIsImE2IiwiYTciLCJnbG9iYWxfZGF0YSIsInBhcnRpYWwiLCJsb2NmbXQiLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliX0F0b21pYyIsIlN0ZGxpYiIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfT2JqIiwicHJpbnRlcnMiLCJjc3RfT3V0X29mX21lbW9yeSIsImNzdF9TdGFja19vdmVyZmxvdyIsImNzdF9QYXR0ZXJuX21hdGNoaW5nX2ZhaWxlZCIsImNzdF9Bc3NlcnRpb25fZmFpbGVkIiwiY3N0X1VuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIiwiY3N0X1JhaXNlZF9hdCIsImNzdF9SZV9yYWlzZWRfYXQiLCJjc3RfUmFpc2VkX2J5X3ByaW1pdGl2ZV9vcGVyYXQiLCJjc3RfQ2FsbGVkX2Zyb20iLCJjc3RfaW5saW5lZCIsImZpZWxkIiwieCIsImkiLCJvdGhlcl9maWVsZHMiLCJ1c2VfcHJpbnRlcnMiLCJwYXJhbSIsInRsIiwiaGQiLCJ2YWwiLCJzIiwic3RyaW5nX29mX2V4dGVuc2lvbl9jb25zdHJ1Y3RvIiwidCIsImNvbnN0cnVjdG9yIiwibWF0Y2giLCJmaWVsZHNfb3B0IiwidG9fc3RyaW5nX2RlZmF1bHQiLCJjaGFyIiwibGluZSIsImZpbGUiLCJ0b19zdHJpbmciLCJlIiwicHJpbnQiLCJmY3QiLCJhcmciLCJjYXRjaCIsInJhd19iYWNrdHJhY2VfZW50cmllcyIsImJ0IiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwicG9zIiwic2xvdCIsImluZm8iLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsImEiLCJzdHIiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImIiLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsInN1Y2Nlc3MiLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsImVycm9ycyIsImRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbiIsImV4biIsInN0YXR1cyIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwiZW1wdHlfYmFja3RyYWNlIiwiY3N0X0ZhdGFsX2Vycm9yX291dF9vZl9tZW1vcnlfIiwiaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImRlYnVnZ2VyX2luX3VzZSIsIlN0ZGxpYl9QcmludGV4YyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvcHJpbnRleGMubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtB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QUFPO0FBQUFBLElBd1YzQjtBQUFBLEtBNUJBO0FBQUE7QUFBQSxPQUFBakM7QUFBQUEsU0FBQSxvQ0FMRTtBQUFBLE1BY0EsSUFBSztBQUFBLE1BQ0w7QUFBQTtBQUFBLGNBQ0U7QUFBQTtBQUFBO0FBQUEsWUFBQTBCO0FBQUFBO0FBQUFBLFFBQUFBLE1EMVZOO0FBQUEsUUFBQTFCLGtCQzBVSTtBQUFBLGNBbUJ3QztBQUFBLE9BQXRDO0FBQUEsT0FDQTtBQUFBLGlCQUVFO0FBQUEsT0FERjtBQUFBLE9BRUE7QUFBQSxpQkFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JEbFdOO0FBQUE7QUFBQSxnQkNxV1E7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQVVKO0FBQUEsR0FBRTtBQUFBLEdBTUo7QUFBQTtBQUFBO0FBQUEsSUFBQWtDO0FBQUFBLE1BQzJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCRHRYN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDc1g2QjtBQUFBO0FBQUEsRUR0WDdCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IEF0b21pYy5tYWtlIFtdXG5cbmxldCBsb2NmbXQgPSBmb3JtYXRfb2Zfc3RyaW5nIFwiRmlsZSBcXFwiJXNcXFwiLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOiAlc1wiXG5cbmxldCBmaWVsZCB4IGkgPVxuICBsZXQgZiA9IE9iai5maWVsZCB4IGkgaW5cbiAgaWYgbm90IChPYmouaXNfYmxvY2sgZikgdGhlblxuICAgIHNwcmludGYgXCIlZFwiIChPYmoubWFnaWMgZiA6IGludCkgICAgICAgICAgICgqIGNhbiBhbHNvIGJlIGEgY2hhciAqKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5zdHJpbmdfdGFnIHRoZW5cbiAgICBzcHJpbnRmIFwiJVNcIiAoT2JqLm1hZ2ljIGYgOiBzdHJpbmcpXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLmRvdWJsZV90YWcgdGhlblxuICAgIHN0cmluZ19vZl9mbG9hdCAoT2JqLm1hZ2ljIGYgOiBmbG9hdClcbiAgZWxzZVxuICAgIFwiX1wiXG5cbmxldCByZWMgb3RoZXJfZmllbGRzIHggaSA9XG4gIGlmIGkgPj0gT2JqLnNpemUgeCB0aGVuIFwiXCJcbiAgZWxzZSBzcHJpbnRmIFwiLCAlcyVzXCIgKGZpZWxkIHggaSkgKG90aGVyX2ZpZWxkcyB4IChpKzEpKVxuXG5sZXQgZmllbGRzIHggPVxuICBtYXRjaCBPYmouc2l6ZSB4IHdpdGhcbiAgfCAwIC0+IFwiXCJcbiAgfCAxIC0+IFwiXCJcbiAgfCAyIC0+IHNwcmludGYgXCIoJXMpXCIgKGZpZWxkIHggMSlcbiAgfCBfIC0+IHNwcmludGYgXCIoJXMlcylcIiAoZmllbGQgeCAxKSAob3RoZXJfZmllbGRzIHggMilcblxubGV0IHVzZV9wcmludGVycyB4ID1cbiAgbGV0IHJlYyBjb252ID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCBoZCB4IHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IGV4Y2VwdGlvbiBfIC0+IGNvbnYgdGxcbiAgICAgICAgIHwgU29tZSBzIC0+IFNvbWUgcylcbiAgICB8IFtdIC0+IE5vbmUgaW5cbiAgY29udiAoQXRvbWljLmdldCBwcmludGVycylcblxubGV0IGRlc3RydWN0X2V4dF9jb25zdHJ1Y3RvciB4ID1cbiAgaWYgT2JqLnRhZyB4IDw+IDAgdGhlblxuICAgICgoT2JqLm1hZ2ljIChPYmouZmllbGQgeCAwKSA6IHN0cmluZyksIE5vbmUpXG4gIGVsc2VcbiAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAoY29uc3RydWN0b3IsIFNvbWUgKGZpZWxkcyB4KSlcblxubGV0IHN0cmluZ19vZl9leHRlbnNpb25fY29uc3RydWN0b3IgdCA9XG4gIGxldCBjb25zdHJ1Y3RvciwgZmllbGRzX29wdCA9IGRlc3RydWN0X2V4dF9jb25zdHJ1Y3RvciB0IGluXG4gIG1hdGNoIGZpZWxkc19vcHQgd2l0aFxuICB8IE5vbmUgLT4gY29uc3RydWN0b3JcbiAgfCBTb21lIGYgLT4gY29uc3RydWN0b3IgXiBmXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBzdHJpbmdfb2ZfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIChPYmoucmVwciB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNTgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0RpZ2VzdF9mcm9tX2hleCIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX1N0cmluZyIsImNvbXBhcmUiLCJlcXVhbCIsImNzdF9EaWdlc3Rfc3Vic3RyaW5nIiwiY3N0X0RpZ2VzdF90b19oZXgiLCJzdHJpbmciLCJzdHIiLCJieXRlcyIsImIiLCJzdWJzdHJpbmciLCJvZnMiLCJsZW4iLCJzdWJieXRlcyIsImZpbGUiLCJmaWxlbmFtZSIsImljIiwiZCIsImUiLCJvdXRwdXQiLCJjaGFuIiwiZGlnZXN0IiwiaW5wdXQiLCJjaGFyX2hleCIsIm4iLCJ0b19oZXgiLCJyZXN1bHQiLCJpIiwieCIsImZyb21faGV4IiwicyIsImRpZ2l0IiwiYyIsIlN0ZGxpYl9EaWdlc3QiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2RpZ2VzdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFyQixzQkFBQTtBQUFBLElBQUFBLHdCQUFBO0FBQUEsWUFBQXNCLE9BQUFDO0FBQUFBLElDMEJFLDBEQUF1QztBQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FFcEIsT0FBMEIsT0FBMUIsZ0NBQTBCO0FBQUEsWUFBQUMsVUFBQUgsS0FBQUksS0FBQUM7QUFBQUEsSUFHN0M7QUFBQSxLQUVLLHFDQUF5QjtBQUFBLElBRHpCLGtEQUN5QjtBQUFBO0FBQUEsWUFBQUMsU0FBQUosR0FBQUUsS0FBQUM7QUFBQUEsSUFFRyxPQUEwQixVQUExQiwwQ0FBa0M7QUFBQTtBQUFBLFlBQUFFLEtBQUFDO0FBQUFBLFFBQUFDLEtBRzFEO0FBQUEsSUFDVCxRQUFBQyxJQUFNO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsSUR2Q1I7QUFBQSxLQ3lDcUI7QUFBQSxLQUFXO0FBQUE7QUFBQSxJQURyQjtBQUFBLElBQVc7QUFBQSxHQUNtQjtBQUFBLFlBQUFDLE9BQUFDLE1BQUFDLFFBR3ZDLDJDQUF5QjtBQUFBLFlBQUFDLE1BQUFGLE1BRVYsdUNBQTJCO0FBQUEsWUFBQUcsU0FBQUMsT0FBQSxNQUcxQyxzQ0FBNEU7QUFBQSxZQUFBQyxPQUFBUjtBQUFBQSxJQUc1RTtBQUFBLEtBQThCO0FBQUEsUUFBQVMsU0FDakIsdUJBQUFDLElBQ2I7QUFBQTtBQUFBLFNBQUFDLElBQ29CO0FBQUEsS0FDZ0MseUNBQXBCO0FBQUEsS0FDMEIsbURBQXhCO0FBQUEsZUFBd0I7QUFBQSxrQkFFMUQsMkNBQTZCO0FBQUEsS0FGNkI7QUFBQTtBQUFBLEdBRTdCO0FBQUEsWUFBQUMsU0FBQUM7QUFBQUEsSUFHN0I7QUFBQSxLQUE4QjtBQUFBLGFBQUFDLE1BQUFDO0FBQUFBLEtBRTVCO0FBQUE7QUFBQSxtQkFHYztBQUFBO0FBQUEsc0JBREE7QUFBQTtBQUFBLGdDQURBO0FBQUEsS0FHUDtBQUFBO0FBQUEsSUFBMEM7QUFBQSxRQUFBTixTQUd0Qyx1QkFBQUMsSUFDYjtBQUFBO0FBQUE7QUFBQSxNQUFBQSxNQUNFO0FBQUEsWUFIK0IsTUFBTTtBQUFBLFlBQXBCLENBQU4sTUFBTTtBQUFBLEtBR2pCLGtDQUFtQjtBQUFBLGVBQXlCO0FBQUEsa0JBRTlDLDJDQUE2QjtBQUFBLEtBRmlCO0FBQUE7QUFBQSxHQUVqQjtBQUFBO0FBQUEsSUFBQU07QUFBQUEsTUQzRS9CIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjM3MDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQmlnYXJyYXlfQXJyYXkzX29mX2FycmF5X24iLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2JhX2NyZWF0ZSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfYmFfcmVzaGFwZSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX2JhX3NsaWNlIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tdWwiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9TeXMiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJwYXJhbSIsImNzdF9CaWdhcnJheV9BcnJheTJfb2ZfYXJyYXlfbiIsImNzdF9CaWdhcnJheV9hcnJheTBfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTFfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTJfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTNfb2ZfZ2VuYXJyYSIsImNsb29wIiwiYXJyIiwiaWR4IiwiY29sIiwibWF4IiwiaiIsImZsb29wIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW1zIiwiZGxlbiIsImEiLCJuIiwiZCIsImkiLCJzaXplX2luX2J5dGVzIiwiY3JlYXRlIiwiZ2V0Iiwic2V0Iiwib2ZfdmFsdWUiLCJ2IiwiZGltIiwic2xpY2UiLCJvZl9hcnJheSIsImRhdGEiLCJiYSIsIm9mcyIsImRpbTEiLCJkaW0yIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwicm93IiwiZGltMyIsInNsaWNlX2xlZnRfMSIsIm0iLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsImsiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJTdGRsaWJfQmlnYXJyYXkiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2JpZ2FycmF5Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEeFpGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIGxldCBkbGVuID0gQXJyYXkubGVuZ3RoIGRpbXMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zOyBhcnJcblxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuICBsZXQgaW5pdCA9IG9mX3ZhbHVlXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMSB0byBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0gZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0gZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgZm9yIGsgPSAwIHRvIHByZWQgZGltMyBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgayA9IDEgdG8gZGltMyBkb1xuICAgICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQyMzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2JhX2JsaXQiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9ieXRlc19zZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2x4bV9uZXh0IiwiY2FtbF9tb2QiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJnbG9iYWxfZGF0YSIsInNlcmlhbGl6YXRpb25fcHJlZml4IiwiU3RkbGliX0RvbWFpbiIsIlN0ZGxpYiIsIlN0ZGxpYl9JbnQzMiIsIlN0ZGxpYl9JbnQ2NCIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYl9EaWdlc3QiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9CaWdhcnJheSIsIlN0ZGxpYl9OYXRpdmVpbnQiLCJjcmVhdGUiLCJwYXJhbSIsInNldCIsInMiLCJpMSIsImkyIiwiaTMiLCJpNCIsIm1rIiwic2VyaWFsaXphdGlvbl9wcmVmaXhfbGVuIiwiY3N0X1JhbmRvbV9TdGF0ZV9vZl9iaW5hcnlfc3RyIiwiY3N0X1JhbmRvbV9pbnQiLCJjc3RfUmFuZG9tX2Z1bGxfaW50IiwiY3N0X1JhbmRvbV9pbnQzMiIsInRvX2JpbmFyeV9zdHJpbmciLCJidWYiLCJpIiwib2ZfYmluYXJ5X3N0cmluZyIsImNvcHkiLCJzcmMiLCJkc3QiLCJyZWluaXQiLCJzZWVkIiwibiIsImIiLCJkMSIsImQyIiwibWFrZSIsIm1ha2Vfc2VsZl9pbml0IiwiYml0cyIsImludGF1eCIsInIiLCJ2IiwiaW50IiwiYm91bmQiLCJmdWxsX2ludCIsImJpdHMzMiIsImludDMyIiwiYml0czY0IiwiY3N0X1JhbmRvbV9pbnQ2NCIsImludDY0IiwibmF0aXZlYml0cyIsIm5hdGl2ZWludCIsImZsb2F0IiwiYm9vbCIsInNwbGl0IiwibWtfZGVmYXVsdCIsInJhbmRvbV9rZXkiLCJzY2FsZSIsImZ1bGxfaW5pdCIsImluaXQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJTdGRsaWJfUmFuZG9tIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9yYW5kb20ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJ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Qiw2Q0FBMkI7QUFBQTtBQUFBLFlBQUFvRCxVQUFBbEM7QUFBQUEsUUFBQUMsTUFDMUI7QUFBQSxJQWhLM0IsNkJBZ0t3RDtBQUFBO0FBQUE7QUFBQSxJQUFBa0M7QUFBQUEsTUF6QkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVENU45RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ2FtYml1bSwgQ29sbGVnZSBkZSBGcmFuY2UgYW5kIElucmlhICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKilcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQ6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuXG4gIG9wZW4gQmlnYXJyYXlcblxuICB0eXBlIHQgPSAoaW50NjQsIGludDY0X2VsdCwgY19sYXlvdXQpIEFycmF5MS50XG5cbiAgZXh0ZXJuYWwgbmV4dDogdCAtPiAoaW50NjRbQHVuYm94ZWRdKVxuICAgICAgPSBcImNhbWxfbHhtX25leHRcIiBcImNhbWxfbHhtX25leHRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNyZWF0ZSAoKSA6IHQgPVxuICAgIEFycmF5MS5jcmVhdGUgSW50NjQgQ19sYXlvdXQgNFxuXG4gIGxldCBzZXQgcyBpMSBpMiBpMyBpNCA9XG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAwIChJbnQ2NC5sb2dvciBpMSAxTCk7ICgqIG11c3QgYmUgb2RkICopXG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAxIGkyO1xuICAgIEFycmF5MS51bnNhZmVfc2V0IHMgMiAoaWYgaTMgPD4gMEwgdGhlbiBpMyBlbHNlIDFMKTsgKCogbXVzdCBub3QgYmUgMCAqKVxuICAgIEFycmF5MS51bnNhZmVfc2V0IHMgMyAoaWYgaTQgPD4gMEwgdGhlbiBpNCBlbHNlIDJMKSAoKiBtdXN0IG5vdCBiZSAwICopXG5cbiAgbGV0IG1rIGkxIGkyIGkzIGk0ID1cbiAgICBsZXQgcyA9IGNyZWF0ZSAoKSBpblxuICAgIHNldCBzIGkxIGkyIGkzIGk0OyBzXG5cbiAgbGV0IHNlcmlhbGl6YXRpb25fcHJlZml4ID1cbiAgICBcImx4bTE6XCJcbiAgICAoKiBcImx4bVwiIGRlbm90ZXMgdGhlIGFsZ29yaXRobSBjdXJyZW50bHkgaW4gdXNlLCBhbmQgJzEnIGlzXG4gICAgICAgYSB2ZXJzaW9uIG51bWJlci4gV2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIHByZWZpeCBpZiB3ZSBjaGFuZ2VcbiAgICAgICB0aGUgUmFuZG9tIGFsZ29yaXRobSBvciB0aGUgc2VyaWFsaXphdGlvbiBmb3JtYXQsIHNvIHRoYXQgdXNlcnNcbiAgICAgICBnZXQgYSBjbGVhbiBlcnJvciBpbnN0ZWFkIG9mIGJlbGlldmluZyB0aGF0IHRoZXkgZmFpdGhmdWxseVxuICAgICAgIHJlcHJvZHVjZSB0aGVpciBwcmV2aW91cyBzdGF0ZSBhbmQgaW4gZmFjdCBnZXQgYSBkaWZmZXJyZW50XG4gICAgICAgc3RyZWFtLlxuXG4gICAgICAgTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGNvbnN0cmFpbnQgdG8ga2VlcCB0aGUgc2FtZVxuICAgICAgIFwiPG5hbWU+PHZlcj46PGRhdGE+XCIgZm9ybWF0IG9yIG1lc3NhZ2Ugc2l6ZSBpbiBmdXR1cmUgdmVyc2lvbnMsXG4gICAgICAgd2UgY291bGQgY2hhbmdlIHRoZSBmb3JtYXQgY29tcGxldGVseSBpZiB3ZSB3YW50ZWQgYXMgbG9uZ1xuICAgICAgIGFzIHRoZXJlIGlzIG5vIGNvbmZ1c2lvbiBwb3NzaWJsZSB3aXRoIHRoZSBwcmV2aW91cyBmb3JtYXRzLiAqKVxuXG4gIGxldCBzZXJpYWxpemF0aW9uX3ByZWZpeF9sZW4gPVxuICAgIFN0cmluZy5sZW5ndGggc2VyaWFsaXphdGlvbl9wcmVmaXhcblxuICBsZXQgdG9fYmluYXJ5X3N0cmluZyBzID1cbiAgICBsZXQgcHJlZml4ID0gc2VyaWFsaXphdGlvbl9wcmVmaXggaW5cbiAgICBsZXQgcHJlZmxlbiA9IHNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKHByZWZsZW4gKyA0ICogOCkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyBwcmVmaXggMCBidWYgMCBwcmVmbGVuO1xuICAgIGZvciBpID0gMCB0byAzIGRvXG4gICAgICBCeXRlcy5zZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgaSAqIDgpIChBcnJheTEuZ2V0IHMgaSlcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG5cbiAgbGV0IG9mX2JpbmFyeV9zdHJpbmcgYnVmID1cbiAgICBsZXQgcHJlZml4ID0gc2VyaWFsaXphdGlvbl9wcmVmaXggaW5cbiAgICBsZXQgcHJlZmxlbiA9IHNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiBpblxuICAgIGlmIFN0cmluZy5sZW5ndGggYnVmIDw+IHByZWZsZW4gKyA0ICogOFxuICAgICAgIHx8IG5vdCAoU3RyaW5nLnN0YXJ0c193aXRoIH5wcmVmaXggYnVmKVxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIChcIlJhbmRvbS5TdGF0ZS5vZl9iaW5hcnlfc3RyaW5nOiBleHBlY3RlZCBhIGZvcm1hdCBcXFxuICAgICAgICAgIGNvbXBhdGlibGUgd2l0aCBPQ2FtbCBcIiBeIFN5cy5vY2FtbF92ZXJzaW9uKTtcbiAgICBsZXQgaTEgPSBTdHJpbmcuZ2V0X2ludDY0X2xlIGJ1ZiAocHJlZmxlbiArIDAgKiA4KSBpblxuICAgIGxldCBpMiA9IFN0cmluZy5nZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgMSAqIDgpIGluXG4gICAgbGV0IGkzID0gU3RyaW5nLmdldF9pbnQ2NF9sZSBidWYgKHByZWZsZW4gKyAyICogOCkgaW5cbiAgICBsZXQgaTQgPSBTdHJpbmcuZ2V0X2ludDY0X2xlIGJ1ZiAocHJlZmxlbiArIDMgKiA4KSBpblxuICAgIG1rIGkxIGkyIGkzIGk0XG5cbiAgbGV0IGFzc2lnbiAoZHN0OiB0KSAoc3JjOiB0KSA9XG4gICAgQXJyYXkxLmJsaXQgc3JjIGRzdFxuXG4gIGxldCBjb3B5IHMgPVxuICAgIGxldCBzJyA9IGNyZWF0ZSgpIGluIGFzc2lnbiBzJyBzOyBzJ1xuXG4gICgqIFRoZSBzZWVkIGlzIGFuIGFycmF5IG9mIGludGVnZXJzLiAgSXQgY2FuIGJlIGp1c3Qgb25lIGludGVnZXIsXG4gICAgIGJ1dCBpdCBjYW4gYWxzbyBiZSAxMiBvciBtb3JlIGJ5dGVzLiAgVG8gaGlkZSB0aGUgZGlmZmVyZW5jZSxcbiAgICAgd2Ugc2VyaWFsaXplIHRoZSBhcnJheSBhcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLCB0aGVuIGhhc2ggdGhlXG4gICAgIHNlcXVlbmNlIHdpdGggTUQ1IChEaWdlc3QuYnl0ZXMpLiAgTUQ1IGdpdmVzIG9ubHkgMTI4IGJpdHMgd2hpbGVcbiAgICAgd2UgbmVlZCAyNTYgYml0cywgc28gd2UgaGFzaCB0d2ljZSB3aXRoIGRpZmZlcmVudCBzdWZmaXhlcy4gKilcbiAgbGV0IHJlaW5pdCBzIHNlZWQgPVxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBsZXQgYiA9IEJ5dGVzLmNyZWF0ZSAobiAqIDggKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgIEJ5dGVzLnNldF9pbnQ2NF9sZSBiIChpICogOCkgKEludDY0Lm9mX2ludCBzZWVkLihpKSlcbiAgICBkb25lO1xuICAgIEJ5dGVzLnNldCBiIChuICogOCkgJ1xceDAxJztcbiAgICBsZXQgZDEgPSBEaWdlc3QuYnl0ZXMgYiBpblxuICAgIEJ5dGVzLnNldCBiIChuICogOCkgJ1xceDAyJztcbiAgICBsZXQgZDIgPSBEaWdlc3QuYnl0ZXMgYiBpblxuICAgIHNldCBzIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQxIDApXG4gICAgICAgICAgKFN0cmluZy5nZXRfaW50NjRfbGUgZDEgOClcbiAgICAgICAgICAoU3RyaW5nLmdldF9pbnQ2NF9sZSBkMiAwKVxuICAgICAgICAgIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQyIDgpXG5cbiAgbGV0IG1ha2Ugc2VlZCA9XG4gICAgbGV0IHMgPSBjcmVhdGUoKSBpbiByZWluaXQgcyBzZWVkOyBzXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID1cbiAgICBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICAoKiBSZXR1cm4gMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIEludDY0LnRvX2ludCAobmV4dCBzKSBsYW5kIDB4M0ZGRl9GRkZGXG5cbiAgKCogUmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKSAqKVxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG4gICgqIFJldHVybiBhbiBpbnRlZ2VyIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuXG4gICAgIFtib3VuZF0gbWF5IGJlIGFueSBwb3NpdGl2ZSBbaW50XS4gKilcbiAgbGV0IHJlYyBpbnQ2M2F1eCBzIG4gPVxuICAgIGxldCByID0gSW50NjQudG9faW50IChuZXh0IHMpIGxhbmQgbWF4X2ludCBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gbWF4X2ludCAtIG4gKyAxIHRoZW4gaW50NjNhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBmdWxsX2ludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiUmFuZG9tLmZ1bGxfaW50XCJcbiAgICBlbHNlIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB0aGVuXG4gICAgICBpbnQ2M2F1eCBzIGJvdW5kXG4gICAgZWxzZVxuICAgICAgaW50YXV4IHMgYm91bmRcblxuICAoKiBSZXR1cm4gMzIgcmFuZG9tIGJpdHMgYXMgYW4gW2ludDMyXSAqKVxuICBsZXQgYml0czMyIHMgPVxuICAgIEludDY0LnRvX2ludDMyIChuZXh0IHMpXG5cbiAgKCogUmV0dXJuIGFuIFtpbnQzMl0gYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCByID0gSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCAoYml0czMyIHMpIDEgaW5cbiAgICBsZXQgdiA9IEludDMyLnJlbSByIG4gaW5cbiAgICBpZiBJbnQzMi4oc3ViIHIgdiA+IGFkZCAoc3ViIG1heF9pbnQgbikgMWwpXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuICAoKiBSZXR1cm4gNjQgcmFuZG9tIGJpdHMgYXMgYW4gW2ludDY0XSAqKVxuICBsZXQgYml0czY0IHMgPVxuICAgIG5leHQgc1xuXG4gICgqIFJldHVybiBhbiBbaW50NjRdIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgciA9IEludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJpdHM2NCBzKSAxIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgaWYgSW50NjQuKHN1YiByIHYgPiBhZGQgKHN1YiBtYXhfaW50IG4pIDFMKVxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cbiAgKCogUmV0dXJuIDMyIG9yIDY0IHJhbmRvbSBiaXRzIGFzIGEgW25hdGl2ZWludF0gKilcbiAgbGV0IG5hdGl2ZWJpdHMgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoYml0czMyIHMpXG4gICAgZWxzZSBmdW4gcyAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGJpdHM2NCBzKVxuXG4gICgqIFJldHVybiBhIFtuYXRpdmVpbnRdIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuICopXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuICAoKiBSZXR1cm4gYSBmbG9hdCAwIDwgeCA8IDEgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIGFtb25nIHRoZVxuICAgICBtdWx0aXBsZXMgb2YgMl4tNTMgKilcbiAgbGV0IHJlYyByYXdmbG9hdCBzID1cbiAgICBsZXQgYiA9IG5leHQgcyBpblxuICAgIGxldCBuID0gSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCBiIDExIGluXG4gICAgaWYgbiA8PiAwTCB0aGVuIEludDY0LnRvX2Zsb2F0IG4gKi4gMHgxLnAtNTMgZWxzZSByYXdmbG9hdCBzXG5cbiAgKCogUmV0dXJuIGEgZmxvYXQgYmV0d2VlbiAwIGFuZCBbYm91bmRdICopXG4gIGxldCBmbG9hdCBzIGJvdW5kID0gcmF3ZmxvYXQgcyAqLiBib3VuZFxuXG4gICgqIFJldHVybiBhIHJhbmRvbSBCb29sZWFuICopXG4gIGxldCBib29sIHMgPSBuZXh0IHMgPCAwTFxuXG4gICgqIFNwbGl0IGEgbmV3IFBSTkcgb2ZmIHRoZSBnaXZlbiBQUk5HICopXG4gIGxldCBzcGxpdCBzID1cbiAgICBsZXQgaTEgPSBiaXRzNjQgcyBpbiBsZXQgaTIgPSBiaXRzNjQgcyBpblxuICAgIGxldCBpMyA9IGJpdHM2NCBzIGluIGxldCBpNCA9IGJpdHM2NCBzIGluXG4gICAgbWsgaTEgaTIgaTMgaTRcbmVuZFxuXG5sZXQgbWtfZGVmYXVsdCAoKSA9XG4gICgqIFRoaXMgaXMgdGhlIHN0YXRlIG9idGFpbmVkIHdpdGggW1N0YXRlLm1ha2UgW3wgMzE0MTU5MjY1IHxdXS4gKilcbiAgU3RhdGUubWsgKC02MTk2ODc0Mjg5NTY3NzA1MDk3TClcbiAgICAgICAgICAgNTg2NTczMjQ5ODMzNzEzMTg5TFxuICAgICAgICAgICAoLTg1OTEyNjg4MDM4NjUwNDM0MDdMKVxuICAgICAgICAgICA2Mzg4NjEzNTk1ODQ5NzcyMDQ0TFxuXG5sZXQgcmFuZG9tX2tleSA9XG4gIERvbWFpbi5ETFMubmV3X2tleSB+c3BsaXRfZnJvbV9wYXJlbnQ6U3RhdGUuc3BsaXQgbWtfZGVmYXVsdFxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgaW50IGJvdW5kID0gU3RhdGUuaW50IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IGZ1bGxfaW50IGJvdW5kID0gU3RhdGUuZnVsbF9pbnQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBuYXRpdmVpbnQgYm91bmQgPSBTdGF0ZS5uYXRpdmVpbnQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KVxubGV0IGJpdHMzMiAoKSA9IFN0YXRlLmJpdHMzMiAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgbmF0aXZlYml0cyAoKSA9IFN0YXRlLm5hdGl2ZWJpdHMgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLnJlaW5pdCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgc2VlZFxubGV0IGluaXQgc2VlZCA9IGZ1bGxfaW5pdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBTcGxpdHRpbmcgKilcblxubGV0IHNwbGl0ICgpID0gU3RhdGUuc3BsaXQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIHNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU1OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2hhc2giLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfc3lzX2dldGVudiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJTdGRsaWJfU3lzIiwiU3RkbGliIiwiU3RkbGliX0F0b21pYyIsIlN0ZGxpYl9Eb21haW4iLCJTdGRsaWJfUmFuZG9tIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9JbnQiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfU3RyaW5nIiwib25nb2luZ190cmF2ZXJzYWwiLCJoIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsImNzdF9IYXNodGJsX3Vuc3VwcG9ydGVkX2hhc2hfdCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJwYXJhbSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nX2tleSIsInBvd2VyXzJfYWJvdmUiLCJ4IiwibiIsImNyZWF0ZSIsIm9wdCIsImluaXRpYWxfc2l6ZSIsInN0aCIsInJhbmRvbSIsInMiLCJzZWVkIiwiY2xlYXIiLCJyZXNldCIsImxlbiIsImNvcHlfYnVja2V0bGlzdCIsImtleSIsImRhdGEiLCJuZXh0IiwicHJlYyIsImNvcHkiLCJsZW5ndGgiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiaSIsImNlbGwiLCJuaWR4IiwibWF0Y2giLCJyZXNpemUiLCJvc2l6ZSIsIml0ZXIiLCJvbGRfdHJhdiIsImQiLCJleG4iLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJzbG90IiwiZm9sZCIsImluaXQiLCJhY2N1IiwiYiIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsIm0iLCJoaXN0byIsImwiLCJ0b19zZXEiLCJ0YmwiLCJ0YmxfZGF0YSIsImF1eCIsImJ1Y2siLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJNYWtlU2VlZGVkIiwiSCIsImtleV9pbmRleCIsImFkZCIsImJ1Y2tldCIsInJlbW92ZSIsImMiLCJrIiwiZmluZCIsImsxIiwiZDEiLCJuZXh0MSIsImsyIiwiZDIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfb3B0IiwiZmluZF9hbGwiLCJibG9jayIsImRzdCIsIm9mZnNldCIsInJlcGxhY2UiLCJtZW0iLCJhZGRfc2VxIiwidiIsInJlcGxhY2Vfc2VxIiwib2Zfc2VxIiwiTWFrZSIsImVxdWFsIiwic2VlZGVkX2hhc2giLCJpbmNsdWRlIiwic3oiLCJoYXNoIiwiaGFzaF9wYXJhbSIsIm4xIiwibjIiLCJyZWJ1aWxkIiwiU3RkbGliX0hhc2h0YmwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vbGliL29jYW1sL2hhc2h0YmwubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUE7QUFBQSxPQUFBQyxnQkFBQTtBQUFBLFlBQUFDLGtCQUFBQztBQUFBQSxRQUFBLE9Dd0NFO0FBQUE7QUFBQSxHQUNxQjtBQUFBLFlBQUFDLHVCQUFBRCxHQUdyQiw0QkFBa0M7QUFBQTtBQUFBLElBQUFFLGlDRDVDcEM7QUFBQSxpQkNrRFEsa0NBQUFDLFNBQUE7QUFBQTtBQUFBLGNEbERSO0FBQUE7QUFBQSxJQ21ESSxjQUFJO0FBQUE7QUFBQSxlRG5EUjtBQUFBO0FBQUEsZUNtRG9EO0FBQUE7QUFBQSxRQUFBQSxTQUFoRDtBQUFB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEM0Q3RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIHRoZSBsb2FkIGZhY3RvciBiZWNvbWVzIHRvbyBoaWdoLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSBBdG9taWMubWFrZSByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IEF0b21pYy5zZXQgcmFuZG9taXplZCB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9IEF0b21pYy5nZXQgcmFuZG9taXplZFxuXG5sZXQgcHJuZ19rZXkgPSBEb21haW4uRExTLm5ld19rZXkgUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChEb21haW4uRExTLmdldCBwcm5nX2tleSkgZWxzZSAwXG4gIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBpZiBoLnNpemUgPiAwIHRoZW4gYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBBcnJheS5maWxsIGguZGF0YSAwIChBcnJheS5sZW5ndGggaC5kYXRhKSBFbXB0eVxuICBlbmRcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IGluc2VydF9hbGxfYnVja2V0cyBpbmRleGZ1biBpbnBsYWNlIG9kYXRhIG5kYXRhID1cbiAgbGV0IG5zaXplID0gQXJyYXkubGVuZ3RoIG5kYXRhIGluXG4gIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGtleSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9kYXRhIC0gMSBkb1xuICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gIGRvbmU7XG4gIGlmIGlucGxhY2UgdGhlblxuICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgIGRvbmVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgaW5zZXJ0X2FsbF9idWNrZXRzIChpbmRleGZ1biBoKSBpbnBsYWNlIG9kYXRhIG5kYXRhXG4gIGVuZFxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzZWVkZWRfaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IGtleSBuZXh0XG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIG1lbV9pbl9idWNrZXQga2V5IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgcmVjIG1lbV9pbl9idWNrZXQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBrZXkgbmV4dFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbWVtX2luX2J1Y2tldCBrZXkgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxubGV0IHJlYnVpbGQgPyhyYW5kb20gPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWQpIGggPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIGluXG4gIGxldCBzZWVkID1cbiAgICBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoRG9tYWluLkRMUy5nZXQgcHJuZ19rZXkpXG4gICAgZWxzZSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguc2VlZFxuICAgIGVsc2UgMCBpblxuICBsZXQgaCcgPSB7XG4gICAgc2l6ZSA9IGguc2l6ZTtcbiAgICBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5O1xuICAgIHNlZWQgPSBzZWVkO1xuICAgIGluaXRpYWxfc2l6ZSA9IGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5pbml0aWFsX3NpemUgZWxzZSBzXG4gIH0gaW5cbiAgaW5zZXJ0X2FsbF9idWNrZXRzIChrZXlfaW5kZXggaCcpIGZhbHNlIGguZGF0YSBoJy5kYXRhO1xuICBoJ1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfUXVldWUiLCJDYW1saW50ZXJuYWxGb3JtYXQiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0RvbWFpbiIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfU2VxIiwiU3RkbGliX0FycmF5IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfU3RhY2siLCJTdGRsaWJfSW50IiwiU3RkbGliX0J5dGVzIiwiaWQiLCJ4IiwiemVybyIsInVua25vd24iLCJTdHJpbmdfdGFnIiwicHBfZW5xdWV1ZSIsInN0YXRlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsImNzdF9Gb3JtYXRfcHBfc2V0X2dlb21ldHJ5IiwicHBfb3V0cHV0X3N0cmluZyIsInMiLCJwcF9vdXRwdXRfbmV3bGluZSIsImZvcm1hdF9wcF90ZXh0Iiwic2l6ZSIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJwYXJhbSIsIndpZHRoIiwiYWZ0ZXIiLCJvZmZzZXQiLCJiZWZvcmUiLCJpbmRlbnQiLCJyZWFsX2luZGVudCIsIm4iLCJicmVha19zYW1lX2xpbmUiLCJmb3JtYXRfcHBfdG9rZW4iLCJtYXRjaCIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJsIiwibGVuZ3RoIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUiLCJpbnNlcnRpb25fcG9pbnQiLCJmaXJzdCIsInRhaWwiLCJoZWFkIiwidGFiIiwidHkiLCJ0Ym94IiwiYWR2YW5jZV9sZWZ0IiwicGVuZGluZ19jb3VudCIsImVucXVldWVfYWR2YW5jZSIsInRvayIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwiYiIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJlbmRfd2l0aF9uZXdsaW5lIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9ieXRlcyIsInBwX3ByaW50X2ludCIsImkiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwiYyIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInZhbGlkYXRlX2dlb21ldHJ5IiwibWFyZ2luIiwibWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Z1bGxfZ2VvbWV0cnkiLCJwcF9zZXRfZ2VvbWV0cnkiLCJtc2ciLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3VwZGF0ZV9nZW9tZXRyeSIsInVwZGF0ZSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImoiLCJoIiwiZyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2JsYW5rcyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJvYyIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInNjYW5fc3RhY2siLCJwcF9tYXJnaW4iLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJvdXRwdXQiLCJmbHVzaCIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwic3RkYnVmX2tleSIsInN0cl9mb3JtYXR0ZXJfa2V5IiwiYnVmZmVyZWRfb3V0X3N0cmluZyIsImtleSIsInN0ciIsIm9mcyIsImxlbiIsImJ1ZmZlcmVkX291dF9mbHVzaCIsImJ1ZiIsInN0ZF9idWZfa2V5IiwiZXJyX2J1Zl9rZXkiLCJzdGRfZm9ybWF0dGVyX2tleSIsImVycl9mb3JtYXR0ZXJfa2V5IiwiZ2V0X3N0ZF9mb3JtYXR0ZXIiLCJnZXRfZXJyX2Zvcm1hdHRlciIsImdldF9zdHJfZm9ybWF0dGVyIiwiZ2V0X3N0ZGJ1ZiIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIiwic3luY2hyb25pemVkX2Zvcm1hdHRlcl9vZl9vdXRfIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsInYiLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInciLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfY2hhciIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfbmV3bGluZSIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2l0ZXIiLCJvcHQiLCJpdGVyIiwicHBfdiIsInN0aCIsInBwX3NlcCIsImlzX2ZpcnN0IiwicHBfcHJpbnRfbGlzdCIsInBwX3ByaW50X2FycmF5IiwicHBfcHJpbnRfc2VxIiwic2VxIiwicHBfcHJpbnRfdGV4dCIsImxlZnQiLCJyaWdodCIsInBwX3ByaW50X29wdGlvbiIsIm5vbmUiLCJwcF9wcmludF9yZXN1bHQiLCJvayIsImVycm9yIiwiZSIsInBwX3ByaW50X2VpdGhlciIsInIiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJmbXRpbmdfbGl0Iiwib3V0cHV0X2FjYyIsImFjYyIsInAiLCJidHkiLCJzdHJwdXRfYWNjIiwia2ZwcmludGYiLCJrIiwiZm10IiwiaWtmcHJpbnRmIiwiaWZwcmludGYiLCJmcHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtkcHJpbnRmIiwiZHByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsImZzIiwiU3RkbGliX0Zvcm1hdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvZm9ybWF0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWIsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBO0FBQUEsSUFBQWMsZUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLEdBQUFDLEdDc0JXLFNBQUM7QUFBQTtBQUFBLElBQUFDLE9EdEJaO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxXQUFBQyxPQUFBQztBQUFBQSxJQzBORTtBQUFBLElBQ0Esb0RBQThCO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNEM05oQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxZQUFBQyxpQkFBQUosT0FBQUs7QUFBQUEsSUMwUCtCLDREQUF5QztBQUFBO0FBQUEsWUFBQUMsa0JBQUFOLE9BQzFDLCtCQUF1QjtBQUFBLFlBQUFPLGVBQUFQLE9BQUFRLE1BQUFDO0FBQUFBLElBTW5EO0FBQUEsSUFDQTtBQUFBLElBQTJCO0FBQUEsR0FDRTtBQUFBLFlBQUFDLGNBQUFWLE9BQUFLO0FBQUFBLFFBQUEsT0FJMUI7QUFBQSxJQUFPLGNBQU0seURBQXdDO0FBQUE7QUFBQSxZQUFBTSxlQUFBWCxPQUFBWSxPQUFBQztBQUFBQSxRQUFBQyxRQUd2QyxVQUFBQyxTQUFBLFVBQUFDLFNBQUE7QUFBQSxJQUNqQjtBQUFBLElBQ0E7QUFBQSxJQUF1QjtBQUFBO0FBQUEsS0FBQUMsU0FFdkI7QUFBQSxLQUFBQyxjQUVrQjtBQUFBLElBQ2xCO0FBQUEsSUFDQTtBQUFBLFFBQUFDLElBQ0E7QUFBQSxJQXRCNkI7QUFBQSxJQXNCaUIsa0NBQ3JCO0FBQUE7QUFBQSxZQUFBQyxnQkFBQXBCLE9BQUFZO0FBQUFBLFFBQUFFLFFBT1AsVUFBQUQsUUFBQSxVQUFBRyxTQUFBO0FBQUEsSUFDbEI7QUFBQSxJQUEwQjtBQUFBLElBaENHO0FBQUEsSUFrQ0Qsa0NBQ0g7QUFBQTtBQUFBLFlBQUFLLGdCQUFBckIsT0FBQVEsUUFBQUk7QUFBQUEsSUFnQ1A7QUFBQTtBQUFBO0FBQUEsWUFBQVUsVUE0Qko7QUFBQSxRQUFpQyxjQUNuQztBQUFBO0FBQUEsU0FBQUMsT0FEbUM7QUFBQSxTQUFBQztBQUFBQSxXQUczQyxTQUFBTCxHQUFBTTtBQUFBQSxZQUFnQixTQUNOO0FBQUEsZ0JBQUFDLElBRE0sT0FBQS9CLElBQUE7QUFBQSxZQUVPO0FBQUE7QUFBQSw2QkFBNkIsY0FBVztBQUFBO0FBQUEsUUFDdkQ7QUFBQSxRQUFxRDtBQUFBO0FBQUEsUUFmL0QsdUNBQW1DO0FBQUE7QUFBQSxRQU1uQyx1Q0FBaUM7QUFBQTtBQUFBLFlBQUEyQixVQWlDckI7QUFBQSxRQUFtQyxjQUNyQywrQkE2Q047QUFBQSxZQUFBVCxVQTlDMkM7QUFBQSxRQWpHdEIsMENBK0lyQjtBQUFBO0FBQUEsbUJBeENKO0FBQUE7QUFBQSxZQUFBUyxVQTlFSTtBQUFBLFFBQTZCLGNBQ3pCO0FBQUEsWUFBQUEsVUFEeUIsWUFBQWQsT0FBQSxZQUFBbUIsU0FBQTtBQUFBLFFBR2pDO0FBQUEsUUFDNkQ7QUFBQTtBQUFBO0FBQUEsWUFBQUwsVUE2R2hEO0FBQUEsUUFBaUMsY0FDbkM7QUFBQSxZQUFBTSxXQURtQyxZQUFBQyxTQUc5QjtBQUFBLFFBQ2Isc0NBQ0M7QUFBQTtBQUFBLElBeEdZO0FBQUE7QUFBQSxXQUFBeEIsSUFBQSxVQUdoQix1Q0FxR0k7QUFBQTtBQUFBO0FBQUEsUUFBQXlCLFNBeEdZO0FBQUEsUUFBQUMsT0FBQTtBQUFBLFFBQUFDLE1Bb0VoQjtBQUFBLFFBQUFoQixTQUFBO0FBQUEsUUFBQU0sVUFDWTtBQUFBLE9BQW1DLGNBQ3JDO0FBQUE7QUFBQSxRQUFBQSxVQURxQztBQUFBLFFBQUFULFVBQUE7QUFBQSxRQUFBb0IsYUFBQTtBQUFBLE9BRzdDO0FBQUE7QUFBQSxVQWlCYSxtQ0FlWDtBQUFBO0FBQUEsVUFoQlcsNkNBZ0JYO0FBQUE7QUFBQSxVQWxCWSw2Q0FrQlo7QUFBQTtBQUFBLFVBOUJBO0FBQUEsb0JBQ0s7QUFBQSxvQkFDQSw0QkE0Qkw7QUFBQTtBQUFBLFVBekJBO0FBQUEsb0JBQTZCO0FBQUE7QUFBQTtBQUFBLGdDQUM3QjtBQUFBLHNCQUNPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3QkFHRjtBQUFBLHdCQUNBLDRCQW1CTDtBQUFBLGtCQWpCVyxtQ0FpQlg7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFBRCxRQXhHWTtBQUFBLFFBQUFiLElBQUE7QUFBQSxRQUFBZSxrQkFzQ2hCO0FBQUEsUUFBQVosVUFDWTtBQUFBLE9BQWlDLGNBQ25DO0FBQUEsV0FBQUMsU0FEbUMsZUFBQUQsVUFHM0M7QUFBQTtBQUFBLFlBQUFhLFFBQUEsWUFBQXZCLFVBUUk7QUFBQTtBQUFBLFNBSmU7QUFBQSxjQUFBd0IsT0FBQSxZQUFBQyxPQUFBO0FBQUEsVUFFWCwyQkFBMEM7QUFBQSxxQkFBVjtBQUFBO0FBQUE7QUFBQSxxQkFDMUI7QUFBQSxhQUFBQyxNQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQSxNQU5KO0FBQUEsV0FBQXZCLFNBT1Y7QUFBQSxPQUNBO0FBQUEsaUJBQ0s7QUFBQSxpQkFDQTtBQUFBLHNFQWtESDtBQUFBO0FBQUE7QUFBQSxRQUFBd0IsS0F4R1k7QUFBQSxRQUFBUCxRQUFBO0FBQUEsUUFBQUUsb0JBTWhCO0FBQUEsT0FDQTtBQUFBLFlBQUFaLFFBaENJO0FBQUEsUUFBbUM7QUFBQSxhQUFBQSxVQUFBLFVBQUFULFFBQUEsWUFBQW9CLFdBQUE7QUFBQSxTQUd2QztBQUFBLFVBakJ5QjtBQUFBO0FBQUE7QUFBQSxTQWVqQjtBQUFBO0FBQUE7QUFBQSxRQUFBcEIsVUFrQ1I7QUFBQSxRQUFBb0IsYUFDQTtBQUFBLE9BS0Esc0VBd0ZJO0FBQUE7QUFBQSxXQUFBTyxPQXhHWTtBQUFBLE9Bc0JoQixrREFrRkk7QUFBQTtBQUFBO0FBQUEsUUFBQVosYUF4R1k7QUFBQSxRQUFBQyxXQThGRjtBQUFBLE9BQ2I7QUFBQSxPQUE2Qix3REFTMUI7QUFBQTtBQUFBO0FBQUEsWUFBQVksYUFBQXpDO0FBQUFBLElBT047QUFBQSxTQUFBc0IsUUFBTTtBQUFBLEtBQTZCLFlBQ3pCO0FBQUE7QUFBQSxNQUFBQSxVQUR5QjtBQUFBLE1BQUFkLE9BQUE7QUFBQSxNQUFBbUIsU0FBQTtBQUFBLE1BQUExQixRQUFBO0FBQUEsTUFBQXlDLGdCQUdqQztBQUFBLGFBeFllO0FBQUEsYUF5WU07QUFBQTtBQUFBLEtBQ25CO0FBQUEsU0FBQWxDLFNBQ2dDO0FBQUEsS0FDaEM7QUFBQSxLQUFnQztBQUFBO0FBQUEsR0FHL0I7QUFBQSxZQUFBbUMsZ0JBQUEzQyxPQUFBNEM7QUFBQUEsSUFJeUI7QUFBQSxJQUFvQiwwQkFBb0I7QUFBQTtBQUFBLFlBQUFDLGtCQUFBN0MsT0FBQVEsTUFBQUg7QUFBQUEsSUFLSSxzREFBRTtBQUFBO0FBQUEsWUFBQXlDLHNCQUFBQztBQUFBQSxJQVk1RTtBQUFBLFFBQUFDLGFBQWlCO0FBQUEsSUFFakIsOERBQWdEO0FBQUE7QUFBQSxZQUFBQyxTQUFBakQsT0FBQXVDO0FBQUFBLFFBQUFqQixRQVkxQztBQUFBLElBQWlDLFlBQzdCO0FBQUE7QUFBQSxLQUFBQSxVQUQ2QjtBQUFBLEtBQUEwQixhQUFBO0FBQUEsS0FBQUUsYUFBQTtBQUFBLEtBQUExQyxPQUdyQztBQUFBLElBRUEsMkJBQ0Usc0NBZUk7QUFBQSxlQWJKO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPRTtBQUFBLGFBQUFiLE1BQWU7QUFBQSxTQUMrQztBQUFBLFNBQzVEO0FBQUE7QUFBQSxRQUZGO0FBQUE7QUFBQTtBQUFBLFFBTEE7QUFBQSxhQUFBQSxJQUFXO0FBQUEsU0FDbUQ7QUFBQSxTQUM1RDtBQUFBO0FBQUEsUUFGRjtBQUFBO0FBQUEsR0FXRTtBQUFBLFlBQUF3RCxVQUFBbkQsT0FBQW9ELEdBQUFuRDtBQUFBQSxJQU1SO0FBQUEsSUFBc0IsTUFDWjtBQUFBLFFBQUFvRCxPQUNWO0FBQUEsSUFDQSxrREFBbUM7QUFBQTtBQUFBLFlBQUFDLGdCQUFBdEQsT0FBQWlCLFFBQUFzQztBQUFBQSxJQU9uQztBQUFBLElBQ0E7QUFBQSxTQUFBL0MsT0FDRSxpQkFBQTZDLE9BQ0E7QUFBQSxLQUNBLGdDQUV5QztBQUFBO0FBQUEsZUFEM0M7QUFBQTtBQUFBLFFBQUFoRCxJQUNLLFdBQUFWLElBakVMO0FBQUEsSUFBdUQscUNBaUVaO0FBQUE7QUFBQSxZQUFBNkQsYUFBQXhELE9BQUFZO0FBQUFBLFFBQUEsT0FRM0M7QUFBQTtBQUFBLEtBQ0E7QUFBQSxNQUdJO0FBQUEsTUFDQTtBQUFBLE1BQXFCO0FBQUE7QUFBQSxLQUV2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQVBGO0FBQUE7QUFBQSxHQVFHO0FBQUEsWUFBQTZDLGFBQUF6RCxPQUFBNEI7QUFBQUEsSUFLSDtBQUFBLEtBRUU7QUFBQSxLQUNBO0FBQUE7QUFBQSxlQUVGO0FBQUE7QUFBQSxRQUFBM0IsUUFDRTtBQUFBLElBQ0EsNkNBQXdEO0FBQUE7QUFBQSxZQUFBeUQsY0FBQTFELE9BQUFZO0FBQUFBLElBSzFELGNBQ0U7QUFBQSxlQUNGO0FBQUE7QUFBQSxTQUFBVSxRQUNRO0FBQUEsS0FBZ0M7QUFBQSxVQUFBTSxXQUFBO0FBQUEsTUFHcEMsc0NBQWlDO0FBQUE7QUFBQSxnQkFGekI7QUFBQTtBQUFBO0FBQUEsZ0JBRlo7QUFBQTtBQUFBLEdBSXFDO0FBQUEsWUFBQStCLGtCQUFBM0QsT0FBQW9ELEdBRVAsd0JBQXdCO0FBQUEsWUFBQVEsaUJBQUE1RCxPQUFBb0QsR0FDekIsd0JBQXVCO0FBQUEsWUFBQVMsa0JBQUE3RCxPQUFBWSxPQUNyQixpQkFBbUI7QUFBQSxZQUFBa0QsaUJBQUE5RCxPQUFBWSxPQUNwQixpQkFBa0I7QUFBQSxZQUFBbUQsWUFBQS9ELE9BQUFvRDtBQUFBQSxJQUVoRDtBQUFBLElBQXlCLGlDQUEwQjtBQUFBO0FBQUEsWUFBQVksK0JBQUFoRSxPQUFBWTtBQUFBQSxJQUlOO0FBQUEsR0FLOUM7QUFBQSxZQUFBcUQsK0JBQUFqRSxPQUFBWTtBQUFBQSxRQUFBc0QsTUFHbUMsVUFBQUMsTUFBQSxVQUFBQyxNQUFBLFVBQUFDLE1BQUE7QUFBQSxJQU1sQztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUEsR0FBK0I7QUFBQSxZQUFBQyxTQUFBdEU7QUFBQUEsSUExVy9CO0FBQUEsSUFBMEI7QUFBQSxJQUMxQjtBQUFBLElBK1dBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQStCO0FBQUEsSUFFL0I7QUFBQSxJQUNBO0FBQUEsSUE1RTBCLG1DQTZFTDtBQUFBO0FBQUEsWUFBQXVFLGVBQUF2RSxPQUFBd0U7QUFBQUEsSUFHckI7QUFBQTtBQUFBLGVBQUE1RCxPQUFxQiw4QkFBc0I7QUFBQTtBQUFBLElBS3RCO0FBQUE7QUFBQSxNQUlyQjtBQUFBLE1BQ0E7QUFBQSxNQUFrQixxQkFDTztBQUFBLE1BQ3pCLHNCQUFjO0FBQUE7QUFBQSxLQUxaO0FBQUE7QUFBQSxHQUtZO0FBQUEsWUFBQTZELGlCQUFBekUsT0FBQVEsTUFBQUg7QUFBQUEsUUFBQSxPQVVkO0FBQUEsa0JBQ0ssd0NBQThCO0FBQUE7QUFBQSxZQUFBcUUsWUFBQTFFLE9BQUEyRSxPQUFBdEU7QUFBQUEsSUFJTyx3Q0FBRTtBQUFBO0FBQUEsWUFBQXVFLGdCQUFBNUUsT0FBQUs7QUFBQUEsUUFBQXNFLFFBSTVDO0FBQUEsSUFKMEMsd0NBSUw7QUFBQTtBQUFBLFlBQUFFLGVBQUE3RSxPQUFBSztBQUFBQTtBQUFBQSxLQUFBQSxNQUdGO0FBQUEsS0FBQXNFLFFBQW1CO0FBQUEsSUFQWiwwQ0FPWTtBQUFBO0FBQUEsWUFBQUcsYUFBQTlFLE9BQUErRTtBQUFBQSxJQUdQLE9BQWlCLHVCQUFqQiw4QkFBaUI7QUFBQTtBQUFBLFlBQUFDLGVBQUFoRixPQUFBNUI7QUFBQUEsSUFHZixPQUFtQix1QkFBbkIsMEJBQW1CO0FBQUE7QUFBQSxZQUFBNkcsY0FBQWpGLE9BQUFvRDtBQUFBQSxJQUdwQixPQUFrQix1QkFBbEIsMEJBQWtCO0FBQUE7QUFBQSxZQUFBOEIsY0FBQWxGLE9BQUFtRjtBQUFBQSxRQUFBOUUsSUFJOUM7QUFBQSxJQXBCc0Isb0NBb0JMO0FBQUE7QUFBQSxZQUFBK0UsYUFBQXBGLE9BQUFZLE9BSVgsbUNBQStCO0FBQUEsWUFBQXlFLGFBQUFyRixPQUFBaUI7QUFBQUEsSUFDM0Isd0NBQW9DO0FBQUE7QUFBQSxZQUFBcUUsY0FBQXRGLE9BQUFpQjtBQUFBQSxJQUVuQyx3Q0FBcUM7QUFBQTtBQUFBLFlBQUFzRSxlQUFBdkYsT0FBQWlCO0FBQUFBLElBQ3BDLHdDQUFzQztBQUFBO0FBQUEsWUFBQXVFLFlBQUF4RixPQUFBaUI7QUFBQUEsSUFDekMsd0NBQW1DO0FBQUE7QUFBQSxZQUFBd0UsaUJBQUF6RixPQUFBWTtBQUFBQSxJQVloRTtBQUFBLElBQTJDLCtCQUF1QjtBQUFBO0FBQUEsWUFBQThFLGVBQUExRixPQUFBWTtBQUFBQSxJQUVsRTtBQUFBLElBQTRDLCtCQUF1QjtBQUFBO0FBQUEsWUFBQStFLGlCQUFBM0YsT0FBQVk7QUFBQUEsUUFBQSxPQUtuRTtBQUFBLGtCQUNFLDhDQUEwRTtBQUFBO0FBQUEsWUFBQWdGLG9CQUFBNUYsT0FBQVk7QUFBQUEsUUFBQSxPQUs1RTtBQUFBLGtCQUNFLDhDQUN5RDtBQUFBO0FBQUEsWUFBQWlGLHNCQUFBN0YsT0FBQStCLE1BQUFEO0FBQUFBO0FBQUFBLEtBQUFoQixRQU0zRDtBQUFBLEtBQUFELFFBQUE7QUFBQSxLQUFBRyxTQUFBO0FBQUEsWUFDQTtBQUFBO0FBQUE7QUFBQSxLQUFBUixPQUNFO0FBQUEsS0FBQVAsUUFDQTtBQUFBLEtBQUEwQjtBQUFBQSxPQUNBO0FBQUE7QUFBQTtBQUFBLEtBQUEwQixPQUNBO0FBQUEsSUFDQSxnQ0FBeUI7QUFBQTtBQUFBLFlBQUF5QyxlQUFBOUYsT0FBQWEsT0FBQUU7QUFBQUEsSUFPM0I7QUFBQSx3RUFDZ0Q7QUFBQTtBQUFBLFlBQUFnRixlQUFBL0YsT0FBQVksT0FRcEIsa0NBQXdCO0FBQUEsWUFBQW9GLGFBQUFoRyxPQUFBWSxPQUMxQixrQ0FBd0I7QUFBQSxZQUFBcUYsYUFBQWpHLE9BQUFZO0FBQUFBLElBS2xEO0FBQUEsZUFDQTtBQUFBO0FBQUEsUUFBQXlDLE9BRUU7QUFBQSxJQUNBLG1DQUEwQjtBQUFBO0FBQUEsWUFBQTZDLGNBQUFsRyxPQUFBWTtBQUFBQSxRQUFBLE9BSzVCO0FBQUE7QUFBQSxnQkFDQTtBQUFBO0FBQUEsVUFBQXlDLE9BRUc7QUFBQSxNQUNBO0FBQUEsTUFBMEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFIN0I7QUFBQTtBQUFBO0FBQUEsZ0JBREE7QUFBQTtBQUFBLEdBTUc7QUFBQSxZQUFBOEMsZ0JBQUFuRyxPQUFBYSxPQUFBRTtBQUFBQSxRQUFBLE9BS0g7QUFBQTtBQUFBLFFBQUFQLE9BQ0UsaUJBQUE2QyxPQUNBO0FBQUEsSUFDQSxnQ0FBeUI7QUFBQTtBQUFBLFlBQUErQyxhQUFBcEcsT0FBQVksT0FHRCxtQ0FBeUI7QUFBQSxZQUFBeUYsV0FBQXJHLE9BQUFZO0FBQUFBLFFBQUEsT0FHbkQ7QUFBQTtBQUFBLFFBQUF5QyxPQUNFO0FBQUEsSUFDQSxtQ0FBMEI7QUFBQTtBQUFBLFlBQUFpRCxpQkFBQXRHLE9BQUFtQjtBQUFBQSxRQUFBLE9BVUM7QUFBQTtBQUFBLEdBQXFDO0FBQUEsWUFBQW9GLGlCQUFBdkcsT0FBQVksT0FHcEMsaUJBQWtCO0FBQUEsWUFBQTRGLGtCQUFBeEcsT0FBQVksT0FFakI7QUFBQSxHQUF3QztBQUFBLFlBQUE2RixxQkFBQXpHLE9BQUFLLEdBR3RDLHdCQUFzQjtBQUFBLFlBQUFxRyxxQkFBQTFHLE9BQUFZLE9BQ3JCLGlCQUFpQjtBQUFBLFlBQUErRixTQUFBeEYsR0FLbkQsc0NBQStDO0FBQUEsWUFBQXlGLGtCQUFBNUcsT0FBQW1CO0FBQUFBLFFBQUEsT0FnQi9DO0FBQUE7QUFBQSxRQUFBQSxNQUNFLDJCQVpGO0FBQUE7QUFBQSxRQUFBQSxJQUNVO0FBQUEsSUFDUjtBQUFBLElBQ0E7QUFBQSxJQUNBLHNCQVFpRDtBQUFBO0FBQUEsWUFBQTBGLGtCQUFBN0csT0FBQVksT0FHcEIsZ0JBQW1CO0FBQUEsWUFBQWtHLGNBQUE5RyxPQUFBbUI7QUFBQUEsUUFBQSxPQUdsRDtBQUFBO0FBQUEsUUFBQUEsTUFDVTtBQUFBLElBQ1I7QUFBQSxJQUNBO0FBQUEsU0FBQTRGLGlCQUdPO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJSTtBQUFBLE1BQUFBLGlCQUFSO0FBQUEsSUFHSCwrQ0FBc0M7QUFBQTtBQUFBLFlBQUFDLGtCQUFBcEc7QUFBQUEsUUFBQXFHLFNBTXBCLFVBQUFDLGFBQUE7QUFBQSxJQUNwQiwrREFJVTtBQUFBO0FBQUEsWUFBQUMsZUFBQUM7QUFBQUEsSUFHSixtREFFWTtBQUFBO0FBQUEsWUFBQUMsY0FBQXJILE9BQUFZLE9BRVMsZ0JBQWU7QUFBQSxZQUFBMEcscUJBQUF0SCxPQUFBWTtBQUFBQSxRQUFBcUcsU0FFbkIsVUFBQUMsYUFBQTtBQUFBLElBQ3ZCO0FBQUEsSUFDQTtBQUFBLElBQWtDO0FBQUEsR0FDaEM7QUFBQSxZQUFBSyxnQkFBQXZILE9BQUFrSCxZQUFBRDtBQUFBQTtBQUFBQSxLQUFBRyxXQUdGO0FBQUEsS0FBQTlGLFFBQ007QUFBQSxJQUEwQixtQkFJOUIsNENBQW1DO0FBQUE7QUFBQSxLQUFBa0csTUFKTDtBQUFBLFlBRU47QUFBQSxJQUFrQztBQUFBLEdBRXZCO0FBQUEsWUFBQUMscUJBQUF6SCxPQUFBa0gsWUFBQUQ7QUFBQUEsUUFBQUcsV0FHckM7QUFBQSxJQUNNO0FBQUEsY0FJSjtBQUFBLGVBQW1DO0FBQUE7QUFBQSxZQUFBTSxnQkFBQTFILE9BQUFZLE9BR3FDLCtCQUFFO0FBQUEsWUFBQStHLG1CQUFBM0gsT0FBQTRIO0FBQUFBLFFBQUFSLFdBRzdEO0FBQUEsSUFDWSxPQUFpQiw0QkFBakIsNkJBQWlCO0FBQUE7QUFBQSxZQUFBUywrQkFBQTdILE9BQUFZO0FBQUFBLFFBQUFrSCxJQUdYLFVBQUEvQyxJQUFBLFVBQUFnRCxJQUFBLFVBQUFDLElBQUEsVUFBQTVKLElBQUE7QUFBQSxJQU9qQztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQUFBLEdBQXdCO0FBQUEsWUFBQTZKLCtCQUFBakksT0FBQVk7QUFBQUEsSUFFb0I7QUFBQSxHQU03QztBQUFBLFlBQUFzSCwrQkFBQWxJLE9BQUE1QixHQUFBNEosR0FLQyxlQUEwQjtBQUFBLEdBQXVCO0FBQUEsWUFBQUcsK0JBQUFuSSxPQUFBWSxPQUdqRDtBQUFBLEdBQXlDO0FBQUEsWUFBQXdILGdCQUFBcEksT0FBQVk7QUFBQUEsSUFJWix5Q0FBNkI7QUFBQTtBQUFBLE9BQUF5SCxhQUczQyw0Q0FBa0I7QUFBQSxZQUFBQyxlQUFBdEksT0FBQW1CO0FBQUFBLFFBQUFBLE1BRWpDO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDQSxjQUFnQixnREFJYjtBQUFBLEtBRkQ7QUFBQSxTQUFBQSxNQUFtQztBQUFBO0FBQUE7QUFBQSxHQUVsQztBQUFBLFlBQUFvSCw2QkFBQXZJLE9BQUF3STtBQUFBQSxJQVNvQjtBQUFBLElBQ3ZCLHFCQUFBNUgsT0FBaUMsaUNBQVE7QUFBQSxJQUNJLDJCQUFyQjtBQUFBLElBQ21CLDJCQUFwQjtBQUFBLElBQ29CLDJCQUFwQjtBQUFBLElBQW9CO0FBQUE7QUFBQSxZQUFBNkgseUJBQUE3SDtBQUFBQSxJQVFkLDRCQUV0QjtBQUFBLFFBQUFQLElBRnNCLGlCQUNMO0FBQUEsSUFBTywwQ0FDdEI7QUFBQTtBQUFBLFlBQUFxSSwwQkFBQTlIO0FBQUFBLElBQ3FCLDRCQUV2QjtBQUFBLFFBQUFQLElBRnVCLGlCQUNMO0FBQUEsSUFBTywyQ0FDdkI7QUFBQTtBQUFBLFlBQUFzSSwwQkFBQSxNRDk1Qlg7QUFBQSxZQUFBQywyQkFBQTtBQUFBLFlBQUFDLGtCQUFBekssR0FBQTRKLEdBQUFELEdBQUFoRCxHQUFBK0M7QUFBQUE7QUFBQUEsS0FBQWdCLFdDdTZCaUI7QUFBQSxLQUFBQyxVQUNmO0FBQUEsSUFFQTtBQUFBLFFBQUFDLGFBQ2lCO0FBQUEsSUFDakI7QUFBQSxJQUNBO0FBQUE7QUFBQSxLQUFBQyxZQUE4RDtBQUFBLFlBUTVDO0FBQUE7QUFBQSxZQUREO0FBQUEsWUFEQztBQUFBLElBREU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFBZTtBQUFBO0FBQUEsWUFBQUMsMkJBQUFDO0FBQUFBLElBZ0NuQztBQUFBLDZFQUtxQjtBQUFBO0FBQUEsWUFBQUMsZUFBQUMsUUFBQUM7QUFBQUE7QUFBQUEsS0FBQUM7QUFBQUEsT0FNWDtBQUFBO0FBQUE7QUFBQSx3QkQ3OUJaO0FBQUE7QUFBQTtBQUFBLElDODlCMkMseUJBQW5CO0FBQUEsSUFDaUIseUJBQWxCO0FBQUEsSUFDa0IseUJBQWxCO0FBQUEsSUFDckI7QUFBQSxHQUFHO0FBQUEsWUFBQUMseUJBQUFoQjtBQUFBQSxJQUtZLE9BQXFCO0FBQUEsYUFBckI7QUFBQSxzQkFBQTVILE9BQWlDLGlDQUFRLEdBQUM7QUFBQTtBQUFBLFlBQUE2SSxvQkFBQXJHO0FBQUFBLElBSzFDLE9BQXdCO0FBQUEsYUFBeEIsaUREMytCakIsV0MyK0JnRDtBQUFBO0FBQUEsT0FBQXNHLGlCQTlHYjtBQUFBLFlBQUFDLGVBQUEvSTtBQUFBQSxJQXFIWCxtREFBNEI7QUFBQTtBQUFBO0FBQUEsSUFBQWdKLFNBR3ZDO0FBQUEsSUFBQUMsZ0JBSU87QUFBQSxJQUFBQyxnQkFDQTtBQUFBLElBQUFDLGdCQUNBO0FBQUEsSUFBQUMsYUFLSDtBQUFBLEdBQ1Q7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BRWdCO0FBQUE7QUFBQTtBQUFBLGlCQUFBcko7QUFBQUEsU0FDRixPQUFvQjtBQUFBLGtCQUFwQiw2Q0FBb0I7QUFBQTtBQUFBLEdBQ2xDO0FBQUEsWUFBQXNKLG9CQUFBQyxLQUFBQyxLQUFBQyxLQUFBQztBQUFBQSxRQUFBLE9BR2U7QUFBQSxJQUFvQix5REFBWTtBQUFBO0FBQUEsWUFBQUMsbUJBQUEvQixJQUFBMkIsS0FBQXZKO0FBQUFBO0FBQUFBLEtBQUE0SixNQUczQztBQUFBLEtBQUFGLE1BQ0E7QUFBQSxLQUFBRixNQUNBO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxJQUFlLHdDQUNDO0FBQUE7QUFBQTtBQUFBLElBQUFLO0FBQUFBLE1BRUE7QUFBQTtBQUFBO0FBQUEsaUJBQUE3SixPQUE4QixtREFBNEI7QUFBQSxJQUFBOEo7QUFBQUEsTUFDMUQ7QUFBQTtBQUFBO0FBQUEsaUJBQUE5SixPQUE4QixtREFBNEI7QUFBQSxJQUFBK0o7QUFBQUEsTUFFcEQ7QUFBQTtBQUFBO0FBQUEsaUJBQUEvSjtBQUFBQTtBQUFBQSxVQUFBLE9BRUY7QUFBQSxVQUFBMkk7QUFBQUEsWUFBbEI7QUFBQTtBQUFBLGVBQWtCO0FBQUE7QUFBQTtBQUFBLGVBQ2hCO0FBQUE7QUFBQSw2QkR4aENOO0FBQUE7QUFBQTtBQUFBLFNDMGhDMkMseUJBQW5CO0FBQUEsU0FDaUIseUJBQWxCO0FBQUEsU0FDa0IseUJBQWxCO0FBQUEsU0FDckI7QUFBQTtBQUFBLDBCQUFlO0FBQUEsU0FBb0I7QUFBQSxRQUNoQztBQUFBLEdBQ0c7QUFBQTtBQUFBLElBQUFxQjtBQUFBQSxNQUVnQjtBQUFBO0FBQUE7QUFBQSxpQkFBQWhLO0FBQUFBO0FBQUFBLFVBQUEsTUFFRjtBQUFBLFVBQUEySTtBQUFBQSxZQUFsQjtBQUFBO0FBQUEsZUFBa0I7QUFBQTtBQUFBLDRCQUNoQjtBQUFBLDRCRHBpQ047QUFBQTtBQUFBO0FBQUEsU0NzaUMyQyx3QkFBbkI7QUFBQSxTQUNpQix3QkFBbEI7QUFBQSxTQUNrQix3QkFBbEI7QUFBQSxTQUNyQjtBQUFBLDJDQUFlO0FBQUEsU0FBb0I7QUFBQSxRQUNoQztBQUFBLEdBQ0c7QUFBQSxZQUFBc0Isa0JBQUFqSztBQUFBQSxJQUVtQiwwREFBeUI7QUFBQTtBQUFBLFlBQUFrSyxrQkFBQWxLO0FBQUFBLElBQ3pCLDBEQUF5QjtBQUFBO0FBQUEsWUFBQW1LLGtCQUFBbks7QUFBQUEsSUFDekIsMERBQXlCO0FBQUE7QUFBQSxZQUFBb0ssV0FBQXBLO0FBQUFBLElBQ2hDLG1EQUFrQjtBQUFBO0FBQUEsWUFBQXFLLHVCQUFBVCxLQUFBakI7QUFBQUEsSUFPcEM7QUFBQSxRQUFBbEosSUFDUTtBQUFBLElBQ1I7QUFBQSxJQUFnQjtBQUFBLEdBQ2Y7QUFBQSxZQUFBNkssb0JBQUF0SztBQUFBQTtBQUFBQSxLQUFBZ0osU0FJWTtBQUFBLEtBQUFHLGdCQUNPO0FBQUEsSUFDcEIsb0RBQTJDO0FBQUE7QUFBQSxZQUFBb0IsNEJBQUE5QixRQUFBQztBQUFBQSxJQUczQztBQUFBO0FBQUE7QUFBQSxzQkFBQTFJO0FBQUFBO0FBQUFBLGVBQUE0SixNQUNZO0FBQUEsZUFBQW5CLFdBQ0k7QUFBQSx1QkFBQUMsUUFBQTFJO0FBQUFBLG1CQUFBLE1BRW1CO0FBQUEsZUFBL0IsbUJBQU87QUFBQSxlQUNQO0FBQUEsZUFBZ0IsMkJBQ1I7QUFBQTtBQUFBLGNBRVYsd0NBQTZCO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQXdLLCtCQUFBNUM7QUFBQUEsSUFHSixPQUFxQjtBQUFBLGFBQXJCO0FBQUEsc0JBQUE1SCxPQUFpQyxpQ0FBUSxHQUFDO0FBQUE7QUFBQSxZQUFBeUssNEJBQUF6SyxPQTJCdEUsY0FBaUM7QUFBQSxZQUFBMEssNkJBQUFDLEtBR2pDLHFCQUFrQztBQUFBLFlBQUFDLDJCQUFBRDtBQUFBQSxJQUdsQywwQ0FBcUM7QUFBQTtBQUFBLFlBQUFFLDZCQUFBRjtBQUFBQSxRQUFBRyxRQUd6QjtBQUFBLElBQ1o7QUFBQSxJQUFnQztBQUFBLEdBQzNCO0FBQUEsWUFBQUMseUJBQUFKLEtBQUFLLE1BR0w7QUFBQSxHQUFvRTtBQUFBLFlBQUFDLCtCQUFBTjtBQUFBQSxhQUFBbk4sRUFBQWlDLEdBQUEwRSxHQUFBNUQ7QUFBQUEsS0FRdEIsT0FBa0I7QUFBQSx1QkFBbEIsd0NBQWtCO0FBQUE7QUFBQSxhQUFBNkcsRUFBQSxLQUo5RDtBQUFBLGFBQUFELEVBQUEsS0FFQTtBQUFBLGFBQUFoRCxFQUFBNUQsR0FJQTtBQUFBLGFBQUEyRyxFQUFBM0csR0FFQTtBQUFBLElBT0YsdUNBQTJCO0FBQUE7QUFBQSxZQUFBMkssVUFBQUM7QUFBQUEsSUFTRSxPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQUMsVUFBQUQ7QUFBQUEsSUFDN0IsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFFLFdBQUFGO0FBQUFBLElBQzNCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBRyxZQUFBSDtBQUFBQSxJQUMzQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQUksU0FBQUo7QUFBQUEsSUFDbkMsT0FBMkIsWUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBSyxVQUFBTDtBQUFBQSxJQUMzQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQU0sVUFBQU47QUFBQUEsSUFDN0IsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFPLFdBQUFQO0FBQUFBLElBQzNCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBUSxTQUFBNUgsT0FBQTZIO0FBQUFBLFFBQUF4TSxRQUMvQjtBQUFBLElBdGlCYSx3Q0FzaUJrQjtBQUFBO0FBQUEsWUFBQXlNLGFBQUFWO0FBQUFBLElBQ3pCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBVyxZQUFBWDtBQUFBQSxJQUMvQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQVksVUFBQVo7QUFBQUEsSUFDakMsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFhLFlBQUFiO0FBQUFBLElBQ3pCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBYyxXQUFBZDtBQUFBQSxJQUMvQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQWUsV0FBQWY7QUFBQUEsSUFDN0IsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFnQixZQUFBaEIsR0FBQVM7QUFBQUEsSUFDekIsT0FBMkI7QUFBQSxhQUEzQiwwREFBK0I7QUFBQTtBQUFBLFlBQUFRLFVBQUFqQjtBQUFBQSxJQUNyQyxPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQWtCLFlBQUFsQjtBQUFBQSxJQUN6QixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQW1CLGNBQUFuQjtBQUFBQSxJQUN6QixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQW9CLFlBQUFwQjtBQUFBQSxJQUNqQyxPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQXFCLGNBQUFyQjtBQUFBQSxJQUN6QixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQXNCLGlCQUFBdEI7QUFBQUEsSUFDdkIsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUF1QixVQUFBdkI7QUFBQUEsSUFFM0MsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUF3QixXQUFBeEI7QUFBQUEsSUFDM0IsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUF5QixhQUFBekIsR0FBQVM7QUFBQUEsSUFDdkIsT0FBMkI7QUFBQSxhQUEzQiwwREFBK0I7QUFBQTtBQUFBLFlBQUFpQixRQUFBMUI7QUFBQUEsSUFFM0MsT0FBMkIsV0FBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBMkIsVUFBQTNCO0FBQUFBLElBQ3pCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBNEIsV0FBQTVCO0FBQUFBLElBRTNCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBNkIsV0FBQTdCO0FBQUFBLFFBQUEvTCxRQUM3QjtBQUFBLElBdFhKO0FBQUEsR0FzWGlDO0FBQUEsWUFBQTZOLGVBQUE5QjtBQUFBQSxJQUVyQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQStCLGVBQUEvQjtBQUFBQSxRQUFBL0wsUUFDN0I7QUFBQSxJQTNaUjtBQUFBLEdBMlpxQztBQUFBLFlBQUErTixhQUFBN0csWUFBQUQ7QUFBQUEsSUFHcEQsT0FBMkI7QUFBQSxhQUEzQjtBQUFBO0FBQUEsb0JBQStDO0FBQUE7QUFBQSxZQUFBK0csa0JBQUE5RyxZQUFBRDtBQUFBQSxJQUUxQyxPQUEyQjtBQUFBLGFBQTNCO0FBQUE7QUFBQSxvQkFBK0M7QUFBQTtBQUFBLFlBQUFnSCxhQUFBbEM7QUFBQUEsSUFDakMsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFtQyxnQkFBQW5DO0FBQUFBLElBQ3ZCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBb0MsY0FBQXBDO0FBQUFBLElBRWpDLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBcUMsY0FBQXJDO0FBQUFBLFFBQUEvTCxRQUM3QjtBQUFBLElBcGNQO0FBQUEsR0FvY29DO0FBQUEsWUFBQXFPLGVBQUF0QztBQUFBQSxJQUMzQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQXVDLGtCQUFBdkM7QUFBQUEsSUFFdkIsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUF3QyxrQkFBQXhDO0FBQUFBLFFBQUEvTCxRQUM3QjtBQUFBLElBbGNYO0FBQUEsR0FrY3dDO0FBQUEsWUFBQXdPLDBCQUFBekM7QUFBQUEsSUFHN0MsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUEwQyw0QkFBQTFDO0FBQUFBLElBRzNCLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBMkMsNEJBQUEzQztBQUFBQSxJQUU3QixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQTRDLCtCQUFBNUMsR0FBQVM7QUFBQUEsSUFHMUIsT0FBMkI7QUFBQSxhQUEzQiwwREFBK0I7QUFBQTtBQUFBLFlBQUFvQywrQkFBQTdDO0FBQUFBLElBRS9CLE9BQTJCO0FBQUEsYUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBOEMsNkJBQUE5QztBQUFBQSxJQUcvQixPQUEyQjtBQUFBLGFBQTNCLHVEQUE2QjtBQUFBO0FBQUEsWUFBQStDLDZCQUFBL0M7QUFBQUEsSUFFN0IsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFnRCxlQUFBaEQ7QUFBQUEsSUFFM0MsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFpRCxlQUFBakQ7QUFBQUEsUUFBQS9MLFFBRTdCO0FBQUEsSUF4cUJhO0FBQUEsR0F3cUJnQjtBQUFBLFlBQUFpUCxjQUFBbEQ7QUFBQUEsSUFFOUIsT0FBMkI7QUFBQSxhQUEzQix1REFBNkI7QUFBQTtBQUFBLFlBQUFtRCxjQUFBbkQ7QUFBQUEsUUFBQS9MLFFBRTdCO0FBQUEsSUEzcUJhO0FBQUEsR0EycUJnQjtBQUFBLFlBQUFtUCxTQUFBcEQ7QUFBQUEsSUFFbEMsT0FBMkIsWUFBM0IsdURBQTZCO0FBQUE7QUFBQSxZQUFBcUQsY0FBQUMsS0FBQUMsTUFBQUMsTUFBQWhHLEtBQUF3QztBQUFBQSxJQU16QyxZQUFBeUQsTUFBQSxRQUFBQyxTQUQyQixjQUFBQSxTQUFBO0FBQUEsUUFBQUMsV0FDM0I7QUFBQSxhQUFBSCxPQUFBeEQ7QUFBQUEsS0FFRSxnQkFBa0Isc0JBQXVCO0FBQUEsS0FDekMsK0JBQVU7QUFBQTtBQUFBLElBRVosa0NBQVc7QUFBQTtBQUFBLFlBQUE0RCxjQUFBTixLQUFBRSxNQUFBaEcsS0FBQXdDO0FBQUFBLElBSVgsWUFBQXlELE1BQUEsUUFBQUMsU0FEMkIsY0FBQUEsU0FBQTtBQUFBLElBQzNCLGdFQUEwQztBQUFBO0FBQUEsWUFBQUcsZUFBQVAsS0FBQUUsTUFBQWhHLEtBQUF3QztBQUFBQSxJQUkxQyxZQUFBeUQsTUFBQSxRQUFBQyxTQUQ0QixjQUFBQSxTQUFBO0FBQUEsSUFDNUIsaUVBQTJDO0FBQUE7QUFBQSxZQUFBSSxhQUFBUixLQUFBRSxNQUFBaEcsS0FBQXVHO0FBQUFBLElBSTNDLFlBQUFOLE1BQUEsUUFBQUMsU0FEMEIsY0FBQUEsU0FBQTtBQUFBLElBQzFCLGdFQUEyQztBQUFBO0FBQUEsWUFBQU0sY0FBQXhHLEtBQUFsSjtBQUFBQSxRQUFBaUssTUFJM0MsMEJBQUEwRixPQUNBLFFBQUFDLFFBQ0E7QUFBQSxhQUFBM0csTUFBQTFJO0FBQUFBLEtBRUU7QUFBQSxZQUFvQjtBQUFBLEtBQXFDO0FBQUEsS0FDN0M7QUFBQTtBQUFBLElBQWU7QUFBQSxJQUU3QjtBQUFBO0FBQUEsZ0JBV0E7QUFBQSxtQkFBcUIsY0FBUTtBQUFBO0FBQUEsU0FBQVUsUUFWckI7QUFBQSxLQUFVO0FBQUEsTUFFWjtBQUFBLE1BQ0E7QUFBQTtBQUFBLDJCQUVBLFVBQVUsOEJBR0w7QUFBQTtBQUFBLEdBRWtCO0FBQUEsWUFBQTRPLGdCQUFBYixLQUFBRSxNQUFBaEcsS0FBQTNJO0FBQUFBLElBRXlCO0FBQUEsU0FBQTRPLE1BQUEsUUFBQVcsT0FBM0I7QUFBQTtBQUFBLFNBQUFBLE9BQUEsU0FBQXZQLE9BQUEsS0FBWSxTQUFFO0FBQUEsSUFBYSxZQUM5QywrQkFDWTtBQUFBLFFBQUFtTCxJQUZrQztBQUFBLElBRTVDLCtCQUFVO0FBQUE7QUFBQSxZQUFBcUUsZ0JBQUFDLElBQUFDLE9BQUEvRyxLQUFBM0k7QUFBQUEsSUFFRix1QkFBQW1MLElBQUEsVUFDViw2QkFDYztBQUFBLFFBQUF3RSxJQUZKO0FBQUEsSUFFUCxnQ0FBVztBQUFBO0FBQUEsWUFBQUMsZ0JBQUFSLE1BQUFDLE9BQUExRyxLQUFBM0k7QUFBQUEsSUFFSix1QkFBQWMsSUFBQSxVQUNELCtCQUNZO0FBQUEsUUFBQStPLElBRlg7QUFBQSxJQUVBLGdDQUFXO0FBQUE7QUFBQSxZQUFBQyxZQUFBckgsUUFBQXNIO0FBQUFBO0FBQUFBLEtBQUFuRyxNQUtuQjtBQUFBLEtBQUFqQixNQUNBO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxRQUFBZSxNQUNVO0FBQUEsSUFDVjtBQUFBLGNBQ0s7QUFBQSxjQURXLGlDQUNlO0FBQUE7QUFBQSxZQUFBc0csc0JBQUFySCxLQUFBc0g7QUFBQUEsSUFhVTtBQUFBO0FBQUE7QUFBQSxRQUNWLDJCQVMwQztBQUFBO0FBQUEsUUFSMUMsNEJBUTBDO0FBQUE7QUFBQSxRQU4xQyw2QkFNMEM7QUFBQTtBQUFBLFFBTDFDLCtCQUswQztBQUFBO0FBQUEsUUFKMUMsK0JBSTBDO0FBQUE7QUFBQSxRQUYxQyw2QkFFMEM7QUFBQSxnQkFEMUMsNkJBQzBDO0FBQUE7QUFBQSxJQVZoQztBQUFBO0FBQUEsV0FBQTlQLFNBQUEsZUFBQUYsUUFBQTtBQUFBLE9BR1YseUNBTzBDO0FBQUE7QUFBQSxPQUgxQztBQUFBO0FBQUEsV0FBQXNFLElBUFU7QUFBQSxPQVVWO0FBQUEsT0FBcUIsNEJBQXFCO0FBQUE7QUFBQTtBQUFBLFlBQUEyTCxXQUFBdkgsS0FBQXdIO0FBQUFBLElBTTlDLDRCQTBCRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BMUJIO0FBQUE7QUFBQSxjQUFBM1MsSUFBQSxRQUFBNFMsSUFBQTtBQUFBLFVBVXpCO0FBQUEsVUFBZ0Isb0NBZ0JjO0FBQUE7QUFBQSxjQUFBMVAsUUExQkwsUUFBQTBQLE1BQUE7QUFBQTtBQUFBLGVBQUFELFFBQUE7QUFBQSxXQWF6QjtBQUFBLFdBQzZCLE9BQTZCO0FBQUEseUNBQTdCLGdDQVlDO0FBQUE7QUFBQSxjQUFBQSxRQTFCTDtBQUFBLFVBZ0J6QjtBQUFBO0FBQUEsaUJBQ3VDO0FBQUEsV0FBQXpQLFVBQW5CO0FBQUEsV0FBQTJQLE1BQWdEO0FBQUEsV0FBQWhRLFNBQUE7QUFBQSxVQUNwRSx3Q0FROEI7QUFBQTtBQUFBLG9CQTFCTDtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBWixNQUFBLFFBQUFHLE9BQUEsUUFBQXdRLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBM1EsSUFBQSxRQUFBMlEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBN0wsTUFBQSxRQUFBM0UsU0FBQSxRQUFBd1EsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUE3TCxJQUFBLFFBQUE2TCxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUEzUSxNQUFBLFFBQUFHLE9BQUEsUUFBQXdRLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBM1EsSUFBQSxRQUFBMlEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBN0wsTUFBQSxRQUFBM0UsU0FBQSxRQUFBd1EsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUE3TCxJQUFBLFFBQUE2TCxNQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUE1UyxNQUFBLFFBQUE0UyxNQUFBO0FBQUEsVUF1Qkc7QUFBQSxVQUFnQiwyQkFHZDtBQUFBO0FBQUEsY0FBQUEsTUExQkw7QUFBQSxVQXdCRztBQUFBLFVBQWdCLDZCQUVkO0FBQUE7QUFBQSxjQUFBeEosTUExQkwsUUFBQXdKLE1BQUE7QUFBQSxVQXlCRztBQUFBLFVBQWdCLGlDQUNkO0FBQUE7QUFBQSxPQW5COUI7QUFBQSxPQUN3QyxPQUFEO0FBQUEsNkJBQUMscUNBa0JWO0FBQUE7QUFBQSxNQUpGO0FBQUEsTUFBZ0IsNEJBSWQ7QUFBQTtBQUFBLEtBdkI5QjtBQUFBLEtBQ3VDLHVDQXNCVDtBQUFBO0FBQUEsSUFORjtBQUFBLElBQWdCLDhCQU1kO0FBQUE7QUFBQSxZQUFBRSxXQUFBM0gsS0FBQXdIO0FBQUFBLElBTUwsNEJBNkJHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0E3Qkg7QUFBQTtBQUFBLGNBQUEzUyxJQUFBLFFBQUE0UyxJQUFBO0FBQUEsVUFhekI7QUFBQSxVQUFnQixvQ0FnQmM7QUFBQTtBQUFBLGNBQUExUCxRQTdCTCxRQUFBMFAsTUFBQTtBQUFBO0FBQUEsZUFBQUQsUUFBQTtBQUFBLFdBZ0J6QjtBQUFBLFdBQzZCLE9BQTZCO0FBQUEseUNBQTdCLGdDQVlDO0FBQUE7QUFBQSxjQUFBQSxRQTdCTDtBQUFBLFVBbUJ6QjtBQUFBO0FBQUEsaUJBQ3VDO0FBQUEsV0FBQXpQLFVBQW5CO0FBQUEsV0FBQTJQLE1BQWdEO0FBQUEsV0FBQWhRLFNBQUE7QUFBQSxVQUNwRSx3Q0FROEI7QUFBQTtBQUFBLG9CQTdCTDtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBWixNQUFBLFFBQUFHLE9BQUEsUUFBQXdRLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBM1EsSUFBQSxRQUFBMlEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBN0wsTUFBQSxRQUFBM0UsU0FBQSxRQUFBd1EsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUE3TCxJQUFBLFFBQUE2TCxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUEzUSxNQUFBLFFBQUFHLE9BQUEsUUFBQXdRLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBM1EsSUFBQSxRQUFBMlEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBN0wsTUFBQSxRQUFBM0UsU0FBQSxRQUFBd1EsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUE3TCxJQUFBLFFBQUE2TCxNQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFBLE1BQUE7QUFBQTtBQUFBLGVBQUExUCxVQUFBO0FBQUE7QUFBQSxnQkFBQWxELE1BQUEsUUFBQW9DLFNBQUEsWUFBQXdRLE1BQUE7QUFBQSxZQVV6QjtBQUFBLFlBQ3dDLE9BQUQsOEJBQUMsbUJBa0JWO0FBQUE7QUFBQTtBQUFBLGNBQUE1UyxNQTdCTDtBQUFBLFVBMEJHO0FBQUEsVUFBc0MsT0FBTSxxQkFBTixtQkFHcEM7QUFBQTtBQUFBLGNBQUE0UyxNQTdCTDtBQUFBLFVBMkJHO0FBQUEsVUFBZ0IsNkJBRWQ7QUFBQTtBQUFBLGNBQUF4SixNQTdCTCxRQUFBd0osTUFBQTtBQUFBLFVBNEJHO0FBQUEsVUFBZ0IsaUNBQ2Q7QUFBQTtBQUFBLE9BdEI5QjtBQUFBLE9BQ3dDLE9BQUQ7QUFBQSw2QkFBQyxxQ0FxQlY7QUFBQTtBQUFBLE1BSkY7QUFBQSxNQUFnQiw0QkFJZDtBQUFBO0FBQUEsS0ExQjlCO0FBQUEsS0FDdUMsdUNBeUJUO0FBQUE7QUFBQSxJQU5GO0FBQUEsSUFBZ0IsOEJBTWQ7QUFBQTtBQUFBLFlBQUFHLFNBQUFDLEdBQUE3SCxLQUFBM0k7QUFBQUEsUUFBQXlRLE1BUXJCO0FBQUEsSUFDWDtBQUFBO0FBQUEsc0JBQUFOLEtBQ2Msc0JBQWtCLHlCQUFPO0FBQUE7QUFBQSxpQkFDdkI7QUFBQTtBQUFBLFlBQUFPLFVBQUFGLEdBQUE3SCxLQUFBM0k7QUFBQUEsUUFBQXlRLE1BRUo7QUFBQSxJQUNaLHFEQUFzQjtBQUFBO0FBQUEsWUFBQUUsU0FBQWhJLEtBQUEzSTtBQUFBQSxRQUFBeVEsTUFFWDtBQUFBLElBQ1gsdUREOTRDRixtQkM4NEM0QjtBQUFBO0FBQUEsWUFBQUcsUUFBQWpJO0FBQUFBLGFBQUEsU0Q5NEM1QjtBQUFBLElDZzVDa0IscUJEaDVDbEIsZ0NDZzVDa0I7QUFBQSxHQUFtQjtBQUFBLFlBQUFrSSxPQUFBN1E7QUFBQUEsUUFBQXlRLE1BRTFCO0FBQUEsSUFDVDtBQUFBO0FBQUEsc0JBQUFOO0FBQUFBLGNBQ3lCLE9BQTJCO0FBQUEsdUJBQTNCLHlEQUErQjtBQUFBO0FBQUE7QUFBQSxpQkFDeEM7QUFBQTtBQUFBLFlBQUFXLFFBQUE5UTtBQUFBQSxRQUFBeVEsTUFFTjtBQUFBLElBQ1Y7QUFBQTtBQUFBLHNCQUFBTjtBQUFBQSxjQUN5QixPQUEyQjtBQUFBLHVCQUEzQix5REFBK0I7QUFBQTtBQUFBO0FBQUEsaUJBQ3hDO0FBQUE7QUFBQSxZQUFBWSxTQUFBUCxHQUFBeFE7QUFBQUEsUUFBQXlRLE1BRUw7QUFBQSxJQUNYO0FBQUE7QUFBQSxzQkFBQU47QUFBQUEsY0FDYztBQUFBLG1DQUFBeEgsS0FBYywyQkFBa0IsR0FBQztBQUFBO0FBQUE7QUFBQSxpQkFDL0I7QUFBQTtBQUFBLFlBQUFxSSxRQUFBUCxLQUVBLHlCQUFBdE0sR0FBbUIsU0FBQyxPQUFLO0FBQUEsWUFBQThNLFNBQUFULEdBQUF4UTtBQUFBQSxRQUFBeVEsTUFFOUIsVUFBQWpPLElBQ0gsbUJBQUFtRyxNQUNFO0FBQUEsYUFBQTZILElBQUFMO0FBQUFBLEtBRVI7QUFBQSxLQUNFLE9BQThCLGNBQTlCLCtCQUE4QjtBQUFBO0FBQUEsSUFDbEMscURBQTRCO0FBQUE7QUFBQSxZQUFBZSxRQUFBVCxLQUdaLHdCQUFlO0FBQUEsWUFBQVUsVUFBQVgsR0FBQXhRO0FBQUFBLFFBQUF5USxNQUVuQixVQUFBak8sSUFDSixtQkFBQW1HLE1BQ0U7QUFBQSxhQUFBNkgsSUFBQUw7QUFBQUEsS0FFUjtBQUFBLEtBQ0UsT0FBOEIsY0FBOUIsK0JBQThCO0FBQUE7QUFBQSxJQUNsQyxxREFBNEI7QUFBQTtBQUFBLFlBQUFpQixTQUFBWCxLQUdYLHlCQUFnQjtBQUFBLFlBQUFZLDBCQUFBclI7QUFBQUEsSUFLakMsZUFBZTtBQUFBLElBQ0EsT0FBMkI7QUFBQSxhQUEzQix1REFBOEI7QUFBQTtBQUFBLEdBRXRDO0FBQUEsR0FFQTtBQUFBO0FBQUEsY0FBQUE7QUFBQUEsTUFDUDtBQUFBO0FBQUEsT0FBQXNSLEtBQ1M7QUFBQSxhQUVlO0FBQUEsTUFEeEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUN3QjtBQUFBO0FBQUEsdUJBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFBLE9BRWQ7QUFBQSxhQUVlO0FBQUEsTUFBK0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBL0I7QUFBQTtBQUFBO0FBQUEsaUJBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFBOEM7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFDdEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDU4Q0QiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gSW50Lm1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV9zdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB+ZW5kX3dpdGhfbmV3bGluZSA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgZW5kX3dpdGhfbmV3bGluZSB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxubGV0IHBwX3ByaW50X2J5dGVzIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoQnl0ZXMubGVuZ3RoIHMpIChCeXRlcy50b19zdHJpbmcgcylcblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgfmVuZF93aXRoX25ld2xpbmU6dHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB+ZW5kX3dpdGhfbmV3bGluZTpmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBJbnQubWF4IChJbnQubWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbU3RkbGliLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1N0ZGxpYi5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG4oKiBJbml0aWFsaXNlIGRvbWFpbiBsb2NhbCBzdGF0ZSAqKVxubW9kdWxlIERMUyA9IERvbWFpbi5ETFNcblxubGV0IHN0ZGJ1Zl9rZXkgPSBETFMubmV3X2tleSBwcF9tYWtlX2J1ZmZlclxubGV0IF8gPSBETFMuc2V0IHN0ZGJ1Zl9rZXkgc3RkYnVmXG5cbmxldCBzdHJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgZm9ybWF0dGVyX29mX2J1ZmZlciAoRExTLmdldCBzdGRidWZfa2V5KSlcbmxldCBfID0gRExTLnNldCBzdHJfZm9ybWF0dGVyX2tleSBzdHJfZm9ybWF0dGVyXG5cbmxldCBidWZmZXJlZF9vdXRfc3RyaW5nIGtleSBzdHIgb2ZzIGxlbiA9XG4gIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIChEb21haW4uRExTLmdldCBrZXkpIHN0ciBvZnMgbGVuXG5cbmxldCBidWZmZXJlZF9vdXRfZmx1c2ggb2Mga2V5ICgpID1cbiAgbGV0IGJ1ZiA9IERvbWFpbi5ETFMuZ2V0IGtleSBpblxuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgbGV0IHN0ciA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgb3V0cHV0X3N1YnN0cmluZyBvYyBzdHIgMCBsZW4gO1xuICBTdGRsaWIuZmx1c2ggb2M7XG4gIEJ1ZmZlci5jbGVhciBidWZcblxubGV0IHN0ZF9idWZfa2V5ID0gRG9tYWluLkRMUy5uZXdfa2V5IChmdW4gKCkgLT4gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSlcbmxldCBlcnJfYnVmX2tleSA9IERvbWFpbi5ETFMubmV3X2tleSAoZnVuICgpIC0+IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemUpXG5cbmxldCBzdGRfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgc3RkX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRvdXQgc3RkX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBzdGRfZm9ybWF0dGVyX2tleSBzdGRfZm9ybWF0dGVyXG5cbmxldCBlcnJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgZXJyX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRlcnIgZXJyX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBlcnJfZm9ybWF0dGVyX2tleSBlcnJfZm9ybWF0dGVyXG5cbmxldCBnZXRfc3RkX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfZXJyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RkYnVmICgpID0gRExTLmdldCBzdGRidWZfa2V5XG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgfmVuZF93aXRoX25ld2xpbmU6ZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID1cbiAgbGV0IHN0ZGJ1ZiA9IERMUy5nZXQgc3RkYnVmX2tleSBpblxuICBsZXQgc3RyX2Zvcm1hdHRlciA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXkgaW5cbiAgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG5sZXQgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBvdXRwdXQnID0gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGluXG4gICAgbGV0IGZsdXNoJyAoKSA9XG4gICAgICBvdXRwdXQgKEJ1ZmZlci5jb250ZW50cyBidWYpIDAgKEJ1ZmZlci5sZW5ndGggYnVmKTtcbiAgICAgIEJ1ZmZlci5jbGVhciBidWY7XG4gICAgICBmbHVzaCAoKVxuICAgIGluXG4gICAgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0JyBmbHVzaCcpXG5cbmxldCBzeW5jaHJvbml6ZWRfZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggdiA9IHBwX29wZW5faGJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fdmJveCB2ID0gcHBfb3Blbl92Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9odmJveCB2ID0gcHBfb3Blbl9odmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5faG92Ym94IHYgPSBwcF9vcGVuX2hvdmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fYm94IHYgPSBwcF9vcGVuX2JveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGNsb3NlX2JveCB2ID0gcHBfY2xvc2VfYm94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9zdGFnIHYgPSBwcF9vcGVuX3N0YWcgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV9zdGFnIHYgPSBwcF9jbG9zZV9zdGFnIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYXMgdiB3ID0gcHBfcHJpbnRfYXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHYgd1xuYW5kIHByaW50X3N0cmluZyB2ID0gcHBfcHJpbnRfc3RyaW5nIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYnl0ZXMgdiA9IHBwX3ByaW50X2J5dGVzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaW50IHYgPSBwcF9wcmludF9pbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbG9hdCB2ID0gcHBfcHJpbnRfZmxvYXQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9jaGFyIHYgPSBwcF9wcmludF9jaGFyIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYm9vbCB2ID0gcHBfcHJpbnRfYm9vbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2JyZWFrIHYgdyA9IHBwX3ByaW50X2JyZWFrIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2IHdcbmFuZCBwcmludF9jdXQgdiA9IHBwX3ByaW50X2N1dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X3NwYWNlIHYgPSBwcF9wcmludF9zcGFjZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGZvcmNlX25ld2xpbmUgdiA9IHBwX2ZvcmNlX25ld2xpbmUgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbHVzaCB2ID0gcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9uZXdsaW5lIHYgPSBwcF9wcmludF9uZXdsaW5lIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaWZfbmV3bGluZSB2ID0gcHBfcHJpbnRfaWZfbmV3bGluZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgb3Blbl90Ym94IHYgPSBwcF9vcGVuX3Rib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV90Ym94IHYgPSBwcF9jbG9zZV90Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGJyZWFrIHYgdyA9IHBwX3ByaW50X3RicmVhayAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5cbmFuZCBzZXRfdGFiIHYgPSBwcF9zZXRfdGFiIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGFiIHYgPSBwcF9wcmludF90YWIgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9tYXJnaW4gdiA9IHBwX3NldF9tYXJnaW4gKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWFyZ2luIHYgPSBwcF9nZXRfbWFyZ2luIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfbWF4X2luZGVudCB2ID0gcHBfc2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWF4X2luZGVudCB2ID0gcHBfZ2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9nZW9tZXRyeSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgcHBfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIHBwX3NhZmVfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgZ2V0X2dlb21ldHJ5IHYgPSBwcF9nZXRfZ2VvbWV0cnkgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgdiA9IHBwX3VwZGF0ZV9nZW9tZXRyeSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X21heF9ib3hlcyB2ID0gcHBfc2V0X21heF9ib3hlcyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXhfYm94ZXMgdiA9IHBwX2dldF9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvdmVyX21heF9ib3hlcyB2ID0gcHBfb3Zlcl9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCB2ID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgdiA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgdyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgdiA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX3NldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX2dldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X21hcmtfdGFncyB2ID1cbiAgcHBfc2V0X21hcmtfdGFncyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXJrX3RhZ3MgdiA9XG4gIHBwX2dldF9tYXJrX3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBzZXRfdGFncyB2ID1cbiAgcHBfc2V0X3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxubGV0IHBwX3ByaW50X2l0ZXIgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIGl0ZXIgcHBfdiBwcGYgdiA9XG4gIGxldCBpc19maXJzdCA9IHJlZiB0cnVlIGluXG4gIGxldCBwcF92IHYgPVxuICAgIGlmICFpc19maXJzdCB0aGVuIGlzX2ZpcnN0IDo9IGZhbHNlIGVsc2UgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2XG4gIGluXG4gIGl0ZXIgcHBfdiB2XG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiB2ID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIExpc3QuaXRlciBwcF92IHBwZiB2XG5cbigqIFRvIGZvcm1hdCBhbiBhcnJheSAqKVxubGV0IHBwX3ByaW50X2FycmF5ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiB2ID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIEFycmF5Lml0ZXIgcHBfdiBwcGYgdlxuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIFNlcS5pdGVyIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2Vfc3RhZyBwcGYgKClcbiAgfCBCcmVhayAoXywgd2lkdGgsIG9mZnNldCkgIC0+IHBwX3ByaW50X2JyZWFrIHBwZiB3aWR0aCBvZmZzZXRcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2ZsdXNoIHBwZiAoKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX3ByaW50X25ld2xpbmUgcHBmICgpXG4gIHwgTWFnaWNfc2l6ZSAoXywgXykgICAgICAgICAtPiAoKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnJSdcbiAgfCBTY2FuX2luZGljIGMgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJzsgcHBfcHJpbnRfY2hhciBwcGYgY1xuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYub3V0cHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIChmICgpKTtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqXG5cbiAgRGVmaW5pbmcgW2ZwcmludGZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW2ZwcmludGZdLlxuXG4qKVxuXG5sZXQga2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgcHBmIGFjYzsgayBwcGYpXG4gICAgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGlmcHJpbnRmIF9wcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgaWdub3JlICgpIGZtdFxuXG5sZXQgZnByaW50ZiBwcGYgPSBrZnByaW50ZiBpZ25vcmUgcHBmXG5cbmxldCBwcmludGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIGFjYylcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgZXByaW50ZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyAoRExTLmdldCBlcnJfZm9ybWF0dGVyX2tleSkgYWNjKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSAoKTtcbiAgcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXkpICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG5sZXQgKCkgPSBEb21haW4uYmVmb3JlX2ZpcnN0X3NwYXduIChmdW4gKCkgLT5cbiAgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKTtcbiAgbGV0IGZzID0gcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXIgKCkgaW5cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiAgICB7ZnMgd2l0aCBvdXRfc3RyaW5nID0gYnVmZmVyZWRfb3V0X3N0cmluZyBzdGRfYnVmX2tleTtcbiAgICAgICAgICAgICBvdXRfZmx1c2ggPSBidWZmZXJlZF9vdXRfZmx1c2ggU3RkbGliLnN0ZG91dCBzdGRfYnVmX2tleX07XG5cbiAgbGV0IGZzID0gcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIGVycl9mb3JtYXR0ZXIgKCkgaW5cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIGVycl9mb3JtYXR0ZXJcbiAgICB7ZnMgd2l0aCBvdXRfc3RyaW5nID0gYnVmZmVyZWRfb3V0X3N0cmluZyBlcnJfYnVmX2tleTtcbiAgICAgICAgICAgICBvdXRfZmx1c2ggPSBidWZmZXJlZF9vdXRfZmx1c2ggU3RkbGliLnN0ZGVyciBlcnJfYnVmX2tleX07XG4pXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjcwNzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfT2JqIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJuYW1lIiwiZXhuIiwic2xvdCIsIlN0ZGxpYl9DYWxsYmFjayJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvY2FsbGJhY2subWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxtQkFBQUMsTUFBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQ3lCZ0I7QUFBQSxLQUFBQyxPQUFBO0FBQUEsSUFDZCw0Q0FBOEI7QUFBQTtBQUFBLE9BQUFDLGtCRDFCaEMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3MTAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2NhbWxpbnRlcm5hbE9PX21sIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfZGl2IiwiY2FtbF9nZXRfcHVibGljX21ldGhvZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX3NldF9vb19pZCIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYl9TeXMiLCJTdGRsaWJfT2JqIiwiU3RkbGliIiwiU3RkbGliX0FycmF5IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfTWFwIiwiY29weSIsIm8iLCJwYXJhbXMiLCJwdWJsaWNfbWV0aG9kX2xhYmVsIiwicyIsImFjY3UiLCJpIiwidGFnIiwiY29tcGFyZSIsIlZhcnMiLCJNZXRocyIsIkxhYnMiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImZpdF9zaXplIiwibiIsIm5ld190YWJsZSIsInB1Yl9sYWJlbHMiLCJsZW4iLCJtZXRob2RzIiwicmVzaXplIiwiYXJyYXkiLCJuZXdfc2l6ZSIsIm9sZF9zaXplIiwibmV3X2J1Y2siLCJtZXRob2RfY291bnQiLCJpbnN0X3Zhcl9jb3VudCIsIm5ld19tZXRob2QiLCJ0YWJsZSIsImluZGV4IiwiZ2V0X21ldGhvZF9sYWJlbCIsIm5hbWUiLCJsYWJlbCIsImdldF9tZXRob2RfbGFiZWxzIiwibmFtZXMiLCJzZXRfbWV0aG9kIiwiZWxlbWVudCIsImdldF9tZXRob2QiLCJ0b19saXN0IiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZpcnRfbWV0aF9sYWJzIiwiY29uY3JfbWV0aF9sYWJzIiwibGFiIiwiaW5mbyIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsIm1hdGNoIiwic2F2ZWRfdmFycyIsInNhdmVkX2hpZGRlbl9tZXRocyIsInYiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm5tZXRocyIsIm52YWxzIiwicmVzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInBhcmFtIiwidG9wIiwiZW52Iiwic3VwZXIiLCJpbml0Iiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsIm9iaiIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJsIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJnZXRfZGF0YSIsImJ1aWxkX3BhdGgiLCJrZXlzIiwidGFibGVzIiwiciIsImxvb2t1cF90YWJsZXMiLCJyb290Iiwicm9vdF9kYXRhIiwia2V5IiwibmV4dCIsInRhYmxlc19kYXRhIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJ4IiwiZSIsInkiLCJtIiwic3RhdHMiLCJDYW1saW50ZXJuYWxPTyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFF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QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUEwQixNQTRGcEIsU0FBQXRHLE9BQWtCO0FBQUEsU0FBeUI7QUFBQSxhQUFBc0csTUExRnZELEtBQUF0RyxPQUFBO0FBQUE7QUFBQSxVQUFBa0c7QUFBQUEsWUFBQSxTQUFBdEI7QUFBQUEsaUJBQUEsTUFDWTtBQUFBLGFBQWdCLDJEQUE2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQUFzQixRQTBGbkM7QUFBQSxLQU1wQjtBQUFBLEtBQTBCO0FBQUE7QUFBQSxHQUV4QjtBQUFBLFlBQUFLLE1BQUEzQztBQUFBQSxJQVFKO0FBQUEsR0FDeUQ7QUFBQTtBQUFBLElBQUE0QztBQUFBQSxNQTdlVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRIbEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAoT2JqLm1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgT2JqLm1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBPYmoub2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIE9iai5tYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIE9iai5tYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIE9iai5tYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBPYmoubWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IE9iai5tYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgT2JqLm1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgT2JqLnJlcHIgaW5pdCB8XTtcbiAgICAgT2JqLm1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gT2JqLnJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBPYmoubWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IE9iai5tYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBPYmoubWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjc4NjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0di5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0JpdHZfYndfb3IiLCJjc3RfQml0dl9vZl9saXN0IiwiY3N0X0JpdHZfb2ZfbGlzdF93aXRoX2xlbmd0aCIsImNzdF9iaXR2X21sIiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHQiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21vZCIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJnbG9iYWxfZGF0YSIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYiIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfQ2hhciIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9BcnJheSIsInNldF9ieXRlIiwicyIsImkiLCJ4IiwibGVuZ3RoIiwidiIsImVxdWFsIiwibiIsImNzdF9CaXR2X3Rhbmltb3RvIiwiY3N0X0JpdHZfb2Zfc3RyaW5nIiwiY3N0X0JpdHZfc3ViIiwiY3N0X0JpdHZfYmxpdCIsImNzdF9CaXR2X2J3X2FuZCIsImNzdF9CaXR2X2ZpbGwiLCJjc3RfQml0dl9zZXQiLCJjc3RfQml0dl9nZXQiLCJjc3RfQml0dl9jcmVhdGUiLCJtYXhfbGVuZ3RoIiwiZXhjZWVkc19tYXhfbGVuZ3RoIiwibG93X21hc2siLCJjcmVhdGUiLCJiIiwiaW5pdHYiLCJxIiwiciIsImNvcHkiLCJ1bnNhZmVfZ2V0IiwiZ2V0IiwidW5zYWZlX3NldCIsImMiLCJtYXNrIiwic2V0IiwiaW5pdCIsImZpbGwiLCJvZnMiLCJsZW4iLCJmaXJzdCIsInN0YXJ0Iiwic3RvcCIsIml0ZXIiLCJtYXAiLCJsIiwiaXRlcmkiLCJtYXBpIiwiZm9sZF9sZWZ0IiwiZm9sZF9yaWdodCIsImZvbGRpX2xlZnQiLCJmb2xkaV9yaWdodCIsIm50eiIsIml0ZXJpX3RydWUiLCJpX2JwaSIsIm5haXZlX3BvcCIsInBvcCIsImFjYyIsImJ3X2FuZCIsInYxIiwidjIiLCJiMSIsImIyIiwiYSIsImJ3X29yIiwiYndfeG9yIiwiYndfbm90Iiwib2ZfbGlzdCIsImFkZF9lbGVtZW50Iiwib2ZfbGlzdF93aXRoX2xlbmd0aCIsInRvX2xpc3QiLCJ1bnNhZmVfYmxpdCIsIm9mczEiLCJvZnMyIiwiYmxpdCIsInN1YiIsImFwcGVuZCIsImwxIiwibDIiLCJjb25jYXQiLCJ2bCIsInNpemUiLCJzeiIsInJlcyIsInBvcyIsImFsbF96ZXJvcyIsImFsbF9vbmVzIiwibSIsInNoaWZ0bCIsImNvdW50ZXIiLCJkIiwic2hpZnRyIiwicm90YXRlbCIsInJvdGF0ZXIiLCJncmF5X2l0ZXIiLCJidiIsIlMiLCJJIiwidG9fc3RyaW5nIiwicHJpbnQiLCJmbXQiLCJvZl9zdHJpbmciLCJMIiwiTSIsInRhbmltb3RvIiwidG9fYmluIiwid3JpdGUiLCJvdXRwdXRfYmluIiwib3V0X2NoIiwidG9fYnl0ZXMiLCJ0IiwiYnVmIiwib2ZfYmluIiwicmVhZCIsInBhcmFtIiwiaW5wdXRfYmluIiwiaW5fY2giLCJvZl9ieXRlcyIsInAiLCJyZXQiLCJvZl9pbnRfZ2VuIiwiZ2V0Ynl0ZSIsImdldGJpdCIsIm9mX2ludF91cyIsIm9mX2ludF9zIiwidG9faW50X2dlbiIsInplcm8iLCJzaGlmdG9yIiwidG9faW50X3VzIiwidG9faW50X3MiLCJnZXRieXRlMzIiLCJnZXRiaXQzMiIsIm9mX2ludDMyX3VzIiwib2ZfaW50MzJfcyIsInNoaWZ0b3IzMiIsInRvX2ludDMyX3VzIiwidG9faW50MzJfcyIsImdldGJ5dGU2NCIsImdldGJpdDY0Iiwib2ZfaW50NjRfdXMiLCJvZl9pbnQ2NF9zIiwic2hpZnRvcjY0IiwidG9faW50NjRfdXMiLCJ0b19pbnQ2NF9zIiwic2VsZWN0X29mIiwiZjMyIiwiZjY0Iiwib2ZfbmF0aXZlaW50X3MiLCJvZl9uYXRpdmVpbnRfdXMiLCJzZWxlY3RfdG8iLCJ0b19uYXRpdmVpbnRfcyIsInRvX25hdGl2ZWludF91cyIsIkJpdHYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0Zsb2F0Vmlldy9GbG9hdFZpZXcvX29wYW0vLm9wYW0tc3dpdGNoL2J1aWxkL2JpdHYuMi4wL19idWlsZC9kZWZhdWx0L2JpdHYubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxTQUFBQyxHQUFBQyxHQUFBQyxHQzJCcUIseUNBQXdDO0FBQUEsWUFBQUMsT0FBQUMsR0FPOUMsWUFBUTtBQUFBO0FBQUEsSUFBQUMsUURsQ3ZCO0FBQUEsSUFBQUMsSUFBQTtBQUFBLFVDMENFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBL0MsaUNBQUE7QUFBQSxJQUFBQSwrQkFBQTtBQUFBLElBQUFELHFCQUFBO0FBQUEsSUFBQUEsbUJBQUE7QUFBQSxJQUFBRCxtQkFBQTtBQUFBLElBQUFBLGlCQUFBO0FBQUEsSUFBQWtELGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLG1CQUFBWDtBQUFBQTtBQUFBQSxLQUFBTixJQUdBO0FBQUEsWUFDQTtBQUFBLEtBQUFBLE1BQUE7QUFBQTtBQUFBLEdBQTBEO0FBQUE7QUFBQSxJQUFBa0I7QUFBQUEsTUFFN0Msd0NBQUFqQixHQUF1Qix3QkFBYTtBQUFBLFlBQUFrQixPQUFBYixHQUFBYztBQUFBQSxRQUFBLE9BR2pEO0FBQUEsYUFBZ0M7QUFBQSxRQUFBQyxRQUNoQyxhQUFBQyxJQUNBLGFBQUFDLElBQ0E7QUFBQSxJQUNBO0FBQUEsZ0JBQ29DO0FBQUEsS0FBYixtREFBNkI7QUFBQTtBQUFBO0FBQUEsWUFFdkI7QUFBQSxLQUFBdkIsSUFBbkI7QUFBQSxJQUNSLHVCQUF5QjtBQUFBLElBQWE7QUFBQSxHQUVyQztBQUFBLFlBQUF3QixLQUFBcEI7QUFBQUEsUUFBQSxPQVNvQztBQUFBLElBQWlCO0FBQUEsR0FBRTtBQUFBLFlBQUFxQixXQUFBckIsR0FBQUU7QUFBQUEsUUFBQUwsSUFHMUQsYUFBQUQsSUFDQTtBQUFBLElBakRzQiwrREFpRFA7QUFBQSxHQUE0QjtBQUFBLFlBQUEwQixJQUFBdEIsR0FBQUU7QUFBQUEsUUFBQSxPQUczQztBQUFBLGFBQStCO0FBQUEsSUFDL0IsdUJBQWM7QUFBQTtBQUFBLFlBQUFxQixXQUFBdkIsR0FBQUUsR0FBQWM7QUFBQUE7QUFBQUEsS0FBQW5CLElBR2Q7QUFBQSxLQUFBRCxJQUNBO0FBQUEsS0FBQTRCLElBekRzQjtBQUFBLEtBQUFDLE9BMER0QjtBQUFBLFlBQ0EsbUJBQW9EO0FBQUEsSUFBcEQsOEJBQWdFO0FBQUE7QUFBQSxZQUFBQyxJQUFBMUIsR0FBQUUsR0FBQWM7QUFBQUEsUUFBQSxPQUdoRTtBQUFBLGFBQStCO0FBQUEsSUFDL0IsMEJBQWdCO0FBQUE7QUFBQSxZQUFBVyxLQUFBekIsR0FBQTFCO0FBQUFBLFFBQUF3QixJQUtSLHFCQUNSO0FBQUE7QUFBQSxTQUFBSCxJQUFBO0FBQUE7QUFBQSxNQUF1QixpQkFBZTtBQUFBLGlCQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUMzQztBQUFBLEdBQUM7QUFBQSxZQUFBK0IsS0FBQTVCLEdBQUE2QixLQUFBQyxLQUFBZDtBQUFBQSxRQUFBLE9BR0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFtRDtBQUFBLGVBQ25EO0FBQUE7QUFBQTtBQUFBLE1BQUFHLElBQWdCO0FBQUEsTUFBQVksUUFHaEIsY0FBaUM7QUFBQSxhQUNqQztBQUFBO0FBQUEsVUFBQWxDLE1BQUE7QUFBQTtBQUFBLE9BQWdDO0FBQUEsa0JBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQUFtQyxRQUVoRDtBQUFBLE1BQUE5QixJQUNBO0FBQUEsYUFDQTtBQUFBLE1BQUFKLElBQVE7QUFBQSxhQUNSO0FBQUE7QUFBQSxVQUFBRCxNQUFBO0FBQUE7QUFBQSxPQUFrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFBRCxJQUVsQyw4QkFDQTtBQUFBO0FBQUEsVUFBQXFDLE9BQ0Usc0JBQ0E7QUFBQTtBQUFBLFdBQUFwQyxJQUFBO0FBQUE7QUFBQSxRQUFnQztBQUFBLG1CQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQWhEO0FBQUE7QUFBQTtBQUFBLGlCQUZGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBWkE7QUFBQTtBQUFBLEdBZUM7QUFBQSxZQUFBcUMsS0FBQTFELEdBQUF3QjtBQUFBQSxRQUFBLE9BT0Q7QUFBQTtBQUFBLFNBQUFILElBQUE7QUFBQTtBQUFBLE1BQTZCLGNBQUU7QUFBQSxpQkFBZ0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQS9DO0FBQUEsR0FBb0Q7QUFBQSxZQUFBc0MsSUFBQTNELEdBQUF3QjtBQUFBQSxRQUFBb0MsSUFHcEQsTUFBQWpCLElBQ1EscUJBQ1I7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxNQUNFLGlCQUFlLGNBQUc7QUFBQSxpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXJDO0FBQUEsR0FBQztBQUFBLFlBQUF3QyxNQUFBN0QsR0FBQXdCO0FBQUFBLFFBQUEsT0FHRDtBQUFBO0FBQUEsU0FBQUgsSUFBQTtBQUFBO0FBQUEsTUFBNkIsaUJBQUk7QUFBQSxpQkFBZ0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQWpEO0FBQUEsR0FBc0Q7QUFBQSxZQUFBeUMsS0FBQTlELEdBQUF3QjtBQUFBQSxRQUFBb0MsSUFHdEQsTUFBQWpCLElBQ1EscUJBQ1I7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxNQUNFLGlCQUFlLGlCQUFLO0FBQUEsaUJBQWlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUV2QztBQUFBLEdBQUM7QUFBQSxZQUFBMEMsVUFBQS9ELEdBQUFzQixHQUFBRTtBQUFBQSxRQUFBbUIsSUFHRCxlQUNBO0FBQUE7QUFBQSxTQUFBdEIsSUFBQTtBQUFBO0FBQUEsaUJBQ1k7QUFBQSxNQUFMO0FBQUEsaUJBQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUU1QjtBQUFBLEdBQUU7QUFBQSxZQUFBMkMsV0FBQWhFLEdBQUF3QixHQUFBRjtBQUFBQSxRQUFBcUIsSUFHRixlQUNBO0FBQUE7QUFBQSxTQUFBdEIsSUFBQTtBQUFBO0FBQUEsaUJBQ1M7QUFBQSxhQUFGLGNBQUU7QUFBQSxpQkFBbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTVCO0FBQUEsR0FBRTtBQUFBLFlBQUE0QyxXQUFBakUsR0FBQXNCLEdBQUFFO0FBQUFBLFFBQUFtQixJQUdGLGVBQ0E7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxpQkFDYztBQUFBLE1BQVA7QUFBQSxpQkFBdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTlCO0FBQUEsR0FBRTtBQUFBLFlBQUE2QyxZQUFBbEUsR0FBQXdCLEdBQUFGO0FBQUFBLFFBQUFxQixJQUdGLGVBQ0E7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxpQkFDVztBQUFBLGFBQUosaUJBQUk7QUFBQSxpQkFBbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTlCO0FBQUEsR0FBRTtBQUFBLE9BQUE4QyxNQVlNLGdDQUFBOUMsSUFBZ0I7QUFBQTtBQUFBLGNBQ0M7QUFBQTtBQUFBLGNBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQStDLFdBQUFwRSxHQUFBd0I7QUFBQUEsSUFJM0M7QUFBQTtBQUFBLHNCQUFBSCxHQUFBMkI7QUFBQUEsa0JBQUFxQixRQUVLLFFBQUEvQyxJQVFBO0FBQUE7QUFBQSwwQkFOTDtBQUFBO0FBQUEsbUJBQUFrQixJQUFlO0FBQUEsZUFFYjtBQUFBLG1CQUFBbEIsTUFBa0I7QUFBQTtBQUFBO0FBQUEsYUFJSTtBQUFBLGtCQUNoQjtBQUFBO0FBQUEsWUFBQWdELFVBQUFoRDtBQUFBQSxJQUtSO0FBQUE7QUFBQSxJQUNBLHlCQUF5QixzQ0FBMkI7QUFBQTtBQUFBLGFBRTNDO0FBQUEsWUFBQWlELElBQUEvQztBQUFBQSxRQUFBRSxJQUlULDRCQUFBYyxJQUNBLE1BQUFnQyxNQUdBLEdBQUFuRCxJQUFBO0FBQUE7QUFBQSxLQURFLFdBQWU7QUFBQTtBQUFBLE1BQUFBLE1BQVM7QUFBQSxNQUFBSyxNQTFMSjtBQUFBLE1BQUE4QyxRQTBMK0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUM3QztBQUFBLFlBQUFDLE9BQUFDLElBQUFDO0FBQUFBLFFBQUFmLElBUVI7QUFBQSxJQUNBLGdCQUF1QjtBQUFBO0FBQUEsS0FBQWdCLEtBQ3ZCO0FBQUEsS0FBQUMsS0FBQTtBQUFBLEtBQUFuRCxJQUVBO0FBQUEsWUFDcUI7QUFBQSxLQUFBb0QsSUFBYjtBQUFBLFlBQ1I7QUFBQTtBQUFBO0FBQUEsU0FBQXpELElBQUE7QUFBQTtBQUFBLE1BQ0U7QUFBQSxjQTFNb0I7QUFBQSxpQkEwTXVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUU3QztBQUFBLEdBQXdCO0FBQUEsWUFBQTBELE1BQUFMLElBQUFDO0FBQUFBLFFBQUFmLElBR3hCO0FBQUEsSUFDQSxnQkFBdUI7QUFBQTtBQUFBLEtBQUFnQixLQUN2QjtBQUFBLEtBQUFDLEtBQUE7QUFBQSxLQUFBbkQsSUFFQTtBQUFBLFlBQ3FCO0FBQUEsS0FBQW9ELElBQWI7QUFBQSxZQUNSO0FBQUE7QUFBQTtBQUFBLFNBQUF6RCxJQUFBO0FBQUE7QUFBQSxNQUNFO0FBQUEsY0F0Tm9CO0FBQUEsaUJBc05zQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFNUM7QUFBQSxHQUF3QjtBQUFBLFlBQUEyRCxPQUFBTixJQUFBQztBQUFBQSxRQUFBZixJQUd4QjtBQUFBLElBQ0EsZ0JBQXVCO0FBQUE7QUFBQSxLQUFBZ0IsS0FDdkI7QUFBQSxLQUFBQyxLQUFBO0FBQUEsS0FBQW5ELElBRUE7QUFBQSxZQUNxQjtBQUFBLEtBQUFvRCxJQUFiO0FBQUEsWUFDUjtBQUFBO0FBQUE7QUFBQSxTQUFBekQsSUFBQTtBQUFBO0FBQUEsTUFDRTtBQUFBLGNBbE9vQjtBQUFBLGlCQWtPdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTdDO0FBQUEsR0FBd0I7QUFBQSxZQUFBNEQsT0FBQXpEO0FBQUFBO0FBQUFBLEtBQUFnQixNQUd4QjtBQUFBLEtBQUFkLElBQ0E7QUFBQSxZQUNxQjtBQUFBLEtBQUFvRCxJQUFiO0FBQUEsWUFDUjtBQUFBO0FBQUE7QUFBQSxTQUFBekQsTUFBQTtBQUFBO0FBQUEsTUFDRTtBQUFBLHNCQUF1Qix1QkEzT0g7QUFBQSxpQkEyT3FCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFBc0IsTUFFM0MsY0FBQUEsSUF0TUE7QUFBQSxJQUNBO0FBQUE7QUFBQSxNQUFBSCxJQUNFO0FBQUEsTUFBQXBCLElBQ0E7QUFBQSxNQUFBQyxJQUNrRDtBQUFBLGFBQVo7QUFBQSxLQUFOLHVCQTNDWjtBQUFBO0FBQUEsSUE4T1g7QUFBQSxHQUNWO0FBQUEsWUFBQTZELFFBQUF0QjtBQUFBQTtBQUFBQSxLQUFBbEMsSUFLVztBQUFBLFlBQ1o7QUFBQTtBQUFBLGFBQWdDO0FBQUEsUUFBQWMsSUFDeEI7QUFBQSxhQUFBMkMsWUFBQTlEO0FBQUFBLEtBR04sVUFBYztBQUFBLEtBQ2QsMEJBQW1CO0FBQUE7QUFBQSxJQUVyQjtBQUFBLElBQXVCO0FBQUEsR0FDdEI7QUFBQSxZQUFBK0Qsb0JBQUF4QixHQUFBTjtBQUFBQSxRQUFBLE9BR0Q7QUFBQSxhQUFvQztBQUFBLFFBQUFkLElBQzVCO0FBQUEsYUFBQTJDLFlBQUE5RDtBQUFBQSxTQUFBLE9BRU47QUFBQSxjQUEwQjtBQUFBLEtBQzFCLDBCQUFtQjtBQUFBO0FBQUEsSUFFckI7QUFBQSxJQUF1QjtBQUFBLEdBQ3RCO0FBQUEsWUFBQWdFLFFBQUE3QztBQUFBQSxRQUFBZCxJQTlQWSxNQUFBTCxNQXNRYixXQUFBQSxJQUFBLEtBQUFtRCxNQUFBO0FBQUE7QUFBQSxLQUhFLFVBQWM7QUFBQSxTQUFBQSxRQUNTLHNDQUFBbkQsTUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBLEdBRXZCO0FBQUEsWUFBQWlFLFlBQUFWLElBQUFXLE1BQUFWLElBQUFXLE1BQUFsQztBQUFBQSxRQUFBLE9BZ0JoQjtBQUFBO0FBQUEsS0FDRTtBQUFBLE1BQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBSUk7QUFBQSxnQkFGSjtBQUFBO0FBQUEsVUFBQWpDLE1BQUE7QUFBQTtBQUFBO0FBQUEsUUFBQUssSUFDRTtBQUFBLFFBQUFMLElBaEJOO0FBQUEsUUFBQUcsSUFwUnNCO0FBQUEsUUFBQUUsTUFvU3FDO0FBQUEsUUFBQUwsTUFaM0Q7QUFBQSxRQUFBMkIsSUF4UnNCO0FBQUEsUUFBQUMsT0EwUnRCO0FBQUEsZUFDQSxtQkFBK0M7QUFBQSxPQUEvQztBQUFBLGtCQVMyRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBRHZEO0FBQUE7QUFBQTtBQUFBLGdCQUpKO0FBQUE7QUFBQSxHQU1RO0FBQUEsWUFBQXdDLEtBQUFmLElBQUFhLE1BQUFaLElBQUFhLE1BQUFsQztBQUFBQSxRQUFBLE9BSVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRUs7QUFBQSxJQUNMLGlEQUF5QztBQUFBO0FBQUEsWUFBQW9DLElBQUFsRSxHQUFBNkIsS0FBQUM7QUFBQUEsUUFBQSxPQUd6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQW1EO0FBQUEsUUFBQVgsSUFDM0M7QUFBQSxJQUNSO0FBQUEsSUFBbUM7QUFBQSxHQUNsQztBQUFBLFlBQUFnRCxPQUFBakIsSUFBQUM7QUFBQUE7QUFBQUEsS0FBQWlCLEtBR0Q7QUFBQSxLQUFBQyxLQUFBO0FBQUEsS0FBQWxELElBRVE7QUFBQSxLQUFBaUMsS0FDUjtBQUFBLEtBQUFwQyxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUE2QjtBQUFBLEdBQzVCO0FBQUEsWUFBQXNELE9BQUFDO0FBQUFBO0FBQUFBLEtBQUFDO0FBQUFBLE9BR1U7QUFBQSxtQ0FBQUMsSUFBQXpFLEdBQTRCLHFCQUFhO0FBQUEsS0FBQTBFLE1BQzFDO0FBQUEsS0FBQTFELElBQ1Y7QUFBQSxLQUFBMkQsTUFDQTtBQUFBLElBQ0E7QUFBQTtBQUFBLGVBQUEzRTtBQUFBQSxXQUFBRSxJQUVLO0FBQUEsT0FDQTtBQUFBLE9BQTZCO0FBQUE7QUFBQSxNQUNkO0FBQUE7QUFBQSxJQUNoQjtBQUFBLEdBQ0Q7QUFBQSxZQUFBMEUsVUFBQTVFO0FBQUFBLFFBQUFnQixJQUtILE1BQUFkLElBQ0EseUJBQUFMLElBRUE7QUFBQTtBQUFBLGdCQURpQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQWhWSztBQUFBLE1BZ1ZjLGFBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUEsS0FBbkI7QUFBQTtBQUFBLEdBQ1g7QUFBQSxZQUFBZ0YsU0FBQTdFO0FBQUFBLFFBQUFnQixJQUdOLE1BQUFkLElBQ0EsK0JBUUE7QUFBQTtBQUFBLFFBQUFMLElBQUE7QUFBQTtBQUFBLEtBTkU7QUFBQTtBQUFBLE9BQUFpRixJQUNFO0FBQUEsYUFDQSxnQkFBcUM7QUFBQSxNQXpWbkIsa0RBeVZWO0FBQUE7QUFBQSxlQXpWVTtBQUFBLEtBMlZWO0FBQUEsU0FBQWpGLE1BQUE7QUFBQTtBQUFBO0FBQUEsR0FFRztBQUFBLFlBQUFrRixTQUFBQyxTQUFBaEYsR0FBQWlGO0FBQUFBLElBT2YsWUFDRSxjQVFDO0FBQUEsSUFQRTtBQUFBLFNBQUEvRSxJQUVBLE1BQUFpQixJQUVLO0FBQUEsS0FDUixVQUFjO0FBQUEsS0FDZDtBQUFBO0FBQUEsY0FMQTtBQUFBLDBFQU1DO0FBQUEsUUFBQTZELFlBTkQ7QUFBQSxzQ0FNQztBQUFBO0FBQUEsWUFBQUQsT0FBQS9FLEdBQUFpRixHQVRILE9EN1hGLGdCQzZYRSxrQkQ3WEY7QUFBQSxZQUFBQyxTQUFBRixTQUFBaEYsR0FBQWlGO0FBQUFBLElDeVlFLFlBQ0UsY0FRQztBQUFBLElBUEU7QUFBQSxTQUFBL0UsSUFFQSxNQUFBaUIsSUFFSztBQUFBLEtBQ1IsVUFBYztBQUFBLEtBQ2Q7QUFBQTtBQUFBLGNBTEE7QUFBQSwwRUFNQztBQUFBLFFBQUE2RCxZQU5EO0FBQUEsc0NBTUM7QUFBQTtBQUFBLFlBQUFFLE9BQUFsRixHQUFBaUYsR0FUSCxPRHpZRixnQkN5WUUsa0JEellGO0FBQUEsWUFBQUUsVUFBQUgsU0FBQWhGLEdBQUFpRjtBQUFBQSxJQ3daRTtBQUFBLGVBQ0U7QUFBQSw0RUFXQztBQUFBLFNBQUFELFlBWEQ7QUFBQSx3Q0FXQztBQUFBO0FBQUEsUUFBQTlFLElBVEg7QUFBQSxJQUNBO0FBQUEsU0FBQStFLE1BRUssZ0JBQUE5RCxJQUVLO0FBQUEsS0FDUjtBQUFBLEtBQ0E7QUFBQSxLQUFxQztBQUFBO0FBQUEsSUFMckMsY0FPQztBQUFBO0FBQUEsWUFBQWdFLFFBQUFuRixHQUFBaUYsR0FaSCxPRHhaRixnQkN3WkUsbUJEeFpGO0FBQUEsWUFBQUcsVUFBQUosU0FBQWhGLEdBQUFpRjtBQUFBQSxJQ3VhRTtBQUFBLGVBQ0U7QUFBQSw0RUFXQztBQUFBLFNBQUFELFlBWEQ7QUFBQSx3Q0FXQztBQUFBO0FBQUEsUUFBQTlFLElBVEg7QUFBQSxJQUNBO0FBQUEsU0FBQStFLE1BRUssZ0JBQUE5RCxJQUVLO0FBQUEsS0FDUjtBQUFBLEtBQ0E7QUFBQSxLQUFxQztBQUFBO0FBQUEsSUFMckMsY0FPQztBQUFBO0FBQUEsWUFBQWlFLFFBQUFwRixHQUFBaUYsR0FaSCxPRHZhRixnQkN1YUUsbUJEdmFGO0FBQUEsWUFBQUksVUFBQTdHLEdBQUEwQjtBQUFBQSxRQUFBb0YsS0MrYlcsb0JBV1Q7QUFBQTtBQUFBLElBQWM7QUFBQSxLQVRaO0FBQUEsS0FDQSxzQkFBcUI7QUFBQSxLQUNyQjtBQUFBLFNBQUF6RixJQVBGO0FBQUE7QUFBQSxNQUhFLFlBQWM7QUFBQSxNQUNYO0FBQUEsVUFBQUEsTUFBMkI7QUFBQTtBQUFBO0FBQUEsU0FBQThFLE1BVUMsaUJBQy9CO0FBQUE7QUFBQSxLQUNFLHdCQUF1QjtBQUFBO0FBQUEsR0FJTjtBQUFBLFlBQUFZLEVBQUFDO0FBQUFBLGFBQUFDLFVBQUF6RjtBQUFBQTtBQUFBQSxNQUFBRSxJQUtuQjtBQUFBLE1BQUFOLElBQ1E7QUFBQSxZQUNSO0FBQUE7QUFBQTtBQUFBLFVBQUFDLElBQUE7QUFBQTtBQUFBLE9BQ0s7QUFBQSxZQUFBQSxNQUFvQjtBQUFBO0FBQUE7QUFBQSxpQkFBTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FFbkIsc0NBQXdCO0FBQUE7QUFBQSxhQUFBNkYsTUFBQUMsS0FBQTNGO0FBQUFBLFNBQUEsTUFFbUI7QUFBQSxLQUFhO0FBQUE7QUFBQSxhQUFBNEYsVUFBQWhHO0FBQUFBO0FBQUFBLE1BQUFNLElBR3hEO0FBQUEsTUFBQUYsSUFDUTtBQUFBLFlBQ1I7QUFBQTtBQUFBO0FBQUEsVUFBQUgsSUFBQTtBQUFBO0FBQUEsV0FBQTJCLElBQ0U7QUFBQSxPQUNBO0FBQUEsa0JBQ0wsR0FBQTNCLE1BQUE7QUFBQTtBQUFBO0FBQUEseUJBRWlCO0FBQUEsaUJBSFo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBS0Y7QUFBQSxJQUFDO0FBQUEsSURsZUw7QUFBQTtBQUFBLE9BQUFnRyxJQzRNcUMsV0FBQUMsSUFBQTtBQUFBLFlBQUFDLFNBQUE3QyxJQUFBQztBQUFBQSxRQUFBZixJQTZSbkM7QUFBQSxJQUNBLGdCQUF1QjtBQUFBLFFBQUFrQixJQUNmLFNBQUF0QyxJQUNBLFNBQUFRLElBQ0EsSUFBSTtBQUFBLElBQ29CO0FBQUE7QUFBQSxZQUFBd0UsT0FBQUMsT0FBQWpHO0FBQUFBO0FBQUFBLEtBQUFGLElBbUJoQztBQUFBO0FBQUEsT0FkQTtBQUFBO0FBQUE7QUFBQSxrQkFBQUQ7QUFBQUEsVUFBdUIsZ0VBQW9DO0FBQUE7QUFBQSxJQWMzRCxXQUF5QjtBQUFBLElBQWdCLGdEQUNsQjtBQUFBO0FBQUEsWUFBQXFHLFdBQUFDLFFBQUFuRztBQUFBQSxRQUFBaUcsUUFHWDtBQUFBLElBQ1osdUJBQWM7QUFBQTtBQUFBLFlBQUFHLFNBQUFDO0FBQUFBLFFBQUFDLE1BR0o7QUFBQSxhQUFBTCxNQUFBbkcsR0FDSSw0Q0FBcUI7QUFBQSxJQUNuQztBQUFBLElBQWMsd0NBQ0s7QUFBQTtBQUFBLFlBQUF5RyxPQUFBQztBQUFBQTtBQUFBQSxLQUFBeEY7QUFBQUEsT0FHVDtBQUFBLHNDQUFBeUYsT0FBdUIsMEJBQU87QUFBQSxJQXpCeEM7QUFBQTtBQUFBLFFBQUEzRSxNQUtBLEdBQUFqQyxJQUFBO0FBQUE7QUFBQSxLQUhFO0FBQUEsU0FBQUEsTUFDSyxXQUFBQyxJQUErQjtBQUFBLEtBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBRSxJQXVCN0M7QUFBQSxLQUFBZ0IsTUFDUjtBQUFBLFdBQ0E7QUFBQTtBQUFBO0FBQUEsU0FBQW5CLE1BQUE7QUFBQTtBQUFBLE1BQ2dDLGdDQUFUO0FBQUEsZ0JBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRWhDO0FBQUEsR0FBQztBQUFBLFlBQUE2RyxVQUFBQztBQUFBQSxhQUFBSCxLQUFBQyxPQUdhLG9DQUFnQjtBQUFBLElBQzlCLG1CQUFXO0FBQUE7QUFBQSxZQUFBRyxTQUFBNUY7QUFBQUEsUUFBQTZGLElBR1g7QUFBQSxhQUFBTCxLQUFBQztBQUFBQSxTQUFBSyxNQUVzQjtBQUFBLEtBQWtCO0FBQUEsS0FBUTtBQUFBLElBQUc7QUFBQSxJQUNuRCxtQkFBVztBQUFBO0FBQUEsWUFBQUMsV0FBQWpGLEtBQUFrRixTQUFBQztBQUFBQSxRQUFBakgsSUFLSCxzQkFDUjtBQUFBO0FBQUEsU0FBQUgsTUFBQTtBQUFBO0FBQUEsZ0JBQWtEO0FBQUEsTUFBbEI7QUFBQSxnQkFBNkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQzVDLHVDQUFRO0FBQUE7QUFBQSxTQUFBQSxJQUFBO0FBQUE7QUFBQSxNQUFlLGlCQUFlO0FBQUEsZ0JBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ2pFO0FBQUEsR0FBQztBQUFBLFlBQUFtSCxRQUFBbEgsR0FBQUQsR0FFZSxxQ0FBdUI7QUFBQSxZQUFBb0gsT0FBQW5ILEdBQUFELEdBQ3hCLHVDQUFvQjtBQUFBLFlBQUFxSCxVQUFBcEg7QUFBQUEsSUFFTTtBQUFBO0FBQUEsMkJBQVg7QUFBQSwyQkFBWSx3QkFBVTtBQUFBO0FBQUEsWUFBQXFILFNBQUFySDtBQUFBQSxJQUVqQjtBQUFBO0FBQUEsMkJBQVg7QUFBQSwyQkFBWSx3QkFBVTtBQUFBO0FBQUEsWUFBQXNILFdBQUFDLE1BQUFDLFNBQUF0SDtBQUFBQSxRQUFBRixJQUc5QztBQUFBLElBQ0E7QUFBQTtBQUFBLGVBQUFELEdBQUEyQjtBQUFBQSxPQUE2QjtBQUFBLE9BQThCO0FBQUE7QUFBQTtBQUFBLElBQVE7QUFBQSxHQUNqRTtBQUFBLFlBQUE4RixRQUFBeEgsR0FBQWtCLEdBQUFuQixHQUVnQixrQkFBZTtBQUFBLFlBQUEwSCxVQUFBdkgsR0FHakMsZ0NBQXNCO0FBQUEsWUFBQXdILFNBQUF4SCxHQUd0QixnQ0FBc0I7QUFBQSxZQUFBeUgsVUFBQTNILEdBQUFELEdBR3VDO0FBQUEsWUFBQTZILFNBQUE1SCxHQUFBRCxHQUU3RCxzQ0FBNEM7QUFBQSxZQUFBOEgsWUFBQTdIO0FBQUFBLElBRWpCO0FBQUE7QUFBQSwyQkFBYjtBQUFBLDJCQUFjLDBCQUFZO0FBQUE7QUFBQSxZQUFBOEgsV0FBQTlIO0FBQUFBLElBRWI7QUFBQTtBQUFBLDJCQUFiO0FBQUEsMkJBQWMsMEJBQVk7QUFBQTtBQUFBLFlBQUErSCxVQUFBL0gsR0FBQWtCLEdBQUFuQixHQUUrQjtBQUFBLFlBQUFpSSxZQUFBOUgsR0FDckQsa0NBQXlCO0FBQUEsWUFBQStILFdBQUEvSCxHQUMxQixrQ0FBeUI7QUFBQSxZQUFBZ0ksVUFBQWxJLEdBQUFEO0FBQUFBLElBR2YsT0FBa0M7QUFBQSxhQUFoRCxlQUFjLDJDQUFrQztBQUFBO0FBQUEsWUFBQW9JLFNBQUFuSSxHQUFBRDtBQUFBQSxJQUVoRCxPQUFiO0FBQUEsNEJBQWEsd0NBQStCO0FBQUE7QUFBQSxZQUFBcUksWUFBQXBJO0FBQUFBLElBRWpCO0FBQUE7QUFBQSwyQkFBYjtBQUFBLDJCQUFjLDBCQUFZO0FBQUE7QUFBQSxZQUFBcUksV0FBQXJJO0FBQUFBLElBRWI7QUFBQTtBQUFBLDJCQUFiO0FBQUEsMkJBQWMsMEJBQVk7QUFBQTtBQUFBLFlBQUFzSSxVQUFBdEksR0FBQWtCLEdBQUFuQjtBQUFBQSxJQUVZLE9BQWhDO0FBQUEsZ0JBQWMsOEJBQWtCLDJCQUFtQjtBQUFBO0FBQUEsWUFBQXdJLFlBQUFySSxHQUNyRCxvQ0FBeUI7QUFBQSxZQUFBc0ksV0FBQXRJLEdBQzFCLG9DQUF5QjtBQUFBLFlBQUF1SSxVQUFBQyxLQUFBQztBQUFBQSxRQUFBLE1BR3BCO0FBQUEsbUJBQ2QsZ0JBQUE1SSxHQUFVLHlCQUEwQixFQUFwQztBQUFBLElBRGM7QUFBQSxLQUVkLGdCQUFBQSxHQUFjLE9BQXNCLGdCQUF0Qix1QkFBc0IsRUFBcEM7QUFBQSxJQUNEO0FBQUEsR0FBWTtBQUFBO0FBQUEsSUFBQTZJLGlCQUNBO0FBQUEsSUFBQUMsa0JBQ0M7QUFBQSxZQUFBQyxVQUFBSixLQUFBQztBQUFBQSxRQUFBLE1BQ0U7QUFBQSxtQkFDZCxnQkFBQTVJLEdBQTZCLHlCQUFPLEVBQXBDO0FBQUEsSUFEYztBQUFBLEtBRWQsZ0JBQUFBLEdBQTZCLE9BQW5CLG9CQUFtQixtQkFBTyxFQUFwQztBQUFBLElBQ0Q7QUFBQSxHQUFZO0FBQUE7QUFBQSxJQUFBZ0osaUJBQ0E7QUFBQSxJQUFBQyxrQkFDQztBQUFBLElBQUFDO0FBQUFBLE1BQWlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEbm1CdkQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgKEMpIEplYW4tQ2hyaXN0b3BoZSBGaWxsaWF0cmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBUaGlzIHNvZnR3YXJlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciAgICAgICAgKilcbigqICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyAgICAgICAgICAgKilcbigqICBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyAgICAgICAgICAgICAgKilcbigqICBkZXNjcmliZWQgaW4gZmlsZSBMSUNFTlNFLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBUaGlzIHNvZnR3YXJlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsICAgICAgKilcbigqICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiAgICAgICAgKilcbigqICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQml0IHZlY3RvcnMuIFRoZSBpbnRlcmZhY2UgYW5kIHBhcnQgb2YgdGhlIGNvZGUgYXJlIGJvcnJvd2VkIGZyb20gdGhlXG4gICBbQXJyYXldIG1vZHVsZSBvZiB0aGUgT0NhbWwgc3RhbmRhcmQgbGlicmFyeSAoYnV0IHRoaW5ncyBhcmUgc2ltcGxpZmllZFxuICAgaGVyZSBzaW5jZSB3ZSBjYW4gYWx3YXlzIGluaXRpYWxpemUgYSBiaXQgdmVjdG9yKS4gVGhpcyBtb2R1bGUgYWxzb1xuICAgcHJvdmlkZXMgYml0d2lzZSBvcGVyYXRpb25zLiAqKVxuXG4oKiBXZSByZXByZXNlbnQgYSBiaXQgdmVjdG9yIGJ5IGEgc3RyaW5nIG9mIGJ5dGVzIChmaWVsZCBbYml0c10pLCBhbmRcbiAgIHdlIGtlZXAgdGhlIGluZm9ybWF0aW9uIG9mIHRoZSBzaXplIG9mIHRoZSBiaXQgdmVjdG9yIChmaWVsZFxuICAgW2xlbmd0aF0pIHNpbmNlIGl0IGNhbiBub3QgYmUgZmlndXJlZCBvdXQgd2l0aCB0aGUgc2l6ZSBvZiB0aGVcbiAgIGFycmF5LiAqKVxuXG5sZXRbQGlubGluZV0gYnl0ZSBzIGkgPSBDaGFyLmNvZGUgKEJ5dGVzLnVuc2FmZV9nZXQgcyBpKVxuXG5sZXQgc2V0X2J5dGUgcyBpIHggPSBCeXRlcy51bnNhZmVfc2V0IHMgaSAoQ2hhci51bnNhZmVfY2hyIHgpXG5cbnR5cGUgdCA9IHtcbiAgbGVuZ3RoIDogaW50O1xuICBiaXRzICAgOiBCeXRlcy50IH1cbiAgKCogaW52YXJpYW50OiB0aGUgdW51c2VkIGhpZ2ggYml0cyBvZiB0aGUgbGFzdCBieXRlIGFyZSB6ZXJvcyAoaWYgYW55KSAqKVxuXG5sZXQgbGVuZ3RoIHYgPSB2Lmxlbmd0aFxuXG5sZXRbQGlubGluZV0gZXF1YWwgKHYxOiB0KSAodjI6IHQpID0gdjEgPSB2MlxuXG5sZXQgbWF4X2xlbmd0aCA9XG4gIGxldCBuID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoICogOCBpblxuICAoKiBXZSB1c2UgNjQgYml0cyBiZWNhdXNlIGl0IGNhbiBvdmVyZmxvdyBvbiBhcmNoaXRlY3R1cmVcbiAgICAgd2l0aCAzMiBiaXRzIGludGVnZXIgbGlrZSBKUyBmb3IgaW5zdGFuY2UuICopXG4gIGlmIG4gPCAwIHRoZW4gbWF4X2ludCBlbHNlIG5cblxubGV0IGV4Y2VlZHNfbWF4X2xlbmd0aCBuID1cbiAgbGV0IHMgPSBuIC8gOCBpblxuICAoaWYgbiBtb2QgOCA9IDAgdGhlbiBzIGVsc2UgcyArIDEpID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5cbmxldCBsb3dfbWFzayA9IEFycmF5LmluaXQgOSAoZnVuIGkgLT4gKDEgbHNsIGkpIC0gMSlcblxubGV0IGNyZWF0ZSBuIGIgPVxuICBpZiBuIDwgMCB8fCBuID4gbWF4X2xlbmd0aCB0aGVuIGludmFsaWRfYXJnIFwiQml0di5jcmVhdGVcIjtcbiAgbGV0IGluaXR2ID0gaWYgYiB0aGVuIDI1NSBlbHNlIDAgaW5cbiAgbGV0IHEgPSBuIGxzciAzIGluXG4gIGxldCByID0gbiBsYW5kIDcgaW5cbiAgaWYgciA9IDAgdGhlblxuICAgIHsgbGVuZ3RoID0gbjsgYml0cyA9IEJ5dGVzLm1ha2UgcSAoQ2hhci5jaHIgaW5pdHYpIH1cbiAgZWxzZSBiZWdpblxuICAgIGxldCBzID0gQnl0ZXMubWFrZSAocSArIDEpIChDaGFyLmNociBpbml0dikgaW5cbiAgICBzZXRfYnl0ZSBzIHEgKGluaXR2IGxhbmQgbG93X21hc2suKHIpKTtcbiAgICB7IGxlbmd0aCA9IG47IGJpdHMgPSBzIH1cbiAgZW5kXG5cbmxldCBub3JtYWxpemUgdiA9XG4gIGxldCByID0gdi5sZW5ndGggbGFuZCA3IGluXG4gIGlmIHIgPiAwIHRoZW5cbiAgICBsZXQgYiA9IHYuYml0cyBpblxuICAgIGxldCBzID0gQnl0ZXMubGVuZ3RoIGIgaW5cbiAgICBzZXRfYnl0ZSBiIChzLTEpICgoYnl0ZSBiIChzLTEpKSBsYW5kIGxvd19tYXNrLihyKSlcblxubGV0IGNvcHkgdiA9IHsgbGVuZ3RoID0gdi5sZW5ndGg7IGJpdHMgPSBCeXRlcy5jb3B5IHYuYml0cyB9XG5cbmxldCB1bnNhZmVfZ2V0IHYgbiA9XG4gIGxldCBpID0gbiBsc3IgMyBpblxuICAoYnl0ZSB2LmJpdHMgaSkgbGFuZCAoMSBsc2wgKG4gbGFuZCA3KSkgPiAwXG5cbmxldCBnZXQgdiBuID1cbiAgaWYgbiA8IDAgfHwgbiA+PSB2Lmxlbmd0aCB0aGVuIGludmFsaWRfYXJnIFwiQml0di5nZXRcIjtcbiAgdW5zYWZlX2dldCB2IG5cblxubGV0IHVuc2FmZV9zZXQgdiBuIGIgPVxuICBsZXQgaSA9IG4gbHNyIDMgaW5cbiAgbGV0IGMgPSBieXRlIHYuYml0cyBpIGluXG4gIGxldCBtYXNrID0gMSBsc2wgKG4gbGFuZCA3KSBpblxuICBzZXRfYnl0ZSB2LmJpdHMgaSAoaWYgYiB0aGVuIGMgbG9yIG1hc2sgZWxzZSBjIGxhbmQgKGxub3QgbWFzaykpXG5cbmxldCBzZXQgdiBuIGIgPVxuICBpZiBuIDwgMCB8fCBuID49IHYubGVuZ3RoIHRoZW4gaW52YWxpZF9hcmcgXCJCaXR2LnNldFwiO1xuICB1bnNhZmVfc2V0IHYgbiBiXG5cbigqIFtpbml0XSBpcyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHVzaW5nIFt1bnNhZmVfc2V0XS4gKilcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHYgPSBjcmVhdGUgbiBmYWxzZSBpblxuICBmb3IgaSA9IDAgdG8gcHJlZCBuIGRvIHVuc2FmZV9zZXQgdiBpIChmIGkpIGRvbmU7XG4gIHZcblxubGV0IGZpbGwgdiBvZnMgbGVuIGIgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gdi5sZW5ndGggLSBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYuZmlsbFwiO1xuICBpZiBsZW4gPiAwIHRoZW4gKFxuICAoKiBpbmNvbXBsZXRlIGZpcnN0IGJ5dGUsIGlmIGFueSAoOC1yIGJpdHMpICopXG4gIGxldCByID0gb2ZzIGxhbmQgNyBpblxuICBsZXQgZmlyc3QgPSBpZiByID0gMCB0aGVuIDAgZWxzZSBtaW4gbGVuICg4LXIpIGluXG4gIGZvciBpID0gb2ZzIHRvIG9mcyArIGZpcnN0LTEgZG8gdW5zYWZlX3NldCB2IGkgYiBkb25lO1xuICAoKiBmdWxsIGJ5dGVzIGluIHRoZSBtaWRkbGUgKilcbiAgbGV0IHN0YXJ0ID0gKG9mcyArIGZpcnN0KSBsc3IgMyBpblxuICBsZXQgbiA9IChsZW4gLSBmaXJzdCkgbHNyIDMgaW5cbiAgbGV0IHggPSBDaGFyLmNociAoaWYgYiB0aGVuIDB4RkYgZWxzZSAwKSBpblxuICBmb3IgaSA9IHN0YXJ0IHRvIHN0YXJ0ICsgbiAtIDEgZG8gQnl0ZXMudW5zYWZlX3NldCB2LmJpdHMgaSB4IGRvbmU7XG4gICgqIGluY29tcGxldGUgbGFzdCBieXRlLCBpZiBhbnkgKilcbiAgbGV0IHMgPSAobGVuIC0gZmlyc3QpIGxhbmQgNyBpblxuICBpZiBzID4gMCB0aGVuXG4gICAgbGV0IHN0b3AgPSBvZnMgKyBsZW4gaW5cbiAgICBmb3IgaSA9IHN0b3AgLSBzIHRvIHN0b3AgLSAxIGRvIHVuc2FmZV9zZXQgdiBpIGIgZG9uZVxuICApXG5cbigqIEFsbCB0aGUgaXRlcmF0b3JzIGFyZSBpbXBsZW1lbnRlZCBhcyBmb3IgdHJhZGl0aW9uYWwgYXJyYXlzLCB1c2luZ1xuICAgW3Vuc2FmZV9nZXRdLiBGb3IgW2l0ZXJdIGFuZCBbbWFwXSwgd2UgZG8gbm90IHByZWNvbXB1dGUgWyhmXG4gICB0cnVlKV0gYW5kIFsoZiBmYWxzZSldIHNpbmNlIFtmXSBtYXkgaGF2ZSBzaWRlLWVmZmVjdHMuICopXG5cbmxldCBpdGVyIGYgdiA9XG4gIGZvciBpID0gMCB0byB2Lmxlbmd0aCAtIDEgZG8gZiAodW5zYWZlX2dldCB2IGkpIGRvbmVcblxubGV0IG1hcCBmIHYgPVxuICBsZXQgbCA9IHYubGVuZ3RoIGluXG4gIGxldCByID0gY3JlYXRlIGwgZmFsc2UgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgdiBpKSlcbiAgZG9uZTtcbiAgclxuXG5sZXQgaXRlcmkgZiB2ID1cbiAgZm9yIGkgPSAwIHRvIHYubGVuZ3RoIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgdiBpKSBkb25lXG5cbmxldCBtYXBpIGYgdiA9XG4gIGxldCBsID0gdi5sZW5ndGggaW5cbiAgbGV0IHIgPSBjcmVhdGUgbCBmYWxzZSBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHYgaSkpXG4gIGRvbmU7XG4gIHJcblxubGV0IGZvbGRfbGVmdCBmIHggdiA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIHYubGVuZ3RoIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB2IGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgdiB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IHYubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCB2IGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkaV9sZWZ0IGYgeCB2ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gdi5sZW5ndGggLSAxIGRvXG4gICAgciA6PSBmICFyIGkgKHVuc2FmZV9nZXQgdiBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZGlfcmlnaHQgZiB2IHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gdi5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmIGkgKHVuc2FmZV9nZXQgdiBpKSAhclxuICBkb25lO1xuICAhclxuXG4oKlxubGV0IGl0ZXJpX3RydWUgZiB2ID1cbiAgQnl0ZXMuaXRlcmlcbiAgICAoZnVuIGkgeCAtPiBsZXQgeCA9IENoYXIuY29kZSB4IGluIGlmIHggIT0gMCB0aGVuIGJlZ2luXG4gICAgICBsZXQgaSA9IGkgbHNsIDMgaW5cbiAgICAgIGZvciBqID0gMCB0byA3IGRvIGlmIHggbGFuZCAoMSBsc2wgaikgPiAwIHRoZW4gZiAoaSArIGopIGRvbmVcbiAgICBlbmQpXG4gICAgdi5iaXRzXG4qKVxuKCogc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgYnkgcHJlY29tcHV0aW5nIE5UWiAqKVxubGV0IG50eiA9IEFycmF5Lm1ha2UgMjU2IDBcbmxldCAoKSA9IGZvciBpID0gMCB0byA3IGRvIG50ei4oMSBsc2wgaSkgPC0gaSBkb25lXG5sZXQgbnR6OCB4ID0gQXJyYXkudW5zYWZlX2dldCBudHogeFxuXG5sZXQgaXRlcmlfdHJ1ZSBmIHYgPVxuICBCeXRlcy5pdGVyaVxuICAgIChmdW4gaSBjIC0+XG4gICAgICAgbGV0IGlfYnBpID0gaSBsc2wgMyBpblxuICAgICAgIGxldCByZWMgdmlzaXQgeCA9XG5cdCBpZiB4ICE9IDAgdGhlbiBiZWdpblxuXHQgICBsZXQgYiA9IHggbGFuZCAoLXgpIGluXG5cdCAgIGYgKGlfYnBpICsgbnR6OCBiKTtcblx0ICAgdmlzaXQgKHggLSBiKVxuXHQgZW5kXG4gICAgICAgaW5cbiAgICAgICB2aXNpdCAoQ2hhci5jb2RlIGMpKVxuICAgIHYuYml0c1xuXG4oKiBQb3B1bGF0aW9uIGNvdW50ICopXG5cbmxldCByZWMgbmFpdmVfcG9wIHggPVxuICBhc3NlcnQgKHggPCAweDEwMCk7XG4gIGlmIHggPSAwIHRoZW4gMCBlbHNlIDEgKyBuYWl2ZV9wb3AgKHggLSAoeCBsYW5kIC14KSlcblxubGV0IHBvcDggPSBBcnJheS5pbml0IDB4MTAwIG5haXZlX3BvcFxubGV0IHBvcDggbiA9IEFycmF5LnVuc2FmZV9nZXQgcG9wOCBuXG5cbmxldCBwb3AgdiA9XG4gIGxldCBuID0gQnl0ZXMubGVuZ3RoIHYuYml0cyBpblxuICBsZXQgYiA9IHYuYml0cyBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIGFjYyBlbHNlIGxvb3AgKGFjYyArIHBvcDggKGJ5dGUgYiBpKSkgKGkgKyAxKSBpblxuICBsb29wIDAgMFxuXG4oKiBCaXR3aXNlIG9wZXJhdGlvbnMuIEl0IGlzIHN0cmFpZ3RoZm9yd2FyZCwgc2luY2UgYml0d2lzZSBvcGVyYXRpb25zXG4gICBjYW4gYmUgcmVhbGl6ZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYml0d2lzZSBvcGVyYXRpb25zIG92ZXIgaW50ZWdlcnMuXG4gICBIb3dldmVyLCBvbmUgaGFzIHRvIHRha2UgY2FyZSBvZiBub3JtYWxpemluZyB0aGUgcmVzdWx0IG9mIFtid25vdF1cbiAgIHdoaWNoIGludHJvZHVjZXMgb25lcyBpbiBoaWdoZXN0IHNpZ25pZmljYW50IHBvc2l0aW9ucy4gKilcblxubGV0IGJ3X2FuZCB2MSB2MiA9XG4gIGxldCBsID0gdjEubGVuZ3RoIGluXG4gIGlmIGwgPD4gdjIubGVuZ3RoIHRoZW4gaW52YWxpZF9hcmcgXCJCaXR2LmJ3X2FuZFwiO1xuICBsZXQgYjEgPSB2MS5iaXRzXG4gIGFuZCBiMiA9IHYyLmJpdHMgaW5cbiAgbGV0IG4gPSBCeXRlcy5sZW5ndGggYjEgaW5cbiAgbGV0IGEgPSBCeXRlcy5tYWtlIG4gKENoYXIuY2hyIDApIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHNldF9ieXRlIGEgaSAoKGJ5dGUgYjEgaSkgbGFuZCAoYnl0ZSBiMiBpKSlcbiAgZG9uZTtcbiAgeyBsZW5ndGggPSBsOyBiaXRzID0gYSB9XG5cbmxldCBid19vciB2MSB2MiA9XG4gIGxldCBsID0gdjEubGVuZ3RoIGluXG4gIGlmIGwgPD4gdjIubGVuZ3RoIHRoZW4gaW52YWxpZF9hcmcgXCJCaXR2LmJ3X29yXCI7XG4gIGxldCBiMSA9IHYxLmJpdHNcbiAgYW5kIGIyID0gdjIuYml0cyBpblxuICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCBiMSBpblxuICBsZXQgYSA9IEJ5dGVzLm1ha2UgbiAoQ2hhci5jaHIgMCkgaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgc2V0X2J5dGUgYSBpICgoYnl0ZSBiMSBpKSBsb3IgKGJ5dGUgYjIgaSkpXG4gIGRvbmU7XG4gIHsgbGVuZ3RoID0gbDsgYml0cyA9IGEgfVxuXG5sZXQgYndfeG9yIHYxIHYyID1cbiAgbGV0IGwgPSB2MS5sZW5ndGggaW5cbiAgaWYgbCA8PiB2Mi5sZW5ndGggdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYuYndfb3JcIjtcbiAgbGV0IGIxID0gdjEuYml0c1xuICBhbmQgYjIgPSB2Mi5iaXRzIGluXG4gIGxldCBuID0gQnl0ZXMubGVuZ3RoIGIxIGluXG4gIGxldCBhID0gQnl0ZXMubWFrZSBuIChDaGFyLmNociAwKSBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBzZXRfYnl0ZSBhIGkgKChieXRlIGIxIGkpIGx4b3IgKGJ5dGUgYjIgaSkpXG4gIGRvbmU7XG4gIHsgbGVuZ3RoID0gbDsgYml0cyA9IGEgfVxuXG5sZXQgYndfbm90IHYgPVxuICBsZXQgYiA9IHYuYml0cyBpblxuICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCBiIGluXG4gIGxldCBhID0gQnl0ZXMubWFrZSBuIChDaGFyLmNociAwKSBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBzZXRfYnl0ZSBhIGkgKDI1NSBsYW5kIChsbm90IChieXRlIGIgaSkpKVxuICBkb25lO1xuICBsZXQgciA9IHsgbGVuZ3RoID0gdi5sZW5ndGg7IGJpdHMgPSBhIH0gaW5cbiAgbm9ybWFsaXplIHI7XG4gIHJcblxuKCogQ29lcmNpb25zIHRvL2Zyb20gbGlzdHMgb2YgaW50ZWdlcnMgKilcblxubGV0IG9mX2xpc3QgbCA9XG4gIGxldCBuID0gMSArIExpc3QuZm9sZF9sZWZ0IG1heCAoLTEpIGwgaW5cbiAgaWYgbiA8IDAgfHwgbiA+IG1heF9sZW5ndGggdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYub2ZfbGlzdFwiO1xuICBsZXQgYiA9IGNyZWF0ZSBuIGZhbHNlIGluXG4gIGxldCBhZGRfZWxlbWVudCBpID1cbiAgICAoKiBuZWdhdGl2ZSBudW1iZXJzIGFyZSBpbnZhbGlkICopXG4gICAgaWYgaSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYub2ZfbGlzdFwiO1xuICAgIHVuc2FmZV9zZXQgYiBpIHRydWVcbiAgaW5cbiAgTGlzdC5pdGVyIGFkZF9lbGVtZW50IGw7XG4gIGJcblxubGV0IG9mX2xpc3Rfd2l0aF9sZW5ndGggbCBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IG1heF9sZW5ndGggdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYub2ZfbGlzdF93aXRoX2xlbmd0aFwiO1xuICBsZXQgYiA9IGNyZWF0ZSBsZW4gZmFsc2UgaW5cbiAgbGV0IGFkZF9lbGVtZW50IGkgPVxuICAgIGlmIGkgPCAwIHx8IGkgPj0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJCaXR2Lm9mX2xpc3Rfd2l0aF9sZW5ndGhcIjtcbiAgICB1bnNhZmVfc2V0IGIgaSB0cnVlXG4gIGluXG4gIExpc3QuaXRlciBhZGRfZWxlbWVudCBsO1xuICBiXG5cbmxldCB0b19saXN0IGIgPVxuICBsZXQgbiA9IGxlbmd0aCBiIGluXG4gIGxldCByZWMgbWFrZSBpIGFjYyA9XG4gICAgaWYgaSA8IDAgdGhlbiBhY2NcbiAgICBlbHNlIG1ha2UgKHByZWQgaSkgKGlmIHVuc2FmZV9nZXQgYiBpIHRoZW4gaSA6OiBhY2MgZWxzZSBhY2MpXG4gIGluXG4gIG1ha2UgKHByZWQgbikgW11cblxubGV0W0BpbmxpbmVdIHBvcyBuID0gbiBsc3IgMywgbiBsYW5kIDdcblxubGV0IHVuc2FmZV9nZXRiIGIgbiA9XG4gIGxldCBpID0gbiBsc3IgMyBpblxuICAoYnl0ZSBiIGkpIGxhbmQgKDEgbHNsIChuIGxhbmQgNykpID4gMFxuXG5sZXQgdW5zYWZlX3NldGIgYiBuIHYgPVxuICBsZXQgaSA9IG4gbHNyIDMgaW5cbiAgbGV0IGMgPSBieXRlIGIgaSBpblxuICBsZXQgbWFzayA9IDEgbHNsIChuIGxhbmQgNykgaW5cbiAgc2V0X2J5dGUgYiBpIChpZiB2IHRoZW4gYyBsb3IgbWFzayBlbHNlIGMgbGFuZCAobG5vdCBtYXNrKSlcblxuKCogQ29waWVzIHYxW29mczEuLm9mczErbGVuWyBpbnRvIHYyW29mczIuLm9mczIrbGVuWyAqKVxubGV0IHVuc2FmZV9ibGl0IGIxIG9mczEgYjIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPiAwIHRoZW5cbiAgICBpZiBvZnMxIGxhbmQgNyA9IDAgJiYgb2ZzMiBsYW5kIDcgPSAwICYmIGxlbiBsYW5kIDcgPSAwIHRoZW5cbiAgICAgIEJ5dGVzLmJsaXQgYjEgKG9mczEgbHNyIDMpIGIyIChvZnMyIGxzciAzKSAobGVuIGxzciAzKVxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXRiIGIyIChvZnMyICsgaSkgKHVuc2FmZV9nZXRiIGIxIChvZnMxICsgaSkpXG4gICAgICBkb25lXG4gICAgICAoKiBUT0RPOiBpbXByb3ZlIGluIG90aGVyIGNhc2VzIHdoZW4gYnl0ZXMgY2FuIGJlIGJhdGNoLWNvcGllZCAqKVxuXG5sZXQgYmxpdCB2MSBvZnMxIHYyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gdjEubGVuZ3RoIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IHYyLmxlbmd0aCAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQml0di5ibGl0XCI7XG4gIHVuc2FmZV9ibGl0IHYxLmJpdHMgb2ZzMSB2Mi5iaXRzIG9mczIgbGVuXG5cbmxldCBzdWIgdiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHYubGVuZ3RoIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJCaXR2LnN1YlwiO1xuICBsZXQgciA9IGNyZWF0ZSBsZW4gZmFsc2UgaW5cbiAgdW5zYWZlX2JsaXQgdi5iaXRzIG9mcyByLmJpdHMgMCBsZW47XG4gIHJcblxubGV0IGFwcGVuZCB2MSB2MiA9XG4gIGxldCBsMSA9IHYxLmxlbmd0aFxuICBhbmQgbDIgPSB2Mi5sZW5ndGggaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGZhbHNlIGluXG4gIGxldCBiMSA9IHYxLmJpdHMgaW5cbiAgbGV0IGIgPSByLmJpdHMgaW5cbiAgQnl0ZXMuYmxpdCBiMSAwIGIgMCAoQnl0ZXMubGVuZ3RoIGIxKTtcbiAgdW5zYWZlX2JsaXQgdjIuYml0cyAwIGIgbDEgbDI7XG4gIHJcblxubGV0IGNvbmNhdCB2bCA9XG4gIGxldCBzaXplID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBzeiB2IC0+IHN6ICsgdi5sZW5ndGgpIDAgdmwgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzaXplIGZhbHNlIGluXG4gIGxldCBiID0gcmVzLmJpdHMgaW5cbiAgbGV0IHBvcyA9IHJlZiAwIGluXG4gIExpc3QuaXRlclxuICAgIChmdW4gdiAtPlxuICAgICAgIGxldCBuID0gdi5sZW5ndGggaW5cbiAgICAgICB1bnNhZmVfYmxpdCB2LmJpdHMgMCBiICFwb3MgbjtcbiAgICAgICBwb3MgOj0gIXBvcyArIG4pXG4gICAgdmw7XG4gIHJlc1xuXG4oKiBUZXN0aW5nIGZvciBhbGwgemVyb3MgYW5kIGFsbCBvbmVzLiAqKVxuXG5sZXQgYWxsX3plcm9zIHYgPVxuICBsZXQgYiA9IHYuYml0cyBpblxuICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCBiIGluXG4gIGxldCByZWMgdGVzdCBpID0gaSA9PSBuIHx8IChieXRlIGIgaSA9PSAwKSAmJiB0ZXN0IChzdWNjIGkpIGluXG4gIHRlc3QgMFxuXG5sZXQgYWxsX29uZXMgdiA9XG4gIGxldCBiID0gdi5iaXRzIGluXG4gIGxldCBuID0gQnl0ZXMubGVuZ3RoIGIgaW5cbiAgbGV0IHJlYyB0ZXN0IGkgPVxuICAgIGlmIGkgPT0gbiAtIDEgdGhlblxuICAgICAgbGV0IG0gPSB2Lmxlbmd0aCBsYW5kIDcgaW5cbiAgICAgIGJ5dGUgYiBpID09IGlmIG0gPT0gMCB0aGVuIDB4RkYgZWxzZSBsb3dfbWFzay4obSlcbiAgICBlbHNlXG4gICAgICBieXRlIGIgaSA9PSAweEZGICYmIHRlc3QgKHN1Y2MgaSlcbiAgaW5cbiAgbiA9IDAgfHwgdGVzdCAwXG5cblxuKCogU2hpZnQgb3BlcmF0aW9ucy4gSXQgaXMgZWFzeSB0byByZXVzZSBbdW5zYWZlX2JsaXRdLCBhbHRob3VnaCBpdCBpc1xuICAgcHJvYmFibHkgc2xpZ2h0bHkgbGVzcyBlZmZpY2llbnQgdGhhbiBhIGFkLWhvYyBwaWVjZSBvZiBjb2RlLiAqKVxuXG5sZXQgcmVjIHNoaWZ0bCB2IGQgPVxuICBpZiBkID09IDAgdGhlblxuICAgIGNvcHkgdlxuICBlbHNlIGlmIGQgPCAwIHRoZW5cbiAgICBzaGlmdHIgdiAoLWQpXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbiA9IHYubGVuZ3RoIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbiBmYWxzZSBpblxuICAgIGlmIGQgPCBuIHRoZW4gdW5zYWZlX2JsaXQgdi5iaXRzIDAgci5iaXRzIGQgKG4gLSBkKTtcbiAgICByXG4gIGVuZFxuXG5hbmQgc2hpZnRyIHYgZCA9XG4gIGlmIGQgPT0gMCB0aGVuXG4gICAgY29weSB2XG4gIGVsc2UgaWYgZCA8IDAgdGhlblxuICAgIHNoaWZ0bCB2ICgtZClcbiAgZWxzZSBiZWdpblxuICAgIGxldCBuID0gdi5sZW5ndGggaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBuIGZhbHNlIGluXG4gICAgaWYgZCA8IG4gdGhlbiB1bnNhZmVfYmxpdCB2LmJpdHMgZCByLmJpdHMgMCAobiAtIGQpO1xuICAgIHJcbiAgZW5kXG5cbigqIFJvdGF0ZSBvcGVyYXRpb25zLiBJdCBpcyBlYXN5IHRvIHJldXNlIFt1bnNhZmVfYmxpdF0sIGFsdGhvdWdoIGl0IGlzXG4gICBwcm9iYWJseSBzbGlnaHRseSBsZXNzIGVmZmljaWVudCB0aGFuIGFuIGFkLWhvYyBwaWVjZSBvZiBjb2RlLiAqKVxuXG5sZXQgcmVjIHJvdGF0ZWwgdiBkID1cbiAgaWYgZCA8IDAgdGhlblxuICAgIHJvdGF0ZXIgdiAoLWQpXG4gIGVsc2VcbiAgbGV0IG4gPSB2Lmxlbmd0aCBpblxuICBpZiBkID09IDAgfHwgbiA9PSAwIHRoZW5cbiAgICBjb3B5IHZcbiAgZWxzZSBiZWdpblxuICAgIGxldCBkID0gZCBtb2QgbiBpblxuICAgIGxldCByID0gY3JlYXRlIG4gZmFsc2UgaW5cbiAgICB1bnNhZmVfYmxpdCB2LmJpdHMgMCByLmJpdHMgZCAobiAtIGQpOyAoKiBzaGlmdGwgKilcbiAgICB1bnNhZmVfYmxpdCB2LmJpdHMgKG4gLSBkKSByLmJpdHMgMCBkOyAoKiB3cmFwYXJvdW5kIG1zIHRvIGxzICopXG4gICAgclxuICBlbmRcblxuYW5kIHJvdGF0ZXIgdiBkID1cbiAgaWYgZCA8IDAgdGhlblxuICAgIHJvdGF0ZWwgdiAoLWQpXG4gIGVsc2VcbiAgbGV0IG4gPSB2Lmxlbmd0aCBpblxuICBpZiBkID09IDAgfHwgbiA9PSAwIHRoZW5cbiAgICBjb3B5IHZcbiAgZWxzZSBiZWdpblxuICAgIGxldCBkID0gZCBtb2QgbiBpblxuICAgIGxldCByID0gY3JlYXRlIG4gZmFsc2UgaW5cbiAgICB1bnNhZmVfYmxpdCB2LmJpdHMgZCByLmJpdHMgMCAobiAtIGQpOyAoKiBzaGlmdHIgKilcbiAgICB1bnNhZmVfYmxpdCB2LmJpdHMgMCByLmJpdHMgKG4gLSBkKSBkOyAoKiB3cmFwYXJvdW5kIGxzIHRvIG1zICopXG4gICAgclxuICBlbmRcblxuKCogSXRlcmF0aW9uIG9uIGFsbCBiaXQgdmVjdG9ycyBvZiBsZW5ndGggW25dIHVzaW5nIGEgR3JheSBjb2RlLiAqKVxuXG5sZXQgZmlyc3Rfc2V0IHYgbiA9XG4gIGxldCByZWMgbG9va3VwIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gcmFpc2UgTm90X2ZvdW5kIDtcbiAgICBpZiB1bnNhZmVfZ2V0IHYgaSB0aGVuIGkgZWxzZSBsb29rdXAgKGkgKyAxKVxuICBpblxuICBsb29rdXAgMFxuXG5sZXQgZ3JheV9pdGVyIGYgbiA9XG4gIGxldCBidiA9IGNyZWF0ZSBuIGZhbHNlIGluXG4gIGxldCByZWMgaXRlciAoKSA9XG4gICAgZiBidjtcbiAgICB1bnNhZmVfc2V0IGJ2IDAgKG5vdCAodW5zYWZlX2dldCBidiAwKSk7XG4gICAgZiBidjtcbiAgICBsZXQgcG9zID0gc3VjYyAoZmlyc3Rfc2V0IGJ2IG4pIGluXG4gICAgaWYgcG9zIDwgbiB0aGVuIGJlZ2luXG4gICAgICB1bnNhZmVfc2V0IGJ2IHBvcyAobm90ICh1bnNhZmVfZ2V0IGJ2IHBvcykpO1xuICAgICAgaXRlciAoKVxuICAgIGVuZFxuICBpblxuICBpZiBuID4gMCB0aGVuIGl0ZXIgKClcblxubW9kdWxlIFMoSSA6IHNpZyB2YWwgbGVhc3RfZmlyc3QgOiBib29sIGVuZCkgPSBzdHJ1Y3RcblxuICBsZXQgdG9fc3RyaW5nIHYgPVxuICAgIGxldCBuID0gdi5sZW5ndGggaW5cbiAgICBsZXQgcyA9IEJ5dGVzLm1ha2UgbiAnMCcgaW5cbiAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgIGlmIHVuc2FmZV9nZXQgdiBpIHRoZW4gQnl0ZXMuc2V0IHMgKGlmIEkubGVhc3RfZmlyc3QgdGhlbiBpIGVsc2Ugbi0xLWkpICcxJ1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5cbiAgbGV0IHByaW50IGZtdCB2ID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgKHRvX3N0cmluZyB2KVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgdiA9IGNyZWF0ZSBuIGZhbHNlIGluXG4gICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYyA9IFN0cmluZy51bnNhZmVfZ2V0IHMgaSBpblxuICAgICAgaWYgYyA9ICcxJyB0aGVuXG5cdHVuc2FmZV9zZXQgdiAoaWYgSS5sZWFzdF9maXJzdCB0aGVuIGkgZWxzZSBuLTEtaSkgdHJ1ZVxuICAgICAgZWxzZVxuXHRpZiBjIDw+ICcwJyB0aGVuIGludmFsaWRfYXJnIFwiQml0di5vZl9zdHJpbmdcIlxuICAgIGRvbmU7XG4gICAgdlxuXG5lbmRcbm1vZHVsZSBMID0gUyhzdHJ1Y3QgbGV0IGxlYXN0X2ZpcnN0ID0gdHJ1ZSBlbmQpXG5tb2R1bGUgTSA9IFMoc3RydWN0IGxldCBsZWFzdF9maXJzdCA9IGZhbHNlIGVuZClcblxubGV0IHRhbmltb3RvIHYxIHYyID1cbiAgbGV0IGwgPSB2MS5sZW5ndGggaW5cbiAgaWYgbCA8PiB2Mi5sZW5ndGggdGhlbiBpbnZhbGlkX2FyZyBcIkJpdHYudGFuaW1vdG9cIjtcbiAgbGV0IGEgPSBwb3AgdjEgaW5cbiAgbGV0IGIgPSBwb3AgdjIgaW5cbiAgbGV0IGMgPSBwb3AgKGJ3X2FuZCB2MSB2MikgaW5cbiAgKGZsb2F0IGMpIC8uIChmbG9hdCAoYSArIGIgLSBjKSlcblxuKCogSW5wdXQvb3V0cHV0IGluIGEgbWFjaGluZS1pbmRlcGVuZGVudCBmb3JtYXQuICopXG5cbmxldCBieXRlc19vZl9pbnQgeCA9XG4gIEJ5dGVzLmluaXQgOCAoZnVuIGkgLT4gQ2hhci5jaHIgKCh4IGxzciAoOCAqIGkpKSBsYW5kIDB4RkYpKVxuXG5sZXQgaW50X29mX2J5dGVzIGIgPVxuICBhc3NlcnQgKEJ5dGVzLmxlbmd0aCBiID0gOCk7XG4gIGxldCByZWMgYnVpbGQgeCBpID1cbiAgICBpZiBpIDwgMCB0aGVuIHhcbiAgICBlbHNlIGJ1aWxkICgoeCBsc2wgOCkgbG9yIENoYXIuY29kZSAoQnl0ZXMuZ2V0IGIgaSkpIChwcmVkIGkpXG4gIGluXG4gIGJ1aWxkIDAgN1xuXG5sZXQgbmJfb2ZfYnl0ZXMgbGVuID1cbiAgbGVuIGxzciAzICsgaWYgbGVuIGxhbmQgNyA9IDAgdGhlbiAwIGVsc2UgMVxuXG5sZXQgdG9fYmluIHdyaXRlIHYgPVxuICBieXRlc19vZl9pbnQgdi5sZW5ndGggfD4gQnl0ZXMuaXRlciB3cml0ZTtcbiAgQnl0ZXMuaXRlciB3cml0ZSB2LmJpdHNcblxubGV0IG91dHB1dF9iaW4gb3V0X2NoIHYgPVxuICBsZXQgd3JpdGUgPSBvdXRwdXRfY2hhciBvdXRfY2ggaW5cbiAgdG9fYmluIHdyaXRlIHZcblxubGV0IHRvX2J5dGVzIHQgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAwIGluXG4gIGxldCB3cml0ZSB4ID0gQnVmZmVyLmFkZF9jaGFyIGJ1ZiB4IGluXG4gIHRvX2JpbiB3cml0ZSB0O1xuICBCdWZmZXIudG9fYnl0ZXMgYnVmXG5cbmxldCBvZl9iaW4gcmVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5pbml0IDggKGZ1biBfIC0+IHJlYWQgKCkpIHw+IGludF9vZl9ieXRlcyBpblxuICBsZXQgdiA9IGNyZWF0ZSBsZW4gZmFsc2UgaW5cbiAgbGV0IGIgPSB2LmJpdHMgaW5cbiAgZm9yIGkgPSAwIHRvIEJ5dGVzLmxlbmd0aCBiIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgYiBpIChyZWFkICgpKVxuICBkb25lO1xuICB2XG5cbmxldCBpbnB1dF9iaW4gaW5fY2ggPVxuICBsZXQgcmVhZCAoKSA9IGlucHV0X2NoYXIgaW5fY2ggaW5cbiAgb2ZfYmluIHJlYWRcblxubGV0IG9mX2J5dGVzIGIgPVxuICBsZXQgcmVhZCA9XG4gICAgbGV0IHAgPSByZWYgMCBpblxuICAgIGZ1biAoKSAtPiBsZXQgcmV0ID0gQnl0ZXMuZ2V0IGIgIXAgaW4gaW5jciBwOyByZXQgaW5cbiAgb2ZfYmluIHJlYWRcblxuKCpzIFRvL2Zyb20gaW50ZWdlcnMuICopXG5cbmxldCBvZl9pbnRfZ2VuIGxlbiBnZXRieXRlIGdldGJpdCA9XG4gIGxldCB2ID0gY3JlYXRlIGxlbiBmYWxzZSBpblxuICBmb3IgaSA9IDAgdG8gKGxlbiBsc3IgMykgLSAxIGRvIHNldF9ieXRlIHYuYml0cyBpIChnZXRieXRlIGkpIGRvbmU7XG4gIGZvciBpID0gbGVuIGxhbmQgKGxub3QgNykgdG8gbGVuIC0gMSBkbyB1bnNhZmVfc2V0IHYgaSAoZ2V0Yml0IGkpIGRvbmU7XG4gIHZcblxubGV0IGdldGJ5dGUgeCBpID0gKHggbHNyICg4KmkpKSBsYW5kIDB4RkZcbmxldCBnZXRiaXQgeCBpID0gKHggbHNyIGkpIGxhbmQgMSA+IDBcbmxldCBvZl9pbnRfdXMgeCA9XG4gIG9mX2ludF9nZW4gKFN5cy5pbnRfc2l6ZSAtIDEpIChnZXRieXRlIHgpIChnZXRiaXQgeClcbmxldCBvZl9pbnRfcyB4ID1cbiAgb2ZfaW50X2dlbiBTeXMuaW50X3NpemUgKGdldGJ5dGUgeCkgKGdldGJpdCB4KVxuXG5sZXQgdG9faW50X2dlbiB6ZXJvIHNoaWZ0b3IgdiA9XG4gIGxldCB4ID0gcmVmIHplcm8gaW5cbiAgQnl0ZXMuaXRlcmkgKGZ1biBpIGMgLT4geCA6PSBzaGlmdG9yICF4IChDaGFyLmNvZGUgYykgKDgqaSkpIHYuYml0cztcbiAgIXhcblxubGV0IHNoaWZ0b3IgeCBiIGkgPSB4IGxvciAoYiBsc2wgaSlcbmxldCB0b19pbnRfdXMgdiA9XG4gICgqIGlmIHYubGVuZ3RoIDwgU3lzLmludF9zaXplIC0gMSB0aGVuIGludmFsaWRfYXJnIFwiQml0di50b19pbnRfdXNcIjsgKilcbiAgdG9faW50X2dlbiAwIHNoaWZ0b3IgdlxubGV0IHRvX2ludF9zIHYgPVxuICAoKiBpZiB2Lmxlbmd0aCA8IFN5cy5pbnRfc2l6ZSB0aGVuIGludmFsaWRfYXJnIFwiQml0di50b19pbnRfc1wiOyAqKVxuICB0b19pbnRfZ2VuIDAgc2hpZnRvciB2XG5cbmxldCBnZXRieXRlMzIgeCBpID1cbiAgSW50MzIudG9faW50IChJbnQzMi5sb2dhbmQgKEludDMyLnNoaWZ0X3JpZ2h0IHggKDgqaSkpIDB4RkZsKVxubGV0IGdldGJpdDMyIHggaSA9XG4gIEludDMyLmxvZ2FuZCAoSW50MzIuc2hpZnRfcmlnaHQgeCBpKSAxbCA+IDBsXG5sZXQgb2ZfaW50MzJfdXMgeCA9XG4gIG9mX2ludF9nZW4gMzEgKGdldGJ5dGUzMiB4KSAoZ2V0Yml0MzIgeClcbmxldCBvZl9pbnQzMl9zIHggPVxuICBvZl9pbnRfZ2VuIDMyIChnZXRieXRlMzIgeCkgKGdldGJpdDMyIHgpXG5cbmxldCBzaGlmdG9yMzIgeCBiIGkgPSBJbnQzMi5sb2dvciB4IChJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgYikgaSlcbmxldCB0b19pbnQzMl91cyB2ID0gdG9faW50X2dlbiAwbCBzaGlmdG9yMzIgdlxubGV0IHRvX2ludDMyX3MgdiA9IHRvX2ludF9nZW4gMGwgc2hpZnRvcjMyIHZcblxubGV0IGdldGJ5dGU2NCB4IGkgPVxuICBJbnQ2NC50b19pbnQgKEludDY0LmxvZ2FuZCAoSW50NjQuc2hpZnRfcmlnaHQgeCAoOCppKSkgMHhGRkwpXG5sZXQgZ2V0Yml0NjQgeCBpID1cbiAgSW50NjQubG9nYW5kIChJbnQ2NC5zaGlmdF9yaWdodCB4IGkpIDFMID4gMExcbmxldCBvZl9pbnQ2NF91cyB4ID1cbiAgb2ZfaW50X2dlbiA2MyAoZ2V0Ynl0ZTY0IHgpIChnZXRiaXQ2NCB4KVxubGV0IG9mX2ludDY0X3MgeCA9XG4gIG9mX2ludF9nZW4gNjQgKGdldGJ5dGU2NCB4KSAoZ2V0Yml0NjQgeClcblxubGV0IHNoaWZ0b3I2NCB4IGIgaSA9IEludDY0LmxvZ29yIHggKEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCBiKSBpKVxubGV0IHRvX2ludDY0X3VzIHYgPSB0b19pbnRfZ2VuIDBMIHNoaWZ0b3I2NCB2XG5sZXQgdG9faW50NjRfcyB2ID0gdG9faW50X2dlbiAwTCBzaGlmdG9yNjQgdlxuXG4oKiBbTmF0aXZlaW50XSAqKVxubGV0IHNlbGVjdF9vZiBmMzIgZjY0ID0gbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT4gKGZ1biBpIC0+IGYzMiAoTmF0aXZlaW50LnRvX2ludDMyIGkpKVxuICB8IDY0IC0+IChmdW4gaSAtPiBmNjQgKEludDY0Lm9mX25hdGl2ZWludCBpKSlcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxubGV0IG9mX25hdGl2ZWludF9zID0gc2VsZWN0X29mIG9mX2ludDMyX3Mgb2ZfaW50NjRfc1xubGV0IG9mX25hdGl2ZWludF91cyA9IHNlbGVjdF9vZiBvZl9pbnQzMl91cyBvZl9pbnQ2NF91c1xubGV0IHNlbGVjdF90byBmMzIgZjY0ID0gbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT4gKGZ1biBpIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoZjMyIGkpKVxuICB8IDY0IC0+IChmdW4gaSAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGY2NCBpKSlcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxubGV0IHRvX25hdGl2ZWludF9zID0gc2VsZWN0X3RvIHRvX2ludDMyX3MgdG9faW50NjRfc1xubGV0IHRvX25hdGl2ZWludF91cyA9IHNlbGVjdF90byB0b19pbnQzMl91cyB0b19pbnQ2NF91c1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4ODc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Inphcml0aC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwidmVyc2lvbiIsIlphcml0aF92ZXJzaW9uIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjg4OTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiemFyaXRoLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfZCIsImNhbWxfZGl2IiwiY2FtbF9lcXVhbCIsImNhbWxfaW50NjRfdG9fZmxvYXQiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX21vZCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9SYW5kb20iLCJTdGRsaWIiLCJTdGRsaWJfQnl0ZXMiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9TeXMiLCJTdGRsaWJfQ2FsbGJhY2siLCJTdGRsaWJfTmF0aXZlaW50IiwiU3RkbGliX0hhc2h0YmwiLCJaYXJpdGhfdmVyc2lvbiIsIk92ZXJmbG93IiwibmVnIiwieCIsImFkZCIsInkiLCJ6Iiwic3ViIiwibXVsIiwiZGl2IiwicmVtIiwiZGl2ZXhhY3QiLCJzdWNjIiwicHJlZCIsImFicyIsImxvZ2FuZCIsImxvZ29yIiwibG9neG9yIiwibG9nbm90Iiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfdHJ1bmMiLCJ1aW50MzJfbWFzayIsIm9mX2ludDMyX3Vuc2lnbmVkIiwidWludDY0X21hc2siLCJvZl9pbnQ2NF91bnNpZ25lZCIsInVpbnRuYXRfbWFzayIsIm9mX25hdGl2ZWludF91bnNpZ25lZCIsInRvX2ludCIsImhhc2giLCJzZWVkZWRfaGFzaCIsImRpdmlzaWJsZSIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJjc3RfWl90ZXN0Yml0IiwiY3N0X1pfZXh0cmFjdF9uZWdhdGl2ZV9iaXRfb2ZmIiwiY3N0X1pfZXh0cmFjdF9ub25wb3NpdGl2ZV9iaXRfIiwiY3N0X1pfc2lnbmVkX2V4dHJhY3RfbmVnYXRpdmVfIiwiY3N0X1pfc2lnbmVkX2V4dHJhY3Rfbm9ucG9zaXRpIiwiY3N0X1pfbG9nMiIsImNzdF9aX2xvZzJ1cCIsImNzdF9yYW5kb21fYml0c19udW1iZXJfb2ZfYml0cyIsImNzdF9yYW5kb21faW50X2JvdW5kX211c3RfYmVfMCIsIm1pbiIsImEiLCJiIiwibWF4IiwibGVxIiwiZ2VxIiwibHQiLCJndCIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsInMiLCJvZl9zdWJzdHJpbmciLCJvZl9zdHJpbmdfYmFzZSIsImJhc2UiLCJlZGl2X3JlbSIsIm1hdGNoIiwiciIsInEiLCJlZGl2IiwiZXJlbSIsImdjZGV4dCIsInUiLCJ2Iiwic3dpdGNoZXIiLCJnIiwibGNtIiwidGVzdGJpdCIsIm4iLCJpc19vZGQiLCJpc19ldmVuIiwiZXh0cmFjdCIsIm8iLCJsIiwic2lnbmVkX2V4dHJhY3QiLCJsb2cyIiwibG9nMnVwIiwicm91bmRfdG9fZmxvYXQiLCJleGFjdCIsIm0iLCJ0b19mbG9hdCIsInRvcCIsInByaW50Iiwib3V0cHV0IiwiY2hhbiIsInNwcmludCIsInBhcmFtIiwiYnByaW50IiwicHBfcHJpbnQiLCJyYXdfYml0c19yYW5kb20iLCJybmciLCJuYml0cyIsImFjY3UiLCJpIiwicmF3X2JpdHNfZnJvbV9ieXRlcyIsImZpbGwiLCJuYnl0ZXMiLCJidWYiLCJyYW5kb21fYml0c19hdXgiLCJyYW5kb21faW50X2F1eCIsImJvdW5kIiwibmJpdHMxIiwicmFuZG9tX2ludCIsInJhbmRvbV9iaXRzIiwicmFuZG9tX2ludF9nZW4iLCJyYW5kb21fYml0c19nZW4iLCJzeW1ib2wiLCJDb21wYXJlIiwidmVyc2lvbiIsIloiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJ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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5Mzc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5GbG9hdFZpZXcub2Jqcy9qc29vL2RlZmF1bHQvRmxvYXRWaWV3LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsNCIsImExIiwiYTIiLCJhMyIsImdsb2JhbF9kYXRhIiwiU3RkbGliX09iaiIsIkFzc2VydF9mYWlsdXJlIiwiQml0diIsIlN0ZGxpYl9Gb3JtYXQiLCJaIiwicHBfZmxvYXQiLCJmbXQiLCJpIiwidiIsIk92ZXJmbG93IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsIm9mX2ludDMyX3Vuc2lnbmVkIiwib2ZfaW50NjRfdW5zaWduZWQiLCJvZl9uYXRpdmVpbnRfdW5zaWduZWQiLCJvZl9zdHJpbmciLCJvZl9zdWJzdHJpbmciLCJvZl9zdHJpbmdfYmFzZSIsInN1Y2MiLCJwcmVkIiwiYWJzIiwibmVnIiwiYWRkIiwic3ViIiwibXVsIiwiZGl2IiwicmVtIiwiZWRpdl9yZW0iLCJlZGl2IiwiZXJlbSIsImRpdmV4YWN0IiwiZGl2aXNpYmxlIiwibG9nYW5kIiwibG9nb3IiLCJsb2d4b3IiLCJsb2dub3QiLCJzaGlmdF9sZWZ0Iiwic2hpZnRfcmlnaHQiLCJzaGlmdF9yaWdodF90cnVuYyIsInRlc3RiaXQiLCJ0b19pbnQiLCJ0b19mbG9hdCIsInRvX3N0cmluZyIsInByaW50Iiwib3V0cHV0Iiwic3ByaW50IiwiYnByaW50IiwicHBfcHJpbnQiLCJsZXEiLCJnZXEiLCJsdCIsImd0IiwibWluIiwibWF4IiwiaXNfZXZlbiIsImlzX29kZCIsImhhc2giLCJzZWVkZWRfaGFzaCIsImdjZGV4dCIsImxjbSIsImxvZzIiLCJsb2cydXAiLCJleHRyYWN0Iiwic2lnbmVkX2V4dHJhY3QiLCJyYW5kb21faW50IiwicmFuZG9tX2JpdHMiLCJyYW5kb21faW50X2dlbiIsInJhbmRvbV9iaXRzX2dlbiIsInN5bWJvbCIsIm1vZCIsImxhbmQiLCJsb3IiLCJseG9yIiwibHNsIiwiYXNyIiwiQ29tcGFyZSIsInZlcnNpb24iLCJyb3VuZF90b19mbG9hdCIsInBvdzEwIiwibiIsIlV0aWxzIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvd29ya3NwYWNlX3Jvb3QvbGliL3V0aWxzLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFLElBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxJQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFNBQUFDLEtBQUFiO0FBQUFBLFFBQUEsTUNXa0I7QUFBQTtBQUFBLEtBQVM7QUFBQSxRQUFBYyxJQUNOLGtDQUFBQyxJQUNYO0FBQUEsSUFDUiwrREFBc0M7QUFBQTtBQUFBO0FBQUEsSUFBQUMsV0RkeEM7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBSixXQUFBO0FBQUEsSUFBQUssTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0NzQkksOEJBQVc7QUFBQTtBQUFBLElBQUE1RTtBQUFBQSxNRHRCZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUE2RSxRQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICogVGhpcyBGaWxlIGlzIHBhcnQgb2YgdGhlIEZsb2F0VmlldyByZXBvc2l0b3J5XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjUgLSBKb3NzZWxpbiBHaWV0XG4gKlxuICogVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbigqKiBbcHBfZmxvYXQgZm10IGZdIHByaW50cyB0aGUgYml0bGF5b3V0IG9mIHRoZSBmbG9hdCBbZl0gKilcbmxldCBwcF9mbG9hdCBmbXQgKGY6IGZsb2F0KSA9XG4gIGxldCB0ID0gT2JqLnJlcHIgZiBpblxuICBsZXQgXyA9IGFzc2VydCAoT2JqLnRhZyB0ID0gT2JqLmRvdWJsZV90YWcpIGluXG4gIGxldCBpOiBuYXRpdmVpbnQgPSBPYmoucmF3X2ZpZWxkIHQgMCBpblxuICBsZXQgdiA9IEJpdHYub2ZfbmF0aXZlaW50X3MgaSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlYVwiIEJpdHYuTS5wcmludCB2XG5cbm1vZHVsZSBaID0gc3RydWN0XG4gIGluY2x1ZGUgWlxuXG4gICgqKiBbcG93MTAgbl0gcmV0dXJucyBbMTBebl0uICopXG4gIGxldCBwb3cxMCBuID1cbiAgICBsZXQgdGVuID0gWi5vZl9pbnQgMTAgaW5cbiAgICBaLnBvdyB0ZW4gblxuICBcbmVuZCJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOTU3NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuRmxvYXRWaWV3Lm9ianMvanNvby9kZWZhdWx0L0Zsb2F0Vmlldy5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMyIsImYiLCJhMCIsImExIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsInJlc2V0IiwiZ3JleSIsImRncmV5IiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwicHVycGxlIiwiY3llbiIsImJvbGQiLCJpdGFsaWMiLCJ1bGluZSIsInV1bGluZSIsImJsaW5rIiwiYmFja2dyZCIsImRhc2hlZCIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfUHJpbnRmIiwic2lnbiIsInRpY2siLCJjcm9zcyIsInBwX2VmZmVjdCIsImZtdCIsImVmZmVjdCIsInN0cl9jb2xvciIsIkNvbG9yIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvd29ya3NwYWNlX3Jvb3QvbGliL2NvbG9yLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDLElBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBQyxJQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQzJDVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFDQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsS0FBQUM7QUFBQUEsSUFvQlY7QUFBQTtBQUFBLFdBQUFDLFlBRWE7QUFBQTtBQUFBLFdBQUFBLFlBQ0E7QUFBQTtBQUFBLFdBQUFBLFlBQ0Q7QUFBQTtBQUFBLFdBQUFBLFlBQ0Q7QUFBQTtBQUFBLFdBQUFBLFlBQ0U7QUFBQTtBQUFBLFdBQUFBLFlBQ0M7QUFBQTtBQUFBLFdBQUFBLFlBQ0Y7QUFBQTtBQUFBLFdBQUFBLFlBQ0U7QUFBQTtBQUFBLFdBQUFBLFlBQ0Y7QUFBQTtBQUFBLFdBQUFBLFlBQ0E7QUFBQTtBQUFBLFdBQUFBLFlBQ0U7QUFBQTtBQUFBLFdBQUFBLFlBQ0Q7QUFBQTtBQUFBLFdBQUFBLFlBQ0M7QUFBQTtBQUFBLFdBQUFBLFlBQ0M7QUFBQSxtQkFBQUEsWUFDRDtBQUFBO0FBQUEsSUFDZCx1REFBa0M7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFyQ2lCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRC9DckQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnlcbiAqIENvcHlyaWdodCAoQykgMjAyNSAtIEpvc3NlbGluIEdpZXRcbiAqXG4gKiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKilcblxuKCoqIFRoaXMgZmlsZSBjb250YWlucyBzdHJpbmcgZm9yIGNvbG9yIG91dHB1dCBpbiBzdGRvdXQuXG4gICAge2IgQXR0ZW50aW9ufSwgdGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gcGlwaW5nIHJlc3VsdC4gKilcblxuXG5sZXQgcmVzZXQgICA9IFwiXFwwMjdbMG1cIlxuKCoqIHJlc2V0IGFsbCBmb3JtYXR0aW5nLCBjb2xvcnMgJiBzdHlsZSAqKVxuXG4oKiogezUgQ29sb3JzfSAqKVxuXG5sZXQgZ3JleSAgICA9IFwiXFwwMjdbMm1cIlxubGV0IGRncmV5ICAgPSBcIlxcMDI3WzMwbVwiXG5sZXQgcmVkICAgICA9IFwiXFwwMjdbMzFtXCJcbmxldCBncmVlbiAgID0gXCJcXDAyN1szMm1cIlxubGV0IHllbGxvdyAgPSBcIlxcMDI3WzMzbVwiXG5sZXQgYmx1ZSAgICA9IFwiXFwwMjdbMzRtXCJcbmxldCBwdXJwbGUgID0gXCJcXDAyN1szNW1cIlxubGV0IGN5ZW4gICAgPSBcIlxcMDI3WzM2bVwiXG5cbigqKiB7NSBTdHlsZX0gKilcblxubGV0IGJvbGQgICAgPSBcIlxcMDI3WzFtXCJcbmxldCBpdGFsaWMgID0gXCJcXDAyN1szbVwiXG5sZXQgdWxpbmUgICA9IFwiXFwwMjdbNG1cIlxuXG5sZXQgdXVsaW5lICA9IFwiXFwwMjdbMjFtXCIgICgqKiBEb3VibGUgdW5kZXJsaW5lZCB0ZXh0ICopXG5cbmxldCBibGluayAgID0gXCJcXDAyN1s1bVwiICAgKCoqIEJsaW5raW5nIHRleHQgKilcblxubGV0IGJhY2tncmQgPSBcIlxcMDI3WzdtXCIgICAoKiogcmV2ZXJzZSBmb250ICYgYmFja2dyb3VuZCBjb2xvciAqKVxuXG5sZXQgZGFzaGVkICA9IFwiXFwwMjdbOW1cIlxuXG5cbigqKiB7NSBVdGlsc30gKilcblxubGV0IHNpZ24gPSBQcmludGYuc3ByaW50ZiBcIiVzJXPimqAgJXNcIiByZWQgYmxpbmsgcmVzZXRcbigqKiByZWQgYmxpbmtpbmcg4pqgIHN5bWJvbCAqKVxuXG5sZXQgdGljayA9IFByaW50Zi5zcHJpbnRmIFwiJXMlc+KckyVzXCIgZ3JlZW4gYm9sZCByZXNldFxubGV0IGNyb3NzID0gUHJpbnRmLnNwcmludGYgXCIlcyVz4pyVJXNcIiByZWQgYm9sZCByZXNldFxuXG50eXBlIGVmZmVjdCA9XG4gIHwgUmVzZXRcbiAgfCBEZ3JleVxuICB8IEdyZXlcbiAgfCBSZWRcbiAgfCBHcmVlblxuICB8IFllbGxvd1xuICB8IEJsdWVcbiAgfCBQdXJwbGVcbiAgfCBDeWFuXG4gIHwgQm9sZFxuICB8IEl0YWxpY1xuICB8IFVsaW5lXG4gIHwgVVVsaW5lXG4gIHwgQmFja2dyZFxuICB8IERhc2hlZFxuXG5sZXQgcHBfZWZmZWN0IGZtdCAoZWZmZWN0OiBlZmZlY3QpID1cbiAgbGV0IHN0cl9jb2xvciA9XG4gICAgbWF0Y2ggZWZmZWN0IHdpdGhcbiAgICB8IFJlc2V0IC0+IHJlc2V0XG4gICAgfCBEZ3JleSAtPiBkZ3JleVxuICAgIHwgR3JleSAtPiBncmV5XG4gICAgfCBSZWQgLT4gcmVkXG4gICAgfCBHcmVlbiAtPiBncmVlblxuICAgIHwgWWVsbG93IC0+IHllbGxvd1xuICAgIHwgQmx1ZSAtPiBibHVlXG4gICAgfCBQdXJwbGUgLT4gcHVycGxlXG4gICAgfCBDeWFuIC0+IGN5ZW5cbiAgICB8IEJvbGQgLT4gYm9sZFxuICAgIHwgSXRhbGljIC0+IGl0YWxpY1xuICAgIHwgVWxpbmUgLT4gdWxpbmVcbiAgICB8IFVVbGluZSAtPiB1dWxpbmVcbiAgICB8IEJhY2tncmQgLT4gYmFja2dyZFxuICAgIHwgRGFzaGVkIC0+IGRhc2hlZCBpblxuICBGb3JtYXQucHBfcHJpbnRfYXMgZm10IDAgc3RyX2NvbG9yXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjk3MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLkZsb2F0Vmlldy5vYmpzL2pzb28vZGVmYXVsdC9GbG9hdFZpZXcuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw1IiwiYTMiLCJhNCIsImNhbWxfY2FsbDciLCJhNSIsImE2IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfRm9ybWF0IiwiQ29sb3IiLCJ0b19pbnQiLCJwYXJhbSIsInByaW50ZWRfbGV2ZWwiLCJwcmludGFibGUiLCJsdmwiLCJtYWtlX3ByZWZpeCIsImdldF9vdXRfY2hhbm5lbCIsIkxvZ0xldmVsIiwib3V0IiwicyIsImluZGV4IiwibGVuIiwiZmx1c2giLCJudWxsX2Zvcm1hdHRlciIsImNzdF9FeGl0IiwibWFrZV9wcmVmaXhlZF9tdWx0aWxpbmVfZm9ybWF0Iiwib3V0X2NoYW5uZWwiLCJwcmVmaXgiLCJpIiwiYyIsImxvZ2siLCJrIiwiZm10IiwicHJmeCIsImZvcm1hdHRlciIsImZsdXNoX2ZtdCIsImxvZ19leGl0IiwiZmx1c2hfZXhpdCIsIm91dHB1dCIsImZhaWwiLCJ0b2RvIiwiZXJyb3IiLCJzdWNjZXNzIiwid2FybiIsImluZm8iLCJkZWJ1ZyIsImxvZyIsIkxvZyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L2xpYi9sb2cubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxRQUFBLElBQUFBLFFBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVQsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFkLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFlLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxPQUFBQztBQUFBQSxJQ3FCZTtB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S0FaekIsOEJBYTJCO0FBQUEsWUFBQWMsSUFBQWQsS0FiM0IsOEJBYzRCO0FBQUE7QUFBQSxJQUFBZTtBQUFBQSxNQWhERztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHhFakMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnlcbiAqIENvcHlyaWdodCAoQykgMjAyNSAtIEpvc3NlbGluIEdpZXRcbiAqXG4gKiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKilcblxubW9kdWxlIExvZ0xldmVsID0gc3RydWN0XG5cbiAgdHlwZSB0ID1cbiAgICB8IE9VVFBVVFxuICAgIHwgRkFUQUxcbiAgICB8IFRPRE9cbiAgICB8IEVSUk9SXG4gICAgfCBTVUNDRVNTXG4gICAgfCBXQVJOXG4gICAgfCBJTkZPXG4gICAgfCBQUk9HUkVTU1xuICAgIHwgREVCVUdcblxuICBsZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgICB8IE9VVFBVVCAgIC0+IDExXG4gICAgfCBGQVRBTCAgICAtPiAxMFxuICAgIHwgVE9ETyAgICAgLT4gIDlcbiAgICB8IEVSUk9SICAgIC0+ICA4XG4gICAgfCBTVUNDRVNTICAtPiAgN1xuICAgIHwgV0FSTiAgICAgLT4gIDZcbiAgICB8IElORk8gICAgIC0+ICA1XG4gICAgfCBQUk9HUkVTUyAtPiAgNFxuICAgIHwgREVCVUcgICAgLT4gIDBcbiAgbGV0IHByaW50ZWRfbGV2ZWwgPSByZWYgSU5GT1xuXG4gIGxldCBwcmludGFibGUgbHZsID1cbiAgICB0b19pbnQgbHZsID49IHRvX2ludCAhcHJpbnRlZF9sZXZlbFxuXG4gIGxldCBtYWtlX3ByZWZpeCA9IGZ1bmN0aW9uXG4gICAgfCBPVVRQVVQgICAtPiBcIlwiXG4gICAgfCBGQVRBTCAgICAtPlxuICAgICAgICBGb3JtYXQuYXNwcmludGYgXCIlYSVhW0ZBVEFMXSVhIFwiXG4gICAgICAgICAgQ29sb3IucHBfZWZmZWN0IENvbG9yLlJlZCBDb2xvci5wcF9lZmZlY3QgQ29sb3IuQm9sZCBDb2xvci5wcF9lZmZlY3QgQ29sb3IuUmVzZXRcbiAgICB8IFRPRE8gICAgIC0+XG4gICAgICAgIEZvcm1hdC5hc3ByaW50ZiBcIiVhJWFbVE9ETyBdJWEgXCJcbiAgICAgICAgICBDb2xvci5wcF9lZmZlY3QgQ29sb3IuUmVkIENvbG9yLnBwX2VmZmVjdCBDb2xvci5Cb2xkIENvbG9yLnBwX2VmZmVjdCBDb2xvci5SZXNldFxuICAgIHwgRVJST1IgICAgLT5cbiAgICAgICAgRm9ybWF0LmFzcHJpbnRmIFwiJWElYVtFUlJPUl0lYSBcIlxuICAgICAgICAgIENvbG9yLnBwX2VmZmVjdCBDb2xvci5SZWQgQ29sb3IucHBfZWZmZWN0IENvbG9yLkJvbGQgQ29sb3IucHBfZWZmZWN0IENvbG9yLlJlc2V0XG4gICAgfCBTVUNDRVNTICAtPlxuICAgICAgICBGb3JtYXQuYXNwcmludGYgXCIlYSVhWyBPSyAgXSVhIFwiXG4gICAgICAgICAgQ29sb3IucHBfZWZmZWN0IENvbG9yLkdyZWVuIENvbG9yLnBwX2VmZmVjdCBDb2xvci5Cb2xkIENvbG9yLnBwX2VmZmVjdCBDb2xvci5SZXNldFxuICAgIHwgV0FSTiAgICAgLT5cbiAgICAgICAgRm9ybWF0LmFzcHJpbnRmIFwiJWElYVtXQVJOIF0lYSBcIlxuICAgICAgICAgIENvbG9yLnBwX2VmZmVjdCBDb2xvci5ZZWxsb3cgQ29sb3IucHBfZWZmZWN0IENvbG9yLkJvbGQgQ29sb3IucHBfZWZmZWN0IENvbG9yLlJlc2V0XG4gICAgfCBJTkZPICAgICAtPlxuICAgICAgICBGb3JtYXQuYXNwcmludGYgXCIlYSVhW0lORk8gXSVhIFwiXG4gICAgICAgICAgQ29sb3IucHBfZWZmZWN0IENvbG9yLkJsdWUgQ29sb3IucHBfZWZmZWN0IENvbG9yLkJvbGQgQ29sb3IucHBfZWZmZWN0IENvbG9yLlJlc2V0XG4gICAgfCBQUk9HUkVTUyAtPlxuICAgICAgICBGb3JtYXQuYXNwcmludGYgXCIlYSVhW1BST0dSXSVhIFwiXG4gICAgICAgICAgQ29sb3IucHBfZWZmZWN0IENvbG9yLkdyZXkgQ29sb3IucHBfZWZmZWN0IENvbG9yLkJvbGQgQ29sb3IucHBfZWZmZWN0IENvbG9yLlJlc2V0XG4gICAgfCBERUJVRyAgICAtPlxuICAgICAgICBGb3JtYXQuYXNwcmludGYgXCIlYVtERUJVR10lYSBcIlxuICAgICAgICAgIENvbG9yLnBwX2VmZmVjdCBDb2xvci5Cb2xkIENvbG9yLnBwX2VmZmVjdCBDb2xvci5SZXNldFxuXG4gIGxldCBnZXRfb3V0X2NoYW5uZWwgPSBmdW5jdGlvblxuICAgIHwgT1VUUFVUIC0+IHN0ZG91dFxuICAgIHwgXyAtPiBzdGRlcnJcblxuZW5kXG5cbmxldCBudWxsX2Zvcm1hdHRlciA9XG4gIGxldCBvdXQgX3MgX2luZGV4IF9sZW4gPSAoKSBpblxuICBsZXQgZmx1c2ggKCkgPSAoKSBpblxuICBGb3JtYXQubWFrZV9mb3JtYXR0ZXIgb3V0IGZsdXNoXG5cbmxldCBtYWtlX3ByZWZpeGVkX211bHRpbGluZV9mb3JtYXR0ZXIgb3V0X2NoYW5uZWwgcHJlZml4ID1cbiAgbGV0IG91dCBzIGluZGV4IGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBjID0gcy5baW5kZXggKyBpXSBpblxuICAgICAgaWYgYyA9ICdcXG4nIHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBvdXRwdXRfc3RyaW5nIG91dF9jaGFubmVsIFwiXFxuXCI7XG4gICAgICAgICAgb3V0cHV0X3N0cmluZyBvdXRfY2hhbm5lbCBwcmVmaXhcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIG91dHB1dF9jaGFyIG91dF9jaGFubmVsIGNcbiAgICBkb25lIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgZmx1c2ggb3V0X2NoYW5uZWwgaW5cbiAgRm9ybWF0Lm1ha2VfZm9ybWF0dGVyIG91dCBmbHVzaFxuXG5sZXQgbG9nayAodHlwZSBhIGIpIChrOiBGb3JtYXQuZm9ybWF0dGVyIC0+IGEpIChsdmw6IExvZ0xldmVsLnQpXG4gICAgKGZtdDogKGIsIEZvcm1hdC5mb3JtYXR0ZXIsIHVuaXQsIGEpIGZvcm1hdDQpOiBiID1cbiAgaWYgbm90IChMb2dMZXZlbC5wcmludGFibGUgbHZsKSB0aGVuIEZvcm1hdC5pa2ZwcmludGYgayBudWxsX2Zvcm1hdHRlciBmbXQgZWxzZVxuICBsZXQgb3V0ID0gTG9nTGV2ZWwuZ2V0X291dF9jaGFubmVsIGx2bCBpblxuICBsZXQgcHJmeCA9IExvZ0xldmVsLm1ha2VfcHJlZml4IGx2bCBpblxuICBpZiBwcmZ4IDw+IFwiXCIgdGhlbiBvdXRwdXRfc3RyaW5nIG91dCBwcmZ4O1xuICAoKiBvdXRwdXRfc3RyaW5nIG91dCBwcmZ4OyAqKVxuICBsZXQgZm9ybWF0dGVyID0gbWFrZV9wcmVmaXhlZF9tdWx0aWxpbmVfZm9ybWF0dGVyIG91dCBwcmZ4ICBpblxuICBGb3JtYXQua2ZwcmludGYgayBmb3JtYXR0ZXIgZm10XG5cbmxldCBmbHVzaF9mbXQgZm9ybWF0dGVyID1cbiAgRm9ybWF0LnBwX3ByaW50X2ZsdXNoIGZvcm1hdHRlciAoKTtcbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgXCJcXG5cIjtcbiAgZmx1c2ggc3RkZXJyXG5cbmxldCBsb2cgKGx2bDogTG9nTGV2ZWwudCkgKGZtdDogKCdhLCBGb3JtYXQuZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpOiAnYSA9XG4gIGxvZ2sgZmx1c2hfZm10IGx2bCBmbXRcblxubGV0IGxvZ19leGl0ICh0eXBlIGEgYikgKGx2bDogTG9nTGV2ZWwudCkgKGZtdDogKGEsIEZvcm1hdC5mb3JtYXR0ZXIsIHVuaXQsYikgZm9ybWF0NCk6IGEgPVxuICBsZXQgZmx1c2hfZXhpdCBmbXQgPSBmbHVzaF9mbXQgZm10OyBmYWlsd2l0aCBcIkV4aXRcIiBpblxuICBsb2drIGZsdXNoX2V4aXQgbHZsIGZtdFxuXG5sZXQgb3V0cHV0IGZtdCA9IGxvZyBPVVRQVVQgZm10XG5sZXQgZmFpbCBmbXQgPSBsb2dfZXhpdCBGQVRBTCBmbXRcbmxldCB0b2RvID0gZnVuIGZtdCAtPiBsb2dfZXhpdCBUT0RPIGZtdFxubGV0IGVycm9yIGZtdCA9IGxvZyBFUlJPUiBmbXRcbmxldCBzdWNjZXNzIGZtdCA9IGxvZyBTVUNDRVNTIGZtdFxubGV0IHdhcm4gIGZtdCA9IGxvZyBXQVJOICBmbXRcbmxldCBpbmZvIGZtdCA9IGxvZyBJTkZPIGZtdFxubGV0IGRlYnVnIGZtdCA9IGxvZyBERUJVRyBmbXRcbmxldCBsb2cgZm10ID0gbG9nIFBST0dSRVNTIGZtdFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5OTQ1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5GbG9hdFZpZXcub2Jqcy9qc29vL2RlZmF1bHQvRmxvYXRWaWV3LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfdl8wIiwiY3N0IiwiY3N0X1VuZXhwZWN0ZWRfT3ZlcmZsb3dfaW5fZGVjIiwiY3N0X1VuZXhwZWN0ZWRfT3ZlcmZsb3d4X2luX2luIiwiY3N0X2xpYl9mbG9hdHNfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiY2FtbF9jYWxsNyIsImE1IiwiYTYiLCJjYW1sX2NhbGw5IiwiYTciLCJhOCIsImNhbWxfY2FsbDExIiwiYTkiLCJhMTAiLCJnbG9iYWxfZGF0YSIsInBhcnRpYWwiLCJTdGRsaWJfRm9ybWF0IiwiQml0diIsIkFzc2VydF9mYWlsdXJlIiwiTG9nIiwiU3RkbGliX09iaiIsIlN0ZGxpYl9TdHJpbmciLCJDb2xvciIsIlN0ZGxpYl9TeXMiLCJwcF9mbG9hdF9wcmVjaXNpb24iLCJmbXQiLCJwYXJhbSIsImJpYWlzIiwiZXhwIiwibWFudGlzc2EiLCJsZW5ndGgiLCJidWlsZF9wcmVjaXNpb24iLCJvcHQiLCJzdGgiLCJuYW1lIiwibWluaSIsImhhbGYiLCJzaW5nbGUiLCJkb3VibGUiLCJxdWFkcnVwbGUiLCJvY3R1cGxlIiwic3oiLCJjc3Rfcm91bmRlZCIsImNzdF9leGFjdCIsImNzdF9ub3JtYWwiLCJjc3Rfc3Vibm9ybWFsIiwiY3N0X3plcm8iLCJjc3RfaW5maW5pdGUiLCJjc3RfbmFuIiwiY3N0X0Zsb2F0c19PdmVyZmxvdyIsInN5c19wcmVjaXNpb24iLCJjb3B5IiwibSIsImUiLCJzIiwicCIsInBwIiwicHBfdWwiLCJwcF9ib3hlZCIsImxpbmUiLCJvZl9mbG9hdCIsImkiLCJ2IiwibCIsImdldF96ZXJvIiwic2lnbiIsImdldF9pbmYiLCJpc196ZXJvIiwiaXNfbmFuIiwiaXNfaW5mIiwiaXNfZGVub3JtYWxpemVkIiwiY2xhc3NpZnkiLCJwcF9mcGNsYXNzIiwiT3ZlcmZsb3ciLCJpbmNfbWFudGlzc2EiLCJkZWNfbWFudGlzc2EiLCJpbmNfZXhwIiwiZGVjX2V4cCIsIm5leHRfaW5mIiwicmVzIiwibmV4dF96ZXJvIiwic3VjYyIsInByZWQiLCJwcF9jb252ZXJzaW9uX2luZm8iLCJGbG9hdHMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9saWIvZmxvYXRzLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdB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QTdORDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRDcEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnlcbiAqIENvcHlyaWdodCAoQykgMjAyNSAtIEpvc3NlbGluIEdpZXRcbiAqXG4gKiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKilcblxuKCoqIHsxIEZsb2F0IHByZWNpc2lvbn0gKilcblxuKCoqIFR5cGUgb2YgZmxvYXQgcmVwcmVzZW50YXRpb24qKVxudHlwZSBmbG9hdF9wcmVjaXNpb24gPSB7XG4gIG1hbnRpc3NhOiBpbnQ7ICgqKiBwaHlzaWNhbCBzaXplIG9mIHRoZSBtYW50aXNzYSB7aSBpLmUufSBkb2VzIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIFsxXSAqKVxuICBleHA6IGludDsgICAgICAoKiogcGh5c2ljYWwgc2l6ZSBvZiB0aGUgZXhwb25lbnQgKilcbiAgYmlhaXM6IGludDsgICAgKCoqIGJpYWlzICopXG4gIG5hbWU6IHN0cmluZzsgICgqKiBuYW1lIG9mIHRoZSBwcmVjaXNpb24gKHtpIGUuZy59IFtzaW5nbGVdLCBbZG91YmxlXSkqKVxufVxuXG5cbmxldCBwcF9mbG9hdF9wcmVjaXNpb24gZm10IHttYW50aXNzYTsgZXhwOyBiaWFpczsgX30gPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJleHA6ICUzaSAoYmlhaXM6ICUxMGkpIG1hbnRpc3NhOiAlaVwiXG4gICAgZXhwIGJpYWlzIG1hbnRpc3NhXG5cbmxldCBsZW5ndGgge21hbnRpc3NhOyBleHA7IF99ID0gMSArIG1hbnRpc3NhICsgZXhwXG5cbmxldCBidWlsZF9wcmVjaXNpb24gPyhuYW1lID0gXCJcIikgbWFudGlzc2EgPyhiaWFpcz1Ob25lKSBleHAgPVxuICBsZXQgYmlhaXMgPSBtYXRjaCBiaWFpcyB3aXRoXG4gICAgfCBOb25lIC0+IChJbnQuc2hpZnRfbGVmdCAxIChleHAtMSkpIC0gMVxuICAgIHwgU29tZSBiaWFpcyAtPiBiaWFpcyBpblxuICB7IG1hbnRpc3NhOyBleHA7IGJpYWlzOyBuYW1lIH1cblxuKCoqIHsyIElFRUUtNzU0IHJlcHJlc2VudGF0aW9ufSopXG5cbmxldCBtaW5pID0gYnVpbGRfcHJlY2lzaW9uIH5uYW1lOlwibWluaVwiIDMgNFxubGV0IGhhbGYgICA9IGJ1aWxkX3ByZWNpc2lvbiB+bmFtZTpcImhhbGZcIiAxMCA1XG5sZXQgc2luZ2xlID0gYnVpbGRfcHJlY2lzaW9uIH5uYW1lOlwic2luZ2xlXCIgMjMgOFxubGV0IGRvdWJsZSA9IGJ1aWxkX3ByZWNpc2lvbiB+bmFtZTpcImRvdWJsZVwiIDUyIDExXG5sZXQgcXVhZHJ1cGxlID0gYnVpbGRfcHJlY2lzaW9uIH5uYW1lOlwicXVhZHJ1cGxlXCIgMTEyIDE1XG5sZXQgb2N0dXBsZSA9IGJ1aWxkX3ByZWNpc2lvbiB+bmFtZTpcIm9jdHVwbGVcIiAyMzYgMTlcblxuKCoqIHByZWNpc2lvbiBvZiB0aGUgY3VycmVudGx5IHN1ZWQgc3lzdGVtLlxuICAgIE1heSBiZSB7IXNpbmdsZX0gKDMyYml0cykgb3IgeyFkb3VibGV9ICg2NCBiaXRzKSAqKVxubGV0IHN5c19wcmVjaXNpb24gPSBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPiBzaW5nbGVcbiAgfCA2NCAtPiBkb3VibGVcbiAgfCBzeiAtPiBMb2cuZmFpbCBcIlVua25vd24gd29yZCBzaXplOiAlaVwiIHN6XG5cbigqKiB7MSBGbG9hdCBiaXR3aXNlIHJlcHJlc2VudGF0aW9ufSAqKVxuXG4oKiogRXhwbGljaXQgYml0d2lzZSBtYW5pcHVsYXRpb24gb2YgYSBJRUVFIGZsb2F0aW5nIHBvaW50IG51bWJlci4gKilcbnR5cGUgZmxvYXRfYncgPSB7XG4gIHA6IGZsb2F0X3ByZWNpc2lvbjsgKCoqIHVuZGVybHlpbmcgcHJlY2lzaW9uIHVzZWQgKilcbiAgczogYm9vbDsgICAgICAgICAgICAoKiogc2lnbiBiaXQuIFt0cnVlXSBmb3IgcG9zaXRpdmUgdmFsdWUuICopXG4gIGU6IEJpdHYudDsgICAgICAgICAgKCoqIGV4cG9uZW50IGJpdGZpZWxkICopXG4gIG06IEJpdHYudDsgICAgICAgICAgKCoqIG1hbnRpc3NhIGJpdGZpZWxkICopXG59XG5cbnR5cGUgdCA9IGZsb2F0X2J3XG5cbigqKiBbY29weSBmXSByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIFtmXS4gKilcbmxldCBjb3B5IHtwOyBzOyBlOyBtfSA9XG4gIGxldCBlJyA9IEJpdHYuY29weSBlIGluXG4gIGxldCBtJyA9IEJpdHYuY29weSBtIGluXG4gIHtwOyBzOyBlID0gZSc7IG0gPSBtJ31cblxuKCoqIHsyIFByZXR0eSBwcmludGVycyB9ICopXG5cbigqKiBQcmludCB0aGUgZmxvYXQgYXMgYml0ZmllbGQuICopXG5sZXQgcHAgZm10ICB7czsgZTsgbTsgX30gPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlaSVhJWFcIlxuICAgIChpZiBzIHRoZW4gMCBlbHNlIDEpXG4gICAgQml0di5NLnByaW50IGVcbiAgICBCaXR2LkwucHJpbnQgbVxuXG4oKiogUHJpbnQgdGhlIGZsb2F0IGFuZCB1bmRlcmxpbmUgdGhlIGV4cG9uZW50LiAqKVxubGV0IHBwX3VsIGZtdCAge3M7IGU7IG07IF99ID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiJWklYSVhJWElYVwiXG4gICAgKGlmIHMgdGhlbiAwIGVsc2UgMSlcbiAgICBDb2xvci5wcF9lZmZlY3QgQ29sb3IuVWxpbmVcbiAgICBCaXR2Lk0ucHJpbnQgZVxuICAgIENvbG9yLnBwX2VmZmVjdCBDb2xvci5SZXNldFxuICAgIEJpdHYuTC5wcmludCBtXG5cbigqKiBQcmludCB0aGUgZmxvYXQgaW4gYSBib3guICopXG5sZXQgcHBfYm94ZWQgZm10IHtzOyBlOyBtOyBwfSA9XG4gIGxldCBsaW5lID0gRm9ybWF0LmFzcHJpbnRmIFwiKy0rJXMrJXMrXCJcbiAgICAoU3RyaW5nLm1ha2UgcC5leHAgJy0nKVxuICAgIChTdHJpbmcubWFrZSBwLm1hbnRpc3NhICctJykgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQFs8diAwPiVzQCB8JWl8JWF8JWF8QCAlc0BdXCJcbiAgICBsaW5lXG4gICAgKGlmIHMgdGhlbiAwIGVsc2UgMSlcbiAgICBCaXR2Lk0ucHJpbnQgZVxuICAgIEJpdHYuTC5wcmludCBtXG4gICAgbGluZVxuXG4oKiogezIgU2ltcGxlIGNvbnN0cnVjdGlvbiBmdW5jdGlvbn0qKVxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGxldCB0ID0gT2JqLnJlcHIgZiBpblxuICBsZXQgKCkgPSBhc3NlcnQgKE9iai50YWcgdCA9IE9iai5kb3VibGVfdGFnKSBpblxuICBsZXQgaTogbmF0aXZlaW50ID0gT2JqLnJhd19maWVsZCB0IDAgaW5cbiAgbGV0IHYgPSBCaXR2Lm9mX25hdGl2ZWludF9zIGkgaW5cbiAgbGV0IHAgPSBzeXNfcHJlY2lzaW9uIGluXG4gIGxldCBsID0gbGVuZ3RoIHAgaW5cbiAgbGV0ICgpID0gYXNzZXJ0IChCaXR2Lmxlbmd0aCB2ID0gbCkgaW5cbiAgbGV0IHMgPSBub3QgKEJpdHYuZ2V0IHYgKGwtMSkpIGluXG4gIGxldCBlID0gQml0di5pbml0IHAuZXhwXG4gICAgKGZ1biBpIC0+IEJpdHYuZ2V0IHYgKHAubWFudGlzc2EgKyBpKSkgaW5cbiAgbGV0IG0gPSBCaXR2LmluaXQgcC5tYW50aXNzYVxuICAgIChmdW4gaSAtPiBCaXR2LmdldCB2IChwLm1hbnRpc3NhIC0xIC1pKSkgaW5cbiAgeyBzOyBlOyBtOyBwIH1cblxubGV0IGdldF96ZXJvID8oc2lnbj10cnVlKSBwID1cbiAgbGV0IGUgPSBCaXR2LmNyZWF0ZSBwLmV4cCBmYWxzZSBpblxuICBsZXQgbSA9IEJpdHYuY3JlYXRlIHAubWFudGlzc2EgZmFsc2UgaW5cbiAgeyBwOyBzID0gc2lnbjsgZTsgbSB9XG5cbmxldCBnZXRfaW5mIHNpZ24gcCA9XG4gIGxldCBlID0gQml0di5jcmVhdGUgcC5leHAgdHJ1ZSAgaW5cbiAgbGV0IG0gPSBCaXR2LmNyZWF0ZSBwLm1hbnRpc3NhIGZhbHNlIGluXG4gIHsgcDsgcyA9IHNpZ247IGU7IG0gfVxuXG4oKiogezIgQ2hlY2tpbmcgZnVuY3Rpb259KilcblxuKCoqIFtpc196ZXJvIGZdIHJldHVybnMgW3RydWVdIGlmZi4gW2ZdIGlzIFsrLy0wLjBdLiAqKVxubGV0IGlzX3plcm8ge2U7IG07IF99ID1cbiAgKEJpdHYuYWxsX3plcm9zIGUpICYmIChCaXR2LmFsbF96ZXJvcyBtKVxuXG4oKiogW2lzX25hbiBmXSByZXR1cm5zIFt0cnVlXSBpZmYuIFtmXSBpcyBhIE5hbiB2YWx1ZS4gKilcbmxldCBpc19uYW4ge2U7bTtffSA9XG4gIEJpdHYuYWxsX29uZXMgZSAmJiBub3QgKEJpdHYuYWxsX3plcm9zIG0pXG5cbigqKiBbaXNfaW5mIGZdIHJldHVybnMgW3RydWVdIGlmZi4gW2ZdIGlzICsvLUluZi4gKilcbmxldCBpc19pbmYge2U7IG07IF99ID1cbiAgQml0di5hbGxfb25lcyBlICYmIEJpdHYuYWxsX3plcm9zIG1cblxuKCoqIFtpc196ZXJvIGZdIHJldHVybnMgW3RydWVdIGlmZi4gW2ZdIGlzIGEgZGVub3JtYWxpemVkIChvciBhIHN1Ym5vcm1hbClcbiAgICBmbG9hdGluZyBwb2ludCB2YWx1ZS4gKilcbmxldCBpc19kZW5vcm1hbGl6ZWQge2U7IF99ID1cbiAgQml0di5hbGxfemVyb3MgZVxuXG4oKiogW2NsYXNzaWZ5IGZdIHJldHVybnMgdGhlIGZsb2F0aW5nIGNsYXNzIG9mIFtmXS5cbiAgICBTZWUgYWxzbyB7IUZsb2F0LmNsYXNzaWZ5X2Zsb2F0fSopXG5sZXQgY2xhc3NpZnkge2U7IG07IF99IDogRmxvYXQuZnBjbGFzcyA9XG4gIGlmIEJpdHYuYWxsX3plcm9zIGUgdGhlblxuICAgIGlmIEJpdHYuYWxsX3plcm9zIG1cbiAgICAgIHRoZW4gRlBfemVyb1xuICAgICAgZWxzZSBGUF9zdWJub3JtYWxcbiAgZWxzZSBpZiBCaXR2LmFsbF9vbmVzIGUgdGhlblxuICAgIGlmIEJpdHYuYWxsX3plcm9zIG1cbiAgICAgIHRoZW4gRlBfaW5maW5pdGVcbiAgICAgIGVsc2UgRlBfbmFuXG4gIGVsc2UgRlBfbm9ybWFsXG5cbmxldCBwcF9mcGNsYXNzIGZtdDogZnBjbGFzcyAtPiB1bml0ID0gZnVuY3Rpb25cbiAgfCBGUF9ub3JtYWwgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJub3JtYWxcIlxuICB8IEZQX3N1Ym5vcm1hbCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcInN1Ym5vcm1hbFwiXG4gIHwgRlBfemVybyAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcInplcm9cIlxuICB8IEZQX25hbiAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIm5hblwiXG4gIHwgRlBfaW5maW5pdGUgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJpbmZpbml0ZVwiXG5cbigqKiB7MiBVdGlsaXRhcmllcyBmdW5jdGlvbnN9KilcblxuZXhjZXB0aW9uIE92ZXJmbG93XG5cbigqKiBbaW5jX21hbnRpc3NhIGJdIEluY3JtZW50IHRoZSBtYW50aXNzYS4gYnkgc3RhcnRpbmcgYnkgdGhlIHtiIG1vc3Qgc2lnbmlmaWNhbnQgYml0c30uXG4gICAgQHJhaXNlIHshT3ZlcmZsb3d9IGlmIHRoZSBtYW50aXNzYSBpcyBbMS4uMTExXSAqKVxubGV0IGluY19tYW50aXNzYSBtID1cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA8IDAgdGhlbiByYWlzZSBPdmVyZmxvdyBlbHNlXG4gICAgaWYgQml0di5nZXQgbSBpIHRoZW4gYmVnaW5cbiAgICAgIEJpdHYuc2V0IG0gaSBmYWxzZTtcbiAgICAgIGF1eCAoaS0xKSBlbmRcbiAgICBlbHNlXG4gICAgICBCaXR2LnNldCBtIGkgdHJ1ZSBpblxuICAgIGF1eCAoQml0di5sZW5ndGggbSAtIDEpXG5cbmxldCBkZWNfbWFudGlzc2EgbSA9XG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmFpc2UgT3ZlcmZsb3cgZWxzZVxuICAgIGlmIEJpdHYuZ2V0IG0gaSB0aGVuXG4gICAgICBCaXR2LnNldCBtIGkgZmFsc2VcbiAgICBlbHNlIGJlZ2luXG4gICAgICBCaXR2LnNldCBtIGkgdHJ1ZTtcbiAgICAgIGF1eCAoaS0xKVxuICAgIGVuZCBpblxuICBhdXggKEJpdHYubGVuZ3RoIG0gLSAxKVxuXG5cbmxldCBpbmNfZXhwIGUgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID49IEJpdHYubGVuZ3RoIGUgdGhlbiByYWlzZSBPdmVyZmxvdyBlbHNlXG4gICAgaWYgQml0di5nZXQgZSBpIHRoZW4gYmVnaW5cbiAgICAgIEJpdHYuc2V0IGUgaSBmYWxzZTtcbiAgICAgIGF1eCAoaSsxKSBlbmRcbiAgICBlbHNlXG4gICAgICBCaXR2LnNldCBlIGkgdHJ1ZSBpblxuICAgIGF1eCAwXG5cbmxldCBkZWNfZXhwIGUgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID49IEJpdHYubGVuZ3RoIGUgdGhlbiByYWlzZSBPdmVyZmxvdyBlbHNlXG4gICAgaWYgQml0di5nZXQgZSBpIHRoZW5cbiAgICAgIEJpdHYuc2V0IGUgaSBmYWxzZVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIEJpdHYuc2V0IGUgaSB0cnVlO1xuICAgICAgYXV4IChpKzEpXG4gICAgZW5kIGluXG4gIGF1eCAwXG5cbigqKiBbbmV4dF9pbmYgZl0gcmV0dXJucyB0aGUgbmV4dCBmbG9hdCBpbiB0aGUgZGlyZWN0aW9uIG9mIMKx4oieIGFjY29yZGluZyB0byB0aGVcbiAgICBzaWduIG9mIFtmXS5cbiAgICBJZiBbZl0gaXMgWytJbmZdIChvciBbLUluZl0pIHRoZW4gYSB7IWNvcHl9IG9mIFtmXSBpcyByZXR1cm5lZC4gKilcbmxldCBuZXh0X2luZiBmID1cbiAgbGV0IHtlOyBtOyBffSBhcyByZXMgPSBjb3B5IGYgaW5cbiAgaWYgaXNfaW5mIGYgdGhlbiByZXMgZWxzZVxuICB0cnkgaW5jX21hbnRpc3NhIG07IHJlc1xuICB3aXRoIE92ZXJmbG93IC0+XG4gICAgbGV0ICgpID0gYXNzZXJ0KCBCaXR2LmFsbF96ZXJvcyBtKSBpblxuICAgIHRyeSBpbmNfZXhwIGU7IHJlc1xuICAgIHdpdGggT3ZlcmZsb3cgLT4gTG9nLmZhaWwgXCJVbmV4cGVjdGVkIE92ZXJmbG93eCBpbiBpbmNyZW1lbnQgZXhwXCJcblxuKCoqIFtuZXh0X2luZiBmXSByZXR1cm5zIHRoZSBuZXh0IGZsb2F0IHRvd2FyZHMgWzBdLlxuICAgIElmIFtmXSBpcyBbKzAuMF0gdGhlbiBbbmV4dF96ZW9dIHJldHVybnMgWy0wLjBdLFxuICAgIElmIFtmXSBpcyBbLTAuMF0gdGhlbiBbbmV4dF96ZW9dIHJldHVybnMgWyswLjBdLCAqKVxubGV0IG5leHRfemVybyBmID1cbiAgbGV0IHtlOyBtOyBzOyBffSBhcyByZXMgPSBjb3B5IGYgaW5cbiAgaWYgaXNfemVybyBmIHRoZW4geyByZXMgd2l0aCBzID0gbm90IHN9IGVsc2VcbiAgdHJ5IGRlY19tYW50aXNzYSBtOyByZXNcbiAgd2l0aCBPdmVyZmxvdyAtPlxuICAgIGxldCAoKSA9IGFzc2VydCAoQml0di5hbGxfb25lcyBtKSBpblxuICAgIHRyeSBkZWNfZXhwIGU7IHJlc1xuICAgIHdpdGggT3ZlcmZsb3cgLT4gTG9nLmZhaWwgXCJVbmV4cGVjdGVkIE92ZXJmbG93IGluIGRlY3JlbWVudCBleHAgXCJcblxuKCoqIFtzdWNjIGZdIHJldHVybnMgdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciByaWdodCBhZnRlciBbZl0uXG4gICAgU2VlIGFsc28geyFGbG9hdC5zdWNjfS4gKilcbmxldCBzdWNjIGYgPVxuICBpZiBpc196ZXJvIGYgdGhlbiBuZXh0X2luZiB7ZiB3aXRoIHMgPSB0cnVlfSBlbHNlXG4gIGlmIGYucyB0aGVuIG5leHRfaW5mIGYgZWxzZSBuZXh0X3plcm8gZlxuXG4oKiogW3ByZWQgZl0gcmV0dXJucyB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIHJpZ2h0IGJlZm9yZSBbZl0uXG4gICAgU2VlIGFsc28geyFGbG9hdC5wcmVkfS4gKilcbmxldCBwcmVkIGYgPVxuICBpZiBpc196ZXJvIGYgdGhlbiBuZXh0X2luZiB7ZiB3aXRoIHMgPSBmYWxzZX0gZWxzZVxuICBpZiBmLnMgdGhlbiBuZXh0X3plcm8gZiBlbHNlIG5leHRfaW5mIGZcblxuKCoqIHsxIFJvdW5maW5nIG1vZGV9ICopXG5cbnR5cGUgcm91bmRpbmcgPVxuICB8IFRPX0lORiB8IFRPX01JTkYgKCoqIHJvdW5kIHRvd2FyZHMgXFxwbSBpbmYgKilcbiAgfCBUT19aRVJPICAgICgqKiByb3VuZHMgdG93YXJkcyB6ZXJvIChpZ25vcmUgdHJhaWxpbmcgYml0cykgKilcbiAgfCBUT19ORUFSRVNUICgqKiByb3VuZHMgdG93YXJkcyBuZWFyZXN0IGZsb2F0aW5nIHBvaW50LiAqKVxuXG50eXBlIGNvbnZlcnNpb25faW5mbyA9XG4gIHwgRVhBQ1RcbiAgfCBST1VOREVEXG5cbmxldCBwcF9jb252ZXJzaW9uX2luZm8gZm10ID0gZnVuY3Rpb25cbiAgICB8IEVYQUNUIC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiZXhhY3RcIlxuICAgIHwgUk9VTkRFRCAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcInJvdW5kZWRcIiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDM1MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuRmxvYXRWaWV3Lm9ianMvanNvby9kZWZhdWx0L0Zsb2F0Vmlldy5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0XzBfaWkiLCJjc3QiLCJjYW1sX2VxdWFsIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDYiLCJhMyIsImE0IiwiYTUiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWIiLCJVdGlscyIsIlN0ZGxpYl9Gb3JtYXQiLCJBc3NlcnRfZmFpbHVyZSIsImV4dGVuZF9mcmFjIiwiZCIsInNpemUiLCJwYWRkIiwiZnJhY19wYXJ0IiwicHJvcGFnYXRlX3NpZ24iLCJpbnRfcGFydCIsInNpZ24iLCJhZGQiLCJkMSIsImQyIiwic2l6ZV9mcmFjIiwiZmFjdCIsIm1hdGNoIiwib3ZlcmZsb3ciLCJzdWIiLCJwcCIsImZtdCIsInBwX3NjaWVudGlmaWMiLCJzaWduaWZpY2FuZCIsInN0ciIsInBvdyIsImludF9zdHIiLCJpIiwibGVuIiwiZnJvbV9pbnQiLCJsIiwicG9zIiwicG93MTAiLCJwIiwiZGl2IiwiZmFjdF9pbnQiLCJyZW0iLCJmYWN0X2ZyYWMiLCJmcm9tX3N0cmluZyIsInMiLCJpZHgiLCJleHBvbmVudCIsIkRlY2ltYWwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9saWIvZGVjaW1hbC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFB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QixhQUt3QjtBQUFBO0FBQUEsS0FBQXVCLE1BTk47QUFBQSxLQUFBakIsY0FHUjtBQUFBLEtBQUFrQjtBQUFBQSxPQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBZjtBQUFBLEtBQUFwQyxJQUNRO0FBQUEsSUFDQSxPQUF3QixTQUF4QixxQ0FBd0I7QUFBQTtBQUFBO0FBQUEsSUFBQXFDO0FBQUFBLE1EMUtwQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAqIFRoaXMgRmlsZSBpcyBwYXJ0IG9mIHRoZSBGbG9hdFZpZXcgcmVwb3NpdG9yeVxuICogQ29weXJpZ2h0IChDKSAyMDI1IC0gSm9zc2VsaW4gR2lldFxuICpcbiAqIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIENlY0lMTCB2Mi4xLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb25zLCBzZWUgdGhlIExJQ0VOU0UgZmlsZS5cbiAqKVxuXG5tb2R1bGUgWiA9IFV0aWxzLlpcblxuKCoqIE1vZHVsZSB1c2VkIGZvciBleGFjdCByZXByZXNlbnRhdGlvbiBhbmQgb3BlcmF0aW9ucyBvZiBkZWNpbWFsIHZhbHVlcy4gKilcblxuKCoqIHsxIEFyYml0cmFyeSBkZWNpbWFsIHJlcHJlc2VudGF0aW9ufSAqKVxuXG4oKiogZXhhY3QgcmVwcmVzZW50YXRpb24gb2YgZGVjaW1hbCBudW1iZXJzICopXG50eXBlIGRlY2ltYWwgPSB7XG4gIHNpZ246IGJvb2w7ICAgICAoKiogU2lnbiBvZiB0aGEgdmFsdWUuIFt0cnVlXSBmb3IgcG9zaXRpdmUgdmFsdWUuICopXG4gIGludF9wYXJ0OiBaLnQ7ICAoKiogaW50ZWdyYWwgcGFydCBvZiB0aGUgZGVjaW1hbCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgQWx3YXlzIHBvc2l0aXZlLiAgKilcbiAgZnJhY19wYXJ0OiBaLnQ7ICgqKiBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIGRlY2ltYWwgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgIEFsd2F5cyBwb3NpdGl2ZS4gKilcbiAgc2l6ZV9mcmFjOiBpbnQ7ICgqKiBzaXplIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnQge2kgaS5lLn0gdGhlIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgcG9pbnQuKilcbn1cbigqKiBUaGUgdmFsdWUgcmVwcnNlbnRlZCBieSBhIGRlY2ltYWwgdHlwZSBpc1xuICAgICgtMSnCtyhbaW50ZWdlcl9wYXJ0XSArIFtmcmFjX3BhcnRdwrcxMF5bLXNpemVfZnJhY10pLlxuICAgICopXG5cbigqKiBbZXh0YW5kX2ZyYWMgcyBzaXplXSBleHRlbmQgdGhlIGRlY2ltYWwgdmFsdWUgW2RdIHNvIHRoYXQgaXRzIGZyYWN0aW9uYWxcbiAgICBwYXJ0IGhhcyBzaXplIFtzaXplXS5cblxuICAgIEByYWlzZSB7IUFzc2VydGlvbl9mYWlsdXJlfSBpZiB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIFtkXSBpcyBncmVhdGVyIHRoYW5cbiAgICAgIFtzaXplXS4gKilcbmxldCBleHRlbmRfZnJhYyBkIHNpemUgPVxuICBhc3NlcnQgKHNpemUgPj0gZC5zaXplX2ZyYWMpO1xuICBpZiBzaXplID0gZC5zaXplX2ZyYWMgdGhlbiBkIGVsc2VcbiAgbGV0IHBhZGQgPSBaLnBvdzEwIChzaXplLWQuc2l6ZV9mcmFjKSBpblxuICBsZXQgZnJhY19wYXJ0ID0gWi5tdWwgZC5mcmFjX3BhcnQgcGFkZCBpblxuICB7IGQgd2l0aCBzaXplX2ZyYWMgPSBzaXplOyBmcmFjX3BhcnQgfVxuXG4oKiogW3Byb3BhZ2F0ZV9zaWduIGRdIHNldCB0aGUgc2lnbiBvZiBbZF0gdG8gaXRzIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgcGFydHMuXG4gICAgVGhpcyBlbnRhaWxzIHRoYXQgdGhlIHJldHVybmVkIGRlY2ltYWwgdmFsdWUgaXMgbm90IGluIG5vcm1hbCBmb3JtLiAqKVxubGV0IHByb3BhZ2F0ZV9zaWduICh7c2lnbjsgaW50X3BhcnQ7IGZyYWNfcGFydDsgX30gYXMgZCkgPVxuICBpZiBzaWduIHRoZW4gZCBlbHNlXG4gIGxldCBpbnRfcGFydCA9IFoubmVnIGludF9wYXJ0IGluXG4gIGxldCBmcmFjX3BhcnQgPSBaLm5lZyBmcmFjX3BhcnQgaW5cbiAgeyBkIHdpdGggaW50X3BhcnQ7IGZyYWNfcGFydH1cblxuXG4oKiogQWRkaXRpb24gb2YgdHdvIGRlY2ltYWwgdmFsdWVzLiAqKVxubGV0IGFkZCBkMSBkMiA9XG4gIGxldCBzaXplX2ZyYWMgPSBtYXggZDEuc2l6ZV9mcmFjIGQyLnNpemVfZnJhYyBpblxuICBsZXQgZDEgPSBleHRlbmRfZnJhYyBkMSBzaXplX2ZyYWMgfD4gcHJvcGFnYXRlX3NpZ24gaW5cbiAgbGV0IGQyID0gZXh0ZW5kX2ZyYWMgZDIgc2l6ZV9mcmFjIHw+IHByb3BhZ2F0ZV9zaWduIGluXG4gIGxldCBpbnRfcGFydCA9IFouYWRkIGQxLmludF9wYXJ0IGQyLmludF9wYXJ0IGluXG4gIGxldCBmcmFjX3BhcnQgPSBaLmFkZCBkMS5mcmFjX3BhcnQgZDIuZnJhY19wYXJ0IGluXG4gIGxldCBmYWN0ID0gWi5wb3cxMCBzaXplX2ZyYWMgaW5cbiAgbGV0IG92ZXJmbG93LCBmcmFjX3BhcnQgPSBaLmRpdl9yZW0gZnJhY19wYXJ0IGZhY3QgaW5cbiAgbGV0IGludF9wYXJ0ID0gWi5hZGQgaW50X3BhcnQgb3ZlcmZsb3cgaW5cbiAgbGV0IGludF9wYXJ0LCBmcmFjX3BhcnQsIHNpZ24gPSBtYXRjaCBaLmdlcSBpbnRfcGFydCBaLnplcm8sIFouZ2VxIGZyYWNfcGFydCBaLnplcm8gd2l0aFxuICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBpbnRfcGFydCwgZnJhY19wYXJ0LCB0cnVlXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gWi5uZWcgaW50X3BhcnQsIFoubmVnIGZyYWNfcGFydCwgZmFsc2VcbiAgICB8IHRydWUsIGZhbHNlIHdoZW4gWi5lcXVhbCBpbnRfcGFydCBaLnplcm8gLT5cbiAgICAgICAgaW50X3BhcnQsIFoubmVnIGZyYWNfcGFydCwgZmFsc2VcbiAgICB8IHRydWUsIGZhbHNlIC0+XG4gICAgICAgIGxldCBpbnRfcGFydCA9IFoucHJlZCBpbnRfcGFydCBpblxuICAgICAgICBsZXQgZnJhY19wYXJ0ID0gWi5hZGQgZmFjdCBmcmFjX3BhcnQgaW5cbiAgICAgICAgaW50X3BhcnQsIGZyYWNfcGFydCwgdHJ1ZVxuICAgIHwgZmFsc2UsIHRydWUgLT5cbiAgICAgICAgbGV0IGludF9wYXJ0ID0gWi5wcmVkIGludF9wYXJ0IGluXG4gICAgICAgIGxldCBmcmFjX3BhcnQgPSBaLnN1YiBmYWN0IGZyYWNfcGFydCBpblxuICAgICAgICBaLm5lZyBpbnRfcGFydCwgZnJhY19wYXJ0LCBmYWxzZSBpblxuICB7IGludF9wYXJ0OyBmcmFjX3BhcnQ7IHNpZ247IHNpemVfZnJhY31cblxuKCoqIFN1YnN0cmFjdGlvbiBvZiB0d28gZGVjaW1hbCB2YWx1ZXMuICopXG5sZXQgc3ViIGQxIGQyID1cbiAgbGV0IGQyID0geyBkMiB3aXRoIHNpZ24gPSBub3QgZDIuc2lnbn0gaW5cbiAgYWRkIGQxIGQyXG5cbnR5cGUgdCA9IGRlY2ltYWxcblxubGV0IHBwIGZtdCBkID1cbiAgaWYgZC5zaWduIHRoZW4gRm9ybWF0LmZwcmludGYgZm10IFwiK1wiIGVsc2UgRm9ybWF0LmZwcmludGYgZm10IFwiLVwiO1xuICBaLnBwX3ByaW50IGZtdCBkLmludF9wYXJ0O1xuICBpZiBaLmVxdWFsIFouemVybyBkLmZyYWNfcGFydCB0aGVuICgpIGVsc2VcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiLiVzXCJcbiAgICAoWi5mb3JtYXQgKEZvcm1hdC5zcHJpbnRmIFwiJSUwJWlpXCIgZC5zaXplX2ZyYWMpIGQuZnJhY19wYXJ0KVxuXG4oKiogW3BwX3NjaWVudGlmaWMgP3NpZ25pZmljYW5kXSBpcyBhIHByZXR0eSBwcmludGVyIG9mIGRlY2ltYWwgdmFsdWVzIGluXG4gICAgc2NpZW50aWZpYyBub3RhdGlvbi5cblxuICAgIFRoZSBvcHRpb25hbCBhcmd1bWVudCBbc2lnbmlmaWNhbmRdIHNldCB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW5kIG51bWJlciB0b1xuICAgIHByaW50LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzZXQ7IG9yIHNldCB0byBbMF0sIHRoZW4gYWxsIGRpZ2l0cyBpbiB0aGVcbiAgICBkZWNpbWFsIHZhbHVlcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9zY2llbnRpZmljID9zaWduaWZpY2FuZCBmbXQgZCA9XG4gIGlmIGQuaW50X3BhcnQgPSBaLnplcm8gJiYgZC5mcmFjX3BhcnQgPSBaLnplcm8gdGhlblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVjMC4wXCJcbiAgICAoaWYgZC5zaWduIHRoZW4gJysnIGVsc2UgJy0nKSBlbHNlXG4gIGxldCBwb3csIHN0ciA9XG4gICAgaWYgZC5pbnRfcGFydCA9IFouemVybyB0aGVuXG4gICAgICBsZXQgc3RyID0gWi50b19zdHJpbmcgZC5mcmFjX3BhcnQgaW5cbiAgICAgIC0gZC5zaXplX2ZyYWMgLTEgKyBTdHJpbmcubGVuZ3RoIHN0ciwgc3RyXG4gICAgZWxzZVxuICAgICAgbGV0IGludF9zdHIgPSBaLnRvX3N0cmluZyBkLmludF9wYXJ0IGluXG4gICAgICBsZXQgcG93ID0gU3RyaW5nLmxlbmd0aCBpbnRfc3RyIC0xIGluXG4gICAgICBsZXQgc3RyID0gRm9ybWF0LmFzcHJpbnRmIFwiJXMlc1wiXG4gICAgICAgICAgaW50X3N0clxuICAgICAgICAgIChaLmZvcm1hdCAoRm9ybWF0LnNwcmludGYgXCIlJTAlaWlcIiBkLnNpemVfZnJhYykgZC5mcmFjX3BhcnQpIGluXG4gICAgICBwb3csIHN0ciBpblxuICBsZXQgbGVuID0gbWF0Y2ggc2lnbmlmaWNhbmQgd2l0aFxuICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHN0ciAtMVxuICAgIHwgU29tZSBpIHdoZW4gaSA8PSAwIC0+IFN0cmluZy5sZW5ndGggc3RyIC0xXG4gICAgfCBTb21lIGkgLT4gbWluIGkgKFN0cmluZy5sZW5ndGggc3RyIC0xICkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiJWMlYy4lc2UlaVwiXG4gICAgKGlmIGQuc2lnbiB0aGVuICcrJyBlbHNlICctJylcbiAgICAoU3RyaW5nLmdldCBzdHIgMClcbiAgICAoU3RyaW5nLnN1YiBzdHIgMSBsZW4pXG4gICAgcG93XG5cbmxldCBmcm9tX2ludCBpID1cbiAgbGV0IHNpZ24sIGkgPSBpZiBpID49IDAgdGhlbiB0cnVlLCBpIGVsc2UgZmFsc2UsIC1pIGluXG4gIGxldCBpbnRfcGFydCA9IFoub2ZfaW50IGkgaW5cbiAgeyBzaWduOyBpbnRfcGFydDsgZnJhY19wYXJ0ID0gWi56ZXJvOyBzaXplX2ZyYWMgPSAwIH1cblxubGV0IGZyb21fc3RyaW5nIHN0ciA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHNpZ24sIHBvcyA9XG4gICAgaWYgU3RyaW5nLnN0YXJ0c193aXRoIH5wcmVmaXg6XCIrXCIgc3RyIHRoZW5cbiAgICAgIHRydWUsIDFcbiAgICBlbHNlIGlmIFN0cmluZy5zdGFydHNfd2l0aCB+cHJlZml4OlwiLVwiIHN0ciB0aGVuXG4gICAgICBmYWxzZSwgMVxuICAgIGVsc2UgdHJ1ZSwgMCBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXhfb3B0IHN0ciAnLicgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGxldCBpbnRfcGFydCA9IFoub2Zfc3Vic3RyaW5nIHN0ciB+cG9zIH5sZW46KGwgLSBwb3MpIGluXG4gICAgICB7IHNpZ247IGludF9wYXJ0OyBmcmFjX3BhcnQgPSBaLnplcm87IHNpemVfZnJhYyA9IDAgfVxuICB8IFNvbWUgaSAtPlxuICAgICAgbGV0IGludF9wYXJ0ID0gWi5vZl9zdWJzdHJpbmcgc3RyIH5wb3MgfmxlbjooaS1wb3MpIGluXG4gICAgICBsZXQgc2l6ZV9mcmFjID0gbCAtaS0xIGluXG4gICAgICBsZXQgZnJhY19wYXJ0ID0gWi5vZl9zdWJzdHJpbmcgc3RyIH5wb3M6KGkrMSkgfmxlbjoobC1pLTEpIGluXG4gICAgICB7IHNpZ247IGludF9wYXJ0OyBzaXplX2ZyYWM7IGZyYWNfcGFydCB9XG5cbigqKiBbcG93MTAgZCBwXSByZXR1cm5zIHRoZSByZXByZXNlbnRhdGlvbiBvZiBbZCoxMF5wXS4gKilcbmxldCBwb3cxMCBkIHAgPVxuICBpZiBwID0gMCB0aGVuIGQgZWxzZVxuICBpZiBwID4gMCB0aGVuXG4gICAgbGV0IHNpemVfZnJhYyA9IG1heCAwIChkLnNpemVfZnJhYyAtIHApIGluXG4gICAgbGV0IGZhY3QgPSBaLnBvdzEwIHNpemVfZnJhYyBpblxuICAgIGxldCBkaXYsIGZyYWNfcGFydCA9IFouZGl2X3JlbSBkLmZyYWNfcGFydCBmYWN0IGluXG4gICAgbGV0IGZhY3RfaW50ID0gWi5wb3cxMCBwIGluXG4gICAgbGV0IGludF9wYXJ0ID0gWi5hZGQgZGl2IChaLm11bCBkLmludF9wYXJ0IGZhY3RfaW50KSBpblxuICAgIHsgc2l6ZV9mcmFjOyBpbnRfcGFydDsgZnJhY19wYXJ0OyBzaWduID0gZC5zaWduIH1cbiAgZWxzZVxuICAgIGxldCBwID0gLXAgaW5cbiAgICBsZXQgc2l6ZV9mcmFjID0gcCArIGQuc2l6ZV9mcmFjIGluXG4gICAgbGV0IGZhY3QgPSAgWi5wb3cxMCBwIGluXG4gICAgbGV0IGludF9wYXJ0LCByZW0gPSBaLmRpdl9yZW0gZC5pbnRfcGFydCBmYWN0IGluXG4gICAgbGV0IGZhY3RfZnJhYyA9IFoucG93MTAgZC5zaXplX2ZyYWMgaW5cbiAgICBsZXQgZnJhY19wYXJ0ID0gWi5hZGQgZC5mcmFjX3BhcnQgKFoubXVsIGZhY3RfZnJhYyByZW0pIGluXG4gICAgeyBzaXplX2ZyYWM7IGludF9wYXJ0OyBmcmFjX3BhcnQ7IHNpZ24gPSBkLnNpZ24gfVxuXG4oKiogW2Zyb21fc3RyaW5nIHNdIHBhcnNlcyB0aGUgdmFsdWUgaW4gW3NdLlxuICAgIEl0IHN1cHBvcnQgc2NpZW50aWZpYyBub3RhdGlvbiBzdWNoIGFzIFsxLjE3NTQ5NDM1MDhl4oiSMzhdLiAqKVxubGV0IGZyb21fc3RyaW5nIHMgPVxuICBtYXRjaCBTdHJpbmcuaW5kZXhfb3B0IHMgJ2UnIHdpdGhcbiAgfCBOb25lIC0+IGZyb21fc3RyaW5nIHNcbiAgfCBTb21lIGlkeCAtPlxuICAgIGxldCBzaWduaWZpY2FuZCA9IFN0cmluZy5zdWIgcyAwIGlkeCBpblxuICAgIGxldCBleHBvbmVudCA9IFN0cmluZy5zdWIgcyAoaWR4KzEpIChTdHJpbmcubGVuZ3RoIHMgLSBpZHggLTEgKSBpblxuICAgIGxldCBkID0gZnJvbV9zdHJpbmcgc2lnbmlmaWNhbmQgaW5cbiAgICBwb3cxMCBkIChpbnRfb2Zfc3RyaW5nIGV4cG9uZW50KSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDYwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuRmxvYXRWaWV3Lm9ianMvanNvby9kZWZhdWx0L0Zsb2F0Vmlldy5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGw0IiwiYTIiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiY3N0IiwiQml0diIsIlN0ZGxpYiIsIlN0ZGxpYl9Gb3JtYXQiLCJwcCIsImZtdCIsInBhcmFtIiwicmVwZWF0aW5nIiwiZnJhY3Rpb25hbCIsImludGVnZXIiLCJzaWduIiwiZnJvbV9pbnQiLCJ4IiwiemVybyIsImdldF9iaXQiLCJiaW4iLCJpIiwibGVuX3VuZGVyIiwibGVuX3JlcGVhdCIsIkZvdW5kIiwiZ2V0X2ZpcnN0X25vbl9udWxsIiwiZXhuIiwiaXNfbnVsbF9hZnRlciIsImIiLCJiaXQiLCJ0aHJlc2giLCJjb21wYXJlIiwiYjEiLCJiMiIsIm1hdGNoIiwiaTEiLCJpMiIsImxpbSIsIkJpbmFyeSJdLCJzb3VyY2VzIjpbIi9i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UDtBQUFBLFFBQUFDLEtBZHVDO0FBQUEsSUFJMUIsY0FBWSx3Q0FVekI7QUFBQTtBQUFBLFdBUmlDO0FBQUEsV0FBNUI7QUFBQSxLQUFBQyxNQUFKO0FBQUEsS0FBQUEsUUFDVjtBQUFBLEtBQUFoQixJQU9BO0FBQUE7QUFBQSxLQUxFLGNBQWdCO0FBQUEsU0FBQWEsVUFDVixnQkFBQUEsVUFBYztBQUFBLEtBQVk7QUFBQSxvQkFDZixxQkFHVjtBQUFBO0FBQUEsc0JBRlUscUJBRVY7QUFBQSxTQUFBYixNQURJO0FBQUE7QUFBQTtBQUFBLEdBQ0o7QUFBQTtBQUFBLElBQUFpQjtBQUFBQSxNQTFFTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR4Q3JCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICogVGhpcyBGaWxlIGlzIHBhcnQgb2YgdGhlIEZsb2F0VmlldyByZXBvc2l0b3J5XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjUgLSBKb3NzZWxpbiBHaWV0XG4gKlxuICogVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbigqKiBNb2R1bGUgdXNlZCBmb3IgZXhhY3QgcmVwcmVzZW50YXRpb24gYW5kIG9wZXJhdGlvbnMgb2YgYmluYXJ5IHZhbHVlcy4gKilcblxuKCoqIHsxIEJpbmFyeX0gKilcblxuKCoqIGV4YWN0IHJlcHJlc2VudGF0aW9uIG9mIGJpbmF5IHZhbHVlcy4gKilcbnR5cGUgYmluYXJ5ID0ge1xuICBzaWduOiBib29sOyAgICAgICAgICgqKiBbdHJ1ZV0gZm9yIHBvc2l0aXZlIHZhbHVlICopXG4gIGludGVnZXI6IEJpdHYudDsgICAgKCoqIGludGVncmFsIHBhcnQgb2YgdGhlIHZhbHVlLiAqKVxuICBmcmFjdGlvbmFsOiBCaXR2LnQ7ICgqKiBub24tcmVwZWF0aW5nIHBhcnQgb2YgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgdmFsdWUuKilcbiAgcmVwZWF0aW5nOiBCaXR2LnQ7ICAoKiogcmVwZWF0aW5nIHBhcnQgb2YgdGhlIGZyY3Rpb25hbCBwYXJ0IG9mIHRoZSB2YWx1ZS4gKilcbn1cblxubGV0IHBwIGZtdCB7c2lnbjsgaW50ZWdlcjsgZnJhY3Rpb25hbDsgcmVwZWF0aW5nIH0gPVxuICBpZiBub3Qgc2lnbiB0aGVuIEZvcm1hdC5wcF9wcmludF9jaGFyIGZtdCAnLSc7XG4gIGlmIEJpdHYubGVuZ3RoIGludGVnZXIgPiAwXG4gICAgdGhlbiBCaXR2Lk0ucHJpbnQgZm10IGludGVnZXJcbiAgICBlbHNlIEZvcm1hdC5wcF9wcmludF9jaGFyIGZtdCAnMCc7XG4gIGxldCBwcmludGVkID0gaWYgdHJ1ZSB8fCBCaXR2Lmxlbmd0aCBmcmFjdGlvbmFsID4gMFxuICAgIHRoZW4gKEZvcm1hdC5mcHJpbnRmIGZtdCBcIi4lYVwiIEJpdHYuTC5wcmludCBmcmFjdGlvbmFsOyB0cnVlKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgaWYgQml0di5sZW5ndGggcmVwZWF0aW5nID4gMCB0aGVuXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJXMoJWEpKlwiXG4gICAgICAoaWYgcHJpbnRlZCB0aGVuIFwiXCIgZWxzZSBcIi5cIilcbiAgICAgIEJpdHYuTC5wcmludCByZXBlYXRpbmdcblxubGV0IGZyb21faW50IHggPVxuICBsZXQgc2lnbiwgeCA9IGlmIHggPj0gMCB0aGVuIHRydWUsIHggZWxzZSBmYWxzZSwgLXggaW5cbiAgbGV0IGludGVnZXIgPSBCaXR2Lm9mX2ludF91cyB4IGluXG4gIGxldCBmcmFjdGlvbmFsID0gQml0di5jcmVhdGUgMCBmYWxzZSBpblxuICBsZXQgcmVwZWF0aW5nID0gZnJhY3Rpb25hbCBpblxuICB7IHNpZ247IGludGVnZXI7IGZyYWN0aW9uYWw7IHJlcGVhdGluZyB9XG5cbmxldCB6ZXJvID0gZnJvbV9pbnQgMFxuXG4oKiogW2dldF9iaXQgYmluIGldIHJldHVybnMgdGhlIGledGggYml0IG9mIGJpbmFyeSB2YWx1ZSBbYmluXS4gKilcbmxldCBnZXRfYml0IGJpbiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBpZiBCaXR2Lmxlbmd0aCBiaW4uaW50ZWdlciA+IGlcbiAgICAgIHRoZW4gQml0di5nZXQgYmluLmludGVnZXIgaVxuICAgICAgZWxzZSBmYWxzZVxuICBlbHNlXG4gICAgbGV0IGkgPSAtaSAtMSBpblxuICAgIGxldCBsZW5fdW5kZXIgPSBCaXR2Lmxlbmd0aCBiaW4uZnJhY3Rpb25hbCBpblxuICAgIGlmIGkgPCBsZW5fdW5kZXIgdGhlblxuICAgICAgQml0di5nZXQgYmluLmZyYWN0aW9uYWwgaVxuICAgIGVsc2VcbiAgICAgIGxldCBpID0gaSAtIGxlbl91bmRlciAgaW5cbiAgICAgIGxldCBsZW5fcmVwZWF0ID0gQml0di5sZW5ndGggYmluLnJlcGVhdGluZyBpblxuICAgICAgaWYgbGVuX3JlcGVhdCA9IDAgdGhlblxuICAgICAgICBmYWxzZVxuICAgICAgZWxzZVxuICAgICAgICBCaXR2LmdldCBiaW4ucmVwZWF0aW5nIChpIG1vZCBsZW5fcmVwZWF0KVxuXG5leGNlcHRpb24gRm91bmQgb2YgaW50XG5cbigqKiBbZ2V0X2ZpcnN0X25vbl9udWxsIGJpbl0gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi1udWxsIGJpdFxuICAgIGluIFtiaW5dLiBSZXR1cm5zIFtOb25lXSBpZiBbYmluXSBpcyBlcXVhbCB0byB6ZXJvLiAqKVxubGV0IGdldF9maXJzdF9ub25fbnVsbCBiaW4gPVxuICB0cnlcbiAgICBmb3IgaSA9IChCaXR2Lmxlbmd0aCBiaW4uaW50ZWdlcikgLSAxIGRvd250byAwIGRvXG4gICAgICBpZiBCaXR2LmdldCBiaW4uaW50ZWdlciBpIHRoZW4gcmFpc2UgKEZvdW5kIGkpXG4gICAgZG9uZTtcbiAgICBmb3IgaSA9IDAgdG8gKEJpdHYubGVuZ3RoIGJpbi5mcmFjdGlvbmFsKSAtIDEgZG9cbiAgICAgIGlmIEJpdHYuZ2V0IGJpbi5mcmFjdGlvbmFsIGkgdGhlbiByYWlzZSAoRm91bmQgKC0oaSsxKSkpXG4gICAgZG9uZTtcbiAgICBmb3IgaSA9IDAgdG8gKEJpdHYubGVuZ3RoIGJpbi5yZXBlYXRpbmcpIC0gMSBkb1xuICAgICAgaWYgQml0di5nZXQgYmluLnJlcGVhdGluZyBpIHRoZW4gcmFpc2UgKEZvdW5kICgtKGkrKEJpdHYubGVuZ3RoIGJpbi5mcmFjdGlvbmFsKSsxKSkpXG4gICAgZG9uZTtcbiAgICBOb25lXG4gIHdpdGggRm91bmQgaSAtPiBTb21lIGlcblxuKCoqIFtpc19udWxsX2FmdGVyIGIgYml0XSByZXR1cm5zIHRydWUgW3RydWVdIGlmZi4gYWxsIGJpdHMgaW4gW2JdIGFmdGVyIHRoZVxuICAgIFtiaXRdXnRoIChpbmNsdWRlZCkgYXJlIG51bGwuKilcbmxldCBpc19udWxsX2FmdGVyIGIgYml0ID1cbiAgbGV0IHRocmVzaCA9IC0oQml0di5sZW5ndGggYi5yZXBlYXRpbmcgKyBCaXR2Lmxlbmd0aCBiLmZyYWN0aW9uYWwgKyAxKSBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpIDwgdGhyZXNoIHx8IG5vdCAoZ2V0X2JpdCBiIGkpICYmIGF1eCAoaS0xKSBpblxuICBhdXggYml0XG5cbigqKiBBbGlhcyBmb3IgdGhlIHshYmluYXJ5fSB0eXBlLiB1c2VkIGZvciB7IU1hcC5NYWtlfSBmdW5jdG9lLiAqKVxudHlwZSB0ID0gYmluYXJ5XG5cbigqKiBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgIEZvbGxvd3MgdGhlIG9yZGVyIG9mIHJlYWwgdmFsdWVzIHtpIGkuZS59ICBbY29tcGFyZSBiMSBiMl0gaXNcbiAgICArIFswXSB3aGVuIFtiMV0gaXMgZXF1YWwgdG8gW2IyXTtcbiAgICArIHNtYWxsZXIgdGhhbiBbMF0gaWYgW2IxXSBpcyBsb3dlciB0aGFuIFtiMl07XG4gICAgKyBncmVhdGVyIHRoYW4gWzBdIG90aGVyd2lzZS4gKilcbmxldCBjb21wYXJlIGIxIGIyID1cbiAgbWF0Y2ggYjEuc2lnbiwgYjIuc2lnbiB3aXRoXG4gIHwgZmFsc2UsIHRydWUgLT4gMVxuICB8IHRydWUsIGZhbHNlIC0+IC0xXG4gIHwgXywgXyAtPlxuICAgIG1hdGNoIGdldF9maXJzdF9ub25fbnVsbCBiMSwgZ2V0X2ZpcnN0X25vbl9udWxsIGIyIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgU29tZSBfLCBOb25lIC0+IGlmIGIxLnNpZ24gdGhlbiAxIGVsc2UgLTFcbiAgICB8IE5vbmUsIFNvbWUgXyAtPiBpZiBiMS5zaWduIHRoZW4gLTEgZWxzZSAxXG4gICAgfCBTb21lIGkxLCBTb21lIGkyIHdoZW4gaTEgPD4gaTIgLT4gaWYgYjEuc2lnbiB0aGVuIGkxIC0gaTIgZWxzZSBpMiAtIGkxXG4gICAgfCBTb21lIGksIFNvbWUgXyAtPlxuICAgICAgbGV0IGxpbSA9IG1heCAoQml0di5sZW5ndGggYjEuZnJhY3Rpb25hbCkgKEJpdHYubGVuZ3RoIGIxLmZyYWN0aW9uYWwpIGluXG4gICAgICBsZXQgbGltID0gLWxpbSBpblxuICAgICAgbGV0IHJlYyBjb21wYXJlIGkgPVxuICAgICAgICBpZiBpIDwgbGltIHRoZW4gMCBlbHNlXG4gICAgICAgIG1hdGNoIGdldF9iaXQgYjEgaSwgZ2V0X2JpdCBiMiBpIHdpdGhcbiAgICAgICAgfCB0cnVlLCBmYWxzZSAtPiBpZiBiMS5zaWduIHRoZW4gMSBlbHNlIC0xXG4gICAgICAgIHwgZmFsc2UsIHRydWUgLT4gaWYgYjEuc2lnbiB0aGVuIC0xIGVsc2UgMVxuICAgICAgICB8IF8sIF8gIC0+IGNvbXBhcmUgKGktMSkgaW5cbiAgICAgIGNvbXBhcmUgaVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwNzkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5GbG9hdFZpZXcub2Jqcy9qc29vL2RlZmF1bHQvRmxvYXRWaWV3LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRXhjZWVkaW5nX2ZyYWN0aW9uYWxfbGltaXQiLCJjc3RfSW1wbGVtZW50X2NvbnZlcnNpb25fZm9yX3IiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkZsb2F0cyIsIkJpbmFyeSIsIkJpdHYiLCJTdGRsaWIiLCJMb2ciLCJaIiwiU3RkbGliX0hhc2h0YmwiLCJmcmFjX2xpbSIsImRlY190b19iaW4iLCJkIiwiaSIsImludGVnZXIiLCJwYXJhbSIsInJlcyIsImZyYWN0aW9uYWwiLCJ0YmwiLCJkaXZpc29yIiwicmVtIiwibWF0Y2giLCJiIiwiaiIsImxpbV9yZXAiLCJsaW1fZnJhYyIsInJlcGVhdGluZyIsImJpbl90b19kZWMiLCJpbnRfcGFydCIsImJpIiwiYWNjIiwidGVuIiwiZml2ZSIsInBvdyIsInNpemVfZnJhYyIsImZyYWNfcGFydCIsImJpbl90b19mbG9hdF9pbmZvIiwicCIsImJpbiIsInNpZ24iLCJpcyIsImV4cCIsImUiLCJtIiwicyIsInJuZCIsInJvdW5kIiwiYmluX3RvX2Zsb2F0IiwiSXNJbmYiLCJJc05hbiIsImZsb2F0X3RvX2JpbiIsImxlbl9mcmFjIiwibGVuX2ludCIsIkNvbnZlcnQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9saWIvY29udmVydC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdB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dGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnlcbiAqIENvcHlyaWdodCAoQykgMjAyNSAtIEpvc3NlbGluIEdpZXRcbiAqXG4gKiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKilcblxubW9kdWxlIEQgPSBEZWNpbWFsXG5tb2R1bGUgQiA9IEJpbmFyeVxubW9kdWxlIEYgPSBGbG9hdHNcblxuKCoqIHsxIERlY2ltYWwgPC0+IEJpbmFyeX0gKilcblxubGV0IGZyYWNfbGltID0gNTAwMFxuXG5sZXQgZGVjX3RvX2JpbiAoZDogRC50KSA6IEIudCA9XG4gIGxldCBpID0gcmVmIGQuaW50X3BhcnQgaW5cbiAgbGV0IGludGVnZXIgPSBCaXR2LmluaXQgKFoubnVtYml0cyBkLmludF9wYXJ0KVxuICAgIChmdW4gXyAtPlxuICAgICAgbGV0IHJlcyA9IFouaXNfb2RkICFpIGluXG4gICAgICBsZXQgKCkgPSBpIDo9IFouc2hpZnRfcmlnaHRfdHJ1bmMgIWkgMSBpblxuICAgICAgcmVzKSBpblxuICBpZiBkLnNpemVfZnJhYyA9IDAgdGhlblxuICAgIGxldCBmcmFjdGlvbmFsID0gQml0di5jcmVhdGUgMCBmYWxzZSBpblxuICAgIGxldCByZXBlYXRpbmcgPSBmcmFjdGlvbmFsIGluXG4gICAgeyBzaWduID0gZC5zaWduOyBpbnRlZ2VyOyByZXBlYXRpbmc7IGZyYWN0aW9uYWwgfVxuICBlbHNlXG4gICAgbGV0IHRibCA9IEhhc2h0YmwuY3JlYXRlIDUwIGluXG4gICAgbGV0IGZyYWN0aW9uYWwgPSBCaXR2LmNyZWF0ZSBmcmFjX2xpbSBmYWxzZSBpblxuICAgIGxldCBkaXZpc29yID0gWi5tdWwgKFoub2ZfaW50IDUpIChaLnBvdyAoWi5vZl9pbnQgMTApIChkLnNpemVfZnJhYy0xKSkgaW5cbiAgICBsZXQgcmVjIGF1eCBpIHJlbSA9XG4gICAgICBpZiBpID49IGZyYWNfbGltIHRoZW4gYmVnaW5cbiAgICAgICAgTG9nLndhcm4gXCJFeGNlZWRpbmcgZnJhY3Rpb25hbCBsaW1pdGUgc2VhcmNoXCI7XG4gICAgICAgIChpLCBpKSBlbmRcbiAgICAgIGVsc2UgaWYgWi5lcXVhbCBaLnplcm8gcmVtIHRoZW4gKGksIGkpIGVsc2VcbiAgICAgICAgbGV0ICgpID0gSGFzaHRibC5hZGQgdGJsIHJlbSBpIGluXG4gICAgICAgIGxldCBiID0gWi5nZXEgcmVtIGRpdmlzb3IgaW5cbiAgICAgICAgbGV0IHJlbSA9IGlmIGIgdGhlbiBaLnNoaWZ0X2xlZnQgKFouc3ViIHJlbSBkaXZpc29yKSAxIGVsc2UgWi5zaGlmdF9sZWZ0IHJlbSAxIGluXG4gICAgICAgIGxldCAoKSA9IEJpdHYuc2V0IGZyYWN0aW9uYWwgaSBiIGluXG4gICAgICAgIG1hdGNoIEhhc2h0YmwuZmluZF9vcHQgdGJsIHJlbSB3aXRoXG4gICAgICAgIHwgU29tZSBqIC0+IChqLCBpKzEpXG4gICAgICAgIHwgTm9uZSAtPiBhdXggKGkrMSkgcmVtIGluXG4gICAgbGV0IGxpbV9mcmFjLCBsaW1fcmVwID0gYXV4IDAgZC5mcmFjX3BhcnQgaW5cbiAgICBsZXQgcmVwZWF0aW5nID0gQml0di5zdWIgZnJhY3Rpb25hbCBsaW1fZnJhYyAobGltX3JlcC1saW1fZnJhYykgaW5cbiAgICBsZXQgZnJhY3Rpb25hbCA9IEJpdHYuc3ViIGZyYWN0aW9uYWwgMCBsaW1fZnJhYyBpblxuICAgIHsgc2lnbiA9IGQuc2lnbjsgaW50ZWdlcjsgcmVwZWF0aW5nOyBmcmFjdGlvbmFsIH1cblxubGV0IGJpbl90b19kZWMgKGI6IEIudCk6IEQudCA9XG4gIGlmIEJpdHYubGVuZ3RoIGIucmVwZWF0aW5nIDw+IDAgdGhlblxuICAgICgqIE1heWJlIGRvIGFuIGl0ZXJhdGl2ZSBhcHByb3hpbWF0aW9uICopXG4gICAgTG9nLnRvZG8gXCJJbXBsZW1lbnQgY29udmVyc2lvbiBmb3IgcmVwZWF0aW5nIHBhcnRcIjtcbiAgbGV0IGludF9wYXJ0ID0gQml0di5mb2xkX3JpZ2h0XG4gICAgKGZ1biBiaSBhY2MgLT5cbiAgICAgIGxldCBhY2MgPSBaLnNoaWZ0X2xlZnQgYWNjIDEgaW5cbiAgICAgIGlmIGJpIHRoZW4gWi5zdWNjIGFjYyBlbHNlIGFjYylcbiAgICBiLmludGVnZXIgWi56ZXJvIGluXG4gIGxldCB0ZW4gPSBaLm9mX2ludCAxMCBpblxuICBsZXQgZml2ZSA9IFoub2ZfaW50IDUgaW5cbiAgbGV0IGZyYWNfcGFydCwgXywgc2l6ZV9mcmFjID0gQml0di5mb2xkX2xlZnRcbiAgICAoZnVuIChhY2MsIHBvdywgaSkgYiAtPlxuICAgICAgbGV0IGFjYyA9IFoubXVsIGFjYyB0ZW4gaW5cbiAgICAgIGxldCBwb3cgPSBaLm11bCBwb3cgZml2ZSBpblxuICAgICAgbGV0IGFjYyA9IGlmIGIgdGhlbiBaLmFkZCBhY2MgcG93IGVsc2UgYWNjIGluXG4gICAgICAoYWNjLCBwb3csIGkrMSkpXG4gICAgKFouemVybywgWi5vbmUsIDApIGIuZnJhY3Rpb25hbCBpblxuICB7IHNpZ24gPSBiLnNpZ247IGludF9wYXJ0OyBmcmFjX3BhcnQ7IHNpemVfZnJhYyB9XG5cbigqKiB7MSBCaW5hcnkgPC0+IEZsb2F0c30gKilcblxuXG5sZXQgYmluX3RvX2Zsb2F0X2luZm8gcCAoYmluOiBCLnQpIDogRi5mbG9hdF9idyAqIEYuY29udmVyc2lvbl9pbmZvID1cbiAgbGV0IHNpZ24gPSBiaW4uc2lnbiBpblxuICBtYXRjaCBCLmdldF9maXJzdF9ub25fbnVsbCBiaW4gd2l0aCBOb25lIC0+IEYuZ2V0X3plcm8gfnNpZ24gcCwgRVhBQ1QgfCBTb21lIGlzIC0+XG4gIGxldCBleHAgPSByZWYgKGlzICsgcC5iaWFpcykgaW5cbiAgaWYgIWV4cCA8PSAwIHRoZW5cbiAgICBpZiAhZXhwICsgcC5tYW50aXNzYSA8PSAwIHRoZW5cbiAgICAgIEZsb2F0cy5nZXRfemVybyB+c2lnbjpiaW4uc2lnbiBwLCBGLlJPVU5ERURcbiAgICBlbHNlXG4gICAgICBsZXQgZSA9IEJpdHYuY3JlYXRlIHAuZXhwIGZhbHNlIGluXG4gICAgICBsZXQgbSA9IEJpdHYuaW5pdCBwLm1hbnRpc3NhIChmdW4gaSAtPiBCLmdldF9iaXQgYmluICgtcC5iaWFpcy1pKSkgaW5cbiAgICAgIGxldCBzID0gYmluLnNpZ24gaW5cbiAgICAgIGxldCBybmQgPSBpZiBCLmlzX251bGxfYWZ0ZXIgYmluICgtcC5iaWFpcy1wLm1hbnRpc3NhKzEpIHRoZW5cbiAgICAgICAgRi5FWEFDVCBlbHNlIEYuUk9VTkRFRCBpblxuICAgICAge3A7IHM7IGU7IG19LCBybmQgZWxzZVxuICBsZXQgZSA9IEJpdHYuY3JlYXRlIHAuZXhwIGZhbHNlIGluXG4gIGxldCAoKSA9XG4gICAgZm9yIGkgPSAwIHRvIHAuZXhwIC0gMSBkb1xuICAgICAgaWYgIWV4cCBtb2QgMiA8PiAwIHRoZW4gQml0di5zZXQgZSBpIHRydWU7XG4gICAgICBleHAgOj0gIWV4cCAvIDI7XG4gICAgZG9uZSBpblxuICBpZiAhZXhwID4gMCB8fCBCaXR2LmFsbF9vbmVzIGUgdGhlbiBGLmdldF9pbmYgYmluLnNpZ24gcCwgRi5ST1VOREVEIGVsc2VcbiAgbGV0IG0gPSBCaXR2LmluaXQgcC5tYW50aXNzYVxuICAgIChmdW4gaSAtPiBCLmdldF9iaXQgYmluIChpcyAtIGkgLSAxKSkgaW5cbiAgbGV0IHJvdW5kID0gQi5nZXRfYml0IGJpbiAoaXMgLSBwLm1hbnRpc3NhIC0xICkgaW5cbiAgbGV0IF8gPSBpZiByb3VuZCB0aGVuIHRyeVxuICAgICAgRmxvYXRzLmluY19tYW50aXNzYSBtXG4gICAgd2l0aCBGLk92ZXJmbG93IC0+XG4gICAgICB0cnkgRmxvYXRzLmluY19leHAgZVxuICAgICAgd2l0aCBGLk92ZXJmbG93IC0+IExvZy5kZWJ1ZyBcIkltcG9zc2libGUgT3ZlcmZsb3c6ICVhXCJcbiAgICAgICAgRi5wcF91bCB7IHA7IGU7IG07IHMgPSBzaWduIH1cbiAgaW5cbiAgbGV0IHJuZCA9IGlmIEIuaXNfbnVsbF9hZnRlciBiaW4gKGlzIC1wLm1hbnRpc3NhIC0xKSB0aGVuXG4gICAgRi5FWEFDVCBlbHNlIEYuUk9VTkRFRCBpblxuICB7IHA7IGU7IG07IHMgPSBzaWduIH0sIHJuZFxuXG5sZXQgYmluX3RvX2Zsb2F0IHAgYmluID1cbiAgbGV0IHJlcywgXyA9IGJpbl90b19mbG9hdF9pbmZvIHAgYmluIGluXG4gIHJlc1xuXG5leGNlcHRpb24gSXNJbmYgb2YgYm9vbFxuZXhjZXB0aW9uIElzTmFuXG5cbigqKiBbZmxvYXRfdG9fYmluIGZdIGNvbnZlcnRzIGEgZmxvYXQgdG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb24uXG5cbiAgICBAcmFpc2VzIFtJc0luZl0gd2hlbiBbZl0gaXMgYW4gaW5pZmluaXRlIHZhbHVlLlxuICAgIEByYWlzZXMgW0lzTmFuXSB3aGVuIFtmXSBpcyBhIG5vdCBhIG51bWJlciB2YWx1ZS5cbiAgICAqKVxubGV0IGZsb2F0X3RvX2JpbiAoZjogRi50KSA9XG4gIGxldCBzaWduID0gZi5zIGluXG4gIGlmIEYuaXNfemVybyBmIHRoZW4geyBCLnplcm8gd2l0aCBzaWduIH0gZWxzZVxuICBpZiBCaXR2LmFsbF9vbmVzIGYuZSB0aGVuXG4gICAgaWYgQml0di5hbGxfemVyb3MgZi5tIHRoZW4gcmFpc2UgKElzSW5mIGYucykgZWxzZSByYWlzZSBJc05hbiBlbHNlXG4gIGxldCBleHAgPSBCaXR2LnRvX2ludF91cyBmLmUgaW5cbiAgbGV0IGV4cCA9IGV4cCAtIGYucC5iaWFpcyBpblxuICBsZXQgbGVuX2ludCwgbGVuX2ZyYWMgPSBpZiBleHAgPj0gMFxuICAgIHRoZW4gZXhwICsgMSwgbWF4IDAgKGYucC5tYW50aXNzYSAtIGV4cClcbiAgICBlbHNlIDAsIC1leHAgKyBmLnAubWFudGlzc2EgaW5cbiAgbGV0IGludGVnZXIgPSBCaXR2LmNyZWF0ZSBsZW5faW50IGZhbHNlIGluXG4gIGxldCBmcmFjdGlvbmFsID0gQml0di5jcmVhdGUgbGVuX2ZyYWMgZmFsc2UgaW5cbiAgbGV0IF8gPVxuICAgIGZvciBpID0gMCB0byBmLnAubWFudGlzc2EgZG9cbiAgICAgIGxldCBiID0gaWYgaSA9IDBcbiAgICAgICAgdGhlbiBub3QgKEYuaXNfZGVub3JtYWxpemVkIGYpXG4gICAgICAgIGVsc2UgQml0di5nZXQgZi5tIChpLTEpIGluXG4gICAgICBpZiBleHAgPj0gMCB0aGVuXG4gICAgICAgIGlmIGkgPCBsZW5faW50IHRoZW5cbiAgICAgICAgICBCaXR2LnNldCBpbnRlZ2VyIChsZW5faW50LWktMSkgYlxuICAgICAgICBlbHNlXG4gICAgICAgICAgQml0di5zZXQgZnJhY3Rpb25hbCAoaS1sZW5faW50KSBiXG4gICAgICBlbHNlXG4gICAgICAgIEJpdHYuc2V0IGZyYWN0aW9uYWwgKC1leHAraS0xKSBiXG4gICAgZG9uZSBpblxuICBsZXQgcmVwZWF0aW5nID0gQml0di5jcmVhdGUgMCBmYWxzZSBpblxuICB7IHNpZ247IGludGVnZXI7IGZyYWN0aW9uYWw7IHJlcGVhdGluZyB9Il0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxMDU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Im9qcy5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3RvX2pzIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfanNfZ2V0IiwiY2FtbF9qc19zZXQiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2pzX3RvX3N0cmluZyIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsImNzdCIsInNoYXJlZCIsIkNhbWxpbnRlcm5hbE9PIiwiU3RkbGliX0FycmF5IiwidHlwZV9vZiIsIngiLCJpbnN0YW5jZV9vZiIsImNvbnN0ciIsIm51bGwiLCJ1bmRlZmluZWQiLCJnbG9iYWwiLCJhcnJheV9tYWtlIiwibiIsImFycmF5X2dldCIsImFycmF5X3NldCIsImFycmF5X29mX2pzX2Zyb20iLCJvYmpzIiwic3RhcnQiLCJpIiwiYXJyYXlfb2ZfanMiLCJhcnJheV90b19qcyIsImFyciIsImEiLCJsaXN0X29mX2pzX2Zyb20iLCJsaXN0X29mX2pzIiwibGlzdF90b19qcyIsImwiLCJvcHRpb25fb2ZfanMiLCJvcHRpb25fdG9fanMiLCJwYXJhbSIsInVuaXRfdG9fanMiLCJ1bml0X29mX2pzIiwib2JqIiwic2VsZl8xIiwiaGFzX3Byb3BlcnR5IiwibyIsImVtcHR5X29iaiIsIml0ZXJfcHJvcGVydGllcyIsImFwcGx5X2FyciIsImNhbGxfYXJyIiwicyIsImlzX251bGwiLCJvYmpfdHlwZSIsInRfdG9fanMiLCJ0X29mX2pzIiwiSW50IiwiU3RyaW5nIiwiQm9vbCIsIkZsb2F0IiwiQXJyYXkiLCJBIiwiTGlzdCIsIk9wdGlvbiIsIk9qcyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvRmxvYXRWaWV3L0Zsb2F0Vmlldy9fb3BhbS9saWIvb2pzL29qcy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlB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QUEsY0FDQTtBQUFBLGFBQUFDLFFBQUE7QUFBQSxJQUFvQjtBQUFBO0FBQUEsWUFBQVEsT0FBQUY7QUFBQUEsUUFBQSxNQUlwQjtBQUFBLGFBQUFQLFFBQUE7QUFBQSxjQUNBO0FBQUEsYUFBQUMsUUFBQTtBQUFBLElBQXNCO0FBQUE7QUFBQTtBQUFBLElBQUFTO0FBQUFBLE1BakhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDVEdEMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoZSBnZW5fanNfYXBpIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiBhbiBNSVQtbGlrZSBsaWNlbnNlLiAgICAgKilcbigqIFNlZSB0aGUgYXR0YWNoZWQgTElDRU5TRSBmaWxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqIENvcHlyaWdodCAyMDE1IGJ5IExleGlGaS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcblxuKCogVGhpcyBtb2R1bGUgKG1vc3RseSkgYWJzdHJhY3RzIGF3YXkgZnJvbSBqc19vZl9vY2FtbCBlbmNvZGluZyBvZlxuICAgT0NhbWwgdmFsdWVzLiAgSXQgc2VydmVzIGFzIGEgc3VwcG9ydCBsaWJyYXJ5IGZvciB0aGUgY29kZSBnZW5lcmF0ZWRcbiAgIGJ5IGdlbl9qc19hcGkuXG5cbiAgIFRoZSBtb2R1bGUgY291bGQgbW9zdGx5IGJlIGltcGxlbWVudGVkIG9uIHRvcCBvZiBqc19vZl9vY2FtbCdzIEpzIG1vZHVsZVxuICAgKGFuZCBpbiBwYXJ0aWN1bGFyIEpzLlVuc2FmZSksIGJ1dCB3ZSBwcmVmZXIgdG8gZHJvcCB0aGUgZGVwZW5kZW5jeVxuICAgdG8ganNfb2Zfb2NhbWwncyBsaWJyYXJ5IGFuZCB0byByZWx5IG9ubHkgb24gaXRzIGNvbXBpbGVyIGFuZCBKU1xuICAgcnVudGltZSBjb2RlLlxuKilcblxuXG50eXBlIHRcblxuZXh0ZXJuYWwgdF9vZl9qczogdCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdF90b19qczogdCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuXG5leHRlcm5hbCBzdHJpbmdfb2ZfanM6IHQgLT4gc3RyaW5nID0gXCJjYW1sX2pzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCBzdHJpbmdfdG9fanM6IHN0cmluZyAtPiB0ID0gXCJjYW1sX2pzX2Zyb21fc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50X29mX2pzOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGludF90b19qczogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5cbmV4dGVybmFsIGJvb2xfb2ZfanM6IHQgLT4gYm9vbCA9IFwiY2FtbF9qc190b19ib29sXCJcbmV4dGVybmFsIGJvb2xfdG9fanM6IGJvb2wgLT4gdCA9IFwiY2FtbF9qc19mcm9tX2Jvb2xcIlxuXG5leHRlcm5hbCBmbG9hdF9vZl9qczogdCAtPiBmbG9hdCA9IFwiY2FtbF9qc190b19mbG9hdFwiXG5leHRlcm5hbCBmbG9hdF90b19qczogZmxvYXQgLT4gdCA9IFwiY2FtbF9qc19mcm9tX2Zsb2F0XCJcblxuZXh0ZXJuYWwgb2JqOiAoc3RyaW5nICogdCkgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19vYmplY3RcIlxuXG5leHRlcm5hbCB2YXJpYWJsZTogc3RyaW5nIC0+IHQgPSBcImNhbWxfanNfdmFyXCJcblxuZXh0ZXJuYWwgZ2V0OiB0IC0+IHN0cmluZyAtPiB0ID0gXCJjYW1sX2pzX2dldFwiXG5leHRlcm5hbCBzZXQ6IHQgLT4gc3RyaW5nIC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuZXh0ZXJuYWwgZGVsZXRlOiB0IC0+IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbmV4dGVybmFsIGdldF9wcm9wOiB0IC0+IHQgLT4gdCA9IFwiY2FtbF9qc19nZXRcIlxuZXh0ZXJuYWwgc2V0X3Byb3A6IHQgLT4gdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfanNfc2V0XCJcbmV4dGVybmFsIGRlbGV0ZV9wcm9wOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19kZWxldGVcIlxuXG5leHRlcm5hbCBnZXRfcHJvcF9hc2NpaTogdCAtPiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc19nZXRcIlxuZXh0ZXJuYWwgc2V0X3Byb3BfYXNjaWk6IHQgLT4gc3RyaW5nIC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuZXh0ZXJuYWwgZGVsZXRlX3Byb3BfYXNjaWk6IHQgLT4gc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfanNfZGVsZXRlXCJcblxuZXh0ZXJuYWwgaW50ZXJuYWxfdHlwZV9vZjogdCAtPiB0ID0gXCJjYW1sX2pzX3R5cGVvZlwiXG5sZXQgdHlwZV9vZiB4ID0gc3RyaW5nX29mX2pzIChpbnRlcm5hbF90eXBlX29mIHgpXG5cbmV4dGVybmFsIGludGVybmFsX2luc3RhbmNlX29mOiB0IC0+IHQgLT4gdCA9IFwiY2FtbF9qc19pbnN0YW5jZW9mXCJcbmxldCBpbnN0YW5jZV9vZiB4IH5jb25zdHIgPSBib29sX29mX2pzIChpbnRlcm5hbF9pbnN0YW5jZV9vZiB4IGNvbnN0cilcblxuZXh0ZXJuYWwgcHVyZV9qc19leHByOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxubGV0IG51bGwgPSBwdXJlX2pzX2V4cHIgXCJudWxsXCJcbmxldCB1bmRlZmluZWQgPSBwdXJlX2pzX2V4cHIgXCJ1bmRlZmluZWRcIlxuXG5leHRlcm5hbCBlcXVhbHM6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2pzX2VxdWFsc1wiXG5cbmxldCBnbG9iYWwgPSBwdXJlX2pzX2V4cHIgXCJnbG9iYWxUaGlzXCJcblxuZXh0ZXJuYWwgbmV3X29iajogdCAtPiB0IGFycmF5IC0+IHQgPSBcImNhbWxfanNfbmV3XCJcblxuZXh0ZXJuYWwgY2FsbDogdCAtPiBzdHJpbmcgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX21ldGhfY2FsbFwiXG5leHRlcm5hbCBhcHBseTogdCAtPiB0IGFycmF5IC0+IHQgPSBcImNhbWxfanNfZnVuX2NhbGxcIlxuXG5sZXQgYXJyYXlfbWFrZSBuID0gbmV3X29iaiAoZ2V0X3Byb3BfYXNjaWkgZ2xvYmFsIFwiQXJyYXlcIikgW3xpbnRfdG9fanMgbnxdXG5sZXQgYXJyYXlfZ2V0IHQgaSA9IGdldF9wcm9wIHQgKGludF90b19qcyBpKVxubGV0IGFycmF5X3NldCB0IGkgeCA9IHNldF9wcm9wIHQgKGludF90b19qcyBpKSB4XG5cbmxldCBhcnJheV9vZl9qc19mcm9tIGYgb2JqcyBzdGFydCA9XG4gIGxldCBuID0gaW50X29mX2pzIChnZXRfcHJvcF9hc2NpaSBvYmpzIFwibGVuZ3RoXCIpIGluXG4gIEFycmF5LmluaXQgKG4gLSBzdGFydCkgKGZ1biBpIC0+IGYgKGFycmF5X2dldCBvYmpzIChzdGFydCArIGkpKSlcblxubGV0IGFycmF5X29mX2pzIGYgb2JqcyA9IGFycmF5X29mX2pzX2Zyb20gZiBvYmpzIDBcblxubGV0IGFycmF5X3RvX2pzIGYgYXJyID1cbiAgbGV0IG4gPSBBcnJheS5sZW5ndGggYXJyIGluXG4gIGxldCBhID0gYXJyYXlfbWFrZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIGFycmF5X3NldCBhIGkgKGYgYXJyLihpKSlcbiAgZG9uZTtcbiAgYVxuXG5sZXQgbGlzdF9vZl9qc19mcm9tIGYgb2JqcyBzdGFydCA9IEFycmF5LnRvX2xpc3QgKGFycmF5X29mX2pzX2Zyb20gZiBvYmpzIHN0YXJ0KVxuXG5sZXQgbGlzdF9vZl9qcyBmIG9ianMgPSBsaXN0X29mX2pzX2Zyb20gZiBvYmpzIDBcblxubGV0IGxpc3RfdG9fanMgZiBsID1cbiAgYXJyYXlfdG9fanMgZiAoQXJyYXkub2ZfbGlzdCBsKVxuXG5sZXQgb3B0aW9uX29mX2pzIGYgeCA9XG4gIGlmIGVxdWFscyB4IG51bGwgdGhlbiBOb25lXG4gIGVsc2UgU29tZSAoZiB4KVxuXG5sZXQgb3B0aW9uX3RvX2pzIGYgPSBmdW5jdGlvblxuICB8IFNvbWUgeCAtPiBmIHhcbiAgfCBOb25lIC0+IG51bGxcblxubGV0IHVuaXRfdG9fanMgKCkgPSB1bmRlZmluZWRcbmxldCB1bml0X29mX2pzIF8gPSAoKVxuXG5jbGFzcyBvYmogKHg6dCkgPVxuICBvYmplY3RcbiAgICBtZXRob2QgdG9fanMgPSB4XG4gIGVuZFxuXG5leHRlcm5hbCBmdW5fdG9fanM6IGludCAtPiAodCAtPiAnYSkgLT4gdCA9IFwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdFwiXG5leHRlcm5hbCBmdW5fdG9fanNfYXJnczogKHQgLT4gJ2EpIC0+IHQgPSBcImNhbWxfb2pzX3dyYXBfZnVuX2FyZ3VtZW50c1wiXG5cbmxldCBoYXNfcHJvcGVydHkgbyB4ID1cbiAgdHlwZV9vZiBvID0gXCJvYmplY3RcIiAmJiBvICE9IG51bGxcbiAgJiYgZ2V0X3Byb3AgbyAoc3RyaW5nX3RvX2pzIHgpICE9IHVuZGVmaW5lZFxuXG5leHRlcm5hbCBuZXdfb2JqX2FycjogdCAtPiB0IC0+IHQgPSBcImNhbWxfb2pzX25ld19hcnJcIlxuXG5sZXQgZW1wdHlfb2JqICgpID0gbmV3X29iaiAoZ2V0X3Byb3BfYXNjaWkgZ2xvYmFsIFwiT2JqZWN0XCIpIFt8fF1cblxuZXh0ZXJuYWwgaXRlcl9wcm9wZXJ0aWVzX3VudHlwZWQgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9vanNfaXRlcmF0ZV9wcm9wZXJ0aWVzXCJcbmxldCBpdGVyX3Byb3BlcnRpZXMgeCBmID1cbiAgaXRlcl9wcm9wZXJ0aWVzX3VudHlwZWQgeCAoZnVuX3RvX2pzIDEgKGZ1biB4IC0+IGYgKHN0cmluZ19vZl9qcyB4KSkpXG5cbmxldCBhcHBseV9hcnIgbyBhcnIgPSBjYWxsIG8gXCJhcHBseVwiIFt8IG51bGw7IGFyciB8XVxubGV0IGNhbGxfYXJyIG8gcyBhcnIgPSBjYWxsIChnZXRfcHJvcCBvIChzdHJpbmdfdG9fanMgcykpIFwiYXBwbHlcIiBbfCBvOyBhcnIgfF1cblxubGV0IGlzX251bGwgeCA9XG4gIGVxdWFscyB4IG51bGxcblxubGV0IG9ial90eXBlIHggPVxuICBzdHJpbmdfb2ZfanMgKGNhbGwgKHB1cmVfanNfZXhwciBcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIikgXCJjYWxsXCIgW3x4fF0pXG5cbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgdHlwZSBqcyA6PSB0XG4gIHR5cGUgdFxuICB2YWwgdF90b19qcyA6IHQgLT4ganNcbiAgdmFsIHRfb2ZfanMgOiBqcyAtPiB0XG5lbmRcblxuKCogT2pzLlQgaW5zdGFuY2VzIGZvciBidWlsdC1pbiB0eXBlcyAqKVxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcbiAgbGV0IHRfdG9fanMgPSBpbnRfdG9fanNcbiAgbGV0IHRfb2ZfanMgPSBpbnRfb2ZfanNcbiBlbmRcbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG4gIGxldCB0X3RvX2pzID0gc3RyaW5nX3RvX2pzXG4gIGxldCB0X29mX2pzID0gc3RyaW5nX29mX2pzXG5lbmRcbm1vZHVsZSBCb29sID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2xcbiAgbGV0IHRfdG9fanMgPSBib29sX3RvX2pzXG4gIGxldCB0X29mX2pzID0gYm9vbF9vZl9qc1xuZW5kXG5tb2R1bGUgRmxvYXQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXRcbiAgbGV0IHRfdG9fanMgPSBmbG9hdF90b19qc1xuICBsZXQgdF9vZl9qcyA9IGZsb2F0X29mX2pzXG5lbmRcbm1vZHVsZSBBcnJheSAoQTogVCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQS50IGFycmF5XG4gIGxldCB0X3RvX2pzID0gYXJyYXlfdG9fanMgQS50X3RvX2pzXG4gIGxldCB0X29mX2pzID0gYXJyYXlfb2ZfanMgQS50X29mX2pzXG5lbmRcbm1vZHVsZSBMaXN0IChBOiBUKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBBLnQgbGlzdFxuICBsZXQgdF90b19qcyA9IGxpc3RfdG9fanMgQS50X3RvX2pzXG4gIGxldCB0X29mX2pzID0gbGlzdF9vZl9qcyBBLnRfb2ZfanNcbmVuZFxubW9kdWxlIE9wdGlvbiAoQTogVCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQS50IG9wdGlvblxuICBsZXQgdF90b19qcyA9IG9wdGlvbl90b19qcyBBLnRfdG9fanNcbiAgbGV0IHRfb2ZfanMgPSBvcHRpb25fb2ZfanMgQS50X29mX2pzXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMTI1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuanNfY29yZS5vYmpzL2pzb28vZGVmYXVsdC9qc19jb3JlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfYm9keSIsImNzdF9pbnB1dCIsImNzdF90YWJsZSIsImNzdF90Ym9keSIsImNzdF90ZCIsImNzdF90aGVhZCIsImNzdF90ciIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2pzX3RvX3N0cmluZyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJPanMiLCJTdGRsaWJfU3RyaW5nIiwiQXNzZXJ0X2ZhaWx1cmUiLCJ1bmtub3duX29mX2pzIiwieDIiLCJ1bmtub3duX3RvX2pzIiwieDEiLCJlbGVtZW50X29mX2pzIiwieDQiLCJlbGVtZW50X3RvX2pzIiwieDMiLCJ0ZXh0X29mX2pzIiwieDYiLCJ0ZXh0X3RvX2pzIiwieDUiLCJjb21tZW50X29mX2pzIiwieDgiLCJjb21tZW50X3RvX2pzIiwieDciLCJwcm9jZXNzaW5nX2luc3RydWN0aW9uX25vZGVfb2YiLCJ4MTAiLCJwcm9jZXNzaW5nX2luc3RydWN0aW9uX25vZGVfdG8iLCJ4OSIsImRvY3VtZW50X29mX2pzIiwieDEyIiwiZG9jdW1lbnRfdG9fanMiLCJ4MTEiLCJkb2N1bWVudF90eXBlX29mX2pzIiwieDE0IiwiZG9jdW1lbnRfdHlwZV90b19qcyIsIngxMyIsImRvY3VtZW50X2ZyYWdtZW50X29mX2pzIiwieDE2IiwiZG9jdW1lbnRfZnJhZ21lbnRfdG9fanMiLCJ4MTUiLCJkZXByZWNhdGVkX29mX2pzIiwieDE4IiwiZGVwcmVjYXRlZF90b19qcyIsIngxNyIsIk5vZGUiLCJib2R5X29mX2pzIiwieDIwIiwiYm9keV90b19qcyIsIngxOSIsImlucHV0X29mX2pzIiwieDIyIiwiaW5wdXRfdG9fanMiLCJ4MjEiLCJ0YWJsZV9vZl9qcyIsIngyNCIsInRhYmxlX3RvX2pzIiwieDIzIiwidGJvZHlfb2ZfanMiLCJ4MjYiLCJ0Ym9keV90b19qcyIsIngyNSIsInRkX29mX2pzIiwieDI4IiwidGRfdG9fanMiLCJ4MjciLCJ0aF9vZl9qcyIsIngzMCIsInRoX3RvX2pzIiwieDI5IiwidGhlYWRfb2ZfanMiLCJ4MzIiLCJ0aGVhZF90b19qcyIsIngzMSIsInRyX29mX2pzIiwieDM0IiwidHJfdG9fanMiLCJ4MzMiLCJIdG1sIiwiS2luZHMiLCJ1bnR5cGVkX29mX2pzIiwieDM2IiwiYXBwZW5kX2NoaWxkIiwieDM4IiwieDM3IiwicGFyZW50X25vZGUiLCJ4MzkiLCJiYXNlX1VSSSIsIng0MCIsImNsb25lX25vZGUiLCJ4NDEiLCJmaXJzdF9jaGlsZCIsIng0MiIsImhhc19jaGlsZF9ub2RlcyIsIng0NCIsImxhc3RfY2hpbGQiLCJ4NDUiLCJjaGlsZHJlbiIsIng0NyIsInJlbW92ZV9jaGlsZCIsIng1MSIsIng1MCIsInNldF90ZXh0X2NvbnRlbnQiLCJ4NTIiLCJ4NTMiLCJ0ZXh0X2NvbnRlbnQiLCJ4NTQiLCJ0X29mX2pzIiwicGFyYW0iLCJ0X3RvX2pzIiwieDM1Iiwibm9kZV90eXBlIiwieDQ5Iiwic3dpdGNoZXIiLCJ4NTciLCJ1bnR5cGVkX3RvX2pzIiwieDU1IiwiaGFzX2F0dHJpYnV0ZSIsIng2MCIsIng1OSIsInNldF9hdHRyaWJ1dGUiLCJ4NjMiLCJ4NjEiLCJ4NjIiLCJnZXRfYXR0cmlidXRlIiwieDY1IiwieDY0IiwiaGFzX2F0dHJpYnV0ZV9uX3MiLCJ4NjgiLCJ4NjYiLCJ4NjciLCJzZXRfYXR0cmlidXRlX25fcyIsIng3MiIsIng2OSIsIng3MCIsIng3MSIsImdldF9hdHRyaWJ1dGVfbl9zIiwieDc1IiwieDczIiwieDc0IiwicmVtb3ZlX2F0dHJpYnV0ZSIsIng3NyIsIng3NiIsInNldF9jbGFzc19uYW1lIiwieDc4IiwieDc5IiwiZ2V0X2NsYXNzX25hbWUiLCJ4ODAiLCJzZXRfaW5uZXJIVE1MIiwieDgxIiwieDgyIiwiaW5uZXJfSFRNTCIsIng4MyIsInNldF9vdXRlcl9IVE1MIiwieDg0IiwieDg1Iiwib3V0ZXJfSFRNTCIsIng4NiIsInNldF9vbmNsaWNrIiwieDg3IiwieDg4IiwieDg5Iiwic2V0X29uZGJjbGljayIsIng5MCIsIng5MSIsInNldF9vbmJsdXIiLCJ4OTIiLCJ4OTMiLCJzZXRfb25mb2N1cyIsIng5NCIsIng5NSIsInNldF9vbmNoYW5nZSIsIng5NiIsIng5NyIsInNldF9vbm1vdXNlb3ZlciIsIng5OCIsIng5OSIsInNldF9vbmtleXVwIiwieDEwMCIsIngxMDEiLCJ4MTAyIiwic2V0X29uaW5wdXQiLCJ4MTAzIiwieDEwNCIsInRhZ19uYW1lIiwieDEwNSIsImNvbnRlbnRfZWRpdGFibGUiLCJ4MTA2Iiwic2V0X2NvbnRlbnRfZWRpdGFibGUiLCJ4MTA3IiwieDEwOCIsIm9wdGlvbnMiLCJ4MTA5Iiwic2VsZWN0ZWRfaW5kZXgiLCJ4MTExIiwia2V5IiwieDExMiIsImRldGFpbCIsIngxMTMiLCJ4IiwidW5zYWZlX2Nhc3QiLCJFbGVtZW50IiwiY3N0X3RoIiwieDExNiIsIngxMTQiLCJzZXRfdGl0bGUiLCJ4MTE4IiwieDExOSIsInRpdGxlIiwieDEyMCIsImdldF9lbGVtZW50X2J5X2lkIiwieDEyMiIsIngxMjEiLCJ4MTIzIiwiZ2V0X2VsZW1lbnRzX2J5X2NsYXNzX25hbWUiLCJ4MTI2IiwieDEyNSIsIngxMjciLCJjcmVhdGVfZWxlbWVudCIsIngxMzAiLCJ4MTI5IiwiY3JlYXRlX2VsZW1lbnRfbl9zIiwieDEzNCIsIngxMzIiLCJ4MTMzIiwiY3JlYXRlX3RleHRfbm9kZSIsIngxMzciLCJ4MTM2IiwiYm9keSIsIngxMzkiLCJoZWlnaHQiLCJ4MTQxIiwid2lkdGgiLCJ4MTQyIiwiY3JlYXRlX2h0bWxfaW5wdXQiLCJkb2N1bWVudCIsImNyZWF0ZV9odG1sX3RhYmxlIiwiY3JlYXRlX2h0bWxfdHIiLCJjcmVhdGVfaHRtbF90ZCIsImNyZWF0ZV9odG1sX3RoIiwiY3JlYXRlX2h0bWxfdGJvZHkiLCJjcmVhdGVfaHRtbF90aGVhZCIsIkRvY3VtZW50IiwieDE0NCIsIngxNDMiLCJ4MTQ1IiwiaW5uZXJfaGVpZ2h0IiwieDE0NiIsImlubmVyX3dpZHRoIiwieDE0NyIsInNldF9vbmxvYWQiLCJ4MTQ4IiwieDE0OSIsIldpbmRvdyIsIngxNTEiLCJ4MTUwIiwibG9nIiwieDE1MyIsIngxNTIiLCJsb2dfc3RyaW5nIiwieDE1NSIsIngxNTQiLCJDb25zb2xlIiwicGFyc2UiLCJ4MTU2Iiwic3RyaW5naWZ5IiwieDE1NyIsIkpTT04iLCJ4MTU5IiwieDE1OCIsIm5hbWUiLCJ4MTYwIiwiRmlsZSIsIngxNjIiLCJ4MTYxIiwiaXRlbSIsIngxNjQiLCJ4MTYzIiwibGVuZ3RoIiwieDE2NiIsIkZpbGVMaXN0Iiwic3RhdGVfb2ZfanMiLCJ4MTY4Iiwic3RhdGVfdG9fanMiLCJ4MTY3IiwieDE3MSIsIngxNzAiLCJuZXdfZmlsZV9yZWFkZXIiLCJyZWFkeV9zdGF0ZSIsIngxNzIiLCJyZXN1bHQiLCJ4MTczIiwieDE3NSIsIngxNzYiLCJyZWFkX2FzX3RleHQiLCJ4MTc4IiwieDE3NyIsIkZpbGVSZWFkZXIiLCJ4MTgxIiwieDE3OSIsImZpbGVzIiwieDE4MyIsInZhbHVlIiwieDE4NCIsIklucHV0IiwicmV0eXBlIiwibWF0Y2giLCJ3aW5kb3ciLCJhbGVydCIsIngxODUiLCJjb25zb2xlIiwiR2xvYmFsVmFyaWFibGVzIiwiSnNfY29yZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L2h0bWwvYmluZGluZ3MvanNfY29yZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLCtCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsY0FBQUMsSUNXRSxVQUEyQjtBQUFBLFlBQUFDLGNBQUFDLElBQTNCLFVBQTJCO0FBQUEsWUFBQUMsY0FBQUMsSUFFekIsVUFBMkI7QUFBQSxZQUFBQyxjQUFBQyxJQUEzQixVQUEyQjtBQUFBLFlBQUFDLFdBQUFDLElBQzNCLFVBQXdCO0FBQUEsWUFBQUMsV0FBQUMsSUFBeEIsVUFBd0I7QUFBQSxZQUFBQyxjQUFBQyxJQUN4QixVQUEyQjtBQUFBLFlBQUFDLGNBQUFDLElBQTNCLFVBQTJCO0FBQUEsWUFBQUMsK0JBQUFDLEtBQzNCLFdBQStDO0FBQUEsWUFBQUMsK0JBQUFDLElBQS9DLFVBQStDO0FBQUEs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QUE7QUFBQTtBQUFBLFlBQUF6QyxhQUFBMEMsTUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUEsMEJBQUF6TCxPQUFBO0FBQUE7QUFBQSxZQUFBMEwsYUFBQUMsTUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBOUwsVUFBQStMLE1DOFNJLGdEQUEwQztBQUFBLFlBQUE3TCxVQUFBOEwsTUFBMUMsZ0RBQTBDO0FBQUEsWUFBQUMsTUFBQUM7QUFBQUEsUUFBQSxNRDlTOUM7QUFBQTtBQUFBO0FBQUEsWUFBQUMsTUFBQUMsTUFBQTtBQUFBLE9BQUFDLFFBQUE7QUFBQSxZQUFBQyxPQUFBMUc7QUFBQUE7QUFBQUEsS0FBQSxNQ3NUaUM7QUFBQSxLQUFBMkcsUUFBdkI7QUFBQSxJQUEyQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUNBR2xDO0FBQUEsdUNBSU07QUFBQSxpQ0FITjtBQUFBLG1DQUVNO0FBQUEsaUNBSkE7QUFBQSxnQ0FEQTtBQUFBLDZCQUlGLDJCQUdKO0FBQUE7QUFBQTtBQUFBLElBQUFwTyxTRDlUbkI7QUFBQSxJQUFBcU8sU0FBQTtBQUFBLFlBQUFDLE1BQUFDLE1BQUE7QUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnkuXG4gKiBUaGlzIGZpbGUgd2FzIHBhcnQgb2YgdGhlIGxhbmRtYXJrcy12aWV3ZXIgcHJvamVjdC5cbiAqIENvcHlyaWdodCAoQykgMjAxNiAtIExleGlGaS4gKHVuZGVyIE1JVCBsaWNlbnNlKVxuICogQ29weXJpZ2h0IChDKSAyMDI1IC0gSm9zc2VsaW4gR2lldFxuICpcbiAqIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbm1vZHVsZSBLaW5kcyA9IHN0cnVjdFxuICB0eXBlIHVua25vd24gPSBPanMudCBbQEBqc11cbiAgbW9kdWxlIE5vZGUgPSBzdHJ1Y3RcbiAgICB0eXBlIGVsZW1lbnQgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIHRleHQgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIGNvbW1lbnQgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIHByb2Nlc3NpbmdfaW5zdHJ1Y3Rpb25fbm9kZSA9IE9qcy50IFtAQGpzXVxuICAgIHR5cGUgZG9jdW1lbnQgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIGRvY3VtZW50X3R5cGUgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIGRvY3VtZW50X2ZyYWdtZW50ID0gT2pzLnQgW0BAanNdXG4gICAgdHlwZSBkZXByZWNhdGVkID0gT2pzLnQgW0BAanNdXG4gIGVuZFxuXG4gIG1vZHVsZSBIdG1sID0gc3RydWN0XG4gICAgdHlwZSBib2R5ID0gT2pzLnQgW0BAanNdXG4gICAgdHlwZSBpbnB1dCA9IE9qcy50IFtAQGpzXVxuXG4gICAgdHlwZSB0YWJsZSA9IE9qcy50IFtAQGpzXVxuICAgIHR5cGUgdGJvZHkgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIHRkID0gT2pzLnQgW0BAanNdXG4gICAgdHlwZSB0aCA9IE9qcy50IFtAQGpzXVxuICAgIHR5cGUgdGhlYWQgPSBPanMudCBbQEBqc11cbiAgICB0eXBlIHRyID0gT2pzLnQgW0BAanNdXG4gIGVuZFxuZW5kXG5cbm9wZW4gS2luZHNcblxubW9kdWxlIE5vZGUgOiBzaWdcbiAgdHlwZSAnYSB0ID0gcHJpdmF0ZSBPanMudFxuICB2YWwgdF9vZl9qczogKE9qcy50IC0+ICdhKSAtPiBPanMudCAtPiAnYSB0XG4gIHZhbCB0X3RvX2pzOiAoJ2EgLT4gT2pzLnQpIC0+ICdhIHQgLT4gT2pzLnRcblxuICAoKiogTm9kZSBBUEkgKilcblxuICB2YWwgYXBwZW5kX2NoaWxkOiAnYSB0IC0+ICdiIHQgLT4gdW5pdFxuICB2YWwgcGFyZW50X25vZGU6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYmFzZV9VUkk6ICdhIHQgLT4gc3RyaW5nXG4gIHZhbCBjbG9uZV9ub2RlOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGZpcnN0X2NoaWxkOiAnYSB0IC0+IHVua25vd24gdCBvcHRpb25cbiAgdmFsIGhhc19jaGlsZF9ub2RlczogJ2EgdCAtPiBib29sXG4gIHZhbCBsYXN0X2NoaWxkOiAnYSB0IC0+IHVua25vd24gdCBvcHRpb25cbiAgdmFsIGNoaWxkcmVuOiAnYSB0IC0+IHVua25vd24gdCBhcnJheVxuICB2YWwgcmVtb3ZlX2NoaWxkOiAnYSB0IC0+ICdiIHQgLT4gdW5pdFxuXG4gIHZhbCBzZXRfdGV4dF9jb250ZW50OiAnYSB0IC0+IHN0cmluZyAtPiB1bml0XG4gIHZhbCB0ZXh0X2NvbnRlbnQ6ICdhIHQgLT4gc3RyaW5nXG5cbiAgb3BlbiBLaW5kcy5Ob2RlXG4gIHZhbCBub2RlX3R5cGU6ICdhIHQgLT5cbiAgICBbIGBFbGVtZW50IG9mIGVsZW1lbnQgdFxuICAgIHwgYFRleHQgb2YgdGV4dCB0XG4gICAgfCBgUHJvY2Vzc2luZ0luc3RydWN0aW9uTmRlIG9mIHByb2Nlc3NpbmdfaW5zdHJ1Y3Rpb25fbm9kZSB0XG4gICAgfCBgQ29tbWVudCBvZiBjb21tZW50IHRcbiAgICB8IGBEb2N1bWVudCBvZiBkb2N1bWVudCB0XG4gICAgfCBgRG9jdW1lbnRUeXBlIG9mIGRvY3VtZW50X3R5cGUgdFxuICAgIHwgYERvY3VtZW50RnJhZ21lbnQgb2YgZG9jdW1lbnRfZnJhZ21lbnQgdFxuICAgIHwgYERlcHJlY2F0ZWQgb2YgZGVwcmVjYXRlZCB0IF1cbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIChbJWpzIDpcbiAgICAgICAgICAgICB0eXBlIHVudHlwZWQgPSBwcml2YXRlIE9qcy50XG4gICAgICAgICAgICAgdmFsIHVudHlwZWRfb2ZfanM6IE9qcy50IC0+IHVudHlwZWRcbiAgICAgICAgICAgICB2YWwgdW50eXBlZF90b19qczogdW50eXBlZCAtPiBPanMudFxuXG4gICAgICAgICAgICAgdmFsIGFwcGVuZF9jaGlsZDogdW50eXBlZCAtPiB1bnR5cGVkIC0+IHVuaXQgW0BAanMuY2FsbF1cbiAgICAgICAgICAgICB2YWwgcGFyZW50X25vZGU6IHVudHlwZWQgLT4gdW50eXBlZCBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIGJhc2VfVVJJOiB1bnR5cGVkIC0+IHN0cmluZyBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIGNsb25lX25vZGU6IHVudHlwZWQgLT4gdW50eXBlZCBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIGZpcnN0X2NoaWxkOiB1bnR5cGVkIC0+IHVudHlwZWQgb3B0aW9uIFtAQGpzLmdldF1cbiAgICAgICAgICAgICB2YWwgaGFzX2NoaWxkX25vZGVzOiB1bnR5cGVkIC0+IGJvb2wgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIHZhbCBsYXN0X2NoaWxkOiB1bnR5cGVkIC0+IHVudHlwZWQgb3B0aW9uIFtAQGpzLmdldF1cbiAgICAgICAgICAgICB2YWwgY2hpbGRyZW46IHVudHlwZWQgLT4gdW50eXBlZCBhcnJheSBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIG5vZGVfdHlwZTogdW50eXBlZCAtPiBpbnQgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIHZhbCByZW1vdmVfY2hpbGQ6IHVudHlwZWQgLT4gdW50eXBlZCAtPiB1bml0IFtAQGpzLmNhbGxdXG5cbiAgICAgICAgICAgICB2YWwgc2V0X3RleHRfY29udGVudDogdW50eXBlZCAtPiBzdHJpbmcgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHRleHRfY29udGVudDogdW50eXBlZCAtPiBzdHJpbmcgW0BAanMuZ2V0XVxuICAgICAgICAgICBdKVxuICB0eXBlICdhIHQgPSB1bnR5cGVkXG4gIGxldCB0X29mX2pzIF8geCA9IHVudHlwZWRfb2ZfanMgeFxuICBsZXQgdF90b19qcyBfIHggPSB1bnR5cGVkX3RvX2pzIHhcblxuICBsZXQgbm9kZV90eXBlIHggPVxuICAgIGxldCBvcGVuIEtpbmRzLk5vZGUgaW5cbiAgICBtYXRjaCBub2RlX3R5cGUgeCB3aXRoXG4gICAgfCAxIC0+IGBFbGVtZW50ICh4IDogZWxlbWVudCB0KVxuICAgIHwgMyAtPiBgVGV4dCAoeCA6IHRleHQgdClcbiAgICB8IDcgLT4gYFByb2Nlc3NpbmdJbnN0cnVjdGlvbk5kZSAoeCA6IHByb2Nlc3NpbmdfaW5zdHJ1Y3Rpb25fbm9kZSB0KVxuICAgIHwgOCAtPiBgQ29tbWVudCAoeCA6IGNvbW1lbnQgdClcbiAgICB8IDkgLT4gYERvY3VtZW50ICh4IDogZG9jdW1lbnQgdClcbiAgICB8IDEwIC0+IGBEb2N1bWVudFR5cGUgKHggOiBkb2N1bWVudF90eXBlIHQpXG4gICAgfCAxMSAtPiBgRG9jdW1lbnRGcmFnbWVudCAoeDogZG9jdW1lbnRfZnJhZ21lbnQgdClcbiAgICB8IF8gLT4gYERlcHJlY2F0ZWQgKHg6IGRlcHJlY2F0ZWQgdClcbmVuZFxuXG5tb2R1bGUgRWxlbWVudCA6IHNpZ1xuICB0eXBlICdhIHQgPSBLaW5kcy5Ob2RlLmVsZW1lbnQgTm9kZS50XG4gIHZhbCB0X29mX2pzOiAoT2pzLnQgLT4gJ2EpIC0+IE9qcy50IC0+ICdhIHRcbiAgdmFsIHRfdG9fanM6ICgnYSAtPiBPanMudCkgLT4gJ2EgdCAtPiBPanMudFxuXG4gIHZhbCBoYXNfYXR0cmlidXRlOiAnYSB0IC0+IHN0cmluZyAtPiBib29sXG4gIHZhbCBzZXRfYXR0cmlidXRlOiAnYSB0IC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gdW5pdFxuICB2YWwgZ2V0X2F0dHJpYnV0ZTogJ2EgdCAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBoYXNfYXR0cmlidXRlX25fczogJ2EgdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2xcbiAgdmFsIHNldF9hdHRyaWJ1dGVfbl9zOiAnYSB0IC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXRcbiAgdmFsIGdldF9hdHRyaWJ1dGVfbl9zOiAnYSB0IC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCByZW1vdmVfYXR0cmlidXRlOiAnYSB0IC0+IHN0cmluZyAtPiB1bml0XG5cbiAgdmFsIHNldF9jbGFzc19uYW1lOiAnYSB0IC0+IHN0cmluZyAtPiB1bml0XG4gIHZhbCBnZXRfY2xhc3NfbmFtZTogJ2EgdCAtPiBzdHJpbmdcblxuICB2YWwgc2V0X2lubmVySFRNTDogICdhIHQgLT4gc3RyaW5nIC0+IHVuaXRcbiAgdmFsIGlubmVyX0hUTUw6ICdhIHQgLT4gc3RyaW5nXG5cbiAgdmFsIHNldF9vdXRlcl9IVE1MOiAnYSB0IC0+IHN0cmluZyAtPiB1bml0XG4gIHZhbCBvdXRlcl9IVE1MOiAnYSB0IC0+IHN0cmluZ1xuXG4gIHZhbCBzZXRfb25jbGljazogJ2EgdCAtPiAoJ2EgdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBzZXRfb25kYmNsaWNrOiAnYSB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIHNldF9vbmJsdXI6ICdhIHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgc2V0X29uZm9jdXM6ICdhIHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgc2V0X29uY2hhbmdlOiAnYSB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIHNldF9vbm1vdXNlb3ZlcjogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBzZXRfb25rZXl1cDogJ2EgdCAtPiAoJ2EgdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBzZXRfb25pbnB1dDogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGtleTogJ2EgdCAtPiBzdHJpbmdcbiAgdmFsIGRldGFpbDogJ2EgdCAtPiBpbnRcblxuICB2YWwgdW5zYWZlX2Nhc3Q6ICdhIHQgLT4gJ2IgdFxuICB2YWwgdGFnX25hbWU6ICdhIHQgLT4gc3RyaW5nXG4gIHZhbCBvcHRpb25zOiAnYSB0IC0+ICdhIHQgYXJyYXlcbiAgdmFsIHNlbGVjdGVkX2luZGV4OiAnYSB0LT4gaW50XG5cbiAgdmFsIGNvbnRlbnRfZWRpdGFibGU6ICdhIHQgLT4gYm9vbFxuICB2YWwgc2V0X2NvbnRlbnRfZWRpdGFibGU6ICdhIHQgLT4gYm9vbCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBbJWpzIDpcbiAgICAgICAgICAgICB0eXBlIHVudHlwZWQgPSBLaW5kcy5Ob2RlLmVsZW1lbnQgTm9kZS50XG4gICAgICAgICAgICAgdmFsIHVudHlwZWRfb2ZfanM6IE9qcy50IC0+IHVudHlwZWRcbiAgICAgICAgICAgICB2YWwgdW50eXBlZF90b19qczogdW50eXBlZCAtPiBPanMudFxuXG4gICAgICAgICAgICAgdmFsIGhhc19hdHRyaWJ1dGU6IHVudHlwZWQgLT4gc3RyaW5nIC0+IGJvb2wgW0BAanMuY2FsbF1cbiAgICAgICAgICAgICB2YWwgc2V0X2F0dHJpYnV0ZTogdW50eXBlZCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQgW0BAanMuY2FsbF1cbiAgICAgICAgICAgICB2YWwgZ2V0X2F0dHJpYnV0ZTogdW50eXBlZCAtPiBzdHJpbmcgLT4gc3RyaW5nIFtAQGpzLmNhbGxdXG4gICAgICAgICAgICAgdmFsIGhhc19hdHRyaWJ1dGVfbl9zOiB1bnR5cGVkIC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCBbQEBqcy5jYWxsXVxuICAgICAgICAgICAgIHZhbCBzZXRfYXR0cmlidXRlX25fczogdW50eXBlZCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0IFtAQGpzLmNhbGxdXG4gICAgICAgICAgICAgdmFsIGdldF9hdHRyaWJ1dGVfbl9zOiB1bnR5cGVkIC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIFtAQGpzLmNhbGxdXG4gICAgICAgICAgICAgdmFsIHJlbW92ZV9hdHRyaWJ1dGU6IHVudHlwZWQgLT4gc3RyaW5nIC0+IHVuaXQgW0BAanMuY2FsbF1cblxuICAgICAgICAgICAgIHZhbCBzZXRfY2xhc3NfbmFtZTogdW50eXBlZCAtPiBzdHJpbmcgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIGdldF9jbGFzc19uYW1lOiB1bnR5cGVkIC0+IHN0cmluZyBbQEBqcy5nZXRdXG5cbiAgICAgICAgICAgICB2YWwgc2V0X2lubmVySFRNTDogIHVudHlwZWQgLT4gc3RyaW5nIC0+IHVuaXQgW0BAanMuc2V0XVxuICAgICAgICAgICAgIHZhbCBpbm5lcl9IVE1MOiB1bnR5cGVkIC0+IHN0cmluZyBbQEBqcy5nZXRdXG5cbiAgICAgICAgICAgICB2YWwgc2V0X291dGVyX0hUTUw6IHVudHlwZWQgLT4gc3RyaW5nIC0+IHVuaXQgW0BAanMuc2V0XVxuICAgICAgICAgICAgIHZhbCBvdXRlcl9IVE1MOiB1bnR5cGVkIC0+IHN0cmluZyBbQEBqcy5nZXRdXG5cbiAgICAgICAgICAgICB2YWwgc2V0X29uY2xpY2s6IHVudHlwZWQgLT4gKHVudHlwZWQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbmRiY2xpY2s6IHVudHlwZWQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbmJsdXI6IHVudHlwZWQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbmZvY3VzOiB1bnR5cGVkIC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQgW0BAanMuc2V0XVxuICAgICAgICAgICAgIHZhbCBzZXRfb25jaGFuZ2U6IHVudHlwZWQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbm1vdXNlb3ZlcjogdW50eXBlZCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0IFtAQGpzLnNldF1cbiAgICAgICAgICAgICB2YWwgc2V0X29ua2V5dXA6IHVudHlwZWQgLT4gKHVudHlwZWQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbmlucHV0OiB1bnR5cGVkIC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQgW0BAanMuc2V0XVxuICAgICAgICAgICAgIHZhbCB0YWdfbmFtZTogdW50eXBlZCAtPiBzdHJpbmcgW0BAanMuZ2V0XVxuXG4gICAgICAgICAgICAgdmFsIGNvbnRlbnRfZWRpdGFibGU6IHVudHlwZWQgLT4gYm9vbCBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9jb250ZW50X2VkaXRhYmxlOiB1bnR5cGVkIC0+IGJvb2wgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIG9wdGlvbnM6IHVudHlwZWQgLT4gdW50eXBlZCBhcnJheSBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIHNlbGVjdGVkX2luZGV4OiB1bnR5cGVkIC0+IGludCBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIGtleTogdW50eXBlZCAtPiBzdHJpbmcgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIHZhbCBkZXRhaWw6IHVudHlwZWQgLT4gaW50IFtAQGpzLmdldF1cbiAgICAgICAgICAgXVxuICB0eXBlICdhIHQgPSB1bnR5cGVkXG4gIGxldCB0X29mX2pzIF8geCA9IHVudHlwZWRfb2ZfanMgeFxuICBsZXQgdF90b19qcyBfIHggPSB1bnR5cGVkX3RvX2pzIHhcbiAgbGV0IHVuc2FmZV9jYXN0IHggPSB4XG5lbmRcblxubW9kdWxlIERvY3VtZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IEtpbmRzLk5vZGUuZG9jdW1lbnQgTm9kZS50IFtAQGpzXVxuXG4gIGluY2x1ZGUgKFslanMgOlxuICAgICAgICAgICAgIHZhbCBzZXRfdGl0bGU6IHQgLT4gc3RyaW5nIC0+IHVuaXQgW0BAanMuc2V0XVxuICAgICAgICAgICAgIHZhbCB0aXRsZTogdCAtPiBzdHJpbmcgW0BAanMuZ2V0XVxuXG4gICAgICAgICAgICAgdmFsIGdldF9lbGVtZW50X2J5X2lkOiB0IC0+IHN0cmluZyAtPiB1bmtub3duIEVsZW1lbnQudCBvcHRpb24gW0BAanMuY2FsbF1cbiAgICAgICAgICAgICB2YWwgZ2V0X2VsZW1lbnRzX2J5X2NsYXNzX25hbWU6IHQgLT4gc3RyaW5nIC0+IHVua25vd24gRWxlbWVudC50IGFycmF5IFtAQGpzLmNhbGxdXG5cbiAgICAgICAgICAgICB2YWwgY3JlYXRlX2VsZW1lbnQ6IHQgLT4gc3RyaW5nIC0+IHVua25vd24gRWxlbWVudC50IFtAQGpzLmNhbGxdXG4gICAgICAgICAgICAgdmFsIGNyZWF0ZV9lbGVtZW50X25fczogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVua25vd24gRWxlbWVudC50IFtAQGpzLmNhbGxdXG4gICAgICAgICAgICAgdmFsIGNyZWF0ZV90ZXh0X25vZGU6IHQgLT4gc3RyaW5nIC0+IEtpbmRzLk5vZGUudGV4dCBOb2RlLnQgW0BAanMuY2FsbF1cblxuICAgICAgICAgICAgIHZhbCBib2R5OiB0IC0+IEtpbmRzLkh0bWwuYm9keSBFbGVtZW50LnQgW0BAanMuZ2V0XVxuXG4gICAgICAgICAgICAgdmFsIGhlaWdodDogdCAtPiBpbnQgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIHZhbCB3aWR0aDogdCAtPiBpbnQgW0BAanMuZ2V0XVxuICAgICAgICAgICBdKVxuXG4gIGxldCBjcmVhdGVfaHRtbF9pbnB1dCBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwiaW5wdXRcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC5pbnB1dCBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90YWJsZSBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidGFibGVcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50YWJsZSBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90ciBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidHJcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50ciBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90ZCBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidGRcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50ZCBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90aCBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidGhcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50aCBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90Ym9keSBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidGJvZHlcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50Ym9keSBFbGVtZW50LnQpXG4gIGxldCBjcmVhdGVfaHRtbF90aGVhZCBkb2N1bWVudCA9XG4gICAgKGNyZWF0ZV9lbGVtZW50IGRvY3VtZW50IFwidGhlYWRcIlxuICAgICB8PiBFbGVtZW50LnVuc2FmZV9jYXN0IDogS2luZHMuSHRtbC50aGVhZCBFbGVtZW50LnQpXG5lbmRcblxubW9kdWxlIFdpbmRvdyA9IFslanMgOlxuICB0eXBlIHQgPSBwcml2YXRlIE9qcy50XG5cbiAgdmFsIHRfb2ZfanM6IE9qcy50IC0+IHRcbiAgdmFsIHRfdG9fanM6IHQgLT4gT2pzLnRcblxuICB2YWwgZG9jdW1lbnQ6IHQgLT4gRG9jdW1lbnQudCBbQEBqcy5nZXRdXG4gIHZhbCBpbm5lcl9oZWlnaHQ6IHQgLT4gaW50IFtAQGpzLmdldF1cbiAgdmFsIGlubmVyX3dpZHRoOiB0IC0+IGludCBbQEBqcy5nZXRdXG5cbiAgdmFsIHNldF9vbmxvYWQ6IHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG5dXG5cbm1vZHVsZSBDb25zb2xlID0gWyVqcyA6XG4gIHR5cGUgdCA9IHByaXZhdGUgT2pzLnRcblxuICB2YWwgdF9vZl9qczogT2pzLnQgLT4gdFxuICB2YWwgdF90b19qczogdCAtPiBPanMudFxuXG4gIHZhbCBsb2c6IHQgLT4gT2pzLnQgLT4gdW5pdCBbQEBqcy5jYWxsXVxuXG4gIHZhbCBsb2dfc3RyaW5nOiB0IC0+IHN0cmluZyAtPiB1bml0XG4gIFtAQGpzLmNhbGwgXCJsb2dcIl1cbl1cblxubW9kdWxlIEpTT04gPSBbJWpzIDpcbiAgdmFsIHBhcnNlOiBzdHJpbmcgLT4gT2pzLnRcbiAgW0BAanMuZ2xvYmFsIFwiSlNPTi5wYXJzZVwiXVxuICB2YWwgc3RyaW5naWZ5OiBPanMudCAtPiBzdHJpbmdcbiAgW0BAanMuZ2xvYmFsIFwiSlNPTi5zdHJpbmdpZnlcIl1cbl1cblxubW9kdWxlIEZpbGUgPSBbJWpzIDpcbiAgdHlwZSB0ID0gcHJpdmF0ZSBPanMudFxuICB2YWwgdF9vZl9qczogT2pzLnQgLT4gdFxuICB2YWwgdF90b19qczogdCAtPiBPanMudFxuICB2YWwgbmFtZTogdCAtPiBzdHJpbmcgW0BAanMuZ2V0XVxuXVxuXG5tb2R1bGUgRmlsZUxpc3QgPSBbJWpzIDpcbiAgdHlwZSB0ID0gcHJpdmF0ZSBPanMudFxuICB2YWwgdF9vZl9qczogT2pzLnQgLT4gdFxuICB2YWwgdF90b19qczogdCAtPiBPanMudFxuICB2YWwgaXRlbTogdCAtPiBpbnQgLT4gRmlsZS50IG9wdGlvbiBbQEBqcy5jYWxsXVxuICB2YWwgbGVuZ3RoOiB0IC0+IGludCBbQEBqcy5nZXRdXG5dXG5cbm1vZHVsZSBGaWxlUmVhZGVyID0gc3RydWN0XG4gIHR5cGUgc3RhdGUgPVxuICAgIHwgRW1wdHkgW0BqcyAwXVxuICAgIHwgTG9hZGluZyBbQGpzIDFdXG4gICAgfCBEb25lIFtAanMgMl0gW0BAanNdIFtAQGpzLmVudW1dXG5cbiAgaW5jbHVkZSBbJWpzIDpcbiAgICAgICAgICAgICB0eXBlIHQgPSBwcml2YXRlIE9qcy50XG4gICAgICAgICAgICAgdmFsIHRfb2ZfanM6IE9qcy50IC0+IHRcbiAgICAgICAgICAgICB2YWwgdF90b19qczogdCAtPiBPanMudFxuICAgICAgICAgICAgIHZhbCBuZXdfZmlsZV9yZWFkZXIgOiB1bml0IC0+IHQgW0BAanMubmV3XVxuICAgICAgICAgICAgIHZhbCByZWFkeV9zdGF0ZSA6IHQgLT4gc3RhdGUgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIHZhbCByZXN1bHQ6IHQgLT4gc3RyaW5nIG9wdGlvbiBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgdmFsIHNldF9vbmxvYWQ6IHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCBbQEBqcy5zZXRdXG4gICAgICAgICAgICAgdmFsIHJlYWRfYXNfdGV4dDogdCAtPiBGaWxlLnQgLT4gdW5pdCBbQEBqcy5jYWxsXVxuICAgICAgICAgICBdXG5lbmRcblxubW9kdWxlIEh0bWwgPSBzdHJ1Y3RcbiAgbW9kdWxlIElucHV0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gS2luZHMuSHRtbC5pbnB1dCBFbGVtZW50LnQgW0BAanNdXG4gICAgaW5jbHVkZSAoWyVqcyA6XG4gICAgICAgICAgICAgICB2YWwgZmlsZXM6IHQgLT4gRmlsZUxpc3QudCBbQEBqcy5nZXRdXG4gICAgICAgICAgICAgICB2YWwgdmFsdWU6IHQtPiBzdHJpbmcgW0BAanMuZ2V0XVxuICAgICAgICAgICAgIF0pXG4gIGVuZFxuXG4gIGxldCByZXR5cGUgeCA9XG4gICAgbWF0Y2ggU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSAoRWxlbWVudC50YWdfbmFtZSB4KSB3aXRoXG4gICAgfCBcImlucHV0XCIgLT4gYElucHV0IChFbGVtZW50LnVuc2FmZV9jYXN0IHggOiBLaW5kcy5IdG1sLmlucHV0IEVsZW1lbnQudClcbiAgICB8IFwidGFibGVcIiAtPiBgVGFibGUgKEVsZW1lbnQudW5zYWZlX2Nhc3QgeCA6IEtpbmRzLkh0bWwudGFibGUgRWxlbWVudC50KVxuICAgIHwgXCJ0clwiIC0+IGBUciAoRWxlbWVudC51bnNhZmVfY2FzdCB4IDogS2luZHMuSHRtbC50ciBFbGVtZW50LnQpXG4gICAgfCBcInRkXCIgLT4gYFRkIChFbGVtZW50LnVuc2FmZV9jYXN0IHggOiBLaW5kcy5IdG1sLnRkIEVsZW1lbnQudClcbiAgICB8IFwiYm9keVwiIC0+IGBCb2R5IChFbGVtZW50LnVuc2FmZV9jYXN0IHggOiBLaW5kcy5IdG1sLmJvZHkgRWxlbWVudC50KVxuICAgIHwgXCJ0Ym9keVwiIC0+IGBUYm9keSAoRWxlbWVudC51bnNhZmVfY2FzdCB4IDogS2luZHMuSHRtbC50Ym9keSBFbGVtZW50LnQpXG4gICAgfCBcInRoZWFkXCIgLT4gYFRoZWFkIChFbGVtZW50LnVuc2FmZV9jYXN0IHggOiBLaW5kcy5IdG1sLnRoZWFkIEVsZW1lbnQudClcbiAgICB8IF8gLT4gYFVua25vd25cbmVuZFxuXG5tb2R1bGUgR2xvYmFsVmFyaWFibGVzID0gWyVqcyA6XG4gIHZhbCB3aW5kb3c6IFdpbmRvdy50XG4gIFtAQGpzLmdsb2JhbF1cblxuICB2YWwgYWxlcnQ6IHN0cmluZyAtPiB1bml0XG4gIFtAQGpzLmdsb2JhbF1cblxuICB2YWwgY29uc29sZTogQ29uc29sZS50XG4gIFtAQGpzLmdsb2JhbF1cbl1cbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMTgzMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuZmxvYXR2aWV3X2pzLmVvYmpzL2pzb28vZHVuZV9fZXhlLmNtby5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJEdW5lX2V4ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxODQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5mbG9hdHZpZXdfanMuZW9ianMvanNvby9kdW5lX19leGVfX0xvZy5jbW8uanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiU3RkbGliX0Zvcm1hdCIsIlN0ZGxpYl9CdWZmZXIiLCJKc19jb3JlIiwiY3N0X0V4aXQiLCJtYWtlX3ByZWZpeGVkX211bHRpbGluZV9mb3JtYXQiLCJjaGFuIiwiYnVmZmVyIiwib3V0IiwicyIsInBhcmFtIiwiZmx1c2giLCJzdHJpbmciLCJsb2drIiwiayIsImZtdCIsImZvcm1hdHRlciIsImZsdXNoX2ZtdCIsImxvZyIsImVycm9yIiwiZmx1c2hfZXhpdCIsImxvZ19vYmoiLCJEdW5lX2V4ZV9Mb2ciXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9odG1sL2xvZy5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsK0JBQUFDO0FBQUFBLFFBQUFDLFNDb0JlO0FBQUEsYUFBQUMsSUFBQUMsR0FBQUMsT0FBQTtBQUFBLEtBRVgsK0NBQXFCO0FBQUE7QUFBQSxhQUFBQyxNQUFBRDtBQUFBQSxTQUFBRSxTQUVSO0FBQUEsS0FDYjtBQUFBLGVBRVc7QUFBQSxlQURFLGlEQUMwQjtBQUFBO0FBQUEsSUFDekMsaURBQTRCO0FBQUE7QUFBQSxZQUFBQyxLQUFBUCxNQUFBUSxHQUFBQztBQUFBQSxRQUFBQyxZQUtaO0FBQUEsSUFDaEIsd0RBQTRCO0FBQUE7QUFBQSxZQUFBQyxVQUFBRDtBQUFBQSxJQUc1QixrREFBK0I7QUFBQTtBQUFBLFlBQUFFLElBQUFILEtBRy9CLDhCQUEwQjtBQUFBLFlBQUFJLE1BQUFKO0FBQUFBLGFBQUFLLFdBQUFMO0FBQUFBLEtBR0w7QUFBQSxLQUFhLHNDQUFpQjtBQUFBO0FBQUEsSUFDbkQsK0JBQXlCO0FBQUE7QUFBQTtBQUFBLElBQUFNLFVBR3pCO0FBQUEsSUFBQUM7QUFBQUEsTUFBbUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQvQ3JDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICogVGhpcyBGaWxlIGlzIHBhcnQgb2YgdGhlIEZsb2F0VmlldyByZXBvc2l0b3J5XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjUgLSBKb3NzZWxpbiBHaWV0XG4gKlxuICogVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbigqKiBNaW5pbWFsaXN0aWMgbG9nZ2luZyBsaWJyYXJ5IGZvciBpbnRlcmFjdGluZyB3aXRoIGNvbnNvbGUgYW5kIGFsZXJ0IHdpdGhcbiAgICB7IUZvcm1hdH0gc3R5bGUgZnVuY3Rpb25zLiAqKVxuXG5vcGVuIEpzX2NvcmVcbm1vZHVsZSBGbXQgPSBGb3JtYXRcblxudHlwZSBvdXRfY2hhbiA9XG4gIHwgQ09OU09MRVxuICB8IEFMRVJUXG5cbmxldCBtYWtlX3ByZWZpeGVkX211bHRpbGluZV9mb3JtYXR0ZXIgY2hhbiA9XG4gIGxldCBtb2R1bGUgQiA9IEJ1ZmZlciBpblxuICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSA4MCBpblxuICBsZXQgb3V0IHMgXyBfID1cbiAgICBCLmFkZF9zdHJpbmcgYnVmZmVyIHMgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBsZXQgc3RyaW5nID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlciBpblxuICAgIG1hdGNoIGNoYW4gd2l0aFxuICAgIHwgQ09OU09MRSAtPiBDb25zb2xlLmxvZ19zdHJpbmcgIEdsb2JhbFZhcmlhYmxlcy5jb25zb2xlIHN0cmluZ1xuICAgIHwgQUxFUlQgLT4gR2xvYmFsVmFyaWFibGVzLmFsZXJ0IHN0cmluZyBpblxuICBGbXQubWFrZV9mb3JtYXR0ZXIgb3V0IGZsdXNoXG5cbmxldCBsb2drICh0eXBlIGEgYikgY2hhbiAoazogRm10LmZvcm1hdHRlciAtPiBhKVxuICAgIChmbXQ6IChiLCBGbXQuZm9ybWF0dGVyLCB1bml0LCBhKSBmb3JtYXQ0KTogYiA9XG4gICgqIG91dHB1dF9zdHJpbmcgb3V0IHByZng7ICopXG4gIGxldCBmb3JtYXR0ZXIgPSBtYWtlX3ByZWZpeGVkX211bHRpbGluZV9mb3JtYXR0ZXIgY2hhbiBpblxuICBGbXQua2ZwcmludGYgayBmb3JtYXR0ZXIgZm10XG5cbmxldCBmbHVzaF9mbXQgZm9ybWF0dGVyID1cbiAgRm10LnBwX3ByaW50X2ZsdXNoIGZvcm1hdHRlciAoKVxuXG5sZXQgbG9nIChmbXQ6ICgnYSwgRm10LmZvcm1hdHRlciwgdW5pdCkgZm9ybWF0KTogJ2EgPVxuICBsb2drIENPTlNPTEUgZmx1c2hfZm10IGZtdFxuXG5sZXQgZXJyb3IgKHR5cGUgYSBiKSAoZm10OiAoYSwgRm10LmZvcm1hdHRlciwgdW5pdCxiKSBmb3JtYXQ0KTogYSA9XG4gIGxldCBmbHVzaF9leGl0IGZtdCA9IGZsdXNoX2ZtdCBmbXQ7IGZhaWx3aXRoIFwiRXhpdFwiIGluXG4gIGxvZ2sgQUxFUlQgZmx1c2hfZXhpdCBmbXRcblxubGV0IGxvZ19vYmo6IE9qcy50IC0+IHVuaXQgPVxuICBDb25zb2xlLmxvZyBHbG9iYWxWYXJpYWJsZXMuY29uc29sZSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMTkxMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuZmxvYXR2aWV3X2pzLmVvYmpzL2pzb28vZHVuZV9fZXhlX19IZWxwZXIuY21vLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9zdHlsZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkpzX2NvcmUiLCJEdW5lX2V4ZV9Mb2ciLCJkb2N1bWVudCIsImNzdF9pZCIsImNzdF9kaXNwbGF5X25vbmUiLCJyZW1vdmVBbGwiLCJlbGVtZW50IiwibWF0Y2giLCJjaGlsZCIsImNyZWF0ZSIsInRleHQiLCJjbGFzc19uYW1lIiwic3R5bGUiLCJpZCIsIm5hbWUiLCJlbGVtZW50X29mX2lkIiwiaGlkZSIsInNob3ciLCJIZWxwZXIiLCJEdW5lX2V4ZV9IZWxwZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9odG1sL2hlbHBlci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGNBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdDYWlCO0FBQUEsSUFBQVgsWUFBc0M7QUFBQSxJQUFBWSxTQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFiLGNBQUE7QUFBQSxJQUFBQSxjQUFBO0FBQUEsWUFBQWMsVUFBQUM7QUFBQUEsSUFFbkQ7QUFBQSxTQUFBQyxRQUNRO0FBQUEsS0FBdUI7QUFBQSxVQUFBQyxRQUFBO0FBQUEsTUFDYjtBQUFBLGdCQUErQjtBQUFBO0FBQUE7QUFBQSxnQkFDckM7QUFBQSxLQUZtQjtBQUFBO0FBQUEsR0FHckI7QUFBQSxZQUFBQyxPQUFBQyxNQUFBQyxZQUFBQyxPQUFBQyxJQUFBQztBQUFBQSxRQUFBUixVQUdJO0FBQUEsSUFDZDtBQUFBLFNBQUFJLFNBQUE7QUFBQSxLQUNnQjtBQUFBO0FBQUEsSUFFaEI7QUFBQSxTQUFBRSxVQUFBO0FBQUEsS0FDaUI7QUFBQTtBQUFBLElBRWpCO0FBQUEsU0FBQUMsT0FBQTtBQUFBLEtBQ2M7QUFBQTtBQUFBLElBRWQ7QUFBQSxTQUFBRixlQUFBO0FBQUEsS0FDc0I7QUFBQTtBQUFBLElBRXRCO0FBQUEsR0FBTztBQUFBLFlBQUFJLGNBQUFGO0FBQUFBLFFBQUFOLFFBR0Q7QUFBQSxJQUFzQyxZQUVsQywyQ0FBMkM7QUFBQSxRQUFBRCxVQUZUO0FBQUEsSUFDMUI7QUFBQSxHQUNtQztBQUFBLFlBQUFVLEtBQUFWO0FBQUFBLElBR3JELHdFQUFxRDtBQUFBO0FBQUEsWUFBQVcsS0FBQVg7QUFBQUEsSUFHckQsc0RBQXdDO0FBQUE7QUFBQTtBQUFBLElBQUFZLFNBakNXO0FBQUEsSUFBQUMsa0JBQUE7QUFBQTtBQUFBO0FBQUEsRURidkQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnkuXG4gKiBUaGlzIGZpbGUgd2FzIHBhcnQgb2YgdGhlIGxhbmRtYXJrcy12aWV3ZXIgcHJvamVjdC5cbiAqIENvcHlyaWdodCAoQykgMjAxNiAtIExleGlGaS4gKHVuZGVyIE1JVCBsaWNlbnNlKVxuICogQ29weXJpZ2h0IChDKSAyMDI1IC0gSm9zc2VsaW4gR2lldFxuICpcbiAqIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbm9wZW4gSnNfY29yZVxuXG5tb2R1bGUgSGVscGVyID0gc3RydWN0XG4gIGxldCBkb2N1bWVudCA9IFdpbmRvdy5kb2N1bWVudCBHbG9iYWxWYXJpYWJsZXMud2luZG93XG4gIGxldCByZW1vdmVBbGwgZWxlbWVudCA9XG4gICAgd2hpbGVcbiAgICAgIG1hdGNoIE5vZGUubGFzdF9jaGlsZCBlbGVtZW50IHdpdGhcbiAgICAgIHwgU29tZSBjaGlsZCAtPiBOb2RlLnJlbW92ZV9jaGlsZCBlbGVtZW50IGNoaWxkOyB0cnVlXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICBkbyAoKSBkb25lXG5cbiAgbGV0IGNyZWF0ZSA/dGV4dCA/Y2xhc3NfbmFtZSA/c3R5bGUgP2lkIG5hbWUgPVxuICAgIGxldCBlbGVtZW50ID0gRG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQgZG9jdW1lbnQgbmFtZSBpblxuICAgIChtYXRjaCB0ZXh0IHdpdGhcbiAgICAgfCBTb21lIHRleHQgLT4gTm9kZS5zZXRfdGV4dF9jb250ZW50IGVsZW1lbnQgdGV4dFxuICAgICB8IF8gLT4gKCkpO1xuICAgIChtYXRjaCBzdHlsZSB3aXRoXG4gICAgIHwgU29tZSBzdHlsZSAtPiBFbGVtZW50LnNldF9hdHRyaWJ1dGUgZWxlbWVudCBcInN0eWxlXCIgc3R5bGVcbiAgICAgfCBfIC0+ICgpKTtcbiAgICAobWF0Y2ggaWQgd2l0aFxuICAgICB8IFNvbWUgaWQgLT4gRWxlbWVudC5zZXRfYXR0cmlidXRlIGVsZW1lbnQgXCJpZFwiIGlkXG4gICAgIHwgXyAtPiAoKSk7XG4gICAgKG1hdGNoIGNsYXNzX25hbWUgd2l0aFxuICAgICB8IFNvbWUgY2xhc3NfbmFtZSAtPiBFbGVtZW50LnNldF9jbGFzc19uYW1lIGVsZW1lbnQgY2xhc3NfbmFtZVxuICAgICB8IF8gLT4gKCkpO1xuICAgIGVsZW1lbnRcblxuICBsZXQgZWxlbWVudF9vZl9pZCBpZCA9XG4gICAgbWF0Y2ggRG9jdW1lbnQuZ2V0X2VsZW1lbnRfYnlfaWQgZG9jdW1lbnQgaWQgd2l0aFxuICAgIHwgU29tZSBlbGVtZW50IC0+IGVsZW1lbnRcbiAgICB8IE5vbmUgLT4gTG9nLmVycm9yIFwiRWxlbWVudCBvZiBpZCAnJXMnIG5vdCBmb3VuZFwiIGlkXG5cbiAgbGV0IGhpZGUgZWxlbWVudCA9XG4gICAgRWxlbWVudC5zZXRfYXR0cmlidXRlIGVsZW1lbnQgXCJzdHlsZVwiIFwiZGlzcGxheTogbm9uZVwiXG5cbiAgbGV0IHNob3cgZWxlbWVudCA9XG4gICAgRWxlbWVudC5yZW1vdmVfYXR0cmlidXRlIGVsZW1lbnQgXCJzdHlsZVwiXG5lbmQiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzE5OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmZsb2F0dmlld19qcy5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fVXRpbHMuY21vLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDMiLCJmIiwiYTAiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0J5dGVzIiwicmVtb3ZlX3doaXRlc3BhY2VzIiwic3RyIiwiYnl0ZXMiLCJpIiwiYyIsIkR1bmVfZXhlX1V0aWxzIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvd29ya3NwYWNlX3Jvb3QvaHRtbC91dGlscy5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsbUJBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFFDV2MsMEJBQVo7QUFBQSxLQUFBQztBQUFBQSxPQUNRO0FBQUE7QUFBQSxrQkFBQUEsR0FBQUM7QUFBQUEsVUFDTTtBQUFBLFdBRUo7QUFBQSxXQUFtQjtBQUFBO0FBQUEsVUFEcEI7QUFBQSxTQUMwQjtBQUFBO0FBQUE7QUFBQSxJQUVuQywrQ0FBMEI7QUFBQTtBQUFBLE9BQUFDLGlCRGpCNUIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gKiBUaGlzIEZpbGUgaXMgcGFydCBvZiB0aGUgRmxvYXRWaWV3IHJlcG9zaXRvcnlcbiAqIENvcHlyaWdodCAoQykgMjAyNSAtIEpvc3NlbGluIEdpZXRcbiAqXG4gKiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBDZWNJTEwgdjIuMS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9ucywgc2VlIHRoZSBMSUNFTlNFIGZpbGUuXG4gKilcblxuKCoqIFtyZW1vdmVfd2hpdGVzcGFjZXMgc3RyXSByZXR1cm5zIGEgY29weSBvZiBzdHIgd2hlcmUgYWxsIHdoaXRlc3BhY2VzXG4gICAgY2hhcmN0ZXJzIFsnICcsICdcXG4nLCAnXFx0J10gYXJlIHJlbW92ZWQuICopXG5sZXQgcmVtb3ZlX3doaXRlc3BhY2VzIHN0ciA9XG4gIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzdHIpIGluXG4gIGxldCBpID0gU3RyaW5nLmZvbGRfbGVmdFxuICAgIChmdW4gaSBjIC0+IGlmIGM9JyAnIHx8IGMgPSAnXFxuJyB8fCBjID0gJ1xcdCdcbiAgICAgIHRoZW4gaVxuICAgICAgZWxzZSAoQnl0ZXMuc2V0IGJ5dGVzIGkgYzsgaSsxKSApXG4gICAgMCBzdHIgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBieXRlcyAwIGlcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMjAzNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiIuZmxvYXR2aWV3X2pzLmVvYmpzL2pzb28vZHVuZV9fZXhlX19GbG9hdHZpZXdfanMuY21vLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9hIiwiY3N0X0luZiIsImNzdF8wIiwiY3N0XzEiLCJjc3RfRW50ZXIiLCJjc3RfTmFuIiwiY3N0X2NvbnRhaW5lciIsImNzdF9kZWNfaW4iLCJjc3RfZGVjX291dCIsImNzdF9kZWNfb3V0cHV0IiwiY3N0X2RpdiIsImNzdF9lcnJfb3V0IiwiY3N0X2Zsb2F0IiwiY3N0X2Zsb2F0X3JlcHIiLCJjc3RfaW5wdXQiLCJjc3RfcHJlIiwiY3N0X3N0YXR1cyIsImNzdF90ZCIsImNzdF90aF9iaXQiLCJjc3RfdGl0bGUiLCJjc3RfdXNhZ2UiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiYXZhaWxhYmxlX3ByZWNpc2lvbnMiLCJEdW5lX2V4ZV9IZWxwZXIiLCJKc19jb3JlIiwiRHVuZV9leGVfVXRpbHMiLCJEZWNpbWFsIiwiQ29udmVydCIsIlN0ZGxpYl9QcmludGV4YyIsIkR1bmVfZXhlX0xvZyIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9BcnJheSIsIkZsb2F0cyIsIkJpdHYiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX01hcCIsIlN0cmluZ01hcCIsImFkZF9wcmVjaXNpb24iLCJwIiwibWFwIiwicHJlY2lzaW9ucyIsImN1cnJlbnRfcHJlY2lzaW9uIiwiY3VycmVudF9kZWMiLCJjdXJyZW50X2Zsb2F0IiwicHBfZGVjIiwiY3N0X3RyIiwiY3N0X2Vycm9yX3ZhbHVlX2lucHV0IiwiY3N0X3NlbGVjdCIsImNzdF9vcHRpb24iLCJjc3RfbnVtYmVyX29mX3NpZ25pZmljYW5kX2RpZ2kiLCJjc3RfYnV0dG9uIiwiY3N0X21haW4iLCJjc3RfdGFibGUiLCJ1cGRhdGVfZGVjaW1hbCIsInBhcmFtIiwibl9kZWMiLCJuX2VyciIsImIiLCJkIiwidHh0IiwiZF9lcnIiLCJhZGRfZmxvYXQiLCJ0YWJsZSIsInRyIiwiZGJjbGljayIsInRkIiwiY2hpbGRyZW4iLCJuIiwiYm9vbCIsIm1hdGNoIiwibSIsImUiLCJzIiwiY2xpY2siLCJpIiwibGVuIiwidGV4dCIsInRkX3NpZ24iLCJsYXN0IiwidiIsIm9ubG9hZCIsIm1haW4iLCJjb250YWluZXIiLCJ1c2FnZSIsInNlbGVjdCIsIm9wdGlvbiIsInRpdGxlIiwiY2hhbmdlIiwiaWR4Iiwib3B0aW9ucyIsInByZWNpc2lvbiIsImRlY2ltYWwiLCJzdHIiLCJleG4iLCJpbnB1dCIsImJsdXIiLCJhIiwiY29kZSIsInByZV9kZWNpbWFsIiwicHJlX2Vycm9yIiwiZXJyIiwicGFyZW50IiwiYXJlYSIsInVwZGF0ZV9zaWduaWZpY2FuZCIsImFyZyIsImV0YSIsInVwZGF0ZV9lbnRlciIsInZhciIsImJ1dHRvbiIsInVwZGF0ZSIsIkR1bmVfZXhlX0Zsb2F0dmlld19qcyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L2h0bWwvZmxvYXR2aWV3X2pzLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFB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VUFDSjtBQUFBLElBQ1o7QUFBQSxJQUNBO0FBQUE7QUFBQSxLQUFBZ0IsWUFDZ0I7QUFBQSxLQUFBQyxNQUNOO0FBQUEsV0FDc0I7QUFBQSxJQUFoQztBQUFBLElBQ0E7QUFBQSxJQUFxQztBQUFBO0FBQUEsS0FBQUMsU0FtRHhCO0FBQUEsS0FBQWxCLFVBQ0Q7QUFBQSxJQUNaO0FBQUE7QUFBQTtBQUFBLEtBQUFtQixPQUlXO0FBQUEsSUFDWDtBQUFBLGFBQUFDLG1CQUFBN0I7QUFBQUEsS0FFRTtBQUFBLE1BR0s7QUFBQSxXQUFBOEIsTUFDSDtBQUFBLDRCQUFBQyxLRGhSTjtBQUFBO0FBQUE7QUFBQSxPQ2tSZ0I7QUFBQTtBQUFBLE1BSlY7QUFBQSxLQU1GLHdCQUFpQjtBQUFBO0FBQUEsYUFBQUMsYUFBQW5DO0FBQUFBLFNBQUEwQixPQUVOO0FBQUEsS0FDTyx1QkFBTTtBQUFBO0FBQUEsTUFBQUwsTUFDZDtBQUFBLE1BQUFBLFFBQ0E7QUFBQSxLQUNWO0FBQUEsU0FBQWUsUUFDVTtBQUFBLEtBQ1YsZ0NBQXNCO0FBQUE7QUFBQSxJQUN4QjtBQUFBLFFBQUFDLFNBQ2E7QUFBQSxhQUFBQyxPQUFBdkQ7QUFBQUE7QUFBQUEsTUFBQUssTUFFRDtBQUFBLE1BQUFnRCxRQUNBO0FBQUEsS0FDVixnQ0FBc0I7QUFBQTtBQUFBLElBQ3hCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFBK0IsOENBZTlCO0FBQUE7QUFBQSxHQUVNO0FBQUEsT0FBQUcsd0JBQStDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR2VHhEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICogVGhpcyBGaWxlIGlzIHBhcnQgb2YgdGhlIEZsb2F0VmlldyByZXBvc2l0b3J5XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjUgLSBKb3NzZWxpbiBHaWV0XG4gKlxuICogVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ2VjSUxMIHYyLjEuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbnMsIHNlZSB0aGUgTElDRU5TRSBmaWxlLlxuICopXG5cbm1vZHVsZSBGID0gRmxvYXRzXG5tb2R1bGUgQiA9IEJpbmFyeVxubW9kdWxlIEQgPSBEZWNpbWFsXG5cbm9wZW4gSnNfY29yZVxub3BlbiBIZWxwZXJcbm9wZW4gVXRpbHNcblxuKCoqIHsyIFByZWNpc2lvbn0gKilcblxubW9kdWxlIFN0cmluZ01hcCA9IE1hcC5NYWtlKFN0cmluZylcblxubGV0IHByZWNpc2lvbnMgPVxuICBsZXQgYWRkX3ByZWNpc2lvbiAocDogRi5mbG9hdF9wcmVjaXNpb24pIG1hcCA9IFN0cmluZ01hcC5hZGQgcC5uYW1lIHAgbWFwIGluXG4gIFN0cmluZ01hcC5lbXB0eVxuICB8PiBhZGRfcHJlY2lzaW9uIEYubWluaVxuICB8PiBhZGRfcHJlY2lzaW9uIEYuaGFsZlxuICB8PiBhZGRfcHJlY2lzaW9uIEYuc2luZ2xlXG4gIHw+IGFkZF9wcmVjaXNpb24gRi5kb3VibGVcblxuKCoqIHsxIEdMb2JhbCBwYXJhbWV0ZXJzfSAqKVxuXG4oKiogUHJlY2lzaW9uIHVzZWQgY3VycmVudGx5LiAqKVxubGV0IGN1cnJlbnRfcHJlY2lzaW9uID0gcmVmIEYuaGFsZlxuXG4oKiogRGVjaW1hbCB2YWx1ZSBhcyBwYXJzZWQgZnJvbSB0aGUgaW5wdXQgSFRNTCBkaXYuICopXG5sZXQgY3VycmVudF9kZWMgPSByZWYgKEQuZnJvbV9pbnQgMClcblxuKCoqIEZsb2F0IHZsYXVlIGN1cnJlbnRseSBkaXNwbGF5ZWQuICopXG5sZXQgY3VycmVudF9mbG9hdCA9IHJlZiAoRi5nZXRfemVybyB+c2lnbjpmYWxzZSAhY3VycmVudF9wcmVjaXNpb24pXG5cbigqKiBDdXJyZW50IGRlY2ltYWwgcHJldHR5IHByaW50ZXIuICopXG5sZXQgcHBfZGVjID0gcmVmIChELnBwX3NjaWVudGlmaWMgfnNpZ25pZmljYW5kOjEwKVxuXG4oKiogW3VwZGF0ZV9kZWNpbWFsICgpXSBwcmludHMgaW4gZWxlbWVudCBbZGVjX291dF0gYW5kIFtlcnJfb3V0XSwgdGhlIHZhbHVlXG4gICAgb2YgeyFjdXJyZW50X2Zsb2F0fSBhbmQgdGhlIGVycm9yIGNvbXBhcmVkIHRvIHshY3VycmVudF9kZWN9LiAqKVxubGV0IHVwZGF0ZV9kZWNpbWFsICgpOiB1bml0ID1cbiAgbGV0IG5fZGVjID0gSGVscGVyLmVsZW1lbnRfb2ZfaWQgXCJkZWNfb3V0XCIgaW5cbiAgbGV0IG5fZXJyID0gSGVscGVyLmVsZW1lbnRfb2ZfaWQgXCJlcnJfb3V0XCIgaW5cbiAgdHJ5XG4gICAgbGV0IGIgPSAhY3VycmVudF9mbG9hdCB8PiBDb252ZXJ0LmZsb2F0X3RvX2JpbiBpblxuICAgIGxldCBkID0gQ29udmVydC5iaW5fdG9fZGVjIGIgaW5cbiAgICBsZXQgdHh0ID0gRm9ybWF0LmFzcHJpbnRmIFwiJWFcIiAhcHBfZGVjIGQgaW5cbiAgICBOb2RlLnNldF90ZXh0X2NvbnRlbnQgbl9kZWMgdHh0O1xuICAgIGxldCBkX2VyciA9IEQuc3ViIGQgIWN1cnJlbnRfZGVjIGluXG4gICAgbGV0IHR4dCA9IEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgIXBwX2RlYyBkX2VyciBpblxuICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2VyciB0eHQ7XG4gIHdpdGhcbiAgfCBDb252ZXJ0LklzSW5mIHRydWUgLT5cbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2RlYyBcIitJbmZcIjtcbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2VyciBcIitJbmZcIlxuICB8IENvbnZlcnQuSXNJbmYgZmFsc2UgLT5cbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2RlYyBcIi1JbmZcIjtcbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2VyciBcIi1JbmZcIlxuICB8IENvbnZlcnQuSXNOYW4gLT5cbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuX2RlYyBcIk5hblwiO1xuICAgICAgTm9kZS5zZXRfdGV4dF9jb250ZW50IG5fZXJyIFwiTmFuXCJcblxuKCoqIFtpbnZlcnNlX2JpdCBpXSBpbnZlcnNlIHRoZSB2bGF1ZSBvZiB0aGUgW2lddGggYml0IGluIHshY3VycmVudF9mbG9hdH0uXG4gICAgTGF0ZXIsIGl0IGNhbGxzIHshdXBkYXRlX2RlY2ltYWx9LiAqKVxubGV0IGludmVyc2VfYml0IGk6IHVuaXQgPVxuICBsZXQgeyBzOyBlOyBtOyBwIH0gOiBGLmZsb2F0X2J3ID0gIWN1cnJlbnRfZmxvYXQgaW5cbiAgbGV0IGxlbiA9IEYubGVuZ3RoIHAgaW5cbiAgYmVnaW5cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW4gdGhlblxuICAgIExvZy5lcnJvciBcIkNhbm5vdCB1cGRhdGUgYml0ICVpIG9mIGZsb2F0IHdpdGggc2l6ZSAlaVwiXG4gICAgICBpIGxlblxuICBlbHNlXG4gICAgaWYgaSA9IGxlbiAtMSB0aGVuXG4gICAgICBsZXQgcyA9IG5vdCBzIGluXG4gICAgICBjdXJyZW50X2Zsb2F0IDo9IHsgIWN1cnJlbnRfZmxvYXQgd2l0aCBzIH1cbiAgICBlbHNlIGlmIGkgPCBwLm1hbnRpc3NhIHRoZW5cbiAgICAgIGxldCBpID0gcC5tYW50aXNzYSAtIGkgLSAxIGluXG4gICAgICBCaXR2LnNldCBtIGkgKG5vdCAoQml0di5nZXQgbSBpKSlcbiAgICBlbHNlXG4gICAgICBsZXQgaSA9IGkgLSBwLm1hbnRpc3NhIGluXG4gICAgICBCaXR2LnNldCBlIGkgKG5vdCAoQml0di5nZXQgZSBpKSk7XG4gIGVuZDtcbiAgdXBkYXRlX2RlY2ltYWwgKClcblxuKCoqIFtzZXRfYWxsIGJvb2xdIHNldHMgYWxsIGJpdHMgb2YgeyFjdXJyZW50X2Zsb2F0fSB0byBbYm9vbF0uXG4gICAgSXQgY2FsbHMgeyF1cGRhdGVfZGVjaW1hbH0gc3Vic2VxdWVudGx5LiAqKVxubGV0IHNldF9hbGwgYm9vbCA9XG4gIGxldCB7IGU7IG07IHA7IF8gfSA6IEYuZmxvYXRfYncgPSAhY3VycmVudF9mbG9hdCBpblxuICBsZXQgcyA9IG5vdCBib29sIGluXG4gIEJpdHYuZmlsbCBlIDAgcC5leHAgYm9vbDtcbiAgQml0di5maWxsIG0gMCBwLm1hbnRpc3NhIGJvb2w7XG4gIGN1cnJlbnRfZmxvYXQgOj0geyAhY3VycmVudF9mbG9hdCB3aXRoIHMgfTtcbiAgdXBkYXRlX2RlY2ltYWwgKClcblxuKCoqIFthZGRfZmxvYXQgdGFibGVdIHByaW50cyBpbiBbdGFibGVdIHRoZSB2YWx1ZSBvZiB7IWN1cnJlbnRfZmxvYXR9LlxuICAgIEl0IHNldHMgdGhlIFtvbmNsaWNrXSBldmVudHMuICopXG5sZXQgYWRkX2Zsb2F0ICh0YWJsZTogT2pzLnQgTm9kZS50KSA9XG4gIGxldCB0ciA9IEhlbHBlci5jcmVhdGUgfmNsYXNzX25hbWU6XCJmbG9hdFwiIFwidHJcIiBpblxuICBsZXQgZGJjbGljayB0ZCAoKTogdW5pdCA9XG4gICAgbGV0IHR4dCA9IE5vZGUudGV4dF9jb250ZW50IHRkIGluXG4gICAgbGV0IHR4dCA9IGlmIHR4dCA9IFwiMFwiIHRoZW4gXCIxXCIgZWxzZSBcIjBcIiBpblxuICAgIGxldCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4gdHIgaW5cbiAgICBBcnJheS5pdGVyXG4gICAgICAoZnVuIG4gLT4gRWxlbWVudC5zZXRfYXR0cmlidXRlIG4gXCJzdGF0dXNcIiB0eHQ7XG4gICAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBuIHR4dClcbiAgICAgIGNoaWxkcmVuO1xuICAgIHNldF9hbGwgKHR4dCA9IFwiMVwiKSBpblxuICBsZXQgY2xpY2sgdGQgaSBlOiB1bml0ID1cbiAgICBpZiBFbGVtZW50LmRldGFpbCBlID4gMSB0aGVuIGRiY2xpY2sgdGQgKCkgZWxzZVxuICAgIGxldCB0eHQgPSBOb2RlLnRleHRfY29udGVudCB0ZCBpblxuICAgIGxldCB0eHQgPSBpZiB0eHQgPSBcIjBcIiB0aGVuIFwiMVwiIGVsc2UgXCIwXCIgaW5cbiAgICBOb2RlLnNldF90ZXh0X2NvbnRlbnQgdGQgdHh0O1xuICAgIEVsZW1lbnQuc2V0X2F0dHJpYnV0ZSB0ZCBcInN0YXR1c1wiIHR4dDtcbiAgICBpbnZlcnNlX2JpdCBpIGluXG4gIEhlbHBlci5yZW1vdmVBbGwgdGFibGU7XG4gICgqIHByaW50IHNpZ24gKilcbiAgbGV0IGYgPSAhY3VycmVudF9mbG9hdCBpblxuICBsZXQgdGV4dCA9IGlmIGYucyB0aGVuIFwiMFwiIGVsc2UgXCIxXCIgaW5cbiAgbGV0IHRkX3NpZ24gPSBIZWxwZXIuY3JlYXRlIFwidGRcIiB+Y2xhc3NfbmFtZTpcInNpZ25cIiB+dGV4dCBpblxuICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgdGRfc2lnbiBcInN0YXR1c1wiIHRleHQ7XG4gIEVsZW1lbnQuc2V0X2F0dHJpYnV0ZSB0ZF9zaWduIFwidGl0bGVcIlxuICAgIChGb3JtYXQuc3ByaW50ZiBcIiVpdGggYml0XFxuc2lnbiBiaXRcIiAoRi5sZW5ndGggZi5wIC0xKSk7XG4gIEVsZW1lbnQuc2V0X29uY2xpY2sgdGRfc2lnbiAoY2xpY2sgdGRfc2lnbiAoZi5wLmV4cCArIGYucC5tYW50aXNzYSkpO1xuICBOb2RlLmFwcGVuZF9jaGlsZCB0ciB0ZF9zaWduO1xuICAoKiBwcmludCBleHBvbmVudCAqKVxuICBsZXQgbGFzdCA9IEJpdHYuZm9sZF9yaWdodFxuICAgIChmdW4gdiBpIC0+XG4gICAgICBsZXQgdGV4dCA9IGlmIHYgdGhlbiBcIjFcIiBlbHNlIFwiMFwiIGluXG4gICAgICBsZXQgdGQgPSBIZWxwZXIuY3JlYXRlIFwidGRcIiB+Y2xhc3NfbmFtZTpcImV4cFwiIH50ZXh0IGluXG4gICAgICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgdGQgXCJ0aXRsZVwiXG4gICAgICAgIChGb3JtYXQuc3ByaW50ZiBcIiVpdGggYml0XFxuJWl0aCBleHBvbmVudCBiaXRcIiBpIChpLWYucC5tYW50aXNzYSkpO1xuICAgICAgRWxlbWVudC5zZXRfYXR0cmlidXRlIHRkIFwic3RhdHVzXCIgdGV4dDtcbiAgICAgIEVsZW1lbnQuc2V0X29uY2xpY2sgdGQgKGNsaWNrIHRkIGkpO1xuICAgICAgRWxlbWVudC5zZXRfb25kYmNsaWNrIHRkIChkYmNsaWNrIHRkKTtcbiAgICAgIE5vZGUuYXBwZW5kX2NoaWxkIHRyIHRkO1xuICAgICAgaS0xKVxuICAgIGYuZSAoZi5wLmV4cCtmLnAubWFudGlzc2EtMSkgaW5cbiAgKCogcHJpbnQgbWFudGlzc2EgKilcbiAgbGV0IF8gPSBCaXR2LmZvbGRfbGVmdFxuICAgIChmdW4gaSB2IC0+XG4gICAgICBsZXQgdGV4dCA9IGlmIHYgdGhlbiBcIjFcIiBlbHNlIFwiMFwiIGluXG4gICAgICBsZXQgdGQgPSBIZWxwZXIuY3JlYXRlIFwidGRcIiB+Y2xhc3NfbmFtZTpcIm1hbnRpc3NhXCIgfnRleHQgaW5cbiAgICAgIEVsZW1lbnQuc2V0X2F0dHJpYnV0ZSB0ZCBcInRpdGxlXCJcbiAgICAgICAgKEZvcm1hdC5zcHJpbnRmIFwiJWl0aCBiaXRcXG4laXRoIG1hbnRpc3NhIGJpdFwiIGkgaSk7XG4gICAgICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgdGQgXCJzdGF0dXNcIiB0ZXh0O1xuICAgICAgRWxlbWVudC5zZXRfb25jbGljayB0ZCAoY2xpY2sgdGQgaSk7XG4gICAgICBFbGVtZW50LnNldF9vbmRiY2xpY2sgdGQgKGRiY2xpY2sgdGQpO1xuICAgICAgTm9kZS5hcHBlbmRfY2hpbGQgdHIgdGQ7XG4gICAgICBpLTEpXG4gICAgbGFzdCBmLm0gaW5cbiAgTm9kZS5hcHBlbmRfY2hpbGQgdGFibGUgdHJcblxuKCoqIHsyIERlY2ltYWwgdmFsdWV9KilcblxuKCoqIFtzZXRfaW5wdXRdIGluc2VydHMgaW4gW2VdIHRoZSBub2RlcyB1c2VkIHRvIGRpc3BsYXkgdGhlIGRlY2ltYWwgdmFsdWUgb2ZcbiAgICB0aGUgZmxvYXQgYXMgd2VsbCBhcyB0aGUgZXJyb3IgdmFsdWUuICopXG5sZXQgc2V0X2lucHV0IGUgPVxuICBsZXQgY29udGFpbmVyID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwiY29udGFpbmVyXCIgaW5cbiAgbGV0IHVzYWdlID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwidXNhZ2VcIiB+dGV4dDpcImlucHV0XCIgaW5cbiAgTm9kZS5hcHBlbmRfY2hpbGQgY29udGFpbmVyIHVzYWdlO1xuICBsZXQgaW5wdXQgPSBIZWxwZXIuY3JlYXRlIFwiZGl2XCIgfmNsYXNzX25hbWU6XCJkZWNfaW5wdXRcIiB+aWQ6XCJkZWNfaW5cIiB+dGV4dDpcIjBcIiBpblxuICBsZXQgY2xpY2sgXyA9XG4gICAgRWxlbWVudC5zZXRfY29udGVudF9lZGl0YWJsZSBpbnB1dCB0cnVlIGluXG4gIGxldCBibHVyIGEgPVxuICAgIGxldCBjb2RlID0gRWxlbWVudC5rZXkgYSBpblxuICAgIGlmIGNvZGUgPD4gXCJFbnRlclwiICYmIGNvZGUgPD4gXCJFc2NhcGVcIiB0aGVuICgpIGVsc2VcbiAgICBsZXQgc3RyID0gTm9kZS50ZXh0X2NvbnRlbnQgaW5wdXQgaW5cbiAgICBsZXQgc3RyID0gcmVtb3ZlX3doaXRlc3BhY2VzIHN0ciBpblxuICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBpbnB1dCBzdHI7XG4gICAgdHJ5XG4gICAgICBsZXQgZCA9IEQuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBjdXJyZW50X2RlYyA6PSBkO1xuICAgICAgbGV0IGIgPSBDb252ZXJ0LmRlY190b19iaW4gZCBpblxuICAgICAgbGV0IGYgPSBDb252ZXJ0LmJpbl90b19mbG9hdCAhY3VycmVudF9wcmVjaXNpb24gYiBpblxuICAgICAgY3VycmVudF9mbG9hdCA6PSBmO1xuICAgICAgbGV0IHRhYmxlID0gSGVscGVyLmVsZW1lbnRfb2ZfaWQgXCJmbG9hdF9yZXByXCIgaW5cbiAgICAgIGFkZF9mbG9hdCB0YWJsZTtcbiAgICAgIHVwZGF0ZV9kZWNpbWFsICgpXG4gICAgd2l0aCBleG4gLT5cbiAgICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBpbnB1dCBcIjBcIjtcbiAgICAgIExvZy5lcnJvciBcIkVycm9yOiAlc1wiIChQcmludGV4Yy50b19zdHJpbmcgZXhuKSBpblxuICBFbGVtZW50LnNldF9vbmNsaWNrIGlucHV0IGNsaWNrO1xuICBFbGVtZW50LnNldF9vbmtleXVwIGlucHV0IGJsdXI7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGNvbnRhaW5lciBpbnB1dDtcbiAgTm9kZS5hcHBlbmRfY2hpbGQgZSBjb250YWluZXJcblxuKCoqIFthZGRfZGVjaW1hbCBlIGZdIGluc2VydHMgYSB0aGUgbm9kZXMgdG8gZGlzcGxheSB0aGUgZGVjaW1hbCB2YWx1ZSBhbmQgdGhlXG4gICAgZXJyb3IgYXMgY2hpbGRyZW4gb2YgW2VdLiAqKVxubGV0IGFkZF9kZWNpbWFsIGUgPVxuICBsZXQgY29udGFpbmVyID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwiY29udGFpbmVyXCIgaW5cbiAgbGV0IHVzYWdlID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwidXNhZ2VcIiB+dGV4dDpcIkRlY2ltYWwgdmFsdWVcIiBpblxuICBOb2RlLmFwcGVuZF9jaGlsZCBjb250YWluZXIgdXNhZ2U7XG4gIGxldCBwcmVfZGVjaW1hbCA9IEhlbHBlci5jcmVhdGUgXCJwcmVcIiB+Y2xhc3NfbmFtZTpcImRlY19vdXRwdXRcIiB+aWQ6XCJkZWNfb3V0XCIgaW5cbiAgbGV0IGQgPSAhY3VycmVudF9mbG9hdCB8PiBDb252ZXJ0LmZsb2F0X3RvX2JpbiB8PiBDb252ZXJ0LmJpbl90b19kZWMgaW5cbiAgTm9kZS5zZXRfdGV4dF9jb250ZW50IHByZV9kZWNpbWFsIChGb3JtYXQuYXNwcmludGYgXCIlYVwiIEQucHAgZCk7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGNvbnRhaW5lciBwcmVfZGVjaW1hbDtcbiAgTm9kZS5hcHBlbmRfY2hpbGQgZSBjb250YWluZXI7XG4gIGxldCBjb250YWluZXIgPSBIZWxwZXIuY3JlYXRlIFwiZGl2XCIgfmNsYXNzX25hbWU6XCJjb250YWluZXJcIiBpblxuICBsZXQgdXNhZ2UgPSBIZWxwZXIuY3JlYXRlIFwiZGl2XCIgfmNsYXNzX25hbWU6XCJ1c2FnZVwiIH50ZXh0OlwiRXJyb3IgdmFsdWVcIiBpblxuICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgdXNhZ2UgXCJ0aXRsZVwiIFwiZXJyb3IgPSB2YWx1ZSAtIGlucHV0XCI7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGNvbnRhaW5lciB1c2FnZTtcbiAgbGV0IHByZV9lcnJvciA9IEhlbHBlci5jcmVhdGUgXCJwcmVcIiB+Y2xhc3NfbmFtZTpcImRlY19vdXRwdXRcIiB+aWQ6XCJlcnJfb3V0XCIgaW5cbiAgbGV0IGVyciA9IEQuc3ViIGQgIWN1cnJlbnRfZGVjIGluXG4gIE5vZGUuc2V0X3RleHRfY29udGVudCBwcmVfZXJyb3IgKEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgRC5wcCBlcnIpO1xuICBOb2RlLmFwcGVuZF9jaGlsZCBjb250YWluZXIgcHJlX2Vycm9yO1xuICBOb2RlLmFwcGVuZF9jaGlsZCBlIGNvbnRhaW5lclxuXG5sZXQgYXZhaWxhYmxlX3ByZWNpc2lvbnMgPSBbXG4gIFwibWluaVwiO1xuICBcImhhbGZcIjtcbiAgXCJzaW5nbGVcIjtcbiAgXCJkb3VibGVcIjtcbl1cblxubGV0IHNldF9wcmVjaXNpb25fc2VsZWN0aW9uIGUgPVxuICBsZXQgY29udGFpbmVyID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwiY29udGFpbmVyXCIgaW5cbiAgbGV0IHVzYWdlID0gSGVscGVyLmNyZWF0ZSBcImRpdlwiIH5jbGFzc19uYW1lOlwidXNhZ2VcIiB+dGV4dDpcIlNlbGVjdCBwcmVjaXNpb25cIiBpblxuICBsZXQgc2VsZWN0ID0gSGVscGVyLmNyZWF0ZSBcInNlbGVjdFwiIH5pZDpcInByZWNpc2lvblwiIGluXG4gIExpc3QuaXRlclxuICAgIChmdW4gcCAtPlxuICAgICAgbGV0IG9wdGlvbiA9IEhlbHBlci5jcmVhdGUgXCJvcHRpb25cIiB+dGV4dDpwIGluXG4gICAgICBsZXQgcCA9IFN0cmluZ01hcC5maW5kIHAgcHJlY2lzaW9ucyBpblxuICAgICAgbGV0IHRpdGxlID0gRm9ybWF0LmFzcHJpbnRmIFwibWFudGlzc2E6ICVpIGJpdHNcXG5leHBvbmVudDogJWkgYml0c1xcbmJpYWlzOiAlaVwiXG4gICAgICAgIHAubWFudGlzc2EgcC5leHAgcC5iaWFpcyBpblxuICAgICAgRWxlbWVudC5zZXRfYXR0cmlidXRlIG9wdGlvbiBcInRpdGxlXCIgdGl0bGU7XG4gICAgICBOb2RlLmFwcGVuZF9jaGlsZCBzZWxlY3Qgb3B0aW9uKVxuICAgIGF2YWlsYWJsZV9wcmVjaXNpb25zO1xuICBOb2RlLmFwcGVuZF9jaGlsZCBjb250YWluZXIgdXNhZ2U7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGNvbnRhaW5lciBzZWxlY3Q7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGUgY29udGFpbmVyO1xuICBsZXQgY2hhbmdlICgpOiB1bml0ID1cbiAgICBsZXQgaWR4ID0gRWxlbWVudC5zZWxlY3RlZF9pbmRleCBzZWxlY3QgaW5cbiAgICBsZXQgb3B0aW9ucyA9IEVsZW1lbnQub3B0aW9ucyBzZWxlY3QgaW5cbiAgICBsZXQgb3B0aW9uID0gb3B0aW9ucy4oaWR4KSBpblxuICAgIGxldCB0ZXh0ID0gTm9kZS50ZXh0X2NvbnRlbnQgb3B0aW9uIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IFN0cmluZ01hcC5maW5kIHRleHQgcHJlY2lzaW9ucyBpblxuICAgIGxldCBkZWNpbWFsID0gSGVscGVyLmVsZW1lbnRfb2ZfaWQgXCJkZWNfaW5cIiBpblxuICAgIGxldCBzdHIgPSBOb2RlLnRleHRfY29udGVudCBkZWNpbWFsIGluXG4gICAgdHJ5XG4gICAgICBsZXQgZCA9IEQuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgYiA9IENvbnZlcnQuZGVjX3RvX2JpbiBkIGluXG4gICAgICBsZXQgZiA9IENvbnZlcnQuYmluX3RvX2Zsb2F0IHByZWNpc2lvbiBiIGluXG4gICAgICBjdXJyZW50X3ByZWNpc2lvbiA6PSBwcmVjaXNpb247XG4gICAgICBjdXJyZW50X2Zsb2F0IDo9IGY7XG4gICAgICBsZXQgdGFibGUgPSBIZWxwZXIuZWxlbWVudF9vZl9pZCBcImZsb2F0X3JlcHJcIiBpblxuICAgICAgYWRkX2Zsb2F0IHRhYmxlO1xuICAgICAgdXBkYXRlX2RlY2ltYWwgKClcbiAgICB3aXRoIGV4biAtPlxuICAgICAgTm9kZS5zZXRfdGV4dF9jb250ZW50IGRlY2ltYWwgXCIwXCI7XG4gICAgICBMb2cuZXJyb3IgXCJJc3N1ZSB3aXRoIHNldHRpbmcgdmFsdWUgJXNcIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bikgaW5cbiAgRWxlbWVudC5zZXRfb25jaGFuZ2Ugc2VsZWN0IGNoYW5nZVxuXG5cblxubGV0IGFkZF9zaWduaWZpY2FuZCBlID1cbiAgbGV0IHBhcmVudCA9IEhlbHBlci5jcmVhdGUgXCJkaXZcIiB+Y2xhc3NfbmFtZTpcImNvbnRhaW5lclwiIGluXG4gIGxldCB1c2FnZSA9IEhlbHBlci5jcmVhdGUgXCJkaXZcIiB+Y2xhc3NfbmFtZTpcInVzYWdlXCIgfnRleHQ6XCJTaWduaWZpY2FuZCBkaWdpdHNcIiBpblxuICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgdXNhZ2UgXCJ0aXRsZVwiXG4gICAgXCJudW1iZXIgb2Ygc2lnbmlmaWNhbmQgZGlnaXQgaW4gdGhlIGRlY2ltYWwgb3V0cHV0XFxuXFxcbiAgICAgVXNlIDAgZm9yIHVubGltaXRlZCBzaWduaWZpY2FuZFxcblxcXG4gICAgIFVzZSAtMSB0byBub3QgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cIjtcbiAgbGV0IGFyZWEgPSBIZWxwZXIuY3JlYXRlIFwiZGl2XCIgfmNsYXNzX25hbWU6XCJpbnB1dFwiIH5pZDpcInNpZ25pZmljYW5kXCIgfnRleHQ6XCIxMFwiIGluXG4gIEVsZW1lbnQuc2V0X2NvbnRlbnRfZWRpdGFibGUgYXJlYSB0cnVlO1xuICBsZXQgdXBkYXRlX3NpZ25pZmljYW5kIGkgPVxuICAgIGJlZ2luXG4gICAgaWYgaSA8IDAgdGhlblxuICAgICAgcHBfZGVjIDo9IEQucHBcbiAgICBlbHNlIGlmIGkgPSAwIHRoZW5cbiAgICAgIHBwX2RlYyA6PSBELnBwX3NjaWVudGlmaWNcbiAgICBlbHNlXG4gICAgICBwcF9kZWMgOj0gRC5wcF9zY2llbnRpZmljIH5zaWduaWZpY2FuZDppXG4gICAgZW5kO1xuICAgIHVwZGF0ZV9kZWNpbWFsICgpIGluXG4gIGxldCB1cGRhdGVfZW50ZXIgZSA9XG4gICAgbGV0IGNvZGUgPSBFbGVtZW50LmtleSBlIGluXG4gICAgaWYgY29kZSA8PiBcIkVudGVyXCIgdGhlbiAoKSBlbHNlXG4gICAgbGV0IHN0ciA9IE5vZGUudGV4dF9jb250ZW50IGFyZWEgaW5cbiAgICBsZXQgc3RyID0gcmVtb3ZlX3doaXRlc3BhY2VzIHN0ciBpblxuICAgIE5vZGUuc2V0X3RleHRfY29udGVudCBhcmVhIHN0cjtcbiAgICBsZXQgdmFyID0gaW50X29mX3N0cmluZyBzdHIgaW5cbiAgICB1cGRhdGVfc2lnbmlmaWNhbmQgdmFyIGluXG4gIEVsZW1lbnQuc2V0X29ua2V5dXAgYXJlYSB1cGRhdGVfZW50ZXI7XG4gIGxldCBidXR0b24gPSBIZWxwZXIuY3JlYXRlIFwiYnV0dG9uXCIgfnRleHQ6XCJ1cGRhdGVcIiBpblxuICBsZXQgdXBkYXRlIF8gPVxuICAgIGxldCB0eHQgPSBOb2RlLnRleHRfY29udGVudCBhcmVhIGluXG4gICAgbGV0IHZhciA9IGludF9vZl9zdHJpbmcgdHh0IGluXG4gICAgdXBkYXRlX3NpZ25pZmljYW5kIHZhciBpblxuICBFbGVtZW50LnNldF9vbmNsaWNrIGJ1dHRvbiB1cGRhdGU7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIHBhcmVudCB1c2FnZTtcbiAgTm9kZS5hcHBlbmRfY2hpbGQgcGFyZW50IGFyZWE7XG4gIE5vZGUuYXBwZW5kX2NoaWxkIHBhcmVudCBidXR0b247XG4gIE5vZGUuYXBwZW5kX2NoaWxkIGUgcGFyZW50XG5cblxuKCoqIHsyIE9ubG9hZH0gKilcblxubGV0IG9ubG9hZCBfID0gYmVnaW5cbiAgbGV0IG1haW4gPSBIZWxwZXIuZWxlbWVudF9vZl9pZCBcIm1haW5cIiBpblxuICBzZXRfcHJlY2lzaW9uX3NlbGVjdGlvbiBtYWluO1xuICBzZXRfaW5wdXQgbWFpbjtcbiAgbGV0IHRhYmxlID0gSGVscGVyLmNyZWF0ZSBcInRhYmxlXCIgfmNsYXNzX25hbWU6XCJmbG9hdFwiIH5pZDpcImZsb2F0X3JlcHJcIiBpblxuICBOb2RlLmFwcGVuZF9jaGlsZCBtYWluIHRhYmxlO1xuICBhZGRfZmxvYXQgdGFibGU7XG4gIGFkZF9kZWNpbWFsIG1haW47XG4gIGFkZF9zaWduaWZpY2FuZCBtYWluXG5lbmRcblxubGV0ICgpID0gV2luZG93LnNldF9vbmxvYWQgR2xvYmFsVmFyaWFibGVzLndpbmRvdyBvbmxvYWQiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzI1NzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkX2V4aXQuY21vLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZF9leGl0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9ydW5uZXIvd29yay9GbG9hdFZpZXcvRmxvYXRWaWV3L19vcGFtL2xpYi9vY2FtbC9zdGRfZXhpdC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLEdDaUJRO0FBQUEsT0FBQUMsV0FBWTtBQUFBO0FBQUE7QUFBQSxFRGpCcEIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRW5zdXJlIHRoYXQgW2F0X2V4aXRdIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgcHJvZ3JhbSAqKVxuXG5sZXQgXyA9IGRvX2F0X2V4aXQoKVxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
